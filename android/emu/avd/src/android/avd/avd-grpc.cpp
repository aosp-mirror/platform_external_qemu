// Copyright (C) 2023 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#include <algorithm>
#include <condition_variable>
#include <fstream>
#include <future>
#include <mutex>
#include "aemu/base/Uuid.h"
#include "aemu/base/files/PathUtils.h"
#include "android/avd/avd-info.h"
#include "android/avd/info-grpc.h"
#include "android/avd/info.h"
#include "android/base/system/System.h"
#include "android/emulation/control/utils/SimpleAvdClient.h"
#include "android/utils/system.h"

using android::base::PathUtils;
using android::base::System;
using android::base::Uuid;

#if DEBUG >= 1
#define DD(fmt, ...) \
    dinfo("AvdClient: %s:%d| " fmt "\n", __func__, __LINE__, ##__VA_ARGS__)
#else
#define DD(...) (void)0
#endif

extern "C" int _avdInfo_getConfigIni(AvdInfo* i);
extern "C" int _avdInfo_getBuildSkinHardwareIni(AvdInfo* i);

static std::string generate_tmp_cfg(
        std::unordered_map<std::string, std::string> cfg) {
    auto configFile = PathUtils::join(System::get()->getTempDir(),
                                      Uuid::generate().toString());
    std::fstream output(PathUtils::asUnicodePath(configFile.c_str()).c_str(),
                        std::ios::out | std::ios::binary);

    output << "## Autogenerated avd cfg file." << std::endl;
    for (const auto [key, val] : cfg) {
        output << key << " = " << val << std::endl;
    }
    output.flush();
    output.close();

    return configFile;
}

AvdInfo* avdInfo_from_grpc(SimpleAvdClient* client) {
    AvdInfo* avd;
    auto info = client->getAvdInfo();
    if (!info.ok()) {
        derror("Unable to obtain avd info: %s", info.status().message().data());
        return nullptr;
    }
    DD("Received: %s", info->ShortDebugString().c_str());

    ANEW0(avd);

    avd->androidOut = ASTRDUP(info->android_out().c_str());
    avd->androidBuildRoot = ASTRDUP(info->android_build_root().c_str());
    avd->targetArch = ASTRDUP(info->target_arch().c_str());
    avd->targetAbi = ASTRDUP(info->target_abi().c_str());
    avd->acpiIniPath = ASTRDUP(info->acpi_ini_path().c_str());
    avd->target = ASTRDUP(info->target().c_str());

    avd->deviceName = ASTRDUP(info->device_name().c_str());
    avd->deviceId = ASTRDUP(info->device_id().c_str());
    avd->sdkRootPath = ASTRDUP(info->sdk_root_path().c_str());

    int i = 0;
    for (const auto& searchPath : info->search_paths()) {
        // Do something with the search path.
        avd->searchPaths[i] = ASTRDUP(searchPath.c_str());
    }
    avd->numSearchPaths = i;

    avd->contentPath = ASTRDUP(info->content_path().c_str());
    avd->rootIniPath = ASTRDUP(info->root_ini_path().c_str());

    // Setup the CINI files.
    // Could also use generate_tmp_cfg(avd->root_ini());
    avd->rootIni = iniFile_newFromFile(avd->rootIniPath);
    _avdInfo_getConfigIni(avd);
    _avdInfo_getBuildSkinHardwareIni(avd);

    avd->apiLevel = info->api_level();
    avd->incrementalVersion = info->incremental_version();
    avd->isGoogleApis = info->is_google_apis();
    avd->isUserBuild = info->is_user_build();
    avd->isAtd = info->is_atd();
    avd->flavor = static_cast<AvdFlavor>((int)info->flavor() - 1);

    avd->skinName = ASTRDUP(info->skin_name().c_str());
    avd->skinDirPath = ASTRDUP(info->skin_dir_path().c_str());
    avd->coreHardwareIniPath = ASTRDUP(info->core_hardware_ini_path().c_str());
    avd->snapshotLockPath = ASTRDUP(info->snapshot_lock_path().c_str());
    avd->multiInstanceLockPath =
            ASTRDUP(info->multi_instance_lock_path().c_str());

    // ownership will transfer
    auto len = info->build_properties().size();
    void* copy = malloc(len);
    memcpy(copy, info->build_properties().c_str(), len);
    fileData_initFromMemory(avd->buildProperties, copy, len);

    len = info->boot_properties().size();
    copy = malloc(len);
    memcpy(copy, info->boot_properties().c_str(), len);
    fileData_initFromMemory(avd->bootProperties, copy, len);

    i = 0;
    for (const auto& path : info->image_paths()) {
        // Do something with the search path.
        avd->imagePath[i] = ASTRDUP(path.c_str());
    }
    i = 0;
    for (const auto& state : info->image_states()) {
        // Do something with the search path.
        avd->imageState[i] = (char)state - 1;
    }

    avd->sysdir = ASTRDUP(info->sysdir().c_str());
    return avd;
}
