// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module VkDecoder
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "VkDecoder.h"


#include "common/goldfish_vk_marshaling.h"
#include "common/goldfish_vk_reserved_marshaling.h"
#include "common/goldfish_vk_private_defs.h"
#include "common/goldfish_vk_transform.h"

#include "android/base/BumpPool.h"
#include "android/base/system/System.h"
#include "android/base/Tracing.h"

#include "IOStream.h"
#include "emugl/common/feature_control.h"
#include "emugl/common/logging.h"

#include "VkDecoderGlobalState.h"
#include "VkDecoderSnapshot.h"

#include "VulkanDispatch.h"
#include "VulkanStream.h"

#include <unordered_map>





using emugl::vkDispatch;

using namespace goldfish_vk;

using android::base::System;

class VkDecoder::Impl {
public:
    Impl() : m_logCalls(System::get()->envGet("ANDROID_EMU_VK_LOG_CALLS") == "1"),
             m_vk(vkDispatch()),
             m_state(VkDecoderGlobalState::get()),
             m_boxedHandleUnwrapMapping(m_state),
             m_boxedHandleCreateMapping(m_state),
             m_boxedHandleDestroyMapping(m_state),
             m_boxedHandleUnwrapAndDeleteMapping(m_state),
             m_boxedHandleUnwrapAndDeletePreserveBoxedMapping(m_state) { }
    VulkanStream* stream() { return &m_vkStream; }
    VulkanMemReadingStream* readStream() { return &m_vkMemReadingStream; }

    void setForSnapshotLoad(bool forSnapshotLoad) {
        m_forSnapshotLoad = forSnapshotLoad;
    }

    void onThreadTeardown() {
        m_threadTeardown = true;
    }

    size_t decode(void* buf, size_t bufsize, IOStream* stream, uint32_t* seqnoPtr);

private:
    bool m_logCalls;
    bool m_forSnapshotLoad = false;
    bool m_threadTeardown = false;
    VulkanDispatch* m_vk;
    VkDecoderGlobalState* m_state;
    VulkanStream m_vkStream { nullptr };
    VulkanMemReadingStream m_vkMemReadingStream { nullptr };
    BoxedHandleUnwrapMapping m_boxedHandleUnwrapMapping;
    BoxedHandleCreateMapping m_boxedHandleCreateMapping;
    BoxedHandleDestroyMapping m_boxedHandleDestroyMapping;
    BoxedHandleUnwrapAndDeleteMapping m_boxedHandleUnwrapAndDeleteMapping;
    android::base::BumpPool m_pool;
    BoxedHandleUnwrapAndDeletePreserveBoxedMapping m_boxedHandleUnwrapAndDeletePreserveBoxedMapping;
};

VkDecoder::VkDecoder() :
    mImpl(new VkDecoder::Impl()) { }

VkDecoder::~VkDecoder() = default;

void VkDecoder::setForSnapshotLoad(bool forSnapshotLoad) {
    mImpl->setForSnapshotLoad(forSnapshotLoad);
}

void VkDecoder::onThreadTeardown() {
    mImpl->onThreadTeardown();
}

size_t VkDecoder::decode(void* buf, size_t bufsize, IOStream* stream, uint32_t* seqnoPtr) {
    return mImpl->decode(buf, bufsize, stream, seqnoPtr);
}

// VkDecoder::Impl::decode to follow
size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream, uint32_t* seqnoPtr)
{
    if (len < 8) return 0;;
    bool queueSubmitWithCommandsEnabled = emugl::emugl_feature_is_enabled(android::featurecontrol::VulkanQueueSubmitWithCommands);
    unsigned char *ptr = (unsigned char *)buf;
    const unsigned char* const end = (const unsigned char*)buf + len;
    if (m_forSnapshotLoad)
    {
        ptr += m_state->setCreatedHandlesForSnapshotLoad(ptr);
    }
    while (end - ptr >= 8)
    {
        uint32_t opcode = *(uint32_t *)ptr;
        int32_t packetLen = *(int32_t *)(ptr + 4);
        if (end - ptr < packetLen) return ptr - (unsigned char*)buf;
        stream()->setStream(ioStream);
        VulkanStream* vkStream = stream();
        VulkanMemReadingStream* vkReadStream = readStream();
        vkReadStream->setBuf((uint8_t*)(ptr + 8));
        uint8_t* readStreamPtr = vkReadStream->getBuf(); uint8_t** readStreamPtrPtr = &readStreamPtr;
        uint8_t* snapshotTraceBegin = vkReadStream->beginTrace();
        vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
        
        if (queueSubmitWithCommandsEnabled && ((opcode >= OP_vkFirst && opcode < OP_vkLast) || (opcode >= OP_vkFirst_old && opcode < OP_vkLast_old))) {
            uint32_t seqno; memcpy(&seqno, *readStreamPtrPtr, sizeof(uint32_t)); *readStreamPtrPtr += sizeof(uint32_t);
            if (seqnoPtr && !m_forSnapshotLoad) {
                while (!m_threadTeardown && (seqno - __atomic_load_n(seqnoPtr, __ATOMIC_SEQ_CST) != 1));
            }
        }
        
        auto vk = m_vk;
        switch (opcode)
        {
#ifdef VK_VERSION_1_0
            case OP_vkCreateInstance:
            {
                android::base::beginTrace("vkCreateInstance decode");
                const VkInstanceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkInstance* pInstance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkInstanceCreateInfo));
                reservedunmarshal_VkInstanceCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkInstanceCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pInstance;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pInstance, sizeof(VkInstance));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkInstance*)pInstance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_1));
                if (pCreateInfo)
                {
                    transform_tohost_VkInstanceCreateInfo(m_state, (VkInstanceCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateInstance 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pInstance);
                }
                VkResult vkCreateInstance_VkResult_return = (VkResult)0;
                vkCreateInstance_VkResult_return = m_state->on_vkCreateInstance(&m_pool, pCreateInfo, pAllocator, pInstance);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_2;
                static_assert(8 == sizeof(VkInstance), "handle map overwrite requres VkInstance to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkInstance((VkInstance*)pInstance, 1);
                vkStream->write((VkInstance*)pInstance, 8 * 1);
                vkStream->write(&vkCreateInstance_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateInstance(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateInstance_VkResult_return, pCreateInfo, pAllocator, pInstance);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyInstance:
            {
                android::base::beginTrace("vkDestroyInstance decode");
                VkInstance instance;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyInstance 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyInstance(&m_pool, instance, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyInstance(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, pAllocator);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEnumeratePhysicalDevices:
            {
                android::base::beginTrace("vkEnumeratePhysicalDevices decode");
                VkInstance instance;
                uint32_t* pPhysicalDeviceCount;
                VkPhysicalDevice* pPhysicalDevices;
                // Begin global wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPhysicalDeviceCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPhysicalDeviceCount);
                *readStreamPtrPtr += 8;
                if (pPhysicalDeviceCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPhysicalDeviceCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pPhysicalDevices;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPhysicalDevice**)&pPhysicalDevices, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPhysicalDevices);
                *readStreamPtrPtr += 8;
                if (pPhysicalDevices)
                {
                    vkReadStream->alloc((void**)&pPhysicalDevices, (*(pPhysicalDeviceCount)) * sizeof(VkPhysicalDevice));
                    if ((*(pPhysicalDeviceCount)))
                    {
                        uint8_t* cgen_var_2_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * (*(pPhysicalDeviceCount));
                        if (pPhysicalDeviceCount)
                        {
                            for (uint32_t k = 0; k < (*(pPhysicalDeviceCount)); ++k)
                            {
                                uint64_t tmpval; memcpy(&tmpval, cgen_var_2_0_ptr + k * 8, sizeof(uint64_t));
                                *(((VkPhysicalDevice*)pPhysicalDevices) + k) = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)tmpval);
                            }
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumeratePhysicalDevices 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pPhysicalDeviceCount, (unsigned long long)pPhysicalDevices);
                }
                VkResult vkEnumeratePhysicalDevices_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDevices_VkResult_return = m_state->on_vkEnumeratePhysicalDevices(&m_pool, instance, pPhysicalDeviceCount, pPhysicalDevices);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPhysicalDeviceCount;
                vkStream->putBe64(cgen_var_3);
                if (pPhysicalDeviceCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pPhysicalDevices;
                vkStream->putBe64(cgen_var_4);
                if (pPhysicalDevices)
                {
                    if ((*(pPhysicalDeviceCount)))
                    {
                        uint64_t* cgen_var_4_0;
                        vkStream->alloc((void**)&cgen_var_4_0, (*(pPhysicalDeviceCount)) * 8);
                        static_assert(8 == sizeof(VkPhysicalDevice), "handle map overwrite requres VkPhysicalDevice to be 8 bytes long");
                        vkStream->handleMapping()->mapHandles_VkPhysicalDevice((VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)));
                        vkStream->write((VkPhysicalDevice*)pPhysicalDevices, 8 * (*(pPhysicalDeviceCount)));
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDevices_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumeratePhysicalDevices(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumeratePhysicalDevices_VkResult_return, instance, pPhysicalDeviceCount, pPhysicalDevices);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceFeatures:
            {
                android::base::beginTrace("vkGetPhysicalDeviceFeatures decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures* pFeatures;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures));
                reservedunmarshal_VkPhysicalDeviceFeatures(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures*)(pFeatures), readStreamPtrPtr);
                if (pFeatures)
                {
                    transform_tohost_VkPhysicalDeviceFeatures(m_state, (VkPhysicalDeviceFeatures*)(pFeatures));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceFeatures 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFeatures);
                }
                m_state->on_vkGetPhysicalDeviceFeatures(&m_pool, physicalDevice, pFeatures);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkPhysicalDeviceFeatures(m_state, (VkPhysicalDeviceFeatures*)(pFeatures));
                }
                marshal_VkPhysicalDeviceFeatures(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures*)(pFeatures));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFeatures(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFeatures);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceFormatProperties decode");
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties* pFormatProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                // Begin manual dispatchable handle unboxing for pFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties));
                reservedunmarshal_VkFormatProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties*)(pFormatProperties), readStreamPtrPtr);
                if (pFormatProperties)
                {
                    transform_tohost_VkFormatProperties(m_state, (VkFormatProperties*)(pFormatProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceFormatProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)pFormatProperties);
                }
                m_state->on_vkGetPhysicalDeviceFormatProperties(&m_pool, physicalDevice, format, pFormatProperties);
                vkStream->unsetHandleMapping();
                if (pFormatProperties)
                {
                    transform_fromhost_VkFormatProperties(m_state, (VkFormatProperties*)(pFormatProperties));
                }
                marshal_VkFormatProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties*)(pFormatProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFormatProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format, pFormatProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceImageFormatProperties decode");
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkImageTiling tiling;
                VkImageUsageFlags usage;
                VkImageCreateFlags flags;
                VkImageFormatProperties* pImageFormatProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                memcpy((VkImageType*)&type, *readStreamPtrPtr, sizeof(VkImageType));
                *readStreamPtrPtr += sizeof(VkImageType);
                memcpy((VkImageTiling*)&tiling, *readStreamPtrPtr, sizeof(VkImageTiling));
                *readStreamPtrPtr += sizeof(VkImageTiling);
                memcpy((VkImageUsageFlags*)&usage, *readStreamPtrPtr, sizeof(VkImageUsageFlags));
                *readStreamPtrPtr += sizeof(VkImageUsageFlags);
                memcpy((VkImageCreateFlags*)&flags, *readStreamPtrPtr, sizeof(VkImageCreateFlags));
                *readStreamPtrPtr += sizeof(VkImageCreateFlags);
                // Begin manual dispatchable handle unboxing for pImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties));
                reservedunmarshal_VkImageFormatProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties*)(pImageFormatProperties), readStreamPtrPtr);
                if (pImageFormatProperties)
                {
                    transform_tohost_VkImageFormatProperties(m_state, (VkImageFormatProperties*)(pImageFormatProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceImageFormatProperties 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)type, (unsigned long long)tiling, (unsigned long long)usage, (unsigned long long)flags, (unsigned long long)pImageFormatProperties);
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties_VkResult_return = m_state->on_vkGetPhysicalDeviceImageFormatProperties(&m_pool, physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pImageFormatProperties)
                {
                    transform_fromhost_VkImageFormatProperties(m_state, (VkImageFormatProperties*)(pImageFormatProperties));
                }
                marshal_VkImageFormatProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceImageFormatProperties_VkResult_return, physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceProperties decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties* pProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties));
                reservedunmarshal_VkPhysicalDeviceProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties*)(pProperties), readStreamPtrPtr);
                if (pProperties)
                {
                    transform_tohost_VkPhysicalDeviceProperties(m_state, (VkPhysicalDeviceProperties*)(pProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceProperties 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pProperties);
                }
                m_state->on_vkGetPhysicalDeviceProperties(&m_pool, physicalDevice, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkPhysicalDeviceProperties(m_state, (VkPhysicalDeviceProperties*)(pProperties));
                }
                marshal_VkPhysicalDeviceProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties*)(pProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceQueueFamilyProperties decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties* pQueueFamilyProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pQueueFamilyPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pQueueFamilyPropertyCount);
                *readStreamPtrPtr += 8;
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pQueueFamilyPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pQueueFamilyProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkQueueFamilyProperties**)&pQueueFamilyProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pQueueFamilyProperties);
                *readStreamPtrPtr += 8;
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkQueueFamilyProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i), readStreamPtrPtr);
                    }
                }
                if (pQueueFamilyPropertyCount)
                {
                    if (pQueueFamilyProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                        {
                            transform_tohost_VkQueueFamilyProperties(m_state, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceQueueFamilyProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pQueueFamilyPropertyCount, (unsigned long long)pQueueFamilyProperties);
                }
                vk->vkGetPhysicalDeviceQueueFamilyProperties(unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_3);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                if (pQueueFamilyPropertyCount)
                {
                    if (pQueueFamilyProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                        {
                            transform_fromhost_VkQueueFamilyProperties(m_state, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_4);
                if (pQueueFamilyProperties)
                {
                    if (pQueueFamilyPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                        {
                            marshal_VkQueueFamilyProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                        }
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceMemoryProperties decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties* pMemoryProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for pMemoryProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties));
                reservedunmarshal_VkPhysicalDeviceMemoryProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties), readStreamPtrPtr);
                if (pMemoryProperties)
                {
                    transform_tohost_VkPhysicalDeviceMemoryProperties(m_state, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceMemoryProperties 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pMemoryProperties);
                }
                m_state->on_vkGetPhysicalDeviceMemoryProperties(&m_pool, physicalDevice, pMemoryProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryProperties)
                {
                    transform_fromhost_VkPhysicalDeviceMemoryProperties(m_state, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                }
                marshal_VkPhysicalDeviceMemoryProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pMemoryProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetInstanceProcAddr:
            {
                android::base::beginTrace("vkGetInstanceProcAddr decode");
                VkInstance instance;
                const char* pName;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pName, readStreamPtrPtr);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetInstanceProcAddr 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pName);
                }
                PFN_vkVoidFunction vkGetInstanceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
                vkGetInstanceProcAddr_PFN_vkVoidFunction_return = vk->vkGetInstanceProcAddr(unboxed_instance, pName);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetInstanceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetInstanceProcAddr(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetInstanceProcAddr_PFN_vkVoidFunction_return, instance, pName);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceProcAddr:
            {
                android::base::beginTrace("vkGetDeviceProcAddr decode");
                VkDevice device;
                const char* pName;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pName, readStreamPtrPtr);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceProcAddr 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pName);
                }
                PFN_vkVoidFunction vkGetDeviceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
                vkGetDeviceProcAddr_PFN_vkVoidFunction_return = vk->vkGetDeviceProcAddr(unboxed_device, pName);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetDeviceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceProcAddr(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDeviceProcAddr_PFN_vkVoidFunction_return, device, pName);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateDevice:
            {
                android::base::beginTrace("vkCreateDevice decode");
                VkPhysicalDevice physicalDevice;
                const VkDeviceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDevice* pDevice;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDeviceCreateInfo));
                reservedunmarshal_VkDeviceCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pDevice;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDevice, sizeof(VkDevice));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDevice*)pDevice = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkDeviceCreateInfo(m_state, (VkDeviceCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDevice 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pDevice);
                }
                VkResult vkCreateDevice_VkResult_return = (VkResult)0;
                vkCreateDevice_VkResult_return = m_state->on_vkCreateDevice(&m_pool, physicalDevice, pCreateInfo, pAllocator, pDevice);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkDevice), "handle map overwrite requres VkDevice to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDevice((VkDevice*)pDevice, 1);
                vkStream->write((VkDevice*)pDevice, 8 * 1);
                vkStream->write(&vkCreateDevice_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDevice(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDevice_VkResult_return, physicalDevice, pCreateInfo, pAllocator, pDevice);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDevice:
            {
                android::base::beginTrace("vkDestroyDevice decode");
                VkDevice device;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDevice 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDevice(&m_pool, device, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDevice(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pAllocator);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEnumerateInstanceExtensionProperties:
            {
                android::base::beginTrace("vkEnumerateInstanceExtensionProperties decode");
                const char* pLayerName;
                uint32_t* pPropertyCount;
                VkExtensionProperties* pProperties;
                if (vkReadStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
                {
                    // WARNING PTR CHECK
                    memcpy((char**)&pLayerName, (*readStreamPtrPtr), 8);
                    android::base::Stream::fromBe64((uint8_t*)&pLayerName);
                    *readStreamPtrPtr += 8;
                    if (pLayerName)
                    {
                        vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pLayerName, readStreamPtrPtr);
                    }
                }
                else
                {
                    vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pLayerName, readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkExtensionProperties**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkExtensionProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkExtensionProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtensionProperties*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_tohost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumerateInstanceExtensionProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)pLayerName, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkEnumerateInstanceExtensionProperties_VkResult_return = (VkResult)0;
                vkEnumerateInstanceExtensionProperties_VkResult_return = vk->vkEnumerateInstanceExtensionProperties(pLayerName, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_2);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_fromhost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_3);
                if (pProperties)
                {
                    if (pPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            marshal_VkExtensionProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtensionProperties*)(pProperties + i));
                        }
                    }
                }
                vkStream->write(&vkEnumerateInstanceExtensionProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateInstanceExtensionProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateInstanceExtensionProperties_VkResult_return, pLayerName, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEnumerateDeviceExtensionProperties:
            {
                android::base::beginTrace("vkEnumerateDeviceExtensionProperties decode");
                VkPhysicalDevice physicalDevice;
                const char* pLayerName;
                uint32_t* pPropertyCount;
                VkExtensionProperties* pProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                if (vkReadStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
                {
                    // WARNING PTR CHECK
                    memcpy((char**)&pLayerName, (*readStreamPtrPtr), 8);
                    android::base::Stream::fromBe64((uint8_t*)&pLayerName);
                    *readStreamPtrPtr += 8;
                    if (pLayerName)
                    {
                        vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pLayerName, readStreamPtrPtr);
                    }
                }
                else
                {
                    vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pLayerName, readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkExtensionProperties**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkExtensionProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkExtensionProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtensionProperties*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_tohost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumerateDeviceExtensionProperties 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pLayerName, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkEnumerateDeviceExtensionProperties_VkResult_return = (VkResult)0;
                vkEnumerateDeviceExtensionProperties_VkResult_return = m_state->on_vkEnumerateDeviceExtensionProperties(&m_pool, physicalDevice, pLayerName, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_3);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_fromhost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_4);
                if (pProperties)
                {
                    if (pPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            marshal_VkExtensionProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtensionProperties*)(pProperties + i));
                        }
                    }
                }
                vkStream->write(&vkEnumerateDeviceExtensionProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateDeviceExtensionProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateDeviceExtensionProperties_VkResult_return, physicalDevice, pLayerName, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEnumerateInstanceLayerProperties:
            {
                android::base::beginTrace("vkEnumerateInstanceLayerProperties decode");
                uint32_t* pPropertyCount;
                VkLayerProperties* pProperties;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkLayerProperties**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkLayerProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkLayerProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkLayerProperties*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_tohost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumerateInstanceLayerProperties 0x%llx 0x%llx \n", ioStream, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkEnumerateInstanceLayerProperties_VkResult_return = (VkResult)0;
                vkEnumerateInstanceLayerProperties_VkResult_return = vk->vkEnumerateInstanceLayerProperties(pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_2);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_fromhost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_3);
                if (pProperties)
                {
                    if (pPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            marshal_VkLayerProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkLayerProperties*)(pProperties + i));
                        }
                    }
                }
                vkStream->write(&vkEnumerateInstanceLayerProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateInstanceLayerProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateInstanceLayerProperties_VkResult_return, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEnumerateDeviceLayerProperties:
            {
                android::base::beginTrace("vkEnumerateDeviceLayerProperties decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkLayerProperties* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkLayerProperties**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkLayerProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkLayerProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkLayerProperties*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_tohost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumerateDeviceLayerProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
                vkEnumerateDeviceLayerProperties_VkResult_return = vk->vkEnumerateDeviceLayerProperties(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_3);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_fromhost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_4);
                if (pProperties)
                {
                    if (pPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            marshal_VkLayerProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkLayerProperties*)(pProperties + i));
                        }
                    }
                }
                vkStream->write(&vkEnumerateDeviceLayerProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateDeviceLayerProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateDeviceLayerProperties_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceQueue:
            {
                android::base::beginTrace("vkGetDeviceQueue decode");
                VkDevice device;
                uint32_t queueFamilyIndex;
                uint32_t queueIndex;
                VkQueue* pQueue;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&queueIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for pQueue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pQueue, sizeof(VkQueue));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkQueue*)pQueue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_1));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceQueue 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)queueFamilyIndex, (unsigned long long)queueIndex, (unsigned long long)pQueue);
                }
                m_state->on_vkGetDeviceQueue(&m_pool, device, queueFamilyIndex, queueIndex, pQueue);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_2;
                static_assert(8 == sizeof(VkQueue), "handle map overwrite requres VkQueue to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkQueue((VkQueue*)pQueue, 1);
                vkStream->write((VkQueue*)pQueue, 8 * 1);
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceQueue(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, queueFamilyIndex, queueIndex, pQueue);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueSubmit:
            {
                android::base::beginTrace("vkQueueSubmit decode");
                VkQueue queue;
                uint32_t submitCount;
                const VkSubmitInfo* pSubmits;
                VkFence fence;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                memcpy((uint32_t*)&submitCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pSubmits, ((submitCount)) * sizeof(const VkSubmitInfo));
                for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
                {
                    reservedunmarshal_VkSubmitInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubmitInfo*)(pSubmits + i), readStreamPtrPtr);
                }
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_1));
                if (pSubmits)
                {
                    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
                    {
                        transform_tohost_VkSubmitInfo(m_state, (VkSubmitInfo*)(pSubmits + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueSubmit 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)submitCount, (unsigned long long)pSubmits, (unsigned long long)fence);
                }
                VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
                vkQueueSubmit_VkResult_return = m_state->on_vkQueueSubmit(&m_pool, queue, submitCount, pSubmits, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueueSubmit_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueSubmit(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueueSubmit_VkResult_return, queue, submitCount, pSubmits, fence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueWaitIdle:
            {
                android::base::beginTrace("vkQueueWaitIdle decode");
                VkQueue queue;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueWaitIdle 0x%llx \n", ioStream, (unsigned long long)queue);
                }
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
                vkQueueWaitIdle_VkResult_return = m_state->on_vkQueueWaitIdle(&m_pool, queue);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueueWaitIdle_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueWaitIdle(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueueWaitIdle_VkResult_return, queue);
                }
                vkReadStream->clearPool();
                android::base::endTrace();
                break;
            }
            case OP_vkDeviceWaitIdle:
            {
                android::base::beginTrace("vkDeviceWaitIdle decode");
                VkDevice device;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDeviceWaitIdle 0x%llx \n", ioStream, (unsigned long long)device);
                }
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
                vkDeviceWaitIdle_VkResult_return = vk->vkDeviceWaitIdle(unboxed_device);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDeviceWaitIdle_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDeviceWaitIdle(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkDeviceWaitIdle_VkResult_return, device);
                }
                vkReadStream->clearPool();
                android::base::endTrace();
                break;
            }
            case OP_vkAllocateMemory:
            {
                android::base::beginTrace("vkAllocateMemory decode");
                VkDevice device;
                const VkMemoryAllocateInfo* pAllocateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDeviceMemory* pMemory;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkMemoryAllocateInfo));
                reservedunmarshal_VkMemoryAllocateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryAllocateInfo*)(pAllocateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pMemory;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemory, sizeof(VkDeviceMemory));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDeviceMemory*)pMemory = (VkDeviceMemory)(VkDeviceMemory)((VkDeviceMemory)(*&cgen_var_2));
                if (pAllocateInfo)
                {
                    transform_tohost_VkMemoryAllocateInfo(m_state, (VkMemoryAllocateInfo*)(pAllocateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAllocateMemory 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAllocateInfo, (unsigned long long)pAllocator, (unsigned long long)pMemory);
                }
                VkResult vkAllocateMemory_VkResult_return = (VkResult)0;
                vkAllocateMemory_VkResult_return = m_state->on_vkAllocateMemory(&m_pool, device, pAllocateInfo, pAllocator, pMemory);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pMemory;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkDeviceMemory), "handle map overwrite requres VkDeviceMemory to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDeviceMemory((VkDeviceMemory*)pMemory, 1);
                vkStream->write((VkDeviceMemory*)pMemory, 8 * 1);
                // Begin manual non dispatchable handle create for pMemory;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkAllocateMemory_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAllocateMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAllocateMemory_VkResult_return, device, pAllocateInfo, pAllocator, pMemory);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkFreeMemory:
            {
                android::base::beginTrace("vkFreeMemory decode");
                VkDevice device;
                VkDeviceMemory memory;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                // Begin manual non dispatchable handle destroy unboxing for memory;
                VkDeviceMemory boxed_memory_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)(VkDeviceMemory)((VkDeviceMemory)(*&cgen_var_1));
                boxed_memory_preserve = memory;
                memory = unbox_VkDeviceMemory(memory);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkFreeMemory 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pAllocator);
                }
                m_state->on_vkFreeMemory(&m_pool, device, memory, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFreeMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_memory_preserve, pAllocator);
                }
                delete_VkDeviceMemory(boxed_memory_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkMapMemory:
            {
                android::base::beginTrace("vkMapMemory decode");
                VkDevice device;
                VkDeviceMemory memory;
                VkDeviceSize offset;
                VkDeviceSize size;
                VkMemoryMapFlags flags;
                void** ppData;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&size, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkMemoryMapFlags*)&flags, *readStreamPtrPtr, sizeof(VkMemoryMapFlags));
                *readStreamPtrPtr += sizeof(VkMemoryMapFlags);
                // Begin manual dispatchable handle unboxing for ppData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((void***)&ppData, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&ppData);
                *readStreamPtrPtr += 8;
                if (ppData)
                {
                    vkReadStream->alloc((void**)&ppData, sizeof(void*));
                    memcpy((void**)ppData, *readStreamPtrPtr, sizeof(void*));
                    *readStreamPtrPtr += sizeof(void*);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkMapMemory 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)offset, (unsigned long long)size, (unsigned long long)flags, (unsigned long long)ppData);
                }
                VkResult vkMapMemory_VkResult_return = (VkResult)0;
                vkMapMemory_VkResult_return = m_state->on_vkMapMemory(&m_pool, device, memory, offset, size, flags, ppData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)ppData;
                vkStream->putBe64(cgen_var_3);
                if (ppData)
                {
                    vkStream->write((void**)ppData, sizeof(void*));
                }
                vkStream->write(&vkMapMemory_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkMapMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkMapMemory_VkResult_return, device, memory, offset, size, flags, ppData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkUnmapMemory:
            {
                android::base::beginTrace("vkUnmapMemory decode");
                VkDevice device;
                VkDeviceMemory memory;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_1));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkUnmapMemory 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory);
                }
                m_state->on_vkUnmapMemory(&m_pool, device, memory);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUnmapMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, memory);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkFlushMappedMemoryRanges:
            {
                android::base::beginTrace("vkFlushMappedMemoryRanges decode");
                VkDevice device;
                uint32_t memoryRangeCount;
                const VkMappedMemoryRange* pMemoryRanges;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&memoryRangeCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pMemoryRanges, ((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
                for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                {
                    reservedunmarshal_VkMappedMemoryRange(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMappedMemoryRange*)(pMemoryRanges + i), readStreamPtrPtr);
                }
                if (pMemoryRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                    {
                        transform_tohost_VkMappedMemoryRange(m_state, (VkMappedMemoryRange*)(pMemoryRanges + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkFlushMappedMemoryRanges 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memoryRangeCount, (unsigned long long)pMemoryRanges);
                }
                if (!m_state->usingDirectMapping())
                {
                    for (uint32_t i = 0; i < memoryRangeCount; ++i)
                    {
                        auto range = pMemoryRanges[i];
                        auto memory = pMemoryRanges[i].memory;
                        auto size = pMemoryRanges[i].size;
                        auto offset = pMemoryRanges[i].offset;
                        uint64_t readStream = 0;
                        memcpy(&readStream, *readStreamPtrPtr, sizeof(uint64_t)); *readStreamPtrPtr += sizeof(uint64_t);
                        auto hostPtr = m_state->getMappedHostPointer(memory);
                        if (!hostPtr && readStream > 0) abort();
                        if (!hostPtr) continue;
                        uint8_t* targetRange = hostPtr + offset;
                        memcpy(targetRange, *readStreamPtrPtr, readStream); *readStreamPtrPtr += readStream;
                    }
                }
                VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
                vkFlushMappedMemoryRanges_VkResult_return = vk->vkFlushMappedMemoryRanges(unboxed_device, memoryRangeCount, pMemoryRanges);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkFlushMappedMemoryRanges_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFlushMappedMemoryRanges(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkFlushMappedMemoryRanges_VkResult_return, device, memoryRangeCount, pMemoryRanges);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkInvalidateMappedMemoryRanges:
            {
                android::base::beginTrace("vkInvalidateMappedMemoryRanges decode");
                VkDevice device;
                uint32_t memoryRangeCount;
                const VkMappedMemoryRange* pMemoryRanges;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&memoryRangeCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pMemoryRanges, ((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
                for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                {
                    reservedunmarshal_VkMappedMemoryRange(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMappedMemoryRange*)(pMemoryRanges + i), readStreamPtrPtr);
                }
                if (pMemoryRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                    {
                        transform_tohost_VkMappedMemoryRange(m_state, (VkMappedMemoryRange*)(pMemoryRanges + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkInvalidateMappedMemoryRanges 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memoryRangeCount, (unsigned long long)pMemoryRanges);
                }
                VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
                vkInvalidateMappedMemoryRanges_VkResult_return = vk->vkInvalidateMappedMemoryRanges(unboxed_device, memoryRangeCount, pMemoryRanges);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkInvalidateMappedMemoryRanges_VkResult_return, sizeof(VkResult));
                if (!m_state->usingDirectMapping())
                {
                    for (uint32_t i = 0; i < memoryRangeCount; ++i)
                    {
                        auto range = pMemoryRanges[i];
                        auto memory = range.memory;
                        auto size = range.size;
                        auto offset = range.offset;
                        auto hostPtr = m_state->getMappedHostPointer(memory);
                        auto actualSize = size == VK_WHOLE_SIZE ? m_state->getDeviceMemorySize(memory) : size;
                        uint64_t writeStream = 0;
                        if (!hostPtr) { vkStream->write(&writeStream, sizeof(uint64_t)); continue; };
                        uint8_t* targetRange = hostPtr + offset;
                        writeStream = actualSize;
                        vkStream->write(&writeStream, sizeof(uint64_t));
                        vkStream->write(targetRange, actualSize);
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkInvalidateMappedMemoryRanges(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkInvalidateMappedMemoryRanges_VkResult_return, device, memoryRangeCount, pMemoryRanges);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceMemoryCommitment:
            {
                android::base::beginTrace("vkGetDeviceMemoryCommitment decode");
                VkDevice device;
                VkDeviceMemory memory;
                VkDeviceSize* pCommittedMemoryInBytes;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pCommittedMemoryInBytes;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                memcpy((VkDeviceSize*)pCommittedMemoryInBytes, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceMemoryCommitment 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pCommittedMemoryInBytes);
                }
                vk->vkGetDeviceMemoryCommitment(unboxed_device, memory, pCommittedMemoryInBytes);
                vkStream->unsetHandleMapping();
                vkStream->write((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceMemoryCommitment(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, memory, pCommittedMemoryInBytes);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBindBufferMemory:
            {
                android::base::beginTrace("vkBindBufferMemory decode");
                VkDevice device;
                VkBuffer buffer;
                VkDeviceMemory memory;
                VkDeviceSize memoryOffset;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_2));
                memcpy((VkDeviceSize*)&memoryOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBindBufferMemory 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)memory, (unsigned long long)memoryOffset);
                }
                VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
                vkBindBufferMemory_VkResult_return = m_state->on_vkBindBufferMemory(&m_pool, device, buffer, memory, memoryOffset);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindBufferMemory_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindBufferMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindBufferMemory_VkResult_return, device, buffer, memory, memoryOffset);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBindImageMemory:
            {
                android::base::beginTrace("vkBindImageMemory decode");
                VkDevice device;
                VkImage image;
                VkDeviceMemory memory;
                VkDeviceSize memoryOffset;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_2));
                memcpy((VkDeviceSize*)&memoryOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBindImageMemory 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)memory, (unsigned long long)memoryOffset);
                }
                VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
                vkBindImageMemory_VkResult_return = m_state->on_vkBindImageMemory(&m_pool, device, image, memory, memoryOffset);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindImageMemory_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindImageMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindImageMemory_VkResult_return, device, image, memory, memoryOffset);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetBufferMemoryRequirements:
            {
                android::base::beginTrace("vkGetBufferMemoryRequirements decode");
                VkDevice device;
                VkBuffer buffer;
                VkMemoryRequirements* pMemoryRequirements;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                reservedunmarshal_VkMemoryRequirements(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements), readStreamPtrPtr);
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetBufferMemoryRequirements 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)pMemoryRequirements);
                }
                vk->vkGetBufferMemoryRequirements(unboxed_device, buffer, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetBufferMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, buffer, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetImageMemoryRequirements:
            {
                android::base::beginTrace("vkGetImageMemoryRequirements decode");
                VkDevice device;
                VkImage image;
                VkMemoryRequirements* pMemoryRequirements;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                reservedunmarshal_VkMemoryRequirements(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements), readStreamPtrPtr);
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageMemoryRequirements 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)pMemoryRequirements);
                }
                m_state->on_vkGetImageMemoryRequirements(&m_pool, device, image, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, image, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements:
            {
                android::base::beginTrace("vkGetImageSparseMemoryRequirements decode");
                VkDevice device;
                VkImage image;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements* pSparseMemoryRequirements;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pSparseMemoryRequirementCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSparseMemoryRequirementCount);
                *readStreamPtrPtr += 8;
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pSparseMemoryRequirementCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSparseImageMemoryRequirements**)&pSparseMemoryRequirements, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSparseMemoryRequirements);
                *readStreamPtrPtr += 8;
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        reservedunmarshal_VkSparseImageMemoryRequirements(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i), readStreamPtrPtr);
                    }
                }
                if (pSparseMemoryRequirementCount)
                {
                    if (pSparseMemoryRequirements)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                        {
                            transform_tohost_VkSparseImageMemoryRequirements(m_state, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageSparseMemoryRequirements 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)pSparseMemoryRequirementCount, (unsigned long long)pSparseMemoryRequirements);
                }
                vk->vkGetImageSparseMemoryRequirements(unboxed_device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_4);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                if (pSparseMemoryRequirementCount)
                {
                    if (pSparseMemoryRequirements)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                        {
                            transform_fromhost_VkSparseImageMemoryRequirements(m_state, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_5 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_5);
                if (pSparseMemoryRequirements)
                {
                    if (pSparseMemoryRequirementCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                        {
                            marshal_VkSparseImageMemoryRequirements(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                        }
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageSparseMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSparseImageFormatProperties decode");
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkSampleCountFlagBits samples;
                VkImageUsageFlags usage;
                VkImageTiling tiling;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                memcpy((VkImageType*)&type, *readStreamPtrPtr, sizeof(VkImageType));
                *readStreamPtrPtr += sizeof(VkImageType);
                memcpy((VkSampleCountFlagBits*)&samples, *readStreamPtrPtr, sizeof(VkSampleCountFlagBits));
                *readStreamPtrPtr += sizeof(VkSampleCountFlagBits);
                memcpy((VkImageUsageFlags*)&usage, *readStreamPtrPtr, sizeof(VkImageUsageFlags));
                *readStreamPtrPtr += sizeof(VkImageUsageFlags);
                memcpy((VkImageTiling*)&tiling, *readStreamPtrPtr, sizeof(VkImageTiling));
                *readStreamPtrPtr += sizeof(VkImageTiling);
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSparseImageFormatProperties**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkSparseImageFormatProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_tohost_VkSparseImageFormatProperties(m_state, (VkSparseImageFormatProperties*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSparseImageFormatProperties 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)type, (unsigned long long)samples, (unsigned long long)usage, (unsigned long long)tiling, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                vk->vkGetPhysicalDeviceSparseImageFormatProperties(unboxed_physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_3);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_fromhost_VkSparseImageFormatProperties(m_state, (VkSparseImageFormatProperties*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_4);
                if (pProperties)
                {
                    if (pPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            marshal_VkSparseImageFormatProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties*)(pProperties + i));
                        }
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueBindSparse:
            {
                android::base::beginTrace("vkQueueBindSparse decode");
                VkQueue queue;
                uint32_t bindInfoCount;
                const VkBindSparseInfo* pBindInfo;
                VkFence fence;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBindInfo, ((bindInfoCount)) * sizeof(const VkBindSparseInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    reservedunmarshal_VkBindSparseInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindSparseInfo*)(pBindInfo + i), readStreamPtrPtr);
                }
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_1));
                if (pBindInfo)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindSparseInfo(m_state, (VkBindSparseInfo*)(pBindInfo + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueBindSparse 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfo, (unsigned long long)fence);
                }
                VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
                vkQueueBindSparse_VkResult_return = m_state->on_vkQueueBindSparse(&m_pool, queue, bindInfoCount, pBindInfo, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueueBindSparse_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueBindSparse(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueueBindSparse_VkResult_return, queue, bindInfoCount, pBindInfo, fence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateFence:
            {
                android::base::beginTrace("vkCreateFence decode");
                VkDevice device;
                const VkFenceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkFenceCreateInfo));
                reservedunmarshal_VkFenceCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFenceCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pFence;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkFence*)pFence = (VkFence)(VkFence)((VkFence)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkFenceCreateInfo(m_state, (VkFenceCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateFence 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pFence);
                }
                VkResult vkCreateFence_VkResult_return = (VkResult)0;
                vkCreateFence_VkResult_return = m_state->on_vkCreateFence(&m_pool, device, pCreateInfo, pAllocator, pFence);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pFence;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkFence), "handle map overwrite requres VkFence to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkFence((VkFence*)pFence, 1);
                vkStream->write((VkFence*)pFence, 8 * 1);
                // Begin manual non dispatchable handle create for pFence;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateFence_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateFence(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateFence_VkResult_return, device, pCreateInfo, pAllocator, pFence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyFence:
            {
                android::base::beginTrace("vkDestroyFence decode");
                VkDevice device;
                VkFence fence;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                // Begin manual non dispatchable handle destroy unboxing for fence;
                VkFence boxed_fence_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)(VkFence)((VkFence)(*&cgen_var_1));
                boxed_fence_preserve = fence;
                fence = unbox_VkFence(fence);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyFence 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)fence, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyFence(&m_pool, device, fence, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyFence(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_fence_preserve, pAllocator);
                }
                delete_VkFence(boxed_fence_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkResetFences:
            {
                android::base::beginTrace("vkResetFences decode");
                VkDevice device;
                uint32_t fenceCount;
                const VkFence* pFences;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                memcpy((uint32_t*)&fenceCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
                if (((fenceCount)))
                {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((fenceCount));
                    for (uint32_t k = 0; k < ((fenceCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkFence*)pFences) + k) = (VkFence)unbox_VkFence((VkFence)tmpval);
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkResetFences 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)fenceCount, (unsigned long long)pFences);
                }
                VkResult vkResetFences_VkResult_return = (VkResult)0;
                vkResetFences_VkResult_return = m_state->on_vkResetFences(&m_pool, device, fenceCount, pFences);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetFences_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetFences(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetFences_VkResult_return, device, fenceCount, pFences);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetFenceStatus:
            {
                android::base::beginTrace("vkGetFenceStatus decode");
                VkDevice device;
                VkFence fence;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_1));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetFenceStatus 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)fence);
                }
                VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
                vkGetFenceStatus_VkResult_return = vk->vkGetFenceStatus(unboxed_device, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetFenceStatus_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetFenceStatus(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetFenceStatus_VkResult_return, device, fence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkWaitForFences:
            {
                android::base::beginTrace("vkWaitForFences decode");
                VkDevice device;
                uint32_t fenceCount;
                const VkFence* pFences;
                VkBool32 waitAll;
                uint64_t timeout;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&fenceCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
                if (((fenceCount)))
                {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((fenceCount));
                    for (uint32_t k = 0; k < ((fenceCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkFence*)pFences) + k) = (VkFence)unbox_VkFence((VkFence)tmpval);
                    }
                }
                memcpy((VkBool32*)&waitAll, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                memcpy((uint64_t*)&timeout, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkWaitForFences 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)fenceCount, (unsigned long long)pFences, (unsigned long long)waitAll, (unsigned long long)timeout);
                }
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                VkResult vkWaitForFences_VkResult_return = (VkResult)0;
                vkWaitForFences_VkResult_return = vk->vkWaitForFences(unboxed_device, fenceCount, pFences, waitAll, timeout);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkWaitForFences_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkWaitForFences(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkWaitForFences_VkResult_return, device, fenceCount, pFences, waitAll, timeout);
                }
                vkReadStream->clearPool();
                android::base::endTrace();
                break;
            }
            case OP_vkCreateSemaphore:
            {
                android::base::beginTrace("vkCreateSemaphore decode");
                VkDevice device;
                const VkSemaphoreCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSemaphore* pSemaphore;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSemaphoreCreateInfo));
                reservedunmarshal_VkSemaphoreCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSemaphore;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSemaphore, sizeof(VkSemaphore));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSemaphore*)pSemaphore = (VkSemaphore)(VkSemaphore)((VkSemaphore)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkSemaphoreCreateInfo(m_state, (VkSemaphoreCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateSemaphore 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSemaphore);
                }
                VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
                vkCreateSemaphore_VkResult_return = m_state->on_vkCreateSemaphore(&m_pool, device, pCreateInfo, pAllocator, pSemaphore);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pSemaphore;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkSemaphore), "handle map overwrite requres VkSemaphore to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSemaphore((VkSemaphore*)pSemaphore, 1);
                vkStream->write((VkSemaphore*)pSemaphore, 8 * 1);
                // Begin manual non dispatchable handle create for pSemaphore;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSemaphore_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSemaphore(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSemaphore_VkResult_return, device, pCreateInfo, pAllocator, pSemaphore);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroySemaphore:
            {
                android::base::beginTrace("vkDestroySemaphore decode");
                VkDevice device;
                VkSemaphore semaphore;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                // Begin manual non dispatchable handle destroy unboxing for semaphore;
                VkSemaphore boxed_semaphore_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSemaphore*)&semaphore = (VkSemaphore)(VkSemaphore)((VkSemaphore)(*&cgen_var_1));
                boxed_semaphore_preserve = semaphore;
                semaphore = unbox_VkSemaphore(semaphore);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroySemaphore 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)semaphore, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroySemaphore(&m_pool, device, semaphore, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySemaphore(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_semaphore_preserve, pAllocator);
                }
                delete_VkSemaphore(boxed_semaphore_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateEvent:
            {
                android::base::beginTrace("vkCreateEvent decode");
                VkDevice device;
                const VkEventCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkEvent* pEvent;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkEventCreateInfo));
                reservedunmarshal_VkEventCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkEventCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pEvent;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pEvent, sizeof(VkEvent));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkEvent*)pEvent = (VkEvent)(VkEvent)((VkEvent)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkEventCreateInfo(m_state, (VkEventCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateEvent 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pEvent);
                }
                VkResult vkCreateEvent_VkResult_return = (VkResult)0;
                vkCreateEvent_VkResult_return = vk->vkCreateEvent(unboxed_device, pCreateInfo, pAllocator, pEvent);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pEvent;
                if (vkCreateEvent_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkEvent), "handle map overwrite requres VkEvent to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkEvent((VkEvent*)pEvent, 1);
                vkStream->write((VkEvent*)pEvent, 8 * 1);
                // Begin auto non dispatchable handle create for pEvent;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateEvent_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateEvent_VkResult_return, device, pCreateInfo, pAllocator, pEvent);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyEvent:
            {
                android::base::beginTrace("vkDestroyEvent decode");
                VkDevice device;
                VkEvent event;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for event;
                VkEvent boxed_event_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)(VkEvent)((VkEvent)(*&cgen_var_1));
                boxed_event_preserve = event;
                event = unbox_VkEvent(event);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyEvent 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)event, (unsigned long long)pAllocator);
                }
                vk->vkDestroyEvent(unboxed_device, event, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_event_preserve, pAllocator);
                }
                delete_VkEvent(boxed_event_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetEventStatus:
            {
                android::base::beginTrace("vkGetEventStatus decode");
                VkDevice device;
                VkEvent event;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_1));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetEventStatus 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)event);
                }
                VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
                vkGetEventStatus_VkResult_return = vk->vkGetEventStatus(unboxed_device, event);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetEventStatus_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetEventStatus(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetEventStatus_VkResult_return, device, event);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkSetEvent:
            {
                android::base::beginTrace("vkSetEvent decode");
                VkDevice device;
                VkEvent event;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_1));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSetEvent 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)event);
                }
                VkResult vkSetEvent_VkResult_return = (VkResult)0;
                vkSetEvent_VkResult_return = vk->vkSetEvent(unboxed_device, event);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSetEvent_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkSetEvent_VkResult_return, device, event);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkResetEvent:
            {
                android::base::beginTrace("vkResetEvent decode");
                VkDevice device;
                VkEvent event;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_1));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkResetEvent 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)event);
                }
                VkResult vkResetEvent_VkResult_return = (VkResult)0;
                vkResetEvent_VkResult_return = vk->vkResetEvent(unboxed_device, event);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetEvent_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetEvent_VkResult_return, device, event);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateQueryPool:
            {
                android::base::beginTrace("vkCreateQueryPool decode");
                VkDevice device;
                const VkQueryPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkQueryPool* pQueryPool;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkQueryPoolCreateInfo));
                reservedunmarshal_VkQueryPoolCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueryPoolCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pQueryPool;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pQueryPool, sizeof(VkQueryPool));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkQueryPool*)pQueryPool = (VkQueryPool)(VkQueryPool)((VkQueryPool)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkQueryPoolCreateInfo(m_state, (VkQueryPoolCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateQueryPool 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pQueryPool);
                }
                VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
                vkCreateQueryPool_VkResult_return = vk->vkCreateQueryPool(unboxed_device, pCreateInfo, pAllocator, pQueryPool);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pQueryPool;
                if (vkCreateQueryPool_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkQueryPool), "handle map overwrite requres VkQueryPool to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkQueryPool((VkQueryPool*)pQueryPool, 1);
                vkStream->write((VkQueryPool*)pQueryPool, 8 * 1);
                // Begin auto non dispatchable handle create for pQueryPool;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateQueryPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateQueryPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateQueryPool_VkResult_return, device, pCreateInfo, pAllocator, pQueryPool);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyQueryPool:
            {
                android::base::beginTrace("vkDestroyQueryPool decode");
                VkDevice device;
                VkQueryPool queryPool;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for queryPool;
                VkQueryPool boxed_queryPool_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)(VkQueryPool)((VkQueryPool)(*&cgen_var_1));
                boxed_queryPool_preserve = queryPool;
                queryPool = unbox_VkQueryPool(queryPool);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyQueryPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)queryPool, (unsigned long long)pAllocator);
                }
                vk->vkDestroyQueryPool(unboxed_device, queryPool, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyQueryPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_queryPool_preserve, pAllocator);
                }
                delete_VkQueryPool(boxed_queryPool_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetQueryPoolResults:
            {
                android::base::beginTrace("vkGetQueryPoolResults decode");
                VkDevice device;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                size_t dataSize;
                void* pData;
                VkDeviceSize stride;
                VkQueryResultFlags flags;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_1));
                memcpy((uint32_t*)&firstQuery, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&queryCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((size_t*)&dataSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&dataSize);
                *readStreamPtrPtr += 8;
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(uint8_t));
                memcpy((void*)pData, *readStreamPtrPtr, ((dataSize)) * sizeof(uint8_t));
                *readStreamPtrPtr += ((dataSize)) * sizeof(uint8_t);
                memcpy((VkDeviceSize*)&stride, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkQueryResultFlags*)&flags, *readStreamPtrPtr, sizeof(VkQueryResultFlags));
                *readStreamPtrPtr += sizeof(VkQueryResultFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetQueryPoolResults 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)queryPool, (unsigned long long)firstQuery, (unsigned long long)queryCount, (unsigned long long)dataSize, (unsigned long long)pData, (unsigned long long)stride, (unsigned long long)flags);
                }
                VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
                vkGetQueryPoolResults_VkResult_return = vk->vkGetQueryPoolResults(unboxed_device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
                vkStream->unsetHandleMapping();
                vkStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkStream->write(&vkGetQueryPoolResults_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetQueryPoolResults(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetQueryPoolResults_VkResult_return, device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateBuffer:
            {
                android::base::beginTrace("vkCreateBuffer decode");
                VkDevice device;
                const VkBufferCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkBuffer* pBuffer;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferCreateInfo));
                reservedunmarshal_VkBufferCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pBuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pBuffer, sizeof(VkBuffer));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkBuffer*)pBuffer = (VkBuffer)(VkBuffer)((VkBuffer)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkBufferCreateInfo(m_state, (VkBufferCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateBuffer 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pBuffer);
                }
                VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
                vkCreateBuffer_VkResult_return = m_state->on_vkCreateBuffer(&m_pool, device, pCreateInfo, pAllocator, pBuffer);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pBuffer;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkBuffer), "handle map overwrite requres VkBuffer to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkBuffer((VkBuffer*)pBuffer, 1);
                vkStream->write((VkBuffer*)pBuffer, 8 * 1);
                // Begin manual non dispatchable handle create for pBuffer;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateBuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateBuffer_VkResult_return, device, pCreateInfo, pAllocator, pBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyBuffer:
            {
                android::base::beginTrace("vkDestroyBuffer decode");
                VkDevice device;
                VkBuffer buffer;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                // Begin manual non dispatchable handle destroy unboxing for buffer;
                VkBuffer boxed_buffer_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)(VkBuffer)((VkBuffer)(*&cgen_var_1));
                boxed_buffer_preserve = buffer;
                buffer = unbox_VkBuffer(buffer);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyBuffer 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyBuffer(&m_pool, device, buffer, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_buffer_preserve, pAllocator);
                }
                delete_VkBuffer(boxed_buffer_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateBufferView:
            {
                android::base::beginTrace("vkCreateBufferView decode");
                VkDevice device;
                const VkBufferViewCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkBufferView* pView;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferViewCreateInfo));
                reservedunmarshal_VkBufferViewCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferViewCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pView;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pView, sizeof(VkBufferView));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkBufferView*)pView = (VkBufferView)(VkBufferView)((VkBufferView)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkBufferViewCreateInfo(m_state, (VkBufferViewCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateBufferView 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pView);
                }
                VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
                vkCreateBufferView_VkResult_return = vk->vkCreateBufferView(unboxed_device, pCreateInfo, pAllocator, pView);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pView;
                if (vkCreateBufferView_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkBufferView), "handle map overwrite requres VkBufferView to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkBufferView((VkBufferView*)pView, 1);
                vkStream->write((VkBufferView*)pView, 8 * 1);
                // Begin auto non dispatchable handle create for pView;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateBufferView_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateBufferView(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateBufferView_VkResult_return, device, pCreateInfo, pAllocator, pView);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyBufferView:
            {
                android::base::beginTrace("vkDestroyBufferView decode");
                VkDevice device;
                VkBufferView bufferView;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for bufferView;
                VkBufferView boxed_bufferView_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBufferView*)&bufferView = (VkBufferView)(VkBufferView)((VkBufferView)(*&cgen_var_1));
                boxed_bufferView_preserve = bufferView;
                bufferView = unbox_VkBufferView(bufferView);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyBufferView 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bufferView, (unsigned long long)pAllocator);
                }
                vk->vkDestroyBufferView(unboxed_device, bufferView, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyBufferView(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_bufferView_preserve, pAllocator);
                }
                delete_VkBufferView(boxed_bufferView_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateImage:
            {
                android::base::beginTrace("vkCreateImage decode");
                VkDevice device;
                const VkImageCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkImage* pImage;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageCreateInfo));
                reservedunmarshal_VkImageCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pImage;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImage, sizeof(VkImage));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkImage*)pImage = (VkImage)(VkImage)((VkImage)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkImageCreateInfo(m_state, (VkImageCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateImage 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pImage);
                }
                VkResult vkCreateImage_VkResult_return = (VkResult)0;
                vkCreateImage_VkResult_return = m_state->on_vkCreateImage(&m_pool, device, pCreateInfo, pAllocator, pImage);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pImage;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkImage), "handle map overwrite requres VkImage to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkImage((VkImage*)pImage, 1);
                vkStream->write((VkImage*)pImage, 8 * 1);
                // Begin manual non dispatchable handle create for pImage;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateImage_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateImage_VkResult_return, device, pCreateInfo, pAllocator, pImage);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyImage:
            {
                android::base::beginTrace("vkDestroyImage decode");
                VkDevice device;
                VkImage image;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                // Begin manual non dispatchable handle destroy unboxing for image;
                VkImage boxed_image_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)(VkImage)((VkImage)(*&cgen_var_1));
                boxed_image_preserve = image;
                image = unbox_VkImage(image);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyImage 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyImage(&m_pool, device, image, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_image_preserve, pAllocator);
                }
                delete_VkImage(boxed_image_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetImageSubresourceLayout:
            {
                android::base::beginTrace("vkGetImageSubresourceLayout decode");
                VkDevice device;
                VkImage image;
                const VkImageSubresource* pSubresource;
                VkSubresourceLayout* pLayout;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                vkReadStream->alloc((void**)&pSubresource, sizeof(const VkImageSubresource));
                reservedunmarshal_VkImageSubresource(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSubresource*)(pSubresource), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pLayout, sizeof(VkSubresourceLayout));
                reservedunmarshal_VkSubresourceLayout(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubresourceLayout*)(pLayout), readStreamPtrPtr);
                if (pSubresource)
                {
                    transform_tohost_VkImageSubresource(m_state, (VkImageSubresource*)(pSubresource));
                }
                if (pLayout)
                {
                    transform_tohost_VkSubresourceLayout(m_state, (VkSubresourceLayout*)(pLayout));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageSubresourceLayout 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)pSubresource, (unsigned long long)pLayout);
                }
                vk->vkGetImageSubresourceLayout(unboxed_device, image, pSubresource, pLayout);
                vkStream->unsetHandleMapping();
                if (pLayout)
                {
                    transform_fromhost_VkSubresourceLayout(m_state, (VkSubresourceLayout*)(pLayout));
                }
                marshal_VkSubresourceLayout(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubresourceLayout*)(pLayout));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageSubresourceLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, image, pSubresource, pLayout);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateImageView:
            {
                android::base::beginTrace("vkCreateImageView decode");
                VkDevice device;
                const VkImageViewCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkImageView* pView;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageViewCreateInfo));
                reservedunmarshal_VkImageViewCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageViewCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pView;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pView, sizeof(VkImageView));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkImageView*)pView = (VkImageView)(VkImageView)((VkImageView)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkImageViewCreateInfo(m_state, (VkImageViewCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateImageView 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pView);
                }
                VkResult vkCreateImageView_VkResult_return = (VkResult)0;
                vkCreateImageView_VkResult_return = m_state->on_vkCreateImageView(&m_pool, device, pCreateInfo, pAllocator, pView);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pView;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkImageView), "handle map overwrite requres VkImageView to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkImageView((VkImageView*)pView, 1);
                vkStream->write((VkImageView*)pView, 8 * 1);
                // Begin manual non dispatchable handle create for pView;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateImageView_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateImageView(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateImageView_VkResult_return, device, pCreateInfo, pAllocator, pView);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyImageView:
            {
                android::base::beginTrace("vkDestroyImageView decode");
                VkDevice device;
                VkImageView imageView;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                // Begin manual non dispatchable handle destroy unboxing for imageView;
                VkImageView boxed_imageView_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImageView*)&imageView = (VkImageView)(VkImageView)((VkImageView)(*&cgen_var_1));
                boxed_imageView_preserve = imageView;
                imageView = unbox_VkImageView(imageView);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyImageView 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)imageView, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyImageView(&m_pool, device, imageView, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyImageView(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_imageView_preserve, pAllocator);
                }
                delete_VkImageView(boxed_imageView_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateShaderModule:
            {
                android::base::beginTrace("vkCreateShaderModule decode");
                VkDevice device;
                const VkShaderModuleCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkShaderModule* pShaderModule;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkShaderModuleCreateInfo));
                reservedunmarshal_VkShaderModuleCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkShaderModuleCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pShaderModule;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pShaderModule, sizeof(VkShaderModule));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkShaderModule*)pShaderModule = (VkShaderModule)(VkShaderModule)((VkShaderModule)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkShaderModuleCreateInfo(m_state, (VkShaderModuleCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateShaderModule 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pShaderModule);
                }
                VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
                vkCreateShaderModule_VkResult_return = vk->vkCreateShaderModule(unboxed_device, pCreateInfo, pAllocator, pShaderModule);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pShaderModule;
                if (vkCreateShaderModule_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkShaderModule), "handle map overwrite requres VkShaderModule to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkShaderModule((VkShaderModule*)pShaderModule, 1);
                vkStream->write((VkShaderModule*)pShaderModule, 8 * 1);
                // Begin auto non dispatchable handle create for pShaderModule;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateShaderModule_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateShaderModule(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateShaderModule_VkResult_return, device, pCreateInfo, pAllocator, pShaderModule);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyShaderModule:
            {
                android::base::beginTrace("vkDestroyShaderModule decode");
                VkDevice device;
                VkShaderModule shaderModule;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for shaderModule;
                VkShaderModule boxed_shaderModule_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkShaderModule*)&shaderModule = (VkShaderModule)(VkShaderModule)((VkShaderModule)(*&cgen_var_1));
                boxed_shaderModule_preserve = shaderModule;
                shaderModule = unbox_VkShaderModule(shaderModule);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyShaderModule 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)shaderModule, (unsigned long long)pAllocator);
                }
                vk->vkDestroyShaderModule(unboxed_device, shaderModule, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyShaderModule(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_shaderModule_preserve, pAllocator);
                }
                delete_VkShaderModule(boxed_shaderModule_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreatePipelineCache:
            {
                android::base::beginTrace("vkCreatePipelineCache decode");
                VkDevice device;
                const VkPipelineCacheCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkPipelineCache* pPipelineCache;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineCacheCreateInfo));
                reservedunmarshal_VkPipelineCacheCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineCacheCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPipelineCache;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelineCache, sizeof(VkPipelineCache));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkPipelineCache*)pPipelineCache = (VkPipelineCache)(VkPipelineCache)((VkPipelineCache)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkPipelineCacheCreateInfo(m_state, (VkPipelineCacheCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreatePipelineCache 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pPipelineCache);
                }
                VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
                vkCreatePipelineCache_VkResult_return = vk->vkCreatePipelineCache(unboxed_device, pCreateInfo, pAllocator, pPipelineCache);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pPipelineCache;
                if (vkCreatePipelineCache_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkPipelineCache), "handle map overwrite requres VkPipelineCache to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkPipelineCache((VkPipelineCache*)pPipelineCache, 1);
                vkStream->write((VkPipelineCache*)pPipelineCache, 8 * 1);
                // Begin auto non dispatchable handle create for pPipelineCache;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreatePipelineCache_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreatePipelineCache(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreatePipelineCache_VkResult_return, device, pCreateInfo, pAllocator, pPipelineCache);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyPipelineCache:
            {
                android::base::beginTrace("vkDestroyPipelineCache decode");
                VkDevice device;
                VkPipelineCache pipelineCache;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for pipelineCache;
                VkPipelineCache boxed_pipelineCache_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineCache*)&pipelineCache = (VkPipelineCache)(VkPipelineCache)((VkPipelineCache)(*&cgen_var_1));
                boxed_pipelineCache_preserve = pipelineCache;
                pipelineCache = unbox_VkPipelineCache(pipelineCache);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyPipelineCache 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineCache, (unsigned long long)pAllocator);
                }
                vk->vkDestroyPipelineCache(unboxed_device, pipelineCache, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyPipelineCache(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_pipelineCache_preserve, pAllocator);
                }
                delete_VkPipelineCache(boxed_pipelineCache_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPipelineCacheData:
            {
                android::base::beginTrace("vkGetPipelineCacheData decode");
                VkDevice device;
                VkPipelineCache pipelineCache;
                size_t* pDataSize;
                void* pData;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineCache*)&pipelineCache = (VkPipelineCache)unbox_VkPipelineCache((VkPipelineCache)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pDataSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((size_t**)&pDataSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pDataSize);
                *readStreamPtrPtr += 8;
                if (pDataSize)
                {
                    vkReadStream->alloc((void**)&pDataSize, sizeof(size_t));
                    memcpy((size_t*)&(*pDataSize), (*readStreamPtrPtr), 8);
                    android::base::Stream::fromBe64((uint8_t*)&(*pDataSize));
                    *readStreamPtrPtr += 8;
                }
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((void**)&pData, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pData);
                *readStreamPtrPtr += 8;
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, (*(pDataSize)) * sizeof(uint8_t));
                    memcpy((void*)pData, *readStreamPtrPtr, (*(pDataSize)) * sizeof(uint8_t));
                    *readStreamPtrPtr += (*(pDataSize)) * sizeof(uint8_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPipelineCacheData 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineCache, (unsigned long long)pDataSize, (unsigned long long)pData);
                }
                VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
                vkGetPipelineCacheData_VkResult_return = vk->vkGetPipelineCacheData(unboxed_device, pipelineCache, pDataSize, pData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pDataSize;
                vkStream->putBe64(cgen_var_4);
                if (pDataSize)
                {
                    uint64_t cgen_var_4_0 = (uint64_t)(*pDataSize);
                    vkStream->putBe64(cgen_var_4_0);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_5 = (uint64_t)(uintptr_t)pData;
                vkStream->putBe64(cgen_var_5);
                if (pData)
                {
                    vkStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetPipelineCacheData_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPipelineCacheData(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPipelineCacheData_VkResult_return, device, pipelineCache, pDataSize, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkMergePipelineCaches:
            {
                android::base::beginTrace("vkMergePipelineCaches decode");
                VkDevice device;
                VkPipelineCache dstCache;
                uint32_t srcCacheCount;
                const VkPipelineCache* pSrcCaches;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineCache*)&dstCache = (VkPipelineCache)unbox_VkPipelineCache((VkPipelineCache)(*&cgen_var_1));
                memcpy((uint32_t*)&srcCacheCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pSrcCaches, ((srcCacheCount)) * sizeof(const VkPipelineCache));
                if (((srcCacheCount)))
                {
                    uint8_t* cgen_var_2_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((srcCacheCount));
                    for (uint32_t k = 0; k < ((srcCacheCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_2_ptr + k * 8, sizeof(uint64_t));
                        *(((VkPipelineCache*)pSrcCaches) + k) = (VkPipelineCache)unbox_VkPipelineCache((VkPipelineCache)tmpval);
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkMergePipelineCaches 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)dstCache, (unsigned long long)srcCacheCount, (unsigned long long)pSrcCaches);
                }
                VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
                vkMergePipelineCaches_VkResult_return = vk->vkMergePipelineCaches(unboxed_device, dstCache, srcCacheCount, pSrcCaches);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkMergePipelineCaches_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkMergePipelineCaches(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkMergePipelineCaches_VkResult_return, device, dstCache, srcCacheCount, pSrcCaches);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateGraphicsPipelines:
            {
                android::base::beginTrace("vkCreateGraphicsPipelines decode");
                VkDevice device;
                VkPipelineCache pipelineCache;
                uint32_t createInfoCount;
                const VkGraphicsPipelineCreateInfo* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkPipeline* pPipelines;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineCache*)&pipelineCache = (VkPipelineCache)unbox_VkPipelineCache((VkPipelineCache)(*&cgen_var_1));
                memcpy((uint32_t*)&createInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkGraphicsPipelineCreateInfo));
                for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                {
                    reservedunmarshal_VkGraphicsPipelineCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkGraphicsPipelineCreateInfo*)(pCreateInfos + i), readStreamPtrPtr);
                }
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPipelines;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                if (((createInfoCount)))
                {
                    uint8_t* cgen_var_3_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((createInfoCount));
                    for (uint32_t k = 0; k < ((createInfoCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_3_ptr + k * 8, sizeof(uint64_t));
                        *(((VkPipeline*)pPipelines) + k) = (VkPipeline)(VkPipeline)((VkPipeline)tmpval);
                    }
                }
                if (pCreateInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                    {
                        transform_tohost_VkGraphicsPipelineCreateInfo(m_state, (VkGraphicsPipelineCreateInfo*)(pCreateInfos + i));
                    }
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateGraphicsPipelines 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineCache, (unsigned long long)createInfoCount, (unsigned long long)pCreateInfos, (unsigned long long)pAllocator, (unsigned long long)pPipelines);
                }
                VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
                vkCreateGraphicsPipelines_VkResult_return = vk->vkCreateGraphicsPipelines(unboxed_device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pPipelines;
                if (vkCreateGraphicsPipelines_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_4;
                    vkStream->alloc((void**)&cgen_var_4, ((createInfoCount)) * 8);
                    static_assert(8 == sizeof(VkPipeline), "handle map overwrite requres VkPipeline to be 8 bytes long");
                    vkStream->handleMapping()->mapHandles_VkPipeline((VkPipeline*)pPipelines, ((createInfoCount)));
                    vkStream->write((VkPipeline*)pPipelines, 8 * ((createInfoCount)));
                }
                // Begin auto non dispatchable handle create for pPipelines;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateGraphicsPipelines_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateGraphicsPipelines(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateGraphicsPipelines_VkResult_return, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateComputePipelines:
            {
                android::base::beginTrace("vkCreateComputePipelines decode");
                VkDevice device;
                VkPipelineCache pipelineCache;
                uint32_t createInfoCount;
                const VkComputePipelineCreateInfo* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkPipeline* pPipelines;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineCache*)&pipelineCache = (VkPipelineCache)unbox_VkPipelineCache((VkPipelineCache)(*&cgen_var_1));
                memcpy((uint32_t*)&createInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkComputePipelineCreateInfo));
                for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                {
                    reservedunmarshal_VkComputePipelineCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkComputePipelineCreateInfo*)(pCreateInfos + i), readStreamPtrPtr);
                }
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPipelines;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                if (((createInfoCount)))
                {
                    uint8_t* cgen_var_3_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((createInfoCount));
                    for (uint32_t k = 0; k < ((createInfoCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_3_ptr + k * 8, sizeof(uint64_t));
                        *(((VkPipeline*)pPipelines) + k) = (VkPipeline)(VkPipeline)((VkPipeline)tmpval);
                    }
                }
                if (pCreateInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                    {
                        transform_tohost_VkComputePipelineCreateInfo(m_state, (VkComputePipelineCreateInfo*)(pCreateInfos + i));
                    }
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateComputePipelines 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineCache, (unsigned long long)createInfoCount, (unsigned long long)pCreateInfos, (unsigned long long)pAllocator, (unsigned long long)pPipelines);
                }
                VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
                vkCreateComputePipelines_VkResult_return = vk->vkCreateComputePipelines(unboxed_device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pPipelines;
                if (vkCreateComputePipelines_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_4;
                    vkStream->alloc((void**)&cgen_var_4, ((createInfoCount)) * 8);
                    static_assert(8 == sizeof(VkPipeline), "handle map overwrite requres VkPipeline to be 8 bytes long");
                    vkStream->handleMapping()->mapHandles_VkPipeline((VkPipeline*)pPipelines, ((createInfoCount)));
                    vkStream->write((VkPipeline*)pPipelines, 8 * ((createInfoCount)));
                }
                // Begin auto non dispatchable handle create for pPipelines;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateComputePipelines(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateComputePipelines_VkResult_return, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyPipeline:
            {
                android::base::beginTrace("vkDestroyPipeline decode");
                VkDevice device;
                VkPipeline pipeline;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for pipeline;
                VkPipeline boxed_pipeline_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipeline*)&pipeline = (VkPipeline)(VkPipeline)((VkPipeline)(*&cgen_var_1));
                boxed_pipeline_preserve = pipeline;
                pipeline = unbox_VkPipeline(pipeline);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyPipeline 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipeline, (unsigned long long)pAllocator);
                }
                vk->vkDestroyPipeline(unboxed_device, pipeline, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyPipeline(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_pipeline_preserve, pAllocator);
                }
                delete_VkPipeline(boxed_pipeline_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreatePipelineLayout:
            {
                android::base::beginTrace("vkCreatePipelineLayout decode");
                VkDevice device;
                const VkPipelineLayoutCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkPipelineLayout* pPipelineLayout;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineLayoutCreateInfo));
                reservedunmarshal_VkPipelineLayoutCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineLayoutCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPipelineLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelineLayout, sizeof(VkPipelineLayout));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkPipelineLayout*)pPipelineLayout = (VkPipelineLayout)(VkPipelineLayout)((VkPipelineLayout)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkPipelineLayoutCreateInfo(m_state, (VkPipelineLayoutCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreatePipelineLayout 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pPipelineLayout);
                }
                m_state->lock();
                VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
                vkCreatePipelineLayout_VkResult_return = vk->vkCreatePipelineLayout(unboxed_device, pCreateInfo, pAllocator, pPipelineLayout);
                m_state->unlock();
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pPipelineLayout;
                if (vkCreatePipelineLayout_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkPipelineLayout), "handle map overwrite requres VkPipelineLayout to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkPipelineLayout((VkPipelineLayout*)pPipelineLayout, 1);
                vkStream->write((VkPipelineLayout*)pPipelineLayout, 8 * 1);
                // Begin auto non dispatchable handle create for pPipelineLayout;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreatePipelineLayout_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreatePipelineLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreatePipelineLayout_VkResult_return, device, pCreateInfo, pAllocator, pPipelineLayout);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyPipelineLayout:
            {
                android::base::beginTrace("vkDestroyPipelineLayout decode");
                VkDevice device;
                VkPipelineLayout pipelineLayout;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for pipelineLayout;
                VkPipelineLayout boxed_pipelineLayout_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineLayout*)&pipelineLayout = (VkPipelineLayout)(VkPipelineLayout)((VkPipelineLayout)(*&cgen_var_1));
                boxed_pipelineLayout_preserve = pipelineLayout;
                pipelineLayout = unbox_VkPipelineLayout(pipelineLayout);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyPipelineLayout 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineLayout, (unsigned long long)pAllocator);
                }
                std::function<void()> delayed_remove_callback = [vk, unboxed_device, pipelineLayout, pAllocator]() {
                auto state = VkDecoderGlobalState::get();
                // state already locked;
                vk->vkDestroyPipelineLayout(unboxed_device, pipelineLayout, pAllocator);
                };
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyPipelineLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_pipelineLayout_preserve, pAllocator);
                }
                delayed_delete_VkPipelineLayout(boxed_pipelineLayout_preserve, unboxed_device, delayed_remove_callback);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateSampler:
            {
                android::base::beginTrace("vkCreateSampler decode");
                VkDevice device;
                const VkSamplerCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSampler* pSampler;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerCreateInfo));
                reservedunmarshal_VkSamplerCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSamplerCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSampler;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSampler, sizeof(VkSampler));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSampler*)pSampler = (VkSampler)(VkSampler)((VkSampler)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkSamplerCreateInfo(m_state, (VkSamplerCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateSampler 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSampler);
                }
                VkResult vkCreateSampler_VkResult_return = (VkResult)0;
                vkCreateSampler_VkResult_return = m_state->on_vkCreateSampler(&m_pool, device, pCreateInfo, pAllocator, pSampler);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pSampler;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkSampler), "handle map overwrite requres VkSampler to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSampler((VkSampler*)pSampler, 1);
                vkStream->write((VkSampler*)pSampler, 8 * 1);
                // Begin manual non dispatchable handle create for pSampler;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSampler_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSampler(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSampler_VkResult_return, device, pCreateInfo, pAllocator, pSampler);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroySampler:
            {
                android::base::beginTrace("vkDestroySampler decode");
                VkDevice device;
                VkSampler sampler;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                // Begin manual non dispatchable handle destroy unboxing for sampler;
                VkSampler boxed_sampler_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSampler*)&sampler = (VkSampler)(VkSampler)((VkSampler)(*&cgen_var_1));
                boxed_sampler_preserve = sampler;
                sampler = unbox_VkSampler(sampler);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroySampler 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)sampler, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroySampler(&m_pool, device, sampler, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySampler(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_sampler_preserve, pAllocator);
                }
                delete_VkSampler(boxed_sampler_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateDescriptorSetLayout:
            {
                android::base::beginTrace("vkCreateDescriptorSetLayout decode");
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorSetLayout* pSetLayout;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                reservedunmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSetLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSetLayout, sizeof(VkDescriptorSetLayout));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDescriptorSetLayout*)pSetLayout = (VkDescriptorSetLayout)(VkDescriptorSetLayout)((VkDescriptorSetLayout)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorSetLayoutCreateInfo(m_state, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDescriptorSetLayout 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSetLayout);
                }
                VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
                vkCreateDescriptorSetLayout_VkResult_return = m_state->on_vkCreateDescriptorSetLayout(&m_pool, device, pCreateInfo, pAllocator, pSetLayout);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pSetLayout;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkDescriptorSetLayout), "handle map overwrite requres VkDescriptorSetLayout to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)pSetLayout, 1);
                vkStream->write((VkDescriptorSetLayout*)pSetLayout, 8 * 1);
                // Begin manual non dispatchable handle create for pSetLayout;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorSetLayout_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDescriptorSetLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDescriptorSetLayout_VkResult_return, device, pCreateInfo, pAllocator, pSetLayout);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDescriptorSetLayout:
            {
                android::base::beginTrace("vkDestroyDescriptorSetLayout decode");
                VkDevice device;
                VkDescriptorSetLayout descriptorSetLayout;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                // Begin manual non dispatchable handle destroy unboxing for descriptorSetLayout;
                VkDescriptorSetLayout boxed_descriptorSetLayout_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorSetLayout*)&descriptorSetLayout = (VkDescriptorSetLayout)(VkDescriptorSetLayout)((VkDescriptorSetLayout)(*&cgen_var_1));
                boxed_descriptorSetLayout_preserve = descriptorSetLayout;
                descriptorSetLayout = unbox_VkDescriptorSetLayout(descriptorSetLayout);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDescriptorSetLayout 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorSetLayout, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDescriptorSetLayout(&m_pool, device, descriptorSetLayout, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDescriptorSetLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_descriptorSetLayout_preserve, pAllocator);
                }
                delete_VkDescriptorSetLayout(boxed_descriptorSetLayout_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateDescriptorPool:
            {
                android::base::beginTrace("vkCreateDescriptorPool decode");
                VkDevice device;
                const VkDescriptorPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorPool* pDescriptorPool;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorPoolCreateInfo));
                reservedunmarshal_VkDescriptorPoolCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorPoolCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pDescriptorPool;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorPool, sizeof(VkDescriptorPool));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDescriptorPool*)pDescriptorPool = (VkDescriptorPool)(VkDescriptorPool)((VkDescriptorPool)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorPoolCreateInfo(m_state, (VkDescriptorPoolCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDescriptorPool 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pDescriptorPool);
                }
                VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
                vkCreateDescriptorPool_VkResult_return = m_state->on_vkCreateDescriptorPool(&m_pool, device, pCreateInfo, pAllocator, pDescriptorPool);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pDescriptorPool;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkDescriptorPool), "handle map overwrite requres VkDescriptorPool to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDescriptorPool((VkDescriptorPool*)pDescriptorPool, 1);
                vkStream->write((VkDescriptorPool*)pDescriptorPool, 8 * 1);
                // Begin manual non dispatchable handle create for pDescriptorPool;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDescriptorPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDescriptorPool_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorPool);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDescriptorPool:
            {
                android::base::beginTrace("vkDestroyDescriptorPool decode");
                VkDevice device;
                VkDescriptorPool descriptorPool;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                // Begin manual non dispatchable handle destroy unboxing for descriptorPool;
                VkDescriptorPool boxed_descriptorPool_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorPool*)&descriptorPool = (VkDescriptorPool)(VkDescriptorPool)((VkDescriptorPool)(*&cgen_var_1));
                boxed_descriptorPool_preserve = descriptorPool;
                descriptorPool = unbox_VkDescriptorPool(descriptorPool);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDescriptorPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorPool, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDescriptorPool(&m_pool, device, descriptorPool, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDescriptorPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_descriptorPool_preserve, pAllocator);
                }
                delete_VkDescriptorPool(boxed_descriptorPool_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkResetDescriptorPool:
            {
                android::base::beginTrace("vkResetDescriptorPool decode");
                VkDevice device;
                VkDescriptorPool descriptorPool;
                VkDescriptorPoolResetFlags flags;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorPool*)&descriptorPool = (VkDescriptorPool)unbox_VkDescriptorPool((VkDescriptorPool)(*&cgen_var_1));
                memcpy((VkDescriptorPoolResetFlags*)&flags, *readStreamPtrPtr, sizeof(VkDescriptorPoolResetFlags));
                *readStreamPtrPtr += sizeof(VkDescriptorPoolResetFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkResetDescriptorPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorPool, (unsigned long long)flags);
                }
                VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
                vkResetDescriptorPool_VkResult_return = m_state->on_vkResetDescriptorPool(&m_pool, device, descriptorPool, flags);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetDescriptorPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetDescriptorPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetDescriptorPool_VkResult_return, device, descriptorPool, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkAllocateDescriptorSets:
            {
                android::base::beginTrace("vkAllocateDescriptorSets decode");
                VkDevice device;
                const VkDescriptorSetAllocateInfo* pAllocateInfo;
                VkDescriptorSet* pDescriptorSets;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkDescriptorSetAllocateInfo));
                reservedunmarshal_VkDescriptorSetAllocateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetAllocateInfo*)(pAllocateInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pDescriptorSets;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorSets, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
                if (pAllocateInfo->descriptorSetCount)
                {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * pAllocateInfo->descriptorSetCount;
                    for (uint32_t k = 0; k < pAllocateInfo->descriptorSetCount; ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkDescriptorSet*)pDescriptorSets) + k) = (VkDescriptorSet)(VkDescriptorSet)((VkDescriptorSet)tmpval);
                    }
                }
                if (pAllocateInfo)
                {
                    transform_tohost_VkDescriptorSetAllocateInfo(m_state, (VkDescriptorSetAllocateInfo*)(pAllocateInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAllocateDescriptorSets 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAllocateInfo, (unsigned long long)pDescriptorSets);
                }
                VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
                vkAllocateDescriptorSets_VkResult_return = m_state->on_vkAllocateDescriptorSets(&m_pool, device, pAllocateInfo, pDescriptorSets);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pDescriptorSets;
                vkStream->unsetHandleMapping();
                if (pAllocateInfo->descriptorSetCount)
                {
                    uint64_t* cgen_var_2;
                    vkStream->alloc((void**)&cgen_var_2, pAllocateInfo->descriptorSetCount * 8);
                    static_assert(8 == sizeof(VkDescriptorSet), "handle map overwrite requres VkDescriptorSet to be 8 bytes long");
                    vkStream->handleMapping()->mapHandles_VkDescriptorSet((VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount);
                    vkStream->write((VkDescriptorSet*)pDescriptorSets, 8 * pAllocateInfo->descriptorSetCount);
                }
                // Begin manual non dispatchable handle create for pDescriptorSets;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkAllocateDescriptorSets_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAllocateDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAllocateDescriptorSets_VkResult_return, device, pAllocateInfo, pDescriptorSets);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkFreeDescriptorSets:
            {
                android::base::beginTrace("vkFreeDescriptorSets decode");
                VkDevice device;
                VkDescriptorPool descriptorPool;
                uint32_t descriptorSetCount;
                const VkDescriptorSet* pDescriptorSets;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorPool*)&descriptorPool = (VkDescriptorPool)unbox_VkDescriptorPool((VkDescriptorPool)(*&cgen_var_1));
                memcpy((uint32_t*)&descriptorSetCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual non dispatchable handle destroy unboxing for pDescriptorSets;
                VkDescriptorSet* boxed_pDescriptorSets_preserve; vkReadStream->alloc((void**)&boxed_pDescriptorSets_preserve, ((descriptorSetCount)) * sizeof(VkDescriptorSet));
                // WARNING PTR CHECK
                memcpy((VkDescriptorSet**)&pDescriptorSets, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pDescriptorSets);
                *readStreamPtrPtr += 8;
                if (pDescriptorSets)
                {
                    vkReadStream->alloc((void**)&pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                    if (((descriptorSetCount)))
                    {
                        uint8_t* cgen_var_2_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((descriptorSetCount));
                        for (uint32_t k = 0; k < ((descriptorSetCount)); ++k)
                        {
                            uint64_t tmpval; memcpy(&tmpval, cgen_var_2_0_ptr + k * 8, sizeof(uint64_t));
                            *(((VkDescriptorSet*)pDescriptorSets) + k) = (VkDescriptorSet)(VkDescriptorSet)((VkDescriptorSet)tmpval);
                        }
                    }
                }
                for (uint32_t i = 0; i < ((descriptorSetCount)); ++i)
                {
                    boxed_pDescriptorSets_preserve[i] = pDescriptorSets[i];
                    ((VkDescriptorSet*)(pDescriptorSets))[i] = unbox_VkDescriptorSet(pDescriptorSets[i]);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkFreeDescriptorSets 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorPool, (unsigned long long)descriptorSetCount, (unsigned long long)pDescriptorSets);
                }
                VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
                vkFreeDescriptorSets_VkResult_return = m_state->on_vkFreeDescriptorSets(&m_pool, device, descriptorPool, descriptorSetCount, pDescriptorSets);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkFreeDescriptorSets_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFreeDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkFreeDescriptorSets_VkResult_return, device, descriptorPool, descriptorSetCount, boxed_pDescriptorSets_preserve);
                }
                // Skipping handle cleanup for vkFreeDescriptorSets
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkUpdateDescriptorSets:
            {
                android::base::beginTrace("vkUpdateDescriptorSets decode");
                VkDevice device;
                uint32_t descriptorWriteCount;
                const VkWriteDescriptorSet* pDescriptorWrites;
                uint32_t descriptorCopyCount;
                const VkCopyDescriptorSet* pDescriptorCopies;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                memcpy((uint32_t*)&descriptorWriteCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pDescriptorWrites, ((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                {
                    reservedunmarshal_VkWriteDescriptorSet(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWriteDescriptorSet*)(pDescriptorWrites + i), readStreamPtrPtr);
                }
                memcpy((uint32_t*)&descriptorCopyCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pDescriptorCopies, ((descriptorCopyCount)) * sizeof(const VkCopyDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
                {
                    reservedunmarshal_VkCopyDescriptorSet(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyDescriptorSet*)(pDescriptorCopies + i), readStreamPtrPtr);
                }
                if (pDescriptorWrites)
                {
                    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                    {
                        transform_tohost_VkWriteDescriptorSet(m_state, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                    }
                }
                if (pDescriptorCopies)
                {
                    for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
                    {
                        transform_tohost_VkCopyDescriptorSet(m_state, (VkCopyDescriptorSet*)(pDescriptorCopies + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkUpdateDescriptorSets 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorWriteCount, (unsigned long long)pDescriptorWrites, (unsigned long long)descriptorCopyCount, (unsigned long long)pDescriptorCopies);
                }
                m_state->on_vkUpdateDescriptorSets(&m_pool, device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUpdateDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateFramebuffer:
            {
                android::base::beginTrace("vkCreateFramebuffer decode");
                VkDevice device;
                const VkFramebufferCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFramebuffer* pFramebuffer;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkFramebufferCreateInfo));
                reservedunmarshal_VkFramebufferCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFramebufferCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pFramebuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFramebuffer, sizeof(VkFramebuffer));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkFramebuffer*)pFramebuffer = (VkFramebuffer)(VkFramebuffer)((VkFramebuffer)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkFramebufferCreateInfo(m_state, (VkFramebufferCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateFramebuffer 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pFramebuffer);
                }
                VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
                vkCreateFramebuffer_VkResult_return = vk->vkCreateFramebuffer(unboxed_device, pCreateInfo, pAllocator, pFramebuffer);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pFramebuffer;
                if (vkCreateFramebuffer_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkFramebuffer), "handle map overwrite requres VkFramebuffer to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkFramebuffer((VkFramebuffer*)pFramebuffer, 1);
                vkStream->write((VkFramebuffer*)pFramebuffer, 8 * 1);
                // Begin auto non dispatchable handle create for pFramebuffer;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateFramebuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateFramebuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateFramebuffer_VkResult_return, device, pCreateInfo, pAllocator, pFramebuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyFramebuffer:
            {
                android::base::beginTrace("vkDestroyFramebuffer decode");
                VkDevice device;
                VkFramebuffer framebuffer;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for framebuffer;
                VkFramebuffer boxed_framebuffer_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFramebuffer*)&framebuffer = (VkFramebuffer)(VkFramebuffer)((VkFramebuffer)(*&cgen_var_1));
                boxed_framebuffer_preserve = framebuffer;
                framebuffer = unbox_VkFramebuffer(framebuffer);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyFramebuffer 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)framebuffer, (unsigned long long)pAllocator);
                }
                vk->vkDestroyFramebuffer(unboxed_device, framebuffer, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyFramebuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_framebuffer_preserve, pAllocator);
                }
                delete_VkFramebuffer(boxed_framebuffer_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateRenderPass:
            {
                android::base::beginTrace("vkCreateRenderPass decode");
                VkDevice device;
                const VkRenderPassCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkRenderPass* pRenderPass;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo));
                reservedunmarshal_VkRenderPassCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pRenderPass;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pRenderPass, sizeof(VkRenderPass));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkRenderPass*)pRenderPass = (VkRenderPass)(VkRenderPass)((VkRenderPass)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkRenderPassCreateInfo(m_state, (VkRenderPassCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateRenderPass 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pRenderPass);
                }
                VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
                vkCreateRenderPass_VkResult_return = m_state->on_vkCreateRenderPass(&m_pool, device, pCreateInfo, pAllocator, pRenderPass);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pRenderPass;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkRenderPass), "handle map overwrite requres VkRenderPass to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkRenderPass((VkRenderPass*)pRenderPass, 1);
                vkStream->write((VkRenderPass*)pRenderPass, 8 * 1);
                // Begin manual non dispatchable handle create for pRenderPass;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateRenderPass_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateRenderPass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateRenderPass_VkResult_return, device, pCreateInfo, pAllocator, pRenderPass);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyRenderPass:
            {
                android::base::beginTrace("vkDestroyRenderPass decode");
                VkDevice device;
                VkRenderPass renderPass;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for renderPass;
                VkRenderPass boxed_renderPass_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkRenderPass*)&renderPass = (VkRenderPass)(VkRenderPass)((VkRenderPass)(*&cgen_var_1));
                boxed_renderPass_preserve = renderPass;
                renderPass = unbox_VkRenderPass(renderPass);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyRenderPass 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)renderPass, (unsigned long long)pAllocator);
                }
                vk->vkDestroyRenderPass(unboxed_device, renderPass, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyRenderPass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_renderPass_preserve, pAllocator);
                }
                delete_VkRenderPass(boxed_renderPass_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetRenderAreaGranularity:
            {
                android::base::beginTrace("vkGetRenderAreaGranularity decode");
                VkDevice device;
                VkRenderPass renderPass;
                VkExtent2D* pGranularity;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkRenderPass*)&renderPass = (VkRenderPass)unbox_VkRenderPass((VkRenderPass)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pGranularity;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pGranularity, sizeof(VkExtent2D));
                reservedunmarshal_VkExtent2D(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtent2D*)(pGranularity), readStreamPtrPtr);
                if (pGranularity)
                {
                    transform_tohost_VkExtent2D(m_state, (VkExtent2D*)(pGranularity));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetRenderAreaGranularity 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)renderPass, (unsigned long long)pGranularity);
                }
                vk->vkGetRenderAreaGranularity(unboxed_device, renderPass, pGranularity);
                vkStream->unsetHandleMapping();
                if (pGranularity)
                {
                    transform_fromhost_VkExtent2D(m_state, (VkExtent2D*)(pGranularity));
                }
                marshal_VkExtent2D(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtent2D*)(pGranularity));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetRenderAreaGranularity(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, renderPass, pGranularity);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateCommandPool:
            {
                android::base::beginTrace("vkCreateCommandPool decode");
                VkDevice device;
                const VkCommandPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkCommandPool* pCommandPool;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkCommandPoolCreateInfo));
                reservedunmarshal_VkCommandPoolCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCommandPoolCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pCommandPool;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCommandPool, sizeof(VkCommandPool));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkCommandPool*)pCommandPool = (VkCommandPool)(VkCommandPool)((VkCommandPool)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkCommandPoolCreateInfo(m_state, (VkCommandPoolCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateCommandPool 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pCommandPool);
                }
                VkResult vkCreateCommandPool_VkResult_return = (VkResult)0;
                vkCreateCommandPool_VkResult_return = m_state->on_vkCreateCommandPool(&m_pool, device, pCreateInfo, pAllocator, pCommandPool);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pCommandPool;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkCommandPool), "handle map overwrite requres VkCommandPool to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkCommandPool((VkCommandPool*)pCommandPool, 1);
                vkStream->write((VkCommandPool*)pCommandPool, 8 * 1);
                // Begin manual non dispatchable handle create for pCommandPool;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateCommandPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateCommandPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateCommandPool_VkResult_return, device, pCreateInfo, pAllocator, pCommandPool);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyCommandPool:
            {
                android::base::beginTrace("vkDestroyCommandPool decode");
                VkDevice device;
                VkCommandPool commandPool;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                // Begin manual non dispatchable handle destroy unboxing for commandPool;
                VkCommandPool boxed_commandPool_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandPool*)&commandPool = (VkCommandPool)(VkCommandPool)((VkCommandPool)(*&cgen_var_1));
                boxed_commandPool_preserve = commandPool;
                commandPool = unbox_VkCommandPool(commandPool);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyCommandPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyCommandPool(&m_pool, device, commandPool, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyCommandPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_commandPool_preserve, pAllocator);
                }
                delete_VkCommandPool(boxed_commandPool_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkResetCommandPool:
            {
                android::base::beginTrace("vkResetCommandPool decode");
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolResetFlags flags;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandPool*)&commandPool = (VkCommandPool)unbox_VkCommandPool((VkCommandPool)(*&cgen_var_1));
                memcpy((VkCommandPoolResetFlags*)&flags, *readStreamPtrPtr, sizeof(VkCommandPoolResetFlags));
                *readStreamPtrPtr += sizeof(VkCommandPoolResetFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkResetCommandPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)flags);
                }
                VkResult vkResetCommandPool_VkResult_return = (VkResult)0;
                vkResetCommandPool_VkResult_return = m_state->on_vkResetCommandPool(&m_pool, device, commandPool, flags);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetCommandPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetCommandPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetCommandPool_VkResult_return, device, commandPool, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkAllocateCommandBuffers:
            {
                android::base::beginTrace("vkAllocateCommandBuffers decode");
                VkDevice device;
                const VkCommandBufferAllocateInfo* pAllocateInfo;
                VkCommandBuffer* pCommandBuffers;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkCommandBufferAllocateInfo));
                reservedunmarshal_VkCommandBufferAllocateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCommandBufferAllocateInfo*)(pAllocateInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pCommandBuffers;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCommandBuffers, pAllocateInfo->commandBufferCount * sizeof(VkCommandBuffer));
                if (pAllocateInfo->commandBufferCount)
                {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * pAllocateInfo->commandBufferCount;
                    for (uint32_t k = 0; k < pAllocateInfo->commandBufferCount; ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkCommandBuffer*)pCommandBuffers) + k) = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)tmpval);
                    }
                }
                if (pAllocateInfo)
                {
                    transform_tohost_VkCommandBufferAllocateInfo(m_state, (VkCommandBufferAllocateInfo*)(pAllocateInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAllocateCommandBuffers 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAllocateInfo, (unsigned long long)pCommandBuffers);
                }
                VkResult vkAllocateCommandBuffers_VkResult_return = (VkResult)0;
                vkAllocateCommandBuffers_VkResult_return = m_state->on_vkAllocateCommandBuffers(&m_pool, device, pAllocateInfo, pCommandBuffers);
                vkStream->unsetHandleMapping();
                if (pAllocateInfo->commandBufferCount)
                {
                    uint64_t* cgen_var_2;
                    vkStream->alloc((void**)&cgen_var_2, pAllocateInfo->commandBufferCount * 8);
                    static_assert(8 == sizeof(VkCommandBuffer), "handle map overwrite requres VkCommandBuffer to be 8 bytes long");
                    vkStream->handleMapping()->mapHandles_VkCommandBuffer((VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount);
                    vkStream->write((VkCommandBuffer*)pCommandBuffers, 8 * pAllocateInfo->commandBufferCount);
                }
                vkStream->write(&vkAllocateCommandBuffers_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAllocateCommandBuffers(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAllocateCommandBuffers_VkResult_return, device, pAllocateInfo, pCommandBuffers);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkFreeCommandBuffers:
            {
                android::base::beginTrace("vkFreeCommandBuffers decode");
                VkDevice device;
                VkCommandPool commandPool;
                uint32_t commandBufferCount;
                const VkCommandBuffer* pCommandBuffers;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandPool*)&commandPool = (VkCommandPool)unbox_VkCommandPool((VkCommandPool)(*&cgen_var_1));
                memcpy((uint32_t*)&commandBufferCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual non dispatchable handle destroy unboxing for pCommandBuffers;
                VkCommandBuffer* boxed_pCommandBuffers_preserve; vkReadStream->alloc((void**)&boxed_pCommandBuffers_preserve, ((commandBufferCount)) * sizeof(VkCommandBuffer));
                // WARNING PTR CHECK
                memcpy((VkCommandBuffer**)&pCommandBuffers, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCommandBuffers);
                *readStreamPtrPtr += 8;
                if (pCommandBuffers)
                {
                    vkReadStream->alloc((void**)&pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                    if (((commandBufferCount)))
                    {
                        uint8_t* cgen_var_2_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((commandBufferCount));
                        for (uint32_t k = 0; k < ((commandBufferCount)); ++k)
                        {
                            uint64_t tmpval; memcpy(&tmpval, cgen_var_2_0_ptr + k * 8, sizeof(uint64_t));
                            *(((VkCommandBuffer*)pCommandBuffers) + k) = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)tmpval);
                        }
                    }
                }
                for (uint32_t i = 0; i < ((commandBufferCount)); ++i)
                {
                    boxed_pCommandBuffers_preserve[i] = pCommandBuffers[i];
                    ((VkCommandBuffer*)(pCommandBuffers))[i] = unbox_VkCommandBuffer(pCommandBuffers[i]);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkFreeCommandBuffers 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)commandBufferCount, (unsigned long long)pCommandBuffers);
                }
                m_state->on_vkFreeCommandBuffers(&m_pool, device, commandPool, commandBufferCount, pCommandBuffers);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFreeCommandBuffers(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, commandPool, commandBufferCount, boxed_pCommandBuffers_preserve);
                }
                if (((commandBufferCount)))
                {
                    for (uint32_t i = 0; i < ((commandBufferCount)); ++i)
                    {
                        delete_VkCommandBuffer(boxed_pCommandBuffers_preserve[i]);
                    }
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBeginCommandBuffer:
            {
                android::base::beginTrace("vkBeginCommandBuffer decode");
                VkCommandBuffer commandBuffer;
                const VkCommandBufferBeginInfo* pBeginInfo;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pBeginInfo, sizeof(const VkCommandBufferBeginInfo));
                reservedunmarshal_VkCommandBufferBeginInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCommandBufferBeginInfo*)(pBeginInfo), readStreamPtrPtr);
                if (pBeginInfo)
                {
                    transform_tohost_VkCommandBufferBeginInfo(m_state, (VkCommandBufferBeginInfo*)(pBeginInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBeginCommandBuffer 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pBeginInfo);
                }
                VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
                vkBeginCommandBuffer_VkResult_return = m_state->on_vkBeginCommandBuffer(&m_pool, commandBuffer, pBeginInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBeginCommandBuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBeginCommandBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBeginCommandBuffer_VkResult_return, commandBuffer, pBeginInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEndCommandBuffer:
            {
                android::base::beginTrace("vkEndCommandBuffer decode");
                VkCommandBuffer commandBuffer;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEndCommandBuffer 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
                vkEndCommandBuffer_VkResult_return = vk->vkEndCommandBuffer(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkEndCommandBuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEndCommandBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEndCommandBuffer_VkResult_return, commandBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkResetCommandBuffer:
            {
                android::base::beginTrace("vkResetCommandBuffer decode");
                VkCommandBuffer commandBuffer;
                VkCommandBufferResetFlags flags;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                memcpy((VkCommandBufferResetFlags*)&flags, *readStreamPtrPtr, sizeof(VkCommandBufferResetFlags));
                *readStreamPtrPtr += sizeof(VkCommandBufferResetFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkResetCommandBuffer 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)flags);
                }
                VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
                vkResetCommandBuffer_VkResult_return = m_state->on_vkResetCommandBuffer(&m_pool, commandBuffer, flags);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetCommandBuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetCommandBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetCommandBuffer_VkResult_return, commandBuffer, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBindPipeline:
            {
                android::base::beginTrace("vkCmdBindPipeline decode");
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipeline pipeline;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                memcpy((VkPipelineBindPoint*)&pipelineBindPoint, *readStreamPtrPtr, sizeof(VkPipelineBindPoint));
                *readStreamPtrPtr += sizeof(VkPipelineBindPoint);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipeline*)&pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_1));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBindPipeline 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineBindPoint, (unsigned long long)pipeline);
                }
                m_state->on_vkCmdBindPipeline(&m_pool, commandBuffer, pipelineBindPoint, pipeline);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindPipeline(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineBindPoint, pipeline);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetViewport:
            {
                android::base::beginTrace("vkCmdSetViewport decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstViewport;
                uint32_t viewportCount;
                const VkViewport* pViewports;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstViewport, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&viewportCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pViewports, ((viewportCount)) * sizeof(const VkViewport));
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                {
                    reservedunmarshal_VkViewport(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkViewport*)(pViewports + i), readStreamPtrPtr);
                }
                if (pViewports)
                {
                    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                    {
                        transform_tohost_VkViewport(m_state, (VkViewport*)(pViewports + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetViewport 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstViewport, (unsigned long long)viewportCount, (unsigned long long)pViewports);
                }
                vk->vkCmdSetViewport(unboxed_commandBuffer, firstViewport, viewportCount, pViewports);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetViewport(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstViewport, viewportCount, pViewports);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetScissor:
            {
                android::base::beginTrace("vkCmdSetScissor decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstScissor;
                uint32_t scissorCount;
                const VkRect2D* pScissors;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstScissor, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&scissorCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pScissors, ((scissorCount)) * sizeof(const VkRect2D));
                for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
                {
                    reservedunmarshal_VkRect2D(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(pScissors + i), readStreamPtrPtr);
                }
                if (pScissors)
                {
                    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
                    {
                        transform_tohost_VkRect2D(m_state, (VkRect2D*)(pScissors + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetScissor 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstScissor, (unsigned long long)scissorCount, (unsigned long long)pScissors);
                }
                vk->vkCmdSetScissor(unboxed_commandBuffer, firstScissor, scissorCount, pScissors);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetScissor(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstScissor, scissorCount, pScissors);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetLineWidth:
            {
                android::base::beginTrace("vkCmdSetLineWidth decode");
                VkCommandBuffer commandBuffer;
                float lineWidth;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((float*)&lineWidth, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetLineWidth 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)lineWidth);
                }
                vk->vkCmdSetLineWidth(unboxed_commandBuffer, lineWidth);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetLineWidth(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, lineWidth);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetDepthBias:
            {
                android::base::beginTrace("vkCmdSetDepthBias decode");
                VkCommandBuffer commandBuffer;
                float depthBiasConstantFactor;
                float depthBiasClamp;
                float depthBiasSlopeFactor;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((float*)&depthBiasConstantFactor, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                memcpy((float*)&depthBiasClamp, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                memcpy((float*)&depthBiasSlopeFactor, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetDepthBias 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)depthBiasConstantFactor, (unsigned long long)depthBiasClamp, (unsigned long long)depthBiasSlopeFactor);
                }
                vk->vkCmdSetDepthBias(unboxed_commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDepthBias(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetBlendConstants:
            {
                android::base::beginTrace("vkCmdSetBlendConstants decode");
                VkCommandBuffer commandBuffer;
                float blendConstants[4];
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((float*)blendConstants, *readStreamPtrPtr, 4 * sizeof(const float));
                *readStreamPtrPtr += 4 * sizeof(const float);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetBlendConstants 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)blendConstants);
                }
                vk->vkCmdSetBlendConstants(unboxed_commandBuffer, blendConstants);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetBlendConstants(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, blendConstants);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetDepthBounds:
            {
                android::base::beginTrace("vkCmdSetDepthBounds decode");
                VkCommandBuffer commandBuffer;
                float minDepthBounds;
                float maxDepthBounds;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((float*)&minDepthBounds, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                memcpy((float*)&maxDepthBounds, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetDepthBounds 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)minDepthBounds, (unsigned long long)maxDepthBounds);
                }
                vk->vkCmdSetDepthBounds(unboxed_commandBuffer, minDepthBounds, maxDepthBounds);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDepthBounds(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, minDepthBounds, maxDepthBounds);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetStencilCompareMask:
            {
                android::base::beginTrace("vkCmdSetStencilCompareMask decode");
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t compareMask;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkStencilFaceFlags*)&faceMask, *readStreamPtrPtr, sizeof(VkStencilFaceFlags));
                *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                memcpy((uint32_t*)&compareMask, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetStencilCompareMask 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)faceMask, (unsigned long long)compareMask);
                }
                vk->vkCmdSetStencilCompareMask(unboxed_commandBuffer, faceMask, compareMask);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetStencilCompareMask(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, faceMask, compareMask);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetStencilWriteMask:
            {
                android::base::beginTrace("vkCmdSetStencilWriteMask decode");
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t writeMask;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkStencilFaceFlags*)&faceMask, *readStreamPtrPtr, sizeof(VkStencilFaceFlags));
                *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                memcpy((uint32_t*)&writeMask, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetStencilWriteMask 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)faceMask, (unsigned long long)writeMask);
                }
                vk->vkCmdSetStencilWriteMask(unboxed_commandBuffer, faceMask, writeMask);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetStencilWriteMask(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, faceMask, writeMask);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetStencilReference:
            {
                android::base::beginTrace("vkCmdSetStencilReference decode");
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t reference;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkStencilFaceFlags*)&faceMask, *readStreamPtrPtr, sizeof(VkStencilFaceFlags));
                *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                memcpy((uint32_t*)&reference, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetStencilReference 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)faceMask, (unsigned long long)reference);
                }
                vk->vkCmdSetStencilReference(unboxed_commandBuffer, faceMask, reference);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetStencilReference(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, faceMask, reference);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBindDescriptorSets:
            {
                android::base::beginTrace("vkCmdBindDescriptorSets decode");
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipelineLayout layout;
                uint32_t firstSet;
                uint32_t descriptorSetCount;
                const VkDescriptorSet* pDescriptorSets;
                uint32_t dynamicOffsetCount;
                const uint32_t* pDynamicOffsets;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                memcpy((VkPipelineBindPoint*)&pipelineBindPoint, *readStreamPtrPtr, sizeof(VkPipelineBindPoint));
                *readStreamPtrPtr += sizeof(VkPipelineBindPoint);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineLayout*)&layout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_1));
                memcpy((uint32_t*)&firstSet, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&descriptorSetCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                if (((descriptorSetCount)))
                {
                    uint8_t* cgen_var_2_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((descriptorSetCount));
                    for (uint32_t k = 0; k < ((descriptorSetCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_2_ptr + k * 8, sizeof(uint64_t));
                        *(((VkDescriptorSet*)pDescriptorSets) + k) = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)tmpval);
                    }
                }
                memcpy((uint32_t*)&dynamicOffsetCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
                memcpy((uint32_t*)pDynamicOffsets, *readStreamPtrPtr, ((dynamicOffsetCount)) * sizeof(const uint32_t));
                *readStreamPtrPtr += ((dynamicOffsetCount)) * sizeof(const uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBindDescriptorSets 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineBindPoint, (unsigned long long)layout, (unsigned long long)firstSet, (unsigned long long)descriptorSetCount, (unsigned long long)pDescriptorSets, (unsigned long long)dynamicOffsetCount, (unsigned long long)pDynamicOffsets);
                }
                m_state->on_vkCmdBindDescriptorSets(&m_pool, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBindIndexBuffer:
            {
                android::base::beginTrace("vkCmdBindIndexBuffer decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkIndexType indexType;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkIndexType*)&indexType, *readStreamPtrPtr, sizeof(VkIndexType));
                *readStreamPtrPtr += sizeof(VkIndexType);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBindIndexBuffer 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)indexType);
                }
                vk->vkCmdBindIndexBuffer(unboxed_commandBuffer, buffer, offset, indexType);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindIndexBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, indexType);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBindVertexBuffers:
            {
                android::base::beginTrace("vkCmdBindVertexBuffers decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstBinding;
                uint32_t bindingCount;
                const VkBuffer* pBuffers;
                const VkDeviceSize* pOffsets;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstBinding, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&bindingCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
                if (((bindingCount)))
                {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((bindingCount));
                    for (uint32_t k = 0; k < ((bindingCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkBuffer*)pBuffers) + k) = (VkBuffer)unbox_VkBuffer((VkBuffer)tmpval);
                    }
                }
                vkReadStream->alloc((void**)&pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
                memcpy((VkDeviceSize*)pOffsets, *readStreamPtrPtr, ((bindingCount)) * sizeof(const VkDeviceSize));
                *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBindVertexBuffers 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstBinding, (unsigned long long)bindingCount, (unsigned long long)pBuffers, (unsigned long long)pOffsets);
                }
                vk->vkCmdBindVertexBuffers(unboxed_commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindVertexBuffers(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDraw:
            {
                android::base::beginTrace("vkCmdDraw decode");
                VkCommandBuffer commandBuffer;
                uint32_t vertexCount;
                uint32_t instanceCount;
                uint32_t firstVertex;
                uint32_t firstInstance;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&vertexCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&instanceCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&firstVertex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&firstInstance, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDraw 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)vertexCount, (unsigned long long)instanceCount, (unsigned long long)firstVertex, (unsigned long long)firstInstance);
                }
                vk->vkCmdDraw(unboxed_commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDraw(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDrawIndexed:
            {
                android::base::beginTrace("vkCmdDrawIndexed decode");
                VkCommandBuffer commandBuffer;
                uint32_t indexCount;
                uint32_t instanceCount;
                uint32_t firstIndex;
                int32_t vertexOffset;
                uint32_t firstInstance;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&indexCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&instanceCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&firstIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((int32_t*)&vertexOffset, *readStreamPtrPtr, sizeof(int32_t));
                *readStreamPtrPtr += sizeof(int32_t);
                memcpy((uint32_t*)&firstInstance, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndexed 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)indexCount, (unsigned long long)instanceCount, (unsigned long long)firstIndex, (unsigned long long)vertexOffset, (unsigned long long)firstInstance);
                }
                vk->vkCmdDrawIndexed(unboxed_commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndexed(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDrawIndirect:
            {
                android::base::beginTrace("vkCmdDrawIndirect decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&drawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndirect 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)drawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndirect(unboxed_commandBuffer, buffer, offset, drawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndirect(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, drawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDrawIndexedIndirect:
            {
                android::base::beginTrace("vkCmdDrawIndexedIndirect decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&drawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndexedIndirect 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)drawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndexedIndirect(unboxed_commandBuffer, buffer, offset, drawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndexedIndirect(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, drawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDispatch:
            {
                android::base::beginTrace("vkCmdDispatch decode");
                VkCommandBuffer commandBuffer;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&groupCountX, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountY, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountZ, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDispatch 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)groupCountX, (unsigned long long)groupCountY, (unsigned long long)groupCountZ);
                }
                vk->vkCmdDispatch(unboxed_commandBuffer, groupCountX, groupCountY, groupCountZ);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDispatch(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, groupCountX, groupCountY, groupCountZ);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDispatchIndirect:
            {
                android::base::beginTrace("vkCmdDispatchIndirect decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDispatchIndirect 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset);
                }
                vk->vkCmdDispatchIndirect(unboxed_commandBuffer, buffer, offset);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDispatchIndirect(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyBuffer:
            {
                android::base::beginTrace("vkCmdCopyBuffer decode");
                VkCommandBuffer commandBuffer;
                VkBuffer srcBuffer;
                VkBuffer dstBuffer;
                uint32_t regionCount;
                const VkBufferCopy* pRegions;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&srcBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_2));
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    reservedunmarshal_VkBufferCopy(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferCopy*)(pRegions + i), readStreamPtrPtr);
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkBufferCopy(m_state, (VkBufferCopy*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyBuffer 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcBuffer, (unsigned long long)dstBuffer, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                vk->vkCmdCopyBuffer(unboxed_commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyImage:
            {
                android::base::beginTrace("vkCmdCopyImage decode");
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageCopy* pRegions;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                memcpy((VkImageLayout*)&srcImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_2));
                memcpy((VkImageLayout*)&dstImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    reservedunmarshal_VkImageCopy(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageCopy*)(pRegions + i), readStreamPtrPtr);
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkImageCopy(m_state, (VkImageCopy*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcImage, (unsigned long long)srcImageLayout, (unsigned long long)dstImage, (unsigned long long)dstImageLayout, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                m_state->on_vkCmdCopyImage(&m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBlitImage:
            {
                android::base::beginTrace("vkCmdBlitImage decode");
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageBlit* pRegions;
                VkFilter filter;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                memcpy((VkImageLayout*)&srcImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_2));
                memcpy((VkImageLayout*)&dstImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageBlit));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    reservedunmarshal_VkImageBlit(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageBlit*)(pRegions + i), readStreamPtrPtr);
                }
                memcpy((VkFilter*)&filter, *readStreamPtrPtr, sizeof(VkFilter));
                *readStreamPtrPtr += sizeof(VkFilter);
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkImageBlit(m_state, (VkImageBlit*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBlitImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcImage, (unsigned long long)srcImageLayout, (unsigned long long)dstImage, (unsigned long long)dstImageLayout, (unsigned long long)regionCount, (unsigned long long)pRegions, (unsigned long long)filter);
                }
                vk->vkCmdBlitImage(unboxed_commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBlitImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyBufferToImage:
            {
                android::base::beginTrace("vkCmdCopyBufferToImage decode");
                VkCommandBuffer commandBuffer;
                VkBuffer srcBuffer;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkBufferImageCopy* pRegions;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&srcBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_2));
                memcpy((VkImageLayout*)&dstImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    reservedunmarshal_VkBufferImageCopy(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferImageCopy*)(pRegions + i), readStreamPtrPtr);
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkBufferImageCopy(m_state, (VkBufferImageCopy*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyBufferToImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcBuffer, (unsigned long long)dstImage, (unsigned long long)dstImageLayout, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                m_state->on_vkCmdCopyBufferToImage(&m_pool, commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyBufferToImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyImageToBuffer:
            {
                android::base::beginTrace("vkCmdCopyImageToBuffer decode");
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkBuffer dstBuffer;
                uint32_t regionCount;
                const VkBufferImageCopy* pRegions;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                memcpy((VkImageLayout*)&srcImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_2));
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    reservedunmarshal_VkBufferImageCopy(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferImageCopy*)(pRegions + i), readStreamPtrPtr);
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkBufferImageCopy(m_state, (VkBufferImageCopy*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyImageToBuffer 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcImage, (unsigned long long)srcImageLayout, (unsigned long long)dstBuffer, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                m_state->on_vkCmdCopyImageToBuffer(&m_pool, commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyImageToBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdUpdateBuffer:
            {
                android::base::beginTrace("vkCmdUpdateBuffer decode");
                VkCommandBuffer commandBuffer;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize dataSize;
                const void* pData;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&dstOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&dataSize, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(const uint8_t));
                memcpy((void*)pData, *readStreamPtrPtr, ((dataSize)) * sizeof(const uint8_t));
                *readStreamPtrPtr += ((dataSize)) * sizeof(const uint8_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdUpdateBuffer 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)dstBuffer, (unsigned long long)dstOffset, (unsigned long long)dataSize, (unsigned long long)pData);
                }
                vk->vkCmdUpdateBuffer(unboxed_commandBuffer, dstBuffer, dstOffset, dataSize, pData);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdUpdateBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, dstBuffer, dstOffset, dataSize, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdFillBuffer:
            {
                android::base::beginTrace("vkCmdFillBuffer decode");
                VkCommandBuffer commandBuffer;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize size;
                uint32_t data;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&dstOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&size, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&data, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdFillBuffer 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)dstBuffer, (unsigned long long)dstOffset, (unsigned long long)size, (unsigned long long)data);
                }
                vk->vkCmdFillBuffer(unboxed_commandBuffer, dstBuffer, dstOffset, size, data);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdFillBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, dstBuffer, dstOffset, size, data);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdClearColorImage:
            {
                android::base::beginTrace("vkCmdClearColorImage decode");
                VkCommandBuffer commandBuffer;
                VkImage image;
                VkImageLayout imageLayout;
                const VkClearColorValue* pColor;
                uint32_t rangeCount;
                const VkImageSubresourceRange* pRanges;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                memcpy((VkImageLayout*)&imageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                vkReadStream->alloc((void**)&pColor, sizeof(const VkClearColorValue));
                reservedunmarshal_VkClearColorValue(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkClearColorValue*)(pColor), readStreamPtrPtr);
                memcpy((uint32_t*)&rangeCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRanges, ((rangeCount)) * sizeof(const VkImageSubresourceRange));
                for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                {
                    reservedunmarshal_VkImageSubresourceRange(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSubresourceRange*)(pRanges + i), readStreamPtrPtr);
                }
                if (pColor)
                {
                    transform_tohost_VkClearColorValue(m_state, (VkClearColorValue*)(pColor));
                }
                if (pRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                    {
                        transform_tohost_VkImageSubresourceRange(m_state, (VkImageSubresourceRange*)(pRanges + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdClearColorImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)image, (unsigned long long)imageLayout, (unsigned long long)pColor, (unsigned long long)rangeCount, (unsigned long long)pRanges);
                }
                vk->vkCmdClearColorImage(unboxed_commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdClearColorImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdClearDepthStencilImage:
            {
                android::base::beginTrace("vkCmdClearDepthStencilImage decode");
                VkCommandBuffer commandBuffer;
                VkImage image;
                VkImageLayout imageLayout;
                const VkClearDepthStencilValue* pDepthStencil;
                uint32_t rangeCount;
                const VkImageSubresourceRange* pRanges;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                memcpy((VkImageLayout*)&imageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                vkReadStream->alloc((void**)&pDepthStencil, sizeof(const VkClearDepthStencilValue));
                reservedunmarshal_VkClearDepthStencilValue(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkClearDepthStencilValue*)(pDepthStencil), readStreamPtrPtr);
                memcpy((uint32_t*)&rangeCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRanges, ((rangeCount)) * sizeof(const VkImageSubresourceRange));
                for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                {
                    reservedunmarshal_VkImageSubresourceRange(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSubresourceRange*)(pRanges + i), readStreamPtrPtr);
                }
                if (pDepthStencil)
                {
                    transform_tohost_VkClearDepthStencilValue(m_state, (VkClearDepthStencilValue*)(pDepthStencil));
                }
                if (pRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                    {
                        transform_tohost_VkImageSubresourceRange(m_state, (VkImageSubresourceRange*)(pRanges + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdClearDepthStencilImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)image, (unsigned long long)imageLayout, (unsigned long long)pDepthStencil, (unsigned long long)rangeCount, (unsigned long long)pRanges);
                }
                vk->vkCmdClearDepthStencilImage(unboxed_commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdClearDepthStencilImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdClearAttachments:
            {
                android::base::beginTrace("vkCmdClearAttachments decode");
                VkCommandBuffer commandBuffer;
                uint32_t attachmentCount;
                const VkClearAttachment* pAttachments;
                uint32_t rectCount;
                const VkClearRect* pRects;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&attachmentCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pAttachments, ((attachmentCount)) * sizeof(const VkClearAttachment));
                for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
                {
                    reservedunmarshal_VkClearAttachment(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkClearAttachment*)(pAttachments + i), readStreamPtrPtr);
                }
                memcpy((uint32_t*)&rectCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRects, ((rectCount)) * sizeof(const VkClearRect));
                for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
                {
                    reservedunmarshal_VkClearRect(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkClearRect*)(pRects + i), readStreamPtrPtr);
                }
                if (pAttachments)
                {
                    for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
                    {
                        transform_tohost_VkClearAttachment(m_state, (VkClearAttachment*)(pAttachments + i));
                    }
                }
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
                    {
                        transform_tohost_VkClearRect(m_state, (VkClearRect*)(pRects + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdClearAttachments 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)attachmentCount, (unsigned long long)pAttachments, (unsigned long long)rectCount, (unsigned long long)pRects);
                }
                vk->vkCmdClearAttachments(unboxed_commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdClearAttachments(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdResolveImage:
            {
                android::base::beginTrace("vkCmdResolveImage decode");
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageResolve* pRegions;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                memcpy((VkImageLayout*)&srcImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_2));
                memcpy((VkImageLayout*)&dstImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageResolve));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    reservedunmarshal_VkImageResolve(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageResolve*)(pRegions + i), readStreamPtrPtr);
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkImageResolve(m_state, (VkImageResolve*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdResolveImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcImage, (unsigned long long)srcImageLayout, (unsigned long long)dstImage, (unsigned long long)dstImageLayout, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                vk->vkCmdResolveImage(unboxed_commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdResolveImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetEvent:
            {
                android::base::beginTrace("vkCmdSetEvent decode");
                VkCommandBuffer commandBuffer;
                VkEvent event;
                VkPipelineStageFlags stageMask;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_1));
                memcpy((VkPipelineStageFlags*)&stageMask, *readStreamPtrPtr, sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetEvent 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)event, (unsigned long long)stageMask);
                }
                vk->vkCmdSetEvent(unboxed_commandBuffer, event, stageMask);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, event, stageMask);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdResetEvent:
            {
                android::base::beginTrace("vkCmdResetEvent decode");
                VkCommandBuffer commandBuffer;
                VkEvent event;
                VkPipelineStageFlags stageMask;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_1));
                memcpy((VkPipelineStageFlags*)&stageMask, *readStreamPtrPtr, sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdResetEvent 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)event, (unsigned long long)stageMask);
                }
                vk->vkCmdResetEvent(unboxed_commandBuffer, event, stageMask);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdResetEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, event, stageMask);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdWaitEvents:
            {
                android::base::beginTrace("vkCmdWaitEvents decode");
                VkCommandBuffer commandBuffer;
                uint32_t eventCount;
                const VkEvent* pEvents;
                VkPipelineStageFlags srcStageMask;
                VkPipelineStageFlags dstStageMask;
                uint32_t memoryBarrierCount;
                const VkMemoryBarrier* pMemoryBarriers;
                uint32_t bufferMemoryBarrierCount;
                const VkBufferMemoryBarrier* pBufferMemoryBarriers;
                uint32_t imageMemoryBarrierCount;
                const VkImageMemoryBarrier* pImageMemoryBarriers;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&eventCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pEvents, ((eventCount)) * sizeof(const VkEvent));
                if (((eventCount)))
                {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((eventCount));
                    for (uint32_t k = 0; k < ((eventCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkEvent*)pEvents) + k) = (VkEvent)unbox_VkEvent((VkEvent)tmpval);
                    }
                }
                memcpy((VkPipelineStageFlags*)&srcStageMask, *readStreamPtrPtr, sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                memcpy((VkPipelineStageFlags*)&dstStageMask, *readStreamPtrPtr, sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                memcpy((uint32_t*)&memoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pMemoryBarriers, ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                {
                    reservedunmarshal_VkMemoryBarrier(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryBarrier*)(pMemoryBarriers + i), readStreamPtrPtr);
                }
                memcpy((uint32_t*)&bufferMemoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBufferMemoryBarriers, ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                {
                    reservedunmarshal_VkBufferMemoryBarrier(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i), readStreamPtrPtr);
                }
                memcpy((uint32_t*)&imageMemoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pImageMemoryBarriers, ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                {
                    reservedunmarshal_VkImageMemoryBarrier(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i), readStreamPtrPtr);
                }
                if (pMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkMemoryBarrier(m_state, (VkMemoryBarrier*)(pMemoryBarriers + i));
                    }
                }
                if (pBufferMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkBufferMemoryBarrier(m_state, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                    }
                }
                if (pImageMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkImageMemoryBarrier(m_state, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdWaitEvents 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)eventCount, (unsigned long long)pEvents, (unsigned long long)srcStageMask, (unsigned long long)dstStageMask, (unsigned long long)memoryBarrierCount, (unsigned long long)pMemoryBarriers, (unsigned long long)bufferMemoryBarrierCount, (unsigned long long)pBufferMemoryBarriers, (unsigned long long)imageMemoryBarrierCount, (unsigned long long)pImageMemoryBarriers);
                }
                vk->vkCmdWaitEvents(unboxed_commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdWaitEvents(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdPipelineBarrier:
            {
                android::base::beginTrace("vkCmdPipelineBarrier decode");
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlags srcStageMask;
                VkPipelineStageFlags dstStageMask;
                VkDependencyFlags dependencyFlags;
                uint32_t memoryBarrierCount;
                const VkMemoryBarrier* pMemoryBarriers;
                uint32_t bufferMemoryBarrierCount;
                const VkBufferMemoryBarrier* pBufferMemoryBarriers;
                uint32_t imageMemoryBarrierCount;
                const VkImageMemoryBarrier* pImageMemoryBarriers;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                memcpy((VkPipelineStageFlags*)&srcStageMask, *readStreamPtrPtr, sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                memcpy((VkPipelineStageFlags*)&dstStageMask, *readStreamPtrPtr, sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                memcpy((VkDependencyFlags*)&dependencyFlags, *readStreamPtrPtr, sizeof(VkDependencyFlags));
                *readStreamPtrPtr += sizeof(VkDependencyFlags);
                memcpy((uint32_t*)&memoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pMemoryBarriers, ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                {
                    reservedunmarshal_VkMemoryBarrier(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryBarrier*)(pMemoryBarriers + i), readStreamPtrPtr);
                }
                memcpy((uint32_t*)&bufferMemoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBufferMemoryBarriers, ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                {
                    reservedunmarshal_VkBufferMemoryBarrier(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i), readStreamPtrPtr);
                }
                memcpy((uint32_t*)&imageMemoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pImageMemoryBarriers, ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                {
                    reservedunmarshal_VkImageMemoryBarrier(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i), readStreamPtrPtr);
                }
                if (pMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkMemoryBarrier(m_state, (VkMemoryBarrier*)(pMemoryBarriers + i));
                    }
                }
                if (pBufferMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkBufferMemoryBarrier(m_state, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                    }
                }
                if (pImageMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkImageMemoryBarrier(m_state, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdPipelineBarrier 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcStageMask, (unsigned long long)dstStageMask, (unsigned long long)dependencyFlags, (unsigned long long)memoryBarrierCount, (unsigned long long)pMemoryBarriers, (unsigned long long)bufferMemoryBarrierCount, (unsigned long long)pBufferMemoryBarriers, (unsigned long long)imageMemoryBarrierCount, (unsigned long long)pImageMemoryBarriers);
                }
                m_state->on_vkCmdPipelineBarrier(&m_pool, commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdPipelineBarrier(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBeginQuery:
            {
                android::base::beginTrace("vkCmdBeginQuery decode");
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t query;
                VkQueryControlFlags flags;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_1));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((VkQueryControlFlags*)&flags, *readStreamPtrPtr, sizeof(VkQueryControlFlags));
                *readStreamPtrPtr += sizeof(VkQueryControlFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBeginQuery 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool, (unsigned long long)query, (unsigned long long)flags);
                }
                vk->vkCmdBeginQuery(unboxed_commandBuffer, queryPool, query, flags);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginQuery(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool, query, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdEndQuery:
            {
                android::base::beginTrace("vkCmdEndQuery decode");
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t query;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_1));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdEndQuery 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool, (unsigned long long)query);
                }
                vk->vkCmdEndQuery(unboxed_commandBuffer, queryPool, query);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndQuery(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool, query);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdResetQueryPool:
            {
                android::base::beginTrace("vkCmdResetQueryPool decode");
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_1));
                memcpy((uint32_t*)&firstQuery, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&queryCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdResetQueryPool 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool, (unsigned long long)firstQuery, (unsigned long long)queryCount);
                }
                vk->vkCmdResetQueryPool(unboxed_commandBuffer, queryPool, firstQuery, queryCount);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdResetQueryPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool, firstQuery, queryCount);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdWriteTimestamp:
            {
                android::base::beginTrace("vkCmdWriteTimestamp decode");
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlagBits pipelineStage;
                VkQueryPool queryPool;
                uint32_t query;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkPipelineStageFlagBits*)&pipelineStage, *readStreamPtrPtr, sizeof(VkPipelineStageFlagBits));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlagBits);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_1));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdWriteTimestamp 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineStage, (unsigned long long)queryPool, (unsigned long long)query);
                }
                vk->vkCmdWriteTimestamp(unboxed_commandBuffer, pipelineStage, queryPool, query);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdWriteTimestamp(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineStage, queryPool, query);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyQueryPoolResults:
            {
                android::base::beginTrace("vkCmdCopyQueryPoolResults decode");
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize stride;
                VkQueryResultFlags flags;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_1));
                memcpy((uint32_t*)&firstQuery, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&queryCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_2));
                memcpy((VkDeviceSize*)&dstOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&stride, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkQueryResultFlags*)&flags, *readStreamPtrPtr, sizeof(VkQueryResultFlags));
                *readStreamPtrPtr += sizeof(VkQueryResultFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyQueryPoolResults 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool, (unsigned long long)firstQuery, (unsigned long long)queryCount, (unsigned long long)dstBuffer, (unsigned long long)dstOffset, (unsigned long long)stride, (unsigned long long)flags);
                }
                vk->vkCmdCopyQueryPoolResults(unboxed_commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyQueryPoolResults(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdPushConstants:
            {
                android::base::beginTrace("vkCmdPushConstants decode");
                VkCommandBuffer commandBuffer;
                VkPipelineLayout layout;
                VkShaderStageFlags stageFlags;
                uint32_t offset;
                uint32_t size;
                const void* pValues;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineLayout*)&layout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_1));
                memcpy((VkShaderStageFlags*)&stageFlags, *readStreamPtrPtr, sizeof(VkShaderStageFlags));
                *readStreamPtrPtr += sizeof(VkShaderStageFlags);
                memcpy((uint32_t*)&offset, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&size, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pValues, ((size)) * sizeof(const uint8_t));
                memcpy((void*)pValues, *readStreamPtrPtr, ((size)) * sizeof(const uint8_t));
                *readStreamPtrPtr += ((size)) * sizeof(const uint8_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdPushConstants 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)layout, (unsigned long long)stageFlags, (unsigned long long)offset, (unsigned long long)size, (unsigned long long)pValues);
                }
                vk->vkCmdPushConstants(unboxed_commandBuffer, layout, stageFlags, offset, size, pValues);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdPushConstants(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, layout, stageFlags, offset, size, pValues);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBeginRenderPass:
            {
                android::base::beginTrace("vkCmdBeginRenderPass decode");
                VkCommandBuffer commandBuffer;
                const VkRenderPassBeginInfo* pRenderPassBegin;
                VkSubpassContents contents;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                reservedunmarshal_VkRenderPassBeginInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassBeginInfo*)(pRenderPassBegin), readStreamPtrPtr);
                memcpy((VkSubpassContents*)&contents, *readStreamPtrPtr, sizeof(VkSubpassContents));
                *readStreamPtrPtr += sizeof(VkSubpassContents);
                if (pRenderPassBegin)
                {
                    transform_tohost_VkRenderPassBeginInfo(m_state, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBeginRenderPass 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pRenderPassBegin, (unsigned long long)contents);
                }
                vk->vkCmdBeginRenderPass(unboxed_commandBuffer, pRenderPassBegin, contents);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginRenderPass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pRenderPassBegin, contents);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdNextSubpass:
            {
                android::base::beginTrace("vkCmdNextSubpass decode");
                VkCommandBuffer commandBuffer;
                VkSubpassContents contents;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkSubpassContents*)&contents, *readStreamPtrPtr, sizeof(VkSubpassContents));
                *readStreamPtrPtr += sizeof(VkSubpassContents);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdNextSubpass 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)contents);
                }
                vk->vkCmdNextSubpass(unboxed_commandBuffer, contents);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdNextSubpass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, contents);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdEndRenderPass:
            {
                android::base::beginTrace("vkCmdEndRenderPass decode");
                VkCommandBuffer commandBuffer;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdEndRenderPass 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                vk->vkCmdEndRenderPass(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndRenderPass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdExecuteCommands:
            {
                android::base::beginTrace("vkCmdExecuteCommands decode");
                VkCommandBuffer commandBuffer;
                uint32_t commandBufferCount;
                const VkCommandBuffer* pCommandBuffers;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                memcpy((uint32_t*)&commandBufferCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                if (((commandBufferCount)))
                {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((commandBufferCount));
                    for (uint32_t k = 0; k < ((commandBufferCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkCommandBuffer*)pCommandBuffers) + k) = (VkCommandBuffer)unbox_VkCommandBuffer((VkCommandBuffer)tmpval);
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdExecuteCommands 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)commandBufferCount, (unsigned long long)pCommandBuffers);
                }
                m_state->on_vkCmdExecuteCommands(&m_pool, commandBuffer, commandBufferCount, pCommandBuffers);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdExecuteCommands(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, commandBufferCount, pCommandBuffers);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_VERSION_1_1
            case OP_vkEnumerateInstanceVersion:
            {
                android::base::beginTrace("vkEnumerateInstanceVersion decode");
                uint32_t* pApiVersion;
                // Begin manual dispatchable handle unboxing for pApiVersion;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pApiVersion, sizeof(uint32_t));
                memcpy((uint32_t*)pApiVersion, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumerateInstanceVersion 0x%llx \n", ioStream, (unsigned long long)pApiVersion);
                }
                VkResult vkEnumerateInstanceVersion_VkResult_return = (VkResult)0;
                vkEnumerateInstanceVersion_VkResult_return = m_state->on_vkEnumerateInstanceVersion(&m_pool, pApiVersion);
                vkStream->unsetHandleMapping();
                vkStream->write((uint32_t*)pApiVersion, sizeof(uint32_t));
                vkStream->write(&vkEnumerateInstanceVersion_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateInstanceVersion(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateInstanceVersion_VkResult_return, pApiVersion);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBindBufferMemory2:
            {
                android::base::beginTrace("vkBindBufferMemory2 decode");
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindBufferMemoryInfo* pBindInfos;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    reservedunmarshal_VkBindBufferMemoryInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindBufferMemoryInfo*)(pBindInfos + i), readStreamPtrPtr);
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindBufferMemoryInfo(m_state, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBindBufferMemory2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfos);
                }
                VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
                vkBindBufferMemory2_VkResult_return = m_state->on_vkBindBufferMemory2(&m_pool, device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindBufferMemory2_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindBufferMemory2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindBufferMemory2_VkResult_return, device, bindInfoCount, pBindInfos);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBindImageMemory2:
            {
                android::base::beginTrace("vkBindImageMemory2 decode");
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindImageMemoryInfo* pBindInfos;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    reservedunmarshal_VkBindImageMemoryInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindImageMemoryInfo*)(pBindInfos + i), readStreamPtrPtr);
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindImageMemoryInfo(m_state, (VkBindImageMemoryInfo*)(pBindInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBindImageMemory2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfos);
                }
                VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
                vkBindImageMemory2_VkResult_return = vk->vkBindImageMemory2(unboxed_device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindImageMemory2_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindImageMemory2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindImageMemory2_VkResult_return, device, bindInfoCount, pBindInfos);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceGroupPeerMemoryFeatures:
            {
                android::base::beginTrace("vkGetDeviceGroupPeerMemoryFeatures decode");
                VkDevice device;
                uint32_t heapIndex;
                uint32_t localDeviceIndex;
                uint32_t remoteDeviceIndex;
                VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&heapIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&localDeviceIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&remoteDeviceIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for pPeerMemoryFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                memcpy((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, *readStreamPtrPtr, sizeof(VkPeerMemoryFeatureFlags));
                *readStreamPtrPtr += sizeof(VkPeerMemoryFeatureFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceGroupPeerMemoryFeatures 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)heapIndex, (unsigned long long)localDeviceIndex, (unsigned long long)remoteDeviceIndex, (unsigned long long)pPeerMemoryFeatures);
                }
                vk->vkGetDeviceGroupPeerMemoryFeatures(unboxed_device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                vkStream->unsetHandleMapping();
                vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceGroupPeerMemoryFeatures(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetDeviceMask:
            {
                android::base::beginTrace("vkCmdSetDeviceMask decode");
                VkCommandBuffer commandBuffer;
                uint32_t deviceMask;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&deviceMask, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetDeviceMask 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)deviceMask);
                }
                vk->vkCmdSetDeviceMask(unboxed_commandBuffer, deviceMask);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDeviceMask(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, deviceMask);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDispatchBase:
            {
                android::base::beginTrace("vkCmdDispatchBase decode");
                VkCommandBuffer commandBuffer;
                uint32_t baseGroupX;
                uint32_t baseGroupY;
                uint32_t baseGroupZ;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&baseGroupX, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&baseGroupY, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&baseGroupZ, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountX, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountY, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountZ, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDispatchBase 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)baseGroupX, (unsigned long long)baseGroupY, (unsigned long long)baseGroupZ, (unsigned long long)groupCountX, (unsigned long long)groupCountY, (unsigned long long)groupCountZ);
                }
                vk->vkCmdDispatchBase(unboxed_commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDispatchBase(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEnumeratePhysicalDeviceGroups:
            {
                android::base::beginTrace("vkEnumeratePhysicalDeviceGroups decode");
                VkInstance instance;
                uint32_t* pPhysicalDeviceGroupCount;
                VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPhysicalDeviceGroupCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPhysicalDeviceGroupCount);
                *readStreamPtrPtr += 8;
                if (pPhysicalDeviceGroupCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPhysicalDeviceGroupCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPhysicalDeviceGroupProperties**)&pPhysicalDeviceGroupProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPhysicalDeviceGroupProperties);
                *readStreamPtrPtr += 8;
                if (pPhysicalDeviceGroupProperties)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupProperties, (*(pPhysicalDeviceGroupCount)) * sizeof(VkPhysicalDeviceGroupProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        reservedunmarshal_VkPhysicalDeviceGroupProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPhysicalDeviceGroupCount)
                {
                    if (pPhysicalDeviceGroupProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                        {
                            transform_tohost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumeratePhysicalDeviceGroups 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pPhysicalDeviceGroupCount, (unsigned long long)pPhysicalDeviceGroupProperties);
                }
                VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDeviceGroups_VkResult_return = vk->vkEnumeratePhysicalDeviceGroups(unboxed_instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
                vkStream->putBe64(cgen_var_3);
                if (pPhysicalDeviceGroupCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                if (pPhysicalDeviceGroupCount)
                {
                    if (pPhysicalDeviceGroupProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                        {
                            transform_fromhost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
                vkStream->putBe64(cgen_var_4);
                if (pPhysicalDeviceGroupProperties)
                {
                    if (pPhysicalDeviceGroupCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                        {
                            marshal_VkPhysicalDeviceGroupProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                        }
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDeviceGroups_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumeratePhysicalDeviceGroups(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumeratePhysicalDeviceGroups_VkResult_return, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetImageMemoryRequirements2:
            {
                android::base::beginTrace("vkGetImageMemoryRequirements2 decode");
                VkDevice device;
                const VkImageMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
                reservedunmarshal_VkImageMemoryRequirementsInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageMemoryRequirementsInfo2*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                reservedunmarshal_VkMemoryRequirements2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkImageMemoryRequirementsInfo2(m_state, (VkImageMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageMemoryRequirements2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pMemoryRequirements);
                }
                m_state->on_vkGetImageMemoryRequirements2(&m_pool, device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageMemoryRequirements2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetBufferMemoryRequirements2:
            {
                android::base::beginTrace("vkGetBufferMemoryRequirements2 decode");
                VkDevice device;
                const VkBufferMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
                reservedunmarshal_VkBufferMemoryRequirementsInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferMemoryRequirementsInfo2*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                reservedunmarshal_VkMemoryRequirements2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkBufferMemoryRequirementsInfo2(m_state, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetBufferMemoryRequirements2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pMemoryRequirements);
                }
                vk->vkGetBufferMemoryRequirements2(unboxed_device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetBufferMemoryRequirements2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements2:
            {
                android::base::beginTrace("vkGetImageSparseMemoryRequirements2 decode");
                VkDevice device;
                const VkImageSparseMemoryRequirementsInfo2* pInfo;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageSparseMemoryRequirementsInfo2));
                reservedunmarshal_VkImageSparseMemoryRequirementsInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSparseMemoryRequirementsInfo2*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pSparseMemoryRequirementCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSparseMemoryRequirementCount);
                *readStreamPtrPtr += 8;
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pSparseMemoryRequirementCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSparseImageMemoryRequirements2**)&pSparseMemoryRequirements, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSparseMemoryRequirements);
                *readStreamPtrPtr += 8;
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        reservedunmarshal_VkSparseImageMemoryRequirements2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i), readStreamPtrPtr);
                    }
                }
                if (pInfo)
                {
                    transform_tohost_VkImageSparseMemoryRequirementsInfo2(m_state, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                }
                if (pSparseMemoryRequirementCount)
                {
                    if (pSparseMemoryRequirements)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                        {
                            transform_tohost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageSparseMemoryRequirements2 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pSparseMemoryRequirementCount, (unsigned long long)pSparseMemoryRequirements);
                }
                vk->vkGetImageSparseMemoryRequirements2(unboxed_device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_3);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                if (pSparseMemoryRequirementCount)
                {
                    if (pSparseMemoryRequirements)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                        {
                            transform_fromhost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_4);
                if (pSparseMemoryRequirements)
                {
                    if (pSparseMemoryRequirementCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                        {
                            marshal_VkSparseImageMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                        }
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageSparseMemoryRequirements2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceFeatures2:
            {
                android::base::beginTrace("vkGetPhysicalDeviceFeatures2 decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures2* pFeatures;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures2));
                reservedunmarshal_VkPhysicalDeviceFeatures2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures2*)(pFeatures), readStreamPtrPtr);
                if (pFeatures)
                {
                    transform_tohost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceFeatures2 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFeatures);
                }
                m_state->on_vkGetPhysicalDeviceFeatures2(&m_pool, physicalDevice, pFeatures);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                marshal_VkPhysicalDeviceFeatures2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFeatures2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFeatures);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties2:
            {
                android::base::beginTrace("vkGetPhysicalDeviceProperties2 decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties2* pProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties2));
                reservedunmarshal_VkPhysicalDeviceProperties2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties2*)(pProperties), readStreamPtrPtr);
                if (pProperties)
                {
                    transform_tohost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceProperties2 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pProperties);
                }
                m_state->on_vkGetPhysicalDeviceProperties2(&m_pool, physicalDevice, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                marshal_VkPhysicalDeviceProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties2*)(pProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties2:
            {
                android::base::beginTrace("vkGetPhysicalDeviceFormatProperties2 decode");
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties2* pFormatProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                // Begin manual dispatchable handle unboxing for pFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties2));
                reservedunmarshal_VkFormatProperties2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties2*)(pFormatProperties), readStreamPtrPtr);
                if (pFormatProperties)
                {
                    transform_tohost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceFormatProperties2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)pFormatProperties);
                }
                m_state->on_vkGetPhysicalDeviceFormatProperties2(&m_pool, physicalDevice, format, pFormatProperties);
                vkStream->unsetHandleMapping();
                if (pFormatProperties)
                {
                    transform_fromhost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                marshal_VkFormatProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties2*)(pFormatProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFormatProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format, pFormatProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties2:
            {
                android::base::beginTrace("vkGetPhysicalDeviceImageFormatProperties2 decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
                VkImageFormatProperties2* pImageFormatProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pImageFormatInfo, sizeof(const VkPhysicalDeviceImageFormatInfo2));
                reservedunmarshal_VkPhysicalDeviceImageFormatInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties2));
                reservedunmarshal_VkImageFormatProperties2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties2*)(pImageFormatProperties), readStreamPtrPtr);
                if (pImageFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceImageFormatInfo2(m_state, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                }
                if (pImageFormatProperties)
                {
                    transform_tohost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceImageFormatProperties2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pImageFormatInfo, (unsigned long long)pImageFormatProperties);
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = m_state->on_vkGetPhysicalDeviceImageFormatProperties2(&m_pool, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pImageFormatProperties)
                {
                    transform_fromhost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                marshal_VkImageFormatProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties2:
            {
                android::base::beginTrace("vkGetPhysicalDeviceQueueFamilyProperties2 decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties2* pQueueFamilyProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pQueueFamilyPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pQueueFamilyPropertyCount);
                *readStreamPtrPtr += 8;
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pQueueFamilyPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pQueueFamilyProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkQueueFamilyProperties2**)&pQueueFamilyProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pQueueFamilyProperties);
                *readStreamPtrPtr += 8;
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkQueueFamilyProperties2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i), readStreamPtrPtr);
                    }
                }
                if (pQueueFamilyPropertyCount)
                {
                    if (pQueueFamilyProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                        {
                            transform_tohost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceQueueFamilyProperties2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pQueueFamilyPropertyCount, (unsigned long long)pQueueFamilyProperties);
                }
                vk->vkGetPhysicalDeviceQueueFamilyProperties2(unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_3);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                if (pQueueFamilyPropertyCount)
                {
                    if (pQueueFamilyProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                        {
                            transform_fromhost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_4);
                if (pQueueFamilyProperties)
                {
                    if (pQueueFamilyPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                        {
                            marshal_VkQueueFamilyProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                        }
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties2:
            {
                android::base::beginTrace("vkGetPhysicalDeviceMemoryProperties2 decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for pMemoryProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties2));
                reservedunmarshal_VkPhysicalDeviceMemoryProperties2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties), readStreamPtrPtr);
                if (pMemoryProperties)
                {
                    transform_tohost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceMemoryProperties2 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pMemoryProperties);
                }
                m_state->on_vkGetPhysicalDeviceMemoryProperties2(&m_pool, physicalDevice, pMemoryProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryProperties)
                {
                    transform_fromhost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                marshal_VkPhysicalDeviceMemoryProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pMemoryProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties2:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSparseImageFormatProperties2 decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties2* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pFormatInfo, sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
                reservedunmarshal_VkPhysicalDeviceSparseImageFormatInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSparseImageFormatProperties2**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkSparseImageFormatProperties2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties2*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(m_state, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_tohost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSparseImageFormatProperties2 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFormatInfo, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                vk->vkGetPhysicalDeviceSparseImageFormatProperties2(unboxed_physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_3);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_fromhost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_4);
                if (pProperties)
                {
                    if (pPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            marshal_VkSparseImageFormatProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties2*)(pProperties + i));
                        }
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkTrimCommandPool:
            {
                android::base::beginTrace("vkTrimCommandPool decode");
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolTrimFlags flags;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandPool*)&commandPool = (VkCommandPool)unbox_VkCommandPool((VkCommandPool)(*&cgen_var_1));
                memcpy((VkCommandPoolTrimFlags*)&flags, *readStreamPtrPtr, sizeof(VkCommandPoolTrimFlags));
                *readStreamPtrPtr += sizeof(VkCommandPoolTrimFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkTrimCommandPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)flags);
                }
                vk->vkTrimCommandPool(unboxed_device, commandPool, flags);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkTrimCommandPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, commandPool, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceQueue2:
            {
                android::base::beginTrace("vkGetDeviceQueue2 decode");
                VkDevice device;
                const VkDeviceQueueInfo2* pQueueInfo;
                VkQueue* pQueue;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pQueueInfo, sizeof(const VkDeviceQueueInfo2));
                reservedunmarshal_VkDeviceQueueInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceQueueInfo2*)(pQueueInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pQueue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pQueue, sizeof(VkQueue));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkQueue*)pQueue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_1));
                if (pQueueInfo)
                {
                    transform_tohost_VkDeviceQueueInfo2(m_state, (VkDeviceQueueInfo2*)(pQueueInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceQueue2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pQueueInfo, (unsigned long long)pQueue);
                }
                vk->vkGetDeviceQueue2(unboxed_device, pQueueInfo, pQueue);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_2;
                vkStream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_2, 1);
                vkStream->write((uint64_t*)&cgen_var_2, 8);
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceQueue2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pQueueInfo, pQueue);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateSamplerYcbcrConversion:
            {
                android::base::beginTrace("vkCreateSamplerYcbcrConversion decode");
                VkDevice device;
                const VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSamplerYcbcrConversion* pYcbcrConversion;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerYcbcrConversionCreateInfo));
                reservedunmarshal_VkSamplerYcbcrConversionCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pYcbcrConversion;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSamplerYcbcrConversion*)pYcbcrConversion = (VkSamplerYcbcrConversion)(VkSamplerYcbcrConversion)((VkSamplerYcbcrConversion)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkSamplerYcbcrConversionCreateInfo(m_state, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateSamplerYcbcrConversion 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pYcbcrConversion);
                }
                VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
                vkCreateSamplerYcbcrConversion_VkResult_return = vk->vkCreateSamplerYcbcrConversion(unboxed_device, pCreateInfo, pAllocator, pYcbcrConversion);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                if (vkCreateSamplerYcbcrConversion_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkSamplerYcbcrConversion), "handle map overwrite requres VkSamplerYcbcrConversion to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
                vkStream->write((VkSamplerYcbcrConversion*)pYcbcrConversion, 8 * 1);
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSamplerYcbcrConversion_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSamplerYcbcrConversion(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSamplerYcbcrConversion_VkResult_return, device, pCreateInfo, pAllocator, pYcbcrConversion);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroySamplerYcbcrConversion:
            {
                android::base::beginTrace("vkDestroySamplerYcbcrConversion decode");
                VkDevice device;
                VkSamplerYcbcrConversion ycbcrConversion;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for ycbcrConversion;
                VkSamplerYcbcrConversion boxed_ycbcrConversion_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSamplerYcbcrConversion*)&ycbcrConversion = (VkSamplerYcbcrConversion)(VkSamplerYcbcrConversion)((VkSamplerYcbcrConversion)(*&cgen_var_1));
                boxed_ycbcrConversion_preserve = ycbcrConversion;
                ycbcrConversion = unbox_VkSamplerYcbcrConversion(ycbcrConversion);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroySamplerYcbcrConversion 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)ycbcrConversion, (unsigned long long)pAllocator);
                }
                vk->vkDestroySamplerYcbcrConversion(unboxed_device, ycbcrConversion, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySamplerYcbcrConversion(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_ycbcrConversion_preserve, pAllocator);
                }
                delete_VkSamplerYcbcrConversion(boxed_ycbcrConversion_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateDescriptorUpdateTemplate:
            {
                android::base::beginTrace("vkCreateDescriptorUpdateTemplate decode");
                VkDevice device;
                const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorUpdateTemplateCreateInfo));
                reservedunmarshal_VkDescriptorUpdateTemplateCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pDescriptorUpdateTemplate;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate = (VkDescriptorUpdateTemplate)(VkDescriptorUpdateTemplate)((VkDescriptorUpdateTemplate)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorUpdateTemplateCreateInfo(m_state, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDescriptorUpdateTemplate 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pDescriptorUpdateTemplate);
                }
                VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
                vkCreateDescriptorUpdateTemplate_VkResult_return = m_state->on_vkCreateDescriptorUpdateTemplate(&m_pool, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkDescriptorUpdateTemplate), "handle map overwrite requres VkDescriptorUpdateTemplate to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
                vkStream->write((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 8 * 1);
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorUpdateTemplate_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDescriptorUpdateTemplate(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDescriptorUpdateTemplate_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDescriptorUpdateTemplate:
            {
                android::base::beginTrace("vkDestroyDescriptorUpdateTemplate decode");
                VkDevice device;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                // Begin manual non dispatchable handle destroy unboxing for descriptorUpdateTemplate;
                VkDescriptorUpdateTemplate boxed_descriptorUpdateTemplate_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)(VkDescriptorUpdateTemplate)((VkDescriptorUpdateTemplate)(*&cgen_var_1));
                boxed_descriptorUpdateTemplate_preserve = descriptorUpdateTemplate;
                descriptorUpdateTemplate = unbox_VkDescriptorUpdateTemplate(descriptorUpdateTemplate);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDescriptorUpdateTemplate 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDescriptorUpdateTemplate(&m_pool, device, descriptorUpdateTemplate, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDescriptorUpdateTemplate(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_descriptorUpdateTemplate_preserve, pAllocator);
                }
                delete_VkDescriptorUpdateTemplate(boxed_descriptorUpdateTemplate_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkUpdateDescriptorSetWithTemplate:
            {
                android::base::beginTrace("vkUpdateDescriptorSetWithTemplate decode");
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const void* pData;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorSet*)&descriptorSet = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)(*&cgen_var_1));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)unbox_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate)(*&cgen_var_2));
                // WARNING PTR CHECK
                memcpy((void**)&pData, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pData);
                *readStreamPtrPtr += 8;
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    memcpy((void*)pData, *readStreamPtrPtr, sizeof(const uint8_t));
                    *readStreamPtrPtr += sizeof(const uint8_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkUpdateDescriptorSetWithTemplate 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorSet, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)pData);
                }
                vk->vkUpdateDescriptorSetWithTemplate(unboxed_device, descriptorSet, descriptorUpdateTemplate, pData);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUpdateDescriptorSetWithTemplate(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorSet, descriptorUpdateTemplate, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalBufferProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceExternalBufferProperties decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
                VkExternalBufferProperties* pExternalBufferProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalBufferInfo, sizeof(const VkPhysicalDeviceExternalBufferInfo));
                reservedunmarshal_VkPhysicalDeviceExternalBufferInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pExternalBufferProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalBufferProperties, sizeof(VkExternalBufferProperties));
                reservedunmarshal_VkExternalBufferProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalBufferProperties*)(pExternalBufferProperties), readStreamPtrPtr);
                if (pExternalBufferInfo)
                {
                    m_state->transformImpl_VkPhysicalDeviceExternalBufferInfo_tohost(pExternalBufferInfo, 1);
                    transform_tohost_VkPhysicalDeviceExternalBufferInfo(m_state, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                }
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_tohost(pExternalBufferProperties, 1);
                    transform_tohost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceExternalBufferProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalBufferInfo, (unsigned long long)pExternalBufferProperties);
                }
                vk->vkGetPhysicalDeviceExternalBufferProperties(unboxed_physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                vkStream->unsetHandleMapping();
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_fromhost(pExternalBufferProperties, 1);
                    transform_fromhost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                marshal_VkExternalBufferProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalBufferProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalFenceProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceExternalFenceProperties decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
                VkExternalFenceProperties* pExternalFenceProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalFenceInfo, sizeof(const VkPhysicalDeviceExternalFenceInfo));
                reservedunmarshal_VkPhysicalDeviceExternalFenceInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pExternalFenceProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalFenceProperties, sizeof(VkExternalFenceProperties));
                reservedunmarshal_VkExternalFenceProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalFenceProperties*)(pExternalFenceProperties), readStreamPtrPtr);
                if (pExternalFenceInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalFenceInfo(m_state, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                }
                if (pExternalFenceProperties)
                {
                    transform_tohost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceExternalFenceProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalFenceInfo, (unsigned long long)pExternalFenceProperties);
                }
                vk->vkGetPhysicalDeviceExternalFenceProperties(unboxed_physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                vkStream->unsetHandleMapping();
                if (pExternalFenceProperties)
                {
                    transform_fromhost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                marshal_VkExternalFenceProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalFenceProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalSemaphoreProperties:
            {
                android::base::beginTrace("vkGetPhysicalDeviceExternalSemaphoreProperties decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
                VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pExternalSemaphoreInfo, sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
                reservedunmarshal_VkPhysicalDeviceExternalSemaphoreInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pExternalSemaphoreProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalSemaphoreProperties, sizeof(VkExternalSemaphoreProperties));
                reservedunmarshal_VkExternalSemaphoreProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties), readStreamPtrPtr);
                if (pExternalSemaphoreInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(m_state, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                }
                if (pExternalSemaphoreProperties)
                {
                    transform_tohost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceExternalSemaphoreProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalSemaphoreInfo, (unsigned long long)pExternalSemaphoreProperties);
                }
                m_state->on_vkGetPhysicalDeviceExternalSemaphoreProperties(&m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                vkStream->unsetHandleMapping();
                if (pExternalSemaphoreProperties)
                {
                    transform_fromhost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                marshal_VkExternalSemaphoreProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalSemaphoreProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDescriptorSetLayoutSupport:
            {
                android::base::beginTrace("vkGetDescriptorSetLayoutSupport decode");
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                VkDescriptorSetLayoutSupport* pSupport;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                reservedunmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pSupport;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSupport, sizeof(VkDescriptorSetLayoutSupport));
                reservedunmarshal_VkDescriptorSetLayoutSupport(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutSupport*)(pSupport), readStreamPtrPtr);
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorSetLayoutCreateInfo(m_state, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                }
                if (pSupport)
                {
                    transform_tohost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDescriptorSetLayoutSupport 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pSupport);
                }
                vk->vkGetDescriptorSetLayoutSupport(unboxed_device, pCreateInfo, pSupport);
                vkStream->unsetHandleMapping();
                if (pSupport)
                {
                    transform_fromhost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                marshal_VkDescriptorSetLayoutSupport(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDescriptorSetLayoutSupport(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pCreateInfo, pSupport);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_VERSION_1_2
            case OP_vkCmdDrawIndirectCount:
            {
                android::base::beginTrace("vkCmdDrawIndirectCount decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&countBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_2));
                memcpy((VkDeviceSize*)&countBufferOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&maxDrawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndirectCount 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndirectCount(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndirectCount(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDrawIndexedIndirectCount:
            {
                android::base::beginTrace("vkCmdDrawIndexedIndirectCount decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&countBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_2));
                memcpy((VkDeviceSize*)&countBufferOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&maxDrawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndexedIndirectCount 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndexedIndirectCount(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndexedIndirectCount(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateRenderPass2:
            {
                android::base::beginTrace("vkCreateRenderPass2 decode");
                VkDevice device;
                const VkRenderPassCreateInfo2* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkRenderPass* pRenderPass;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo2));
                reservedunmarshal_VkRenderPassCreateInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassCreateInfo2*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pRenderPass;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pRenderPass, sizeof(VkRenderPass));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkRenderPass*)pRenderPass = (VkRenderPass)(VkRenderPass)((VkRenderPass)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkRenderPassCreateInfo2(m_state, (VkRenderPassCreateInfo2*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateRenderPass2 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pRenderPass);
                }
                VkResult vkCreateRenderPass2_VkResult_return = (VkResult)0;
                vkCreateRenderPass2_VkResult_return = vk->vkCreateRenderPass2(unboxed_device, pCreateInfo, pAllocator, pRenderPass);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkCreateRenderPass2_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateRenderPass2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateRenderPass2_VkResult_return, device, pCreateInfo, pAllocator, pRenderPass);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBeginRenderPass2:
            {
                android::base::beginTrace("vkCmdBeginRenderPass2 decode");
                VkCommandBuffer commandBuffer;
                const VkRenderPassBeginInfo* pRenderPassBegin;
                const VkSubpassBeginInfo* pSubpassBeginInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                reservedunmarshal_VkRenderPassBeginInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassBeginInfo*)(pRenderPassBegin), readStreamPtrPtr);
                vkReadStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfo));
                reservedunmarshal_VkSubpassBeginInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassBeginInfo*)(pSubpassBeginInfo), readStreamPtrPtr);
                if (pRenderPassBegin)
                {
                    transform_tohost_VkRenderPassBeginInfo(m_state, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                }
                if (pSubpassBeginInfo)
                {
                    transform_tohost_VkSubpassBeginInfo(m_state, (VkSubpassBeginInfo*)(pSubpassBeginInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBeginRenderPass2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pRenderPassBegin, (unsigned long long)pSubpassBeginInfo);
                }
                vk->vkCmdBeginRenderPass2(unboxed_commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginRenderPass2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdNextSubpass2:
            {
                android::base::beginTrace("vkCmdNextSubpass2 decode");
                VkCommandBuffer commandBuffer;
                const VkSubpassBeginInfo* pSubpassBeginInfo;
                const VkSubpassEndInfo* pSubpassEndInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfo));
                reservedunmarshal_VkSubpassBeginInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassBeginInfo*)(pSubpassBeginInfo), readStreamPtrPtr);
                vkReadStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfo));
                reservedunmarshal_VkSubpassEndInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassEndInfo*)(pSubpassEndInfo), readStreamPtrPtr);
                if (pSubpassBeginInfo)
                {
                    transform_tohost_VkSubpassBeginInfo(m_state, (VkSubpassBeginInfo*)(pSubpassBeginInfo));
                }
                if (pSubpassEndInfo)
                {
                    transform_tohost_VkSubpassEndInfo(m_state, (VkSubpassEndInfo*)(pSubpassEndInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdNextSubpass2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pSubpassBeginInfo, (unsigned long long)pSubpassEndInfo);
                }
                vk->vkCmdNextSubpass2(unboxed_commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdNextSubpass2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdEndRenderPass2:
            {
                android::base::beginTrace("vkCmdEndRenderPass2 decode");
                VkCommandBuffer commandBuffer;
                const VkSubpassEndInfo* pSubpassEndInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfo));
                reservedunmarshal_VkSubpassEndInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassEndInfo*)(pSubpassEndInfo), readStreamPtrPtr);
                if (pSubpassEndInfo)
                {
                    transform_tohost_VkSubpassEndInfo(m_state, (VkSubpassEndInfo*)(pSubpassEndInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdEndRenderPass2 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pSubpassEndInfo);
                }
                vk->vkCmdEndRenderPass2(unboxed_commandBuffer, pSubpassEndInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndRenderPass2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pSubpassEndInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkResetQueryPool:
            {
                android::base::beginTrace("vkResetQueryPool decode");
                VkDevice device;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_1));
                memcpy((uint32_t*)&firstQuery, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&queryCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkResetQueryPool 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)queryPool, (unsigned long long)firstQuery, (unsigned long long)queryCount);
                }
                vk->vkResetQueryPool(unboxed_device, queryPool, firstQuery, queryCount);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetQueryPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, queryPool, firstQuery, queryCount);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetSemaphoreCounterValue:
            {
                android::base::beginTrace("vkGetSemaphoreCounterValue decode");
                VkDevice device;
                VkSemaphore semaphore;
                uint64_t* pValue;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSemaphore*)&semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pValue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pValue, sizeof(uint64_t));
                memcpy((uint64_t*)pValue, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetSemaphoreCounterValue 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)semaphore, (unsigned long long)pValue);
                }
                VkResult vkGetSemaphoreCounterValue_VkResult_return = (VkResult)0;
                vkGetSemaphoreCounterValue_VkResult_return = vk->vkGetSemaphoreCounterValue(unboxed_device, semaphore, pValue);
                vkStream->unsetHandleMapping();
                vkStream->write((uint64_t*)pValue, sizeof(uint64_t));
                vkStream->write(&vkGetSemaphoreCounterValue_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSemaphoreCounterValue(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSemaphoreCounterValue_VkResult_return, device, semaphore, pValue);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkWaitSemaphores:
            {
                android::base::beginTrace("vkWaitSemaphores decode");
                VkDevice device;
                const VkSemaphoreWaitInfo* pWaitInfo;
                uint64_t timeout;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pWaitInfo, sizeof(const VkSemaphoreWaitInfo));
                reservedunmarshal_VkSemaphoreWaitInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreWaitInfo*)(pWaitInfo), readStreamPtrPtr);
                memcpy((uint64_t*)&timeout, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                if (pWaitInfo)
                {
                    transform_tohost_VkSemaphoreWaitInfo(m_state, (VkSemaphoreWaitInfo*)(pWaitInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkWaitSemaphores 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pWaitInfo, (unsigned long long)timeout);
                }
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                VkResult vkWaitSemaphores_VkResult_return = (VkResult)0;
                vkWaitSemaphores_VkResult_return = vk->vkWaitSemaphores(unboxed_device, pWaitInfo, timeout);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkWaitSemaphores_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkWaitSemaphores(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkWaitSemaphores_VkResult_return, device, pWaitInfo, timeout);
                }
                vkReadStream->clearPool();
                android::base::endTrace();
                break;
            }
            case OP_vkSignalSemaphore:
            {
                android::base::beginTrace("vkSignalSemaphore decode");
                VkDevice device;
                const VkSemaphoreSignalInfo* pSignalInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pSignalInfo, sizeof(const VkSemaphoreSignalInfo));
                reservedunmarshal_VkSemaphoreSignalInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreSignalInfo*)(pSignalInfo), readStreamPtrPtr);
                if (pSignalInfo)
                {
                    transform_tohost_VkSemaphoreSignalInfo(m_state, (VkSemaphoreSignalInfo*)(pSignalInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSignalSemaphore 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pSignalInfo);
                }
                VkResult vkSignalSemaphore_VkResult_return = (VkResult)0;
                vkSignalSemaphore_VkResult_return = vk->vkSignalSemaphore(unboxed_device, pSignalInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSignalSemaphore_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSignalSemaphore(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkSignalSemaphore_VkResult_return, device, pSignalInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetBufferDeviceAddress:
            {
                android::base::beginTrace("vkGetBufferDeviceAddress decode");
                VkDevice device;
                const VkBufferDeviceAddressInfo* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferDeviceAddressInfo));
                reservedunmarshal_VkBufferDeviceAddressInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkBufferDeviceAddressInfo(m_state, (VkBufferDeviceAddressInfo*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetBufferDeviceAddress 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo);
                }
                VkDeviceAddress vkGetBufferDeviceAddress_VkDeviceAddress_return = (VkDeviceAddress)0;
                vkGetBufferDeviceAddress_VkDeviceAddress_return = vk->vkGetBufferDeviceAddress(unboxed_device, pInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetBufferDeviceAddress_VkDeviceAddress_return, sizeof(VkDeviceAddress));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetBufferDeviceAddress(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetBufferDeviceAddress_VkDeviceAddress_return, device, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetBufferOpaqueCaptureAddress:
            {
                android::base::beginTrace("vkGetBufferOpaqueCaptureAddress decode");
                VkDevice device;
                const VkBufferDeviceAddressInfo* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferDeviceAddressInfo));
                reservedunmarshal_VkBufferDeviceAddressInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkBufferDeviceAddressInfo(m_state, (VkBufferDeviceAddressInfo*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetBufferOpaqueCaptureAddress 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo);
                }
                uint64_t vkGetBufferOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
                vkGetBufferOpaqueCaptureAddress_uint64_t_return = vk->vkGetBufferOpaqueCaptureAddress(unboxed_device, pInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetBufferOpaqueCaptureAddress_uint64_t_return, sizeof(uint64_t));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetBufferOpaqueCaptureAddress(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetBufferOpaqueCaptureAddress_uint64_t_return, device, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceMemoryOpaqueCaptureAddress:
            {
                android::base::beginTrace("vkGetDeviceMemoryOpaqueCaptureAddress decode");
                VkDevice device;
                const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkDeviceMemoryOpaqueCaptureAddressInfo));
                reservedunmarshal_VkDeviceMemoryOpaqueCaptureAddressInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceMemoryOpaqueCaptureAddressInfo*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkDeviceMemoryOpaqueCaptureAddressInfo(m_state, (VkDeviceMemoryOpaqueCaptureAddressInfo*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceMemoryOpaqueCaptureAddress 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo);
                }
                uint64_t vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
                vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return = vk->vkGetDeviceMemoryOpaqueCaptureAddress(unboxed_device, pInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return, sizeof(uint64_t));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceMemoryOpaqueCaptureAddress(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return, device, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_surface
            case OP_vkDestroySurfaceKHR:
            {
                android::base::beginTrace("vkDestroySurfaceKHR decode");
                VkInstance instance;
                VkSurfaceKHR surface;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual non dispatchable handle destroy unboxing for surface;
                VkSurfaceKHR boxed_surface_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_1));
                boxed_surface_preserve = surface;
                surface = unbox_VkSurfaceKHR(surface);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroySurfaceKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)surface, (unsigned long long)pAllocator);
                }
                vk->vkDestroySurfaceKHR(unboxed_instance, surface, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, boxed_surface_preserve, pAllocator);
                }
                delete_VkSurfaceKHR(boxed_surface_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceSupportKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfaceSupportKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                VkSurfaceKHR surface;
                VkBool32* pSupported;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pSupported;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSupported, sizeof(VkBool32));
                memcpy((VkBool32*)pSupported, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfaceSupportKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)surface, (unsigned long long)pSupported);
                }
                VkResult vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceSupportKHR(unboxed_physicalDevice, queueFamilyIndex, surface, pSupported);
                vkStream->unsetHandleMapping();
                vkStream->write((VkBool32*)pSupported, sizeof(VkBool32));
                vkStream->write(&vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, physicalDevice, queueFamilyIndex, surface, pSupported);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfaceCapabilitiesKHR decode");
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                VkSurfaceCapabilitiesKHR* pSurfaceCapabilities;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pSurfaceCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilitiesKHR));
                reservedunmarshal_VkSurfaceCapabilitiesKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities), readStreamPtrPtr);
                if (pSurfaceCapabilities)
                {
                    transform_tohost_VkSurfaceCapabilitiesKHR(m_state, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfaceCapabilitiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pSurfaceCapabilities);
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceCapabilitiesKHR(unboxed_physicalDevice, surface, pSurfaceCapabilities);
                vkStream->unsetHandleMapping();
                if (pSurfaceCapabilities)
                {
                    transform_fromhost_VkSurfaceCapabilitiesKHR(m_state, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                }
                marshal_VkSurfaceCapabilitiesKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceCapabilitiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, physicalDevice, surface, pSurfaceCapabilities);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceFormatsKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfaceFormatsKHR decode");
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pSurfaceFormatCount;
                VkSurfaceFormatKHR* pSurfaceFormats;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pSurfaceFormatCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pSurfaceFormatCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSurfaceFormatCount);
                *readStreamPtrPtr += 8;
                if (pSurfaceFormatCount)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormatCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pSurfaceFormatCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pSurfaceFormats;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSurfaceFormatKHR**)&pSurfaceFormats, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSurfaceFormats);
                *readStreamPtrPtr += 8;
                if (pSurfaceFormats)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormats, (*(pSurfaceFormatCount)) * sizeof(VkSurfaceFormatKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        reservedunmarshal_VkSurfaceFormatKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceFormatKHR*)(pSurfaceFormats + i), readStreamPtrPtr);
                    }
                }
                if (pSurfaceFormatCount)
                {
                    if (pSurfaceFormats)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                        {
                            transform_tohost_VkSurfaceFormatKHR(m_state, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfaceFormatsKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pSurfaceFormatCount, (unsigned long long)pSurfaceFormats);
                }
                VkResult vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceFormatsKHR(unboxed_physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
                vkStream->putBe64(cgen_var_4);
                if (pSurfaceFormatCount)
                {
                    vkStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                if (pSurfaceFormatCount)
                {
                    if (pSurfaceFormats)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                        {
                            transform_fromhost_VkSurfaceFormatKHR(m_state, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_5 = (uint64_t)(uintptr_t)pSurfaceFormats;
                vkStream->putBe64(cgen_var_5);
                if (pSurfaceFormats)
                {
                    if (pSurfaceFormatCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                        {
                            marshal_VkSurfaceFormatKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                        }
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceFormatsKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfacePresentModesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfacePresentModesKHR decode");
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pPresentModeCount;
                VkPresentModeKHR* pPresentModes;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pPresentModeCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPresentModeCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPresentModeCount);
                *readStreamPtrPtr += 8;
                if (pPresentModeCount)
                {
                    vkReadStream->alloc((void**)&pPresentModeCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPresentModeCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pPresentModes;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPresentModeKHR**)&pPresentModes, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPresentModes);
                *readStreamPtrPtr += 8;
                if (pPresentModes)
                {
                    vkReadStream->alloc((void**)&pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                    memcpy((VkPresentModeKHR*)pPresentModes, *readStreamPtrPtr, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                    *readStreamPtrPtr += (*(pPresentModeCount)) * sizeof(VkPresentModeKHR);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfacePresentModesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pPresentModeCount, (unsigned long long)pPresentModes);
                }
                VkResult vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfacePresentModesKHR(unboxed_physicalDevice, surface, pPresentModeCount, pPresentModes);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pPresentModeCount;
                vkStream->putBe64(cgen_var_4);
                if (pPresentModeCount)
                {
                    vkStream->write((uint32_t*)pPresentModeCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_5 = (uint64_t)(uintptr_t)pPresentModes;
                vkStream->putBe64(cgen_var_5);
                if (pPresentModes)
                {
                    vkStream->write((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                }
                vkStream->write(&vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfacePresentModesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, physicalDevice, surface, pPresentModeCount, pPresentModes);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_swapchain
            case OP_vkCreateSwapchainKHR:
            {
                android::base::beginTrace("vkCreateSwapchainKHR decode");
                VkDevice device;
                const VkSwapchainCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSwapchainKHR* pSwapchain;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSwapchainCreateInfoKHR));
                reservedunmarshal_VkSwapchainCreateInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSwapchainCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSwapchain;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSwapchain, sizeof(VkSwapchainKHR));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSwapchainKHR*)pSwapchain = (VkSwapchainKHR)(VkSwapchainKHR)((VkSwapchainKHR)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkSwapchainCreateInfoKHR(m_state, (VkSwapchainCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateSwapchainKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSwapchain);
                }
                VkResult vkCreateSwapchainKHR_VkResult_return = (VkResult)0;
                vkCreateSwapchainKHR_VkResult_return = vk->vkCreateSwapchainKHR(unboxed_device, pCreateInfo, pAllocator, pSwapchain);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pSwapchain;
                if (vkCreateSwapchainKHR_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkSwapchainKHR), "handle map overwrite requres VkSwapchainKHR to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)pSwapchain, 1);
                vkStream->write((VkSwapchainKHR*)pSwapchain, 8 * 1);
                // Begin auto non dispatchable handle create for pSwapchain;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSwapchainKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSwapchainKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSwapchainKHR_VkResult_return, device, pCreateInfo, pAllocator, pSwapchain);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroySwapchainKHR:
            {
                android::base::beginTrace("vkDestroySwapchainKHR decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for swapchain;
                VkSwapchainKHR boxed_swapchain_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)(VkSwapchainKHR)((VkSwapchainKHR)(*&cgen_var_1));
                boxed_swapchain_preserve = swapchain;
                swapchain = unbox_VkSwapchainKHR(swapchain);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroySwapchainKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)pAllocator);
                }
                vk->vkDestroySwapchainKHR(unboxed_device, swapchain, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySwapchainKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_swapchain_preserve, pAllocator);
                }
                delete_VkSwapchainKHR(boxed_swapchain_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetSwapchainImagesKHR:
            {
                android::base::beginTrace("vkGetSwapchainImagesKHR decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint32_t* pSwapchainImageCount;
                VkImage* pSwapchainImages;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pSwapchainImageCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pSwapchainImageCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSwapchainImageCount);
                *readStreamPtrPtr += 8;
                if (pSwapchainImageCount)
                {
                    vkReadStream->alloc((void**)&pSwapchainImageCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pSwapchainImageCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pSwapchainImages;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkImage**)&pSwapchainImages, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSwapchainImages);
                *readStreamPtrPtr += 8;
                if (pSwapchainImages)
                {
                    vkReadStream->alloc((void**)&pSwapchainImages, (*(pSwapchainImageCount)) * sizeof(VkImage));
                    if ((*(pSwapchainImageCount)))
                    {
                        uint8_t* cgen_var_3_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * (*(pSwapchainImageCount));
                        if (pSwapchainImageCount)
                        {
                            for (uint32_t k = 0; k < (*(pSwapchainImageCount)); ++k)
                            {
                                uint64_t tmpval; memcpy(&tmpval, cgen_var_3_0_ptr + k * 8, sizeof(uint64_t));
                                *(((VkImage*)pSwapchainImages) + k) = (VkImage)(VkImage)((VkImage)tmpval);
                            }
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetSwapchainImagesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)pSwapchainImageCount, (unsigned long long)pSwapchainImages);
                }
                VkResult vkGetSwapchainImagesKHR_VkResult_return = (VkResult)0;
                vkGetSwapchainImagesKHR_VkResult_return = vk->vkGetSwapchainImagesKHR(unboxed_device, swapchain, pSwapchainImageCount, pSwapchainImages);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pSwapchainImageCount;
                vkStream->putBe64(cgen_var_4);
                if (pSwapchainImageCount)
                {
                    vkStream->write((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_5 = (uint64_t)(uintptr_t)pSwapchainImages;
                vkStream->putBe64(cgen_var_5);
                if (pSwapchainImages)
                {
                    if ((*(pSwapchainImageCount)))
                    {
                        uint64_t* cgen_var_5_0;
                        vkStream->alloc((void**)&cgen_var_5_0, (*(pSwapchainImageCount)) * 8);
                        vkStream->handleMapping()->mapHandles_VkImage_u64(pSwapchainImages, cgen_var_5_0, (*(pSwapchainImageCount)));
                        vkStream->write((uint64_t*)cgen_var_5_0, (*(pSwapchainImageCount)) * 8);
                    }
                }
                vkStream->write(&vkGetSwapchainImagesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSwapchainImagesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSwapchainImagesKHR_VkResult_return, device, swapchain, pSwapchainImageCount, pSwapchainImages);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkAcquireNextImageKHR:
            {
                android::base::beginTrace("vkAcquireNextImageKHR decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint64_t timeout;
                VkSemaphore semaphore;
                VkFence fence;
                uint32_t* pImageIndex;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_1));
                memcpy((uint64_t*)&timeout, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSemaphore*)&semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_2));
                uint64_t cgen_var_3;
                memcpy((uint64_t*)&cgen_var_3, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_3));
                // Begin manual dispatchable handle unboxing for pImageIndex;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageIndex, sizeof(uint32_t));
                memcpy((uint32_t*)pImageIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAcquireNextImageKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)timeout, (unsigned long long)semaphore, (unsigned long long)fence, (unsigned long long)pImageIndex);
                }
                VkResult vkAcquireNextImageKHR_VkResult_return = (VkResult)0;
                vkAcquireNextImageKHR_VkResult_return = vk->vkAcquireNextImageKHR(unboxed_device, swapchain, timeout, semaphore, fence, pImageIndex);
                vkStream->unsetHandleMapping();
                vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkStream->write(&vkAcquireNextImageKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquireNextImageKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquireNextImageKHR_VkResult_return, device, swapchain, timeout, semaphore, fence, pImageIndex);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueuePresentKHR:
            {
                android::base::beginTrace("vkQueuePresentKHR decode");
                VkQueue queue;
                const VkPresentInfoKHR* pPresentInfo;
                // Begin non wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->alloc((void**)&pPresentInfo, sizeof(const VkPresentInfoKHR));
                reservedunmarshal_VkPresentInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPresentInfoKHR*)(pPresentInfo), readStreamPtrPtr);
                if (pPresentInfo)
                {
                    transform_tohost_VkPresentInfoKHR(m_state, (VkPresentInfoKHR*)(pPresentInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueuePresentKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)pPresentInfo);
                }
                VkResult vkQueuePresentKHR_VkResult_return = (VkResult)0;
                vkQueuePresentKHR_VkResult_return = vk->vkQueuePresentKHR(unboxed_queue, pPresentInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueuePresentKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueuePresentKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueuePresentKHR_VkResult_return, queue, pPresentInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceGroupPresentCapabilitiesKHR:
            {
                android::base::beginTrace("vkGetDeviceGroupPresentCapabilitiesKHR decode");
                VkDevice device;
                VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual dispatchable handle unboxing for pDeviceGroupPresentCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDeviceGroupPresentCapabilities, sizeof(VkDeviceGroupPresentCapabilitiesKHR));
                reservedunmarshal_VkDeviceGroupPresentCapabilitiesKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities), readStreamPtrPtr);
                if (pDeviceGroupPresentCapabilities)
                {
                    transform_tohost_VkDeviceGroupPresentCapabilitiesKHR(m_state, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceGroupPresentCapabilitiesKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pDeviceGroupPresentCapabilities);
                }
                VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = vk->vkGetDeviceGroupPresentCapabilitiesKHR(unboxed_device, pDeviceGroupPresentCapabilities);
                vkStream->unsetHandleMapping();
                if (pDeviceGroupPresentCapabilities)
                {
                    transform_fromhost_VkDeviceGroupPresentCapabilitiesKHR(m_state, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                }
                marshal_VkDeviceGroupPresentCapabilitiesKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                vkStream->write(&vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceGroupPresentCapabilitiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, device, pDeviceGroupPresentCapabilities);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceGroupSurfacePresentModesKHR:
            {
                android::base::beginTrace("vkGetDeviceGroupSurfacePresentModesKHR decode");
                VkDevice device;
                VkSurfaceKHR surface;
                VkDeviceGroupPresentModeFlagsKHR* pModes;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pModes;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDeviceGroupPresentModeFlagsKHR**)&pModes, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pModes);
                *readStreamPtrPtr += 8;
                if (pModes)
                {
                    vkReadStream->alloc((void**)&pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                    memcpy((VkDeviceGroupPresentModeFlagsKHR*)pModes, *readStreamPtrPtr, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                    *readStreamPtrPtr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceGroupSurfacePresentModesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)surface, (unsigned long long)pModes);
                }
                VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = (VkResult)0;
                vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = vk->vkGetDeviceGroupSurfacePresentModesKHR(unboxed_device, surface, pModes);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pModes;
                vkStream->putBe64(cgen_var_3);
                if (pModes)
                {
                    vkStream->write((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                }
                vkStream->write(&vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceGroupSurfacePresentModesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, device, surface, pModes);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDevicePresentRectanglesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDevicePresentRectanglesKHR decode");
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pRectCount;
                VkRect2D* pRects;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pRectCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pRectCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pRectCount);
                *readStreamPtrPtr += 8;
                if (pRectCount)
                {
                    vkReadStream->alloc((void**)&pRectCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pRectCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pRects;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkRect2D**)&pRects, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pRects);
                *readStreamPtrPtr += 8;
                if (pRects)
                {
                    vkReadStream->alloc((void**)&pRects, (*(pRectCount)) * sizeof(VkRect2D));
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        reservedunmarshal_VkRect2D(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(pRects + i), readStreamPtrPtr);
                    }
                }
                if (pRectCount)
                {
                    if (pRects)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                        {
                            transform_tohost_VkRect2D(m_state, (VkRect2D*)(pRects + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDevicePresentRectanglesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pRectCount, (unsigned long long)pRects);
                }
                VkResult vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = vk->vkGetPhysicalDevicePresentRectanglesKHR(unboxed_physicalDevice, surface, pRectCount, pRects);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pRectCount;
                vkStream->putBe64(cgen_var_4);
                if (pRectCount)
                {
                    vkStream->write((uint32_t*)pRectCount, sizeof(uint32_t));
                }
                if (pRectCount)
                {
                    if (pRects)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                        {
                            transform_fromhost_VkRect2D(m_state, (VkRect2D*)(pRects + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_5 = (uint64_t)(uintptr_t)pRects;
                vkStream->putBe64(cgen_var_5);
                if (pRects)
                {
                    if (pRectCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                        {
                            marshal_VkRect2D(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(pRects + i));
                        }
                    }
                }
                vkStream->write(&vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDevicePresentRectanglesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, physicalDevice, surface, pRectCount, pRects);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkAcquireNextImage2KHR:
            {
                android::base::beginTrace("vkAcquireNextImage2KHR decode");
                VkDevice device;
                const VkAcquireNextImageInfoKHR* pAcquireInfo;
                uint32_t* pImageIndex;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pAcquireInfo, sizeof(const VkAcquireNextImageInfoKHR));
                reservedunmarshal_VkAcquireNextImageInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAcquireNextImageInfoKHR*)(pAcquireInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pImageIndex;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageIndex, sizeof(uint32_t));
                memcpy((uint32_t*)pImageIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (pAcquireInfo)
                {
                    transform_tohost_VkAcquireNextImageInfoKHR(m_state, (VkAcquireNextImageInfoKHR*)(pAcquireInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAcquireNextImage2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAcquireInfo, (unsigned long long)pImageIndex);
                }
                VkResult vkAcquireNextImage2KHR_VkResult_return = (VkResult)0;
                vkAcquireNextImage2KHR_VkResult_return = vk->vkAcquireNextImage2KHR(unboxed_device, pAcquireInfo, pImageIndex);
                vkStream->unsetHandleMapping();
                vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkStream->write(&vkAcquireNextImage2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquireNextImage2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquireNextImage2KHR_VkResult_return, device, pAcquireInfo, pImageIndex);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_display
            case OP_vkGetPhysicalDeviceDisplayPropertiesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceDisplayPropertiesKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPropertiesKHR* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDisplayPropertiesKHR**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkDisplayPropertiesKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPropertiesKHR*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_tohost_VkDisplayPropertiesKHR(m_state, (VkDisplayPropertiesKHR*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceDisplayPropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayPropertiesKHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_3);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_fromhost_VkDisplayPropertiesKHR(m_state, (VkDisplayPropertiesKHR*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_4);
                if (pProperties)
                {
                    if (pPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            marshal_VkDisplayPropertiesKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPropertiesKHR*)(pProperties + i));
                        }
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceDisplayPropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceDisplayPlanePropertiesKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPlanePropertiesKHR* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDisplayPlanePropertiesKHR**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPlanePropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkDisplayPlanePropertiesKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlanePropertiesKHR*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_tohost_VkDisplayPlanePropertiesKHR(m_state, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceDisplayPlanePropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayPlanePropertiesKHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_3);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_fromhost_VkDisplayPlanePropertiesKHR(m_state, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_4);
                if (pProperties)
                {
                    if (pPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            marshal_VkDisplayPlanePropertiesKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                        }
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceDisplayPlanePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDisplayPlaneSupportedDisplaysKHR:
            {
                android::base::beginTrace("vkGetDisplayPlaneSupportedDisplaysKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t planeIndex;
                uint32_t* pDisplayCount;
                VkDisplayKHR* pDisplays;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((uint32_t*)&planeIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for pDisplayCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pDisplayCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pDisplayCount);
                *readStreamPtrPtr += 8;
                if (pDisplayCount)
                {
                    vkReadStream->alloc((void**)&pDisplayCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pDisplayCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pDisplays;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDisplayKHR**)&pDisplays, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pDisplays);
                *readStreamPtrPtr += 8;
                if (pDisplays)
                {
                    vkReadStream->alloc((void**)&pDisplays, (*(pDisplayCount)) * sizeof(VkDisplayKHR));
                    if ((*(pDisplayCount)))
                    {
                        uint8_t* cgen_var_2_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * (*(pDisplayCount));
                        if (pDisplayCount)
                        {
                            for (uint32_t k = 0; k < (*(pDisplayCount)); ++k)
                            {
                                uint64_t tmpval; memcpy(&tmpval, cgen_var_2_0_ptr + k * 8, sizeof(uint64_t));
                                *(((VkDisplayKHR*)pDisplays) + k) = (VkDisplayKHR)(VkDisplayKHR)((VkDisplayKHR)tmpval);
                            }
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDisplayPlaneSupportedDisplaysKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)planeIndex, (unsigned long long)pDisplayCount, (unsigned long long)pDisplays);
                }
                VkResult vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = vk->vkGetDisplayPlaneSupportedDisplaysKHR(unboxed_physicalDevice, planeIndex, pDisplayCount, pDisplays);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pDisplayCount;
                vkStream->putBe64(cgen_var_3);
                if (pDisplayCount)
                {
                    vkStream->write((uint32_t*)pDisplayCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pDisplays;
                vkStream->putBe64(cgen_var_4);
                if (pDisplays)
                {
                    if ((*(pDisplayCount)))
                    {
                        uint64_t* cgen_var_4_0;
                        vkStream->alloc((void**)&cgen_var_4_0, (*(pDisplayCount)) * 8);
                        vkStream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplays, cgen_var_4_0, (*(pDisplayCount)));
                        vkStream->write((uint64_t*)cgen_var_4_0, (*(pDisplayCount)) * 8);
                    }
                }
                vkStream->write(&vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayPlaneSupportedDisplaysKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, physicalDevice, planeIndex, pDisplayCount, pDisplays);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDisplayModePropertiesKHR:
            {
                android::base::beginTrace("vkGetDisplayModePropertiesKHR decode");
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                uint32_t* pPropertyCount;
                VkDisplayModePropertiesKHR* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayKHR*)&display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDisplayModePropertiesKHR**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayModePropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkDisplayModePropertiesKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayModePropertiesKHR*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_tohost_VkDisplayModePropertiesKHR(m_state, (VkDisplayModePropertiesKHR*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDisplayModePropertiesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)display, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetDisplayModePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetDisplayModePropertiesKHR_VkResult_return = vk->vkGetDisplayModePropertiesKHR(unboxed_physicalDevice, display, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_4);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_fromhost_VkDisplayModePropertiesKHR(m_state, (VkDisplayModePropertiesKHR*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_5 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_5);
                if (pProperties)
                {
                    if (pPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            marshal_VkDisplayModePropertiesKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayModePropertiesKHR*)(pProperties + i));
                        }
                    }
                }
                vkStream->write(&vkGetDisplayModePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayModePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayModePropertiesKHR_VkResult_return, physicalDevice, display, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateDisplayModeKHR:
            {
                android::base::beginTrace("vkCreateDisplayModeKHR decode");
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                const VkDisplayModeCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDisplayModeKHR* pMode;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayKHR*)&display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_1));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDisplayModeCreateInfoKHR));
                reservedunmarshal_VkDisplayModeCreateInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayModeCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pMode;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMode, sizeof(VkDisplayModeKHR));
                uint64_t cgen_var_3;
                memcpy((uint64_t*)&cgen_var_3, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDisplayModeKHR*)pMode = (VkDisplayModeKHR)(VkDisplayModeKHR)((VkDisplayModeKHR)(*&cgen_var_3));
                if (pCreateInfo)
                {
                    transform_tohost_VkDisplayModeCreateInfoKHR(m_state, (VkDisplayModeCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDisplayModeKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)display, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pMode);
                }
                VkResult vkCreateDisplayModeKHR_VkResult_return = (VkResult)0;
                vkCreateDisplayModeKHR_VkResult_return = vk->vkCreateDisplayModeKHR(unboxed_physicalDevice, display, pCreateInfo, pAllocator, pMode);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pMode;
                if (vkCreateDisplayModeKHR_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_4;
                static_assert(8 == sizeof(VkDisplayModeKHR), "handle map overwrite requres VkDisplayModeKHR to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDisplayModeKHR((VkDisplayModeKHR*)pMode, 1);
                vkStream->write((VkDisplayModeKHR*)pMode, 8 * 1);
                // Begin auto non dispatchable handle create for pMode;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDisplayModeKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDisplayModeKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDisplayModeKHR_VkResult_return, physicalDevice, display, pCreateInfo, pAllocator, pMode);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDisplayPlaneCapabilitiesKHR:
            {
                android::base::beginTrace("vkGetDisplayPlaneCapabilitiesKHR decode");
                VkPhysicalDevice physicalDevice;
                VkDisplayModeKHR mode;
                uint32_t planeIndex;
                VkDisplayPlaneCapabilitiesKHR* pCapabilities;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayModeKHR*)&mode = (VkDisplayModeKHR)unbox_VkDisplayModeKHR((VkDisplayModeKHR)(*&cgen_var_1));
                memcpy((uint32_t*)&planeIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for pCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCapabilities, sizeof(VkDisplayPlaneCapabilitiesKHR));
                reservedunmarshal_VkDisplayPlaneCapabilitiesKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities), readStreamPtrPtr);
                if (pCapabilities)
                {
                    transform_tohost_VkDisplayPlaneCapabilitiesKHR(m_state, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDisplayPlaneCapabilitiesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)mode, (unsigned long long)planeIndex, (unsigned long long)pCapabilities);
                }
                VkResult vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = vk->vkGetDisplayPlaneCapabilitiesKHR(unboxed_physicalDevice, mode, planeIndex, pCapabilities);
                vkStream->unsetHandleMapping();
                if (pCapabilities)
                {
                    transform_fromhost_VkDisplayPlaneCapabilitiesKHR(m_state, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                }
                marshal_VkDisplayPlaneCapabilitiesKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                vkStream->write(&vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayPlaneCapabilitiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, physicalDevice, mode, planeIndex, pCapabilities);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateDisplayPlaneSurfaceKHR:
            {
                android::base::beginTrace("vkCreateDisplayPlaneSurfaceKHR decode");
                VkInstance instance;
                const VkDisplaySurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDisplaySurfaceCreateInfoKHR));
                reservedunmarshal_VkDisplaySurfaceCreateInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplaySurfaceCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkDisplaySurfaceCreateInfoKHR(m_state, (VkDisplaySurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDisplayPlaneSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateDisplayPlaneSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateDisplayPlaneSurfaceKHR_VkResult_return = vk->vkCreateDisplayPlaneSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkCreateDisplayPlaneSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDisplayPlaneSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDisplayPlaneSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_display_swapchain
            case OP_vkCreateSharedSwapchainsKHR:
            {
                android::base::beginTrace("vkCreateSharedSwapchainsKHR decode");
                VkDevice device;
                uint32_t swapchainCount;
                const VkSwapchainCreateInfoKHR* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkSwapchainKHR* pSwapchains;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&swapchainCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pCreateInfos, ((swapchainCount)) * sizeof(const VkSwapchainCreateInfoKHR));
                for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                {
                    reservedunmarshal_VkSwapchainCreateInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSwapchainCreateInfoKHR*)(pCreateInfos + i), readStreamPtrPtr);
                }
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSwapchains;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSwapchains, ((swapchainCount)) * sizeof(VkSwapchainKHR));
                if (((swapchainCount)))
                {
                    uint8_t* cgen_var_2_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((swapchainCount));
                    for (uint32_t k = 0; k < ((swapchainCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_2_ptr + k * 8, sizeof(uint64_t));
                        *(((VkSwapchainKHR*)pSwapchains) + k) = (VkSwapchainKHR)(VkSwapchainKHR)((VkSwapchainKHR)tmpval);
                    }
                }
                if (pCreateInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                    {
                        transform_tohost_VkSwapchainCreateInfoKHR(m_state, (VkSwapchainCreateInfoKHR*)(pCreateInfos + i));
                    }
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateSharedSwapchainsKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchainCount, (unsigned long long)pCreateInfos, (unsigned long long)pAllocator, (unsigned long long)pSwapchains);
                }
                VkResult vkCreateSharedSwapchainsKHR_VkResult_return = (VkResult)0;
                vkCreateSharedSwapchainsKHR_VkResult_return = vk->vkCreateSharedSwapchainsKHR(unboxed_device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
                vkStream->unsetHandleMapping();
                if (((swapchainCount)))
                {
                    uint64_t* cgen_var_3;
                    vkStream->alloc((void**)&cgen_var_3, ((swapchainCount)) * 8);
                    vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchains, cgen_var_3, ((swapchainCount)));
                    vkStream->write((uint64_t*)cgen_var_3, ((swapchainCount)) * 8);
                }
                vkStream->write(&vkCreateSharedSwapchainsKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSharedSwapchainsKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSharedSwapchainsKHR_VkResult_return, device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_xlib_surface
            case OP_vkCreateXlibSurfaceKHR:
            {
                android::base::beginTrace("vkCreateXlibSurfaceKHR decode");
                VkInstance instance;
                const VkXlibSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkXlibSurfaceCreateInfoKHR));
                reservedunmarshal_VkXlibSurfaceCreateInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkXlibSurfaceCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkXlibSurfaceCreateInfoKHR(m_state, (VkXlibSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateXlibSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateXlibSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateXlibSurfaceKHR_VkResult_return = vk->vkCreateXlibSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkCreateXlibSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateXlibSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateXlibSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceXlibPresentationSupportKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceXlibPresentationSupportKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                Display* dpy;
                VisualID visualID;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for dpy;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                memcpy((Display*)dpy, *readStreamPtrPtr, sizeof(Display));
                *readStreamPtrPtr += sizeof(Display);
                memcpy((VisualID*)&visualID, *readStreamPtrPtr, sizeof(VisualID));
                *readStreamPtrPtr += sizeof(VisualID);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceXlibPresentationSupportKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)dpy, (unsigned long long)visualID);
                }
                VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceXlibPresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex, dpy, visualID);
                vkStream->unsetHandleMapping();
                vkStream->write((Display*)dpy, sizeof(Display));
                vkStream->write(&vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceXlibPresentationSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex, dpy, visualID);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_xcb_surface
            case OP_vkCreateXcbSurfaceKHR:
            {
                android::base::beginTrace("vkCreateXcbSurfaceKHR decode");
                // Decoding vkCreateXcbSurfaceKHR is not supported. This should not run.
                fprintf(stderr, "stream %p: fatal: decoding unsupported API vkCreateXcbSurfaceKHR\n", ioStream);
                __builtin_trap();
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceXcbPresentationSupportKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceXcbPresentationSupportKHR decode");
                // Decoding vkGetPhysicalDeviceXcbPresentationSupportKHR is not supported. This should not run.
                fprintf(stderr, "stream %p: fatal: decoding unsupported API vkGetPhysicalDeviceXcbPresentationSupportKHR\n", ioStream);
                __builtin_trap();
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_wayland_surface
            case OP_vkCreateWaylandSurfaceKHR:
            {
                android::base::beginTrace("vkCreateWaylandSurfaceKHR decode");
                VkInstance instance;
                const VkWaylandSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkWaylandSurfaceCreateInfoKHR));
                reservedunmarshal_VkWaylandSurfaceCreateInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWaylandSurfaceCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkWaylandSurfaceCreateInfoKHR(m_state, (VkWaylandSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateWaylandSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateWaylandSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateWaylandSurfaceKHR_VkResult_return = vk->vkCreateWaylandSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkCreateWaylandSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateWaylandSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateWaylandSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceWaylandPresentationSupportKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceWaylandPresentationSupportKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                wl_display* display;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for display;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&display, sizeof(wl_display));
                memcpy((wl_display*)display, *readStreamPtrPtr, sizeof(wl_display));
                *readStreamPtrPtr += sizeof(wl_display);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceWaylandPresentationSupportKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)display);
                }
                VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceWaylandPresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex, display);
                vkStream->unsetHandleMapping();
                vkStream->write((wl_display*)display, sizeof(wl_display));
                vkStream->write(&vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceWaylandPresentationSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex, display);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_android_surface
            case OP_vkCreateAndroidSurfaceKHR:
            {
                android::base::beginTrace("vkCreateAndroidSurfaceKHR decode");
                VkInstance instance;
                const VkAndroidSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkAndroidSurfaceCreateInfoKHR));
                reservedunmarshal_VkAndroidSurfaceCreateInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAndroidSurfaceCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkAndroidSurfaceCreateInfoKHR(m_state, (VkAndroidSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateAndroidSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateAndroidSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateAndroidSurfaceKHR_VkResult_return = vk->vkCreateAndroidSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkCreateAndroidSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateAndroidSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateAndroidSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_win32_surface
            case OP_vkCreateWin32SurfaceKHR:
            {
                android::base::beginTrace("vkCreateWin32SurfaceKHR decode");
                VkInstance instance;
                const VkWin32SurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkWin32SurfaceCreateInfoKHR));
                reservedunmarshal_VkWin32SurfaceCreateInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWin32SurfaceCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkWin32SurfaceCreateInfoKHR(m_state, (VkWin32SurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateWin32SurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateWin32SurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateWin32SurfaceKHR_VkResult_return = vk->vkCreateWin32SurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkCreateWin32SurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateWin32SurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateWin32SurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceWin32PresentationSupportKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceWin32PresentationSupportKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceWin32PresentationSupportKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex);
                }
                VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceWin32PresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceWin32PresentationSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
            case OP_vkGetPhysicalDeviceFeatures2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceFeatures2KHR decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures2* pFeatures;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures2));
                reservedunmarshal_VkPhysicalDeviceFeatures2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures2*)(pFeatures), readStreamPtrPtr);
                if (pFeatures)
                {
                    transform_tohost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceFeatures2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFeatures);
                }
                m_state->on_vkGetPhysicalDeviceFeatures2KHR(&m_pool, physicalDevice, pFeatures);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                marshal_VkPhysicalDeviceFeatures2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFeatures2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFeatures);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties2* pProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties2));
                reservedunmarshal_VkPhysicalDeviceProperties2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties2*)(pProperties), readStreamPtrPtr);
                if (pProperties)
                {
                    transform_tohost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceProperties2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pProperties);
                }
                m_state->on_vkGetPhysicalDeviceProperties2KHR(&m_pool, physicalDevice, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                marshal_VkPhysicalDeviceProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties2*)(pProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceFormatProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties2* pFormatProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                // Begin manual dispatchable handle unboxing for pFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties2));
                reservedunmarshal_VkFormatProperties2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties2*)(pFormatProperties), readStreamPtrPtr);
                if (pFormatProperties)
                {
                    transform_tohost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceFormatProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)pFormatProperties);
                }
                m_state->on_vkGetPhysicalDeviceFormatProperties2KHR(&m_pool, physicalDevice, format, pFormatProperties);
                vkStream->unsetHandleMapping();
                if (pFormatProperties)
                {
                    transform_fromhost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                marshal_VkFormatProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties2*)(pFormatProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFormatProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format, pFormatProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceImageFormatProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
                VkImageFormatProperties2* pImageFormatProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pImageFormatInfo, sizeof(const VkPhysicalDeviceImageFormatInfo2));
                reservedunmarshal_VkPhysicalDeviceImageFormatInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties2));
                reservedunmarshal_VkImageFormatProperties2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties2*)(pImageFormatProperties), readStreamPtrPtr);
                if (pImageFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceImageFormatInfo2(m_state, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                }
                if (pImageFormatProperties)
                {
                    transform_tohost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceImageFormatProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pImageFormatInfo, (unsigned long long)pImageFormatProperties);
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = m_state->on_vkGetPhysicalDeviceImageFormatProperties2KHR(&m_pool, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pImageFormatProperties)
                {
                    transform_fromhost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                marshal_VkImageFormatProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceQueueFamilyProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties2* pQueueFamilyProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pQueueFamilyPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pQueueFamilyPropertyCount);
                *readStreamPtrPtr += 8;
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pQueueFamilyPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pQueueFamilyProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkQueueFamilyProperties2**)&pQueueFamilyProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pQueueFamilyProperties);
                *readStreamPtrPtr += 8;
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkQueueFamilyProperties2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i), readStreamPtrPtr);
                    }
                }
                if (pQueueFamilyPropertyCount)
                {
                    if (pQueueFamilyProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                        {
                            transform_tohost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceQueueFamilyProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pQueueFamilyPropertyCount, (unsigned long long)pQueueFamilyProperties);
                }
                vk->vkGetPhysicalDeviceQueueFamilyProperties2KHR(unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_3);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                if (pQueueFamilyPropertyCount)
                {
                    if (pQueueFamilyProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                        {
                            transform_fromhost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_4);
                if (pQueueFamilyProperties)
                {
                    if (pQueueFamilyPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                        {
                            marshal_VkQueueFamilyProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                        }
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceMemoryProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for pMemoryProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties2));
                reservedunmarshal_VkPhysicalDeviceMemoryProperties2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties), readStreamPtrPtr);
                if (pMemoryProperties)
                {
                    transform_tohost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceMemoryProperties2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pMemoryProperties);
                }
                m_state->on_vkGetPhysicalDeviceMemoryProperties2KHR(&m_pool, physicalDevice, pMemoryProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryProperties)
                {
                    transform_fromhost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                marshal_VkPhysicalDeviceMemoryProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pMemoryProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSparseImageFormatProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties2* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pFormatInfo, sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
                reservedunmarshal_VkPhysicalDeviceSparseImageFormatInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSparseImageFormatProperties2**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkSparseImageFormatProperties2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties2*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(m_state, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_tohost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSparseImageFormatProperties2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFormatInfo, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                vk->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(unboxed_physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_3);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_fromhost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_4);
                if (pProperties)
                {
                    if (pPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            marshal_VkSparseImageFormatProperties2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties2*)(pProperties + i));
                        }
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_device_group
            case OP_vkGetDeviceGroupPeerMemoryFeaturesKHR:
            {
                android::base::beginTrace("vkGetDeviceGroupPeerMemoryFeaturesKHR decode");
                VkDevice device;
                uint32_t heapIndex;
                uint32_t localDeviceIndex;
                uint32_t remoteDeviceIndex;
                VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&heapIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&localDeviceIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&remoteDeviceIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for pPeerMemoryFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                memcpy((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, *readStreamPtrPtr, sizeof(VkPeerMemoryFeatureFlags));
                *readStreamPtrPtr += sizeof(VkPeerMemoryFeatureFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceGroupPeerMemoryFeaturesKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)heapIndex, (unsigned long long)localDeviceIndex, (unsigned long long)remoteDeviceIndex, (unsigned long long)pPeerMemoryFeatures);
                }
                vk->vkGetDeviceGroupPeerMemoryFeaturesKHR(unboxed_device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                vkStream->unsetHandleMapping();
                vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceGroupPeerMemoryFeaturesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetDeviceMaskKHR:
            {
                android::base::beginTrace("vkCmdSetDeviceMaskKHR decode");
                VkCommandBuffer commandBuffer;
                uint32_t deviceMask;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&deviceMask, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetDeviceMaskKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)deviceMask);
                }
                vk->vkCmdSetDeviceMaskKHR(unboxed_commandBuffer, deviceMask);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDeviceMaskKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, deviceMask);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDispatchBaseKHR:
            {
                android::base::beginTrace("vkCmdDispatchBaseKHR decode");
                VkCommandBuffer commandBuffer;
                uint32_t baseGroupX;
                uint32_t baseGroupY;
                uint32_t baseGroupZ;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&baseGroupX, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&baseGroupY, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&baseGroupZ, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountX, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountY, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountZ, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDispatchBaseKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)baseGroupX, (unsigned long long)baseGroupY, (unsigned long long)baseGroupZ, (unsigned long long)groupCountX, (unsigned long long)groupCountY, (unsigned long long)groupCountZ);
                }
                vk->vkCmdDispatchBaseKHR(unboxed_commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDispatchBaseKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
            case OP_vkTrimCommandPoolKHR:
            {
                android::base::beginTrace("vkTrimCommandPoolKHR decode");
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolTrimFlags flags;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandPool*)&commandPool = (VkCommandPool)unbox_VkCommandPool((VkCommandPool)(*&cgen_var_1));
                memcpy((VkCommandPoolTrimFlags*)&flags, *readStreamPtrPtr, sizeof(VkCommandPoolTrimFlags));
                *readStreamPtrPtr += sizeof(VkCommandPoolTrimFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkTrimCommandPoolKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)flags);
                }
                vk->vkTrimCommandPoolKHR(unboxed_device, commandPool, flags);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkTrimCommandPoolKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, commandPool, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_device_group_creation
            case OP_vkEnumeratePhysicalDeviceGroupsKHR:
            {
                android::base::beginTrace("vkEnumeratePhysicalDeviceGroupsKHR decode");
                VkInstance instance;
                uint32_t* pPhysicalDeviceGroupCount;
                VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPhysicalDeviceGroupCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPhysicalDeviceGroupCount);
                *readStreamPtrPtr += 8;
                if (pPhysicalDeviceGroupCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPhysicalDeviceGroupCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPhysicalDeviceGroupProperties**)&pPhysicalDeviceGroupProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPhysicalDeviceGroupProperties);
                *readStreamPtrPtr += 8;
                if (pPhysicalDeviceGroupProperties)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupProperties, (*(pPhysicalDeviceGroupCount)) * sizeof(VkPhysicalDeviceGroupProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        reservedunmarshal_VkPhysicalDeviceGroupProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPhysicalDeviceGroupCount)
                {
                    if (pPhysicalDeviceGroupProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                        {
                            transform_tohost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumeratePhysicalDeviceGroupsKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pPhysicalDeviceGroupCount, (unsigned long long)pPhysicalDeviceGroupProperties);
                }
                VkResult vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = vk->vkEnumeratePhysicalDeviceGroupsKHR(unboxed_instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
                vkStream->putBe64(cgen_var_3);
                if (pPhysicalDeviceGroupCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                if (pPhysicalDeviceGroupCount)
                {
                    if (pPhysicalDeviceGroupProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                        {
                            transform_fromhost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
                vkStream->putBe64(cgen_var_4);
                if (pPhysicalDeviceGroupProperties)
                {
                    if (pPhysicalDeviceGroupCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                        {
                            marshal_VkPhysicalDeviceGroupProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                        }
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumeratePhysicalDeviceGroupsKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_memory_capabilities
            case OP_vkGetPhysicalDeviceExternalBufferPropertiesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceExternalBufferPropertiesKHR decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
                VkExternalBufferProperties* pExternalBufferProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalBufferInfo, sizeof(const VkPhysicalDeviceExternalBufferInfo));
                reservedunmarshal_VkPhysicalDeviceExternalBufferInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pExternalBufferProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalBufferProperties, sizeof(VkExternalBufferProperties));
                reservedunmarshal_VkExternalBufferProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalBufferProperties*)(pExternalBufferProperties), readStreamPtrPtr);
                if (pExternalBufferInfo)
                {
                    m_state->transformImpl_VkPhysicalDeviceExternalBufferInfo_tohost(pExternalBufferInfo, 1);
                    transform_tohost_VkPhysicalDeviceExternalBufferInfo(m_state, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                }
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_tohost(pExternalBufferProperties, 1);
                    transform_tohost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceExternalBufferPropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalBufferInfo, (unsigned long long)pExternalBufferProperties);
                }
                vk->vkGetPhysicalDeviceExternalBufferPropertiesKHR(unboxed_physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                vkStream->unsetHandleMapping();
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_fromhost(pExternalBufferProperties, 1);
                    transform_fromhost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                marshal_VkExternalBufferProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalBufferPropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
            case OP_vkGetMemoryWin32HandleKHR:
            {
                android::base::beginTrace("vkGetMemoryWin32HandleKHR decode");
                VkDevice device;
                const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkMemoryGetWin32HandleInfoKHR));
                reservedunmarshal_VkMemoryGetWin32HandleInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryGetWin32HandleInfoKHR*)(pGetWin32HandleInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                memcpy((HANDLE*)pHandle, *readStreamPtrPtr, sizeof(HANDLE));
                *readStreamPtrPtr += sizeof(HANDLE);
                if (pGetWin32HandleInfo)
                {
                    transform_tohost_VkMemoryGetWin32HandleInfoKHR(m_state, (VkMemoryGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryWin32HandleKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetWin32HandleInfo, (unsigned long long)pHandle);
                }
                VkResult vkGetMemoryWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandleKHR_VkResult_return = vk->vkGetMemoryWin32HandleKHR(unboxed_device, pGetWin32HandleInfo, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetMemoryWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryWin32HandleKHR_VkResult_return, device, pGetWin32HandleInfo, pHandle);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetMemoryWin32HandlePropertiesKHR:
            {
                android::base::beginTrace("vkGetMemoryWin32HandlePropertiesKHR decode");
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                HANDLE handle;
                VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkExternalMemoryHandleTypeFlagBits*)&handleType, *readStreamPtrPtr, sizeof(VkExternalMemoryHandleTypeFlagBits));
                *readStreamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
                memcpy((HANDLE*)&handle, *readStreamPtrPtr, sizeof(HANDLE));
                *readStreamPtrPtr += sizeof(HANDLE);
                // Begin manual dispatchable handle unboxing for pMemoryWin32HandleProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryWin32HandleProperties, sizeof(VkMemoryWin32HandlePropertiesKHR));
                reservedunmarshal_VkMemoryWin32HandlePropertiesKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties), readStreamPtrPtr);
                if (pMemoryWin32HandleProperties)
                {
                    transform_tohost_VkMemoryWin32HandlePropertiesKHR(m_state, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryWin32HandlePropertiesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)handleType, (unsigned long long)handle, (unsigned long long)pMemoryWin32HandleProperties);
                }
                VkResult vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = vk->vkGetMemoryWin32HandlePropertiesKHR(unboxed_device, handleType, handle, pMemoryWin32HandleProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryWin32HandleProperties)
                {
                    transform_fromhost_VkMemoryWin32HandlePropertiesKHR(m_state, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                }
                marshal_VkMemoryWin32HandlePropertiesKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                vkStream->write(&vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryWin32HandlePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, device, handleType, handle, pMemoryWin32HandleProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_memory_fd
            case OP_vkGetMemoryFdKHR:
            {
                android::base::beginTrace("vkGetMemoryFdKHR decode");
                VkDevice device;
                const VkMemoryGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkMemoryGetFdInfoKHR));
                reservedunmarshal_VkMemoryGetFdInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryGetFdInfoKHR*)(pGetFdInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                memcpy((int*)pFd, *readStreamPtrPtr, sizeof(int));
                *readStreamPtrPtr += sizeof(int);
                if (pGetFdInfo)
                {
                    transform_tohost_VkMemoryGetFdInfoKHR(m_state, (VkMemoryGetFdInfoKHR*)(pGetFdInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryFdKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetFdInfo, (unsigned long long)pFd);
                }
                VkResult vkGetMemoryFdKHR_VkResult_return = (VkResult)0;
                vkGetMemoryFdKHR_VkResult_return = vk->vkGetMemoryFdKHR(unboxed_device, pGetFdInfo, pFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetMemoryFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryFdKHR_VkResult_return, device, pGetFdInfo, pFd);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetMemoryFdPropertiesKHR:
            {
                android::base::beginTrace("vkGetMemoryFdPropertiesKHR decode");
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                int fd;
                VkMemoryFdPropertiesKHR* pMemoryFdProperties;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkExternalMemoryHandleTypeFlagBits*)&handleType, *readStreamPtrPtr, sizeof(VkExternalMemoryHandleTypeFlagBits));
                *readStreamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
                memcpy((int*)&fd, *readStreamPtrPtr, sizeof(int));
                *readStreamPtrPtr += sizeof(int);
                // Begin manual dispatchable handle unboxing for pMemoryFdProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryFdProperties, sizeof(VkMemoryFdPropertiesKHR));
                reservedunmarshal_VkMemoryFdPropertiesKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties), readStreamPtrPtr);
                if (pMemoryFdProperties)
                {
                    transform_tohost_VkMemoryFdPropertiesKHR(m_state, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryFdPropertiesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)handleType, (unsigned long long)fd, (unsigned long long)pMemoryFdProperties);
                }
                VkResult vkGetMemoryFdPropertiesKHR_VkResult_return = (VkResult)0;
                vkGetMemoryFdPropertiesKHR_VkResult_return = vk->vkGetMemoryFdPropertiesKHR(unboxed_device, handleType, fd, pMemoryFdProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryFdProperties)
                {
                    transform_fromhost_VkMemoryFdPropertiesKHR(m_state, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                }
                marshal_VkMemoryFdPropertiesKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                vkStream->write(&vkGetMemoryFdPropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryFdPropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryFdPropertiesKHR_VkResult_return, device, handleType, fd, pMemoryFdProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_win32_keyed_mutex
#endif
#ifdef VK_KHR_external_semaphore_capabilities
            case OP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
                VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
                // Begin global wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pExternalSemaphoreInfo, sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
                reservedunmarshal_VkPhysicalDeviceExternalSemaphoreInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pExternalSemaphoreProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalSemaphoreProperties, sizeof(VkExternalSemaphoreProperties));
                reservedunmarshal_VkExternalSemaphoreProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties), readStreamPtrPtr);
                if (pExternalSemaphoreInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(m_state, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                }
                if (pExternalSemaphoreProperties)
                {
                    transform_tohost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceExternalSemaphorePropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalSemaphoreInfo, (unsigned long long)pExternalSemaphoreProperties);
                }
                m_state->on_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(&m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                vkStream->unsetHandleMapping();
                if (pExternalSemaphoreProperties)
                {
                    transform_fromhost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                marshal_VkExternalSemaphoreProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
            case OP_vkImportSemaphoreWin32HandleKHR:
            {
                android::base::beginTrace("vkImportSemaphoreWin32HandleKHR decode");
                VkDevice device;
                const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pImportSemaphoreWin32HandleInfo, sizeof(const VkImportSemaphoreWin32HandleInfoKHR));
                reservedunmarshal_VkImportSemaphoreWin32HandleInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImportSemaphoreWin32HandleInfoKHR*)(pImportSemaphoreWin32HandleInfo), readStreamPtrPtr);
                if (pImportSemaphoreWin32HandleInfo)
                {
                    transform_tohost_VkImportSemaphoreWin32HandleInfoKHR(m_state, (VkImportSemaphoreWin32HandleInfoKHR*)(pImportSemaphoreWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkImportSemaphoreWin32HandleKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pImportSemaphoreWin32HandleInfo);
                }
                VkResult vkImportSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
                vkImportSemaphoreWin32HandleKHR_VkResult_return = vk->vkImportSemaphoreWin32HandleKHR(unboxed_device, pImportSemaphoreWin32HandleInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkImportSemaphoreWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkImportSemaphoreWin32HandleKHR_VkResult_return, device, pImportSemaphoreWin32HandleInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetSemaphoreWin32HandleKHR:
            {
                android::base::beginTrace("vkGetSemaphoreWin32HandleKHR decode");
                VkDevice device;
                const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkSemaphoreGetWin32HandleInfoKHR));
                reservedunmarshal_VkSemaphoreGetWin32HandleInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreGetWin32HandleInfoKHR*)(pGetWin32HandleInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                memcpy((HANDLE*)pHandle, *readStreamPtrPtr, sizeof(HANDLE));
                *readStreamPtrPtr += sizeof(HANDLE);
                if (pGetWin32HandleInfo)
                {
                    transform_tohost_VkSemaphoreGetWin32HandleInfoKHR(m_state, (VkSemaphoreGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetSemaphoreWin32HandleKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetWin32HandleInfo, (unsigned long long)pHandle);
                }
                VkResult vkGetSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetSemaphoreWin32HandleKHR_VkResult_return = vk->vkGetSemaphoreWin32HandleKHR(unboxed_device, pGetWin32HandleInfo, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSemaphoreWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSemaphoreWin32HandleKHR_VkResult_return, device, pGetWin32HandleInfo, pHandle);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_semaphore_fd
            case OP_vkImportSemaphoreFdKHR:
            {
                android::base::beginTrace("vkImportSemaphoreFdKHR decode");
                VkDevice device;
                const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pImportSemaphoreFdInfo, sizeof(const VkImportSemaphoreFdInfoKHR));
                reservedunmarshal_VkImportSemaphoreFdInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImportSemaphoreFdInfoKHR*)(pImportSemaphoreFdInfo), readStreamPtrPtr);
                if (pImportSemaphoreFdInfo)
                {
                    transform_tohost_VkImportSemaphoreFdInfoKHR(m_state, (VkImportSemaphoreFdInfoKHR*)(pImportSemaphoreFdInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkImportSemaphoreFdKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pImportSemaphoreFdInfo);
                }
                VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
                vkImportSemaphoreFdKHR_VkResult_return = m_state->on_vkImportSemaphoreFdKHR(&m_pool, device, pImportSemaphoreFdInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkImportSemaphoreFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkImportSemaphoreFdKHR_VkResult_return, device, pImportSemaphoreFdInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetSemaphoreFdKHR:
            {
                android::base::beginTrace("vkGetSemaphoreFdKHR decode");
                VkDevice device;
                const VkSemaphoreGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkSemaphoreGetFdInfoKHR));
                reservedunmarshal_VkSemaphoreGetFdInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreGetFdInfoKHR*)(pGetFdInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                memcpy((int*)pFd, *readStreamPtrPtr, sizeof(int));
                *readStreamPtrPtr += sizeof(int);
                if (pGetFdInfo)
                {
                    transform_tohost_VkSemaphoreGetFdInfoKHR(m_state, (VkSemaphoreGetFdInfoKHR*)(pGetFdInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetSemaphoreFdKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetFdInfo, (unsigned long long)pFd);
                }
                VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
                vkGetSemaphoreFdKHR_VkResult_return = m_state->on_vkGetSemaphoreFdKHR(&m_pool, device, pGetFdInfo, pFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSemaphoreFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSemaphoreFdKHR_VkResult_return, device, pGetFdInfo, pFd);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_push_descriptor
            case OP_vkCmdPushDescriptorSetKHR:
            {
                android::base::beginTrace("vkCmdPushDescriptorSetKHR decode");
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipelineLayout layout;
                uint32_t set;
                uint32_t descriptorWriteCount;
                const VkWriteDescriptorSet* pDescriptorWrites;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkPipelineBindPoint*)&pipelineBindPoint, *readStreamPtrPtr, sizeof(VkPipelineBindPoint));
                *readStreamPtrPtr += sizeof(VkPipelineBindPoint);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineLayout*)&layout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_1));
                memcpy((uint32_t*)&set, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&descriptorWriteCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pDescriptorWrites, ((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                {
                    reservedunmarshal_VkWriteDescriptorSet(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWriteDescriptorSet*)(pDescriptorWrites + i), readStreamPtrPtr);
                }
                if (pDescriptorWrites)
                {
                    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                    {
                        transform_tohost_VkWriteDescriptorSet(m_state, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdPushDescriptorSetKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineBindPoint, (unsigned long long)layout, (unsigned long long)set, (unsigned long long)descriptorWriteCount, (unsigned long long)pDescriptorWrites);
                }
                vk->vkCmdPushDescriptorSetKHR(unboxed_commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdPushDescriptorSetKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdPushDescriptorSetWithTemplateKHR:
            {
                android::base::beginTrace("vkCmdPushDescriptorSetWithTemplateKHR decode");
                VkCommandBuffer commandBuffer;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                VkPipelineLayout layout;
                uint32_t set;
                const void* pData;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)unbox_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate)(*&cgen_var_1));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineLayout*)&layout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_2));
                memcpy((uint32_t*)&set, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // WARNING PTR CHECK
                memcpy((void**)&pData, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pData);
                *readStreamPtrPtr += 8;
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    memcpy((void*)pData, *readStreamPtrPtr, sizeof(const uint8_t));
                    *readStreamPtrPtr += sizeof(const uint8_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdPushDescriptorSetWithTemplateKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)layout, (unsigned long long)set, (unsigned long long)pData);
                }
                vk->vkCmdPushDescriptorSetWithTemplateKHR(unboxed_commandBuffer, descriptorUpdateTemplate, layout, set, pData);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdPushDescriptorSetWithTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, descriptorUpdateTemplate, layout, set, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
            case OP_vkCreateDescriptorUpdateTemplateKHR:
            {
                android::base::beginTrace("vkCreateDescriptorUpdateTemplateKHR decode");
                VkDevice device;
                const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorUpdateTemplateCreateInfo));
                reservedunmarshal_VkDescriptorUpdateTemplateCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pDescriptorUpdateTemplate;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate = (VkDescriptorUpdateTemplate)(VkDescriptorUpdateTemplate)((VkDescriptorUpdateTemplate)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorUpdateTemplateCreateInfo(m_state, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDescriptorUpdateTemplateKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pDescriptorUpdateTemplate);
                }
                VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
                vkCreateDescriptorUpdateTemplateKHR_VkResult_return = m_state->on_vkCreateDescriptorUpdateTemplateKHR(&m_pool, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkDescriptorUpdateTemplate), "handle map overwrite requres VkDescriptorUpdateTemplate to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
                vkStream->write((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 8 * 1);
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorUpdateTemplateKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDescriptorUpdateTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDescriptorUpdateTemplateKHR_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDescriptorUpdateTemplateKHR:
            {
                android::base::beginTrace("vkDestroyDescriptorUpdateTemplateKHR decode");
                VkDevice device;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                // Begin manual non dispatchable handle destroy unboxing for descriptorUpdateTemplate;
                VkDescriptorUpdateTemplate boxed_descriptorUpdateTemplate_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)(VkDescriptorUpdateTemplate)((VkDescriptorUpdateTemplate)(*&cgen_var_1));
                boxed_descriptorUpdateTemplate_preserve = descriptorUpdateTemplate;
                descriptorUpdateTemplate = unbox_VkDescriptorUpdateTemplate(descriptorUpdateTemplate);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDescriptorUpdateTemplateKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDescriptorUpdateTemplateKHR(&m_pool, device, descriptorUpdateTemplate, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDescriptorUpdateTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_descriptorUpdateTemplate_preserve, pAllocator);
                }
                delete_VkDescriptorUpdateTemplate(boxed_descriptorUpdateTemplate_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkUpdateDescriptorSetWithTemplateKHR:
            {
                android::base::beginTrace("vkUpdateDescriptorSetWithTemplateKHR decode");
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const void* pData;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorSet*)&descriptorSet = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)(*&cgen_var_1));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)unbox_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate)(*&cgen_var_2));
                // WARNING PTR CHECK
                memcpy((void**)&pData, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pData);
                *readStreamPtrPtr += 8;
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    memcpy((void*)pData, *readStreamPtrPtr, sizeof(const uint8_t));
                    *readStreamPtrPtr += sizeof(const uint8_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkUpdateDescriptorSetWithTemplateKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorSet, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)pData);
                }
                vk->vkUpdateDescriptorSetWithTemplateKHR(unboxed_device, descriptorSet, descriptorUpdateTemplate, pData);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUpdateDescriptorSetWithTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorSet, descriptorUpdateTemplate, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_imageless_framebuffer
#endif
#ifdef VK_KHR_create_renderpass2
            case OP_vkCreateRenderPass2KHR:
            {
                android::base::beginTrace("vkCreateRenderPass2KHR decode");
                VkDevice device;
                const VkRenderPassCreateInfo2* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkRenderPass* pRenderPass;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo2));
                reservedunmarshal_VkRenderPassCreateInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassCreateInfo2*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pRenderPass;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pRenderPass, sizeof(VkRenderPass));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkRenderPass*)pRenderPass = (VkRenderPass)(VkRenderPass)((VkRenderPass)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkRenderPassCreateInfo2(m_state, (VkRenderPassCreateInfo2*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateRenderPass2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pRenderPass);
                }
                VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
                vkCreateRenderPass2KHR_VkResult_return = vk->vkCreateRenderPass2KHR(unboxed_device, pCreateInfo, pAllocator, pRenderPass);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkCreateRenderPass2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateRenderPass2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateRenderPass2KHR_VkResult_return, device, pCreateInfo, pAllocator, pRenderPass);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBeginRenderPass2KHR:
            {
                android::base::beginTrace("vkCmdBeginRenderPass2KHR decode");
                VkCommandBuffer commandBuffer;
                const VkRenderPassBeginInfo* pRenderPassBegin;
                const VkSubpassBeginInfo* pSubpassBeginInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                reservedunmarshal_VkRenderPassBeginInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassBeginInfo*)(pRenderPassBegin), readStreamPtrPtr);
                vkReadStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfo));
                reservedunmarshal_VkSubpassBeginInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassBeginInfo*)(pSubpassBeginInfo), readStreamPtrPtr);
                if (pRenderPassBegin)
                {
                    transform_tohost_VkRenderPassBeginInfo(m_state, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                }
                if (pSubpassBeginInfo)
                {
                    transform_tohost_VkSubpassBeginInfo(m_state, (VkSubpassBeginInfo*)(pSubpassBeginInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBeginRenderPass2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pRenderPassBegin, (unsigned long long)pSubpassBeginInfo);
                }
                vk->vkCmdBeginRenderPass2KHR(unboxed_commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginRenderPass2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdNextSubpass2KHR:
            {
                android::base::beginTrace("vkCmdNextSubpass2KHR decode");
                VkCommandBuffer commandBuffer;
                const VkSubpassBeginInfo* pSubpassBeginInfo;
                const VkSubpassEndInfo* pSubpassEndInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfo));
                reservedunmarshal_VkSubpassBeginInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassBeginInfo*)(pSubpassBeginInfo), readStreamPtrPtr);
                vkReadStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfo));
                reservedunmarshal_VkSubpassEndInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassEndInfo*)(pSubpassEndInfo), readStreamPtrPtr);
                if (pSubpassBeginInfo)
                {
                    transform_tohost_VkSubpassBeginInfo(m_state, (VkSubpassBeginInfo*)(pSubpassBeginInfo));
                }
                if (pSubpassEndInfo)
                {
                    transform_tohost_VkSubpassEndInfo(m_state, (VkSubpassEndInfo*)(pSubpassEndInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdNextSubpass2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pSubpassBeginInfo, (unsigned long long)pSubpassEndInfo);
                }
                vk->vkCmdNextSubpass2KHR(unboxed_commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdNextSubpass2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdEndRenderPass2KHR:
            {
                android::base::beginTrace("vkCmdEndRenderPass2KHR decode");
                VkCommandBuffer commandBuffer;
                const VkSubpassEndInfo* pSubpassEndInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfo));
                reservedunmarshal_VkSubpassEndInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassEndInfo*)(pSubpassEndInfo), readStreamPtrPtr);
                if (pSubpassEndInfo)
                {
                    transform_tohost_VkSubpassEndInfo(m_state, (VkSubpassEndInfo*)(pSubpassEndInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdEndRenderPass2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pSubpassEndInfo);
                }
                vk->vkCmdEndRenderPass2KHR(unboxed_commandBuffer, pSubpassEndInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndRenderPass2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pSubpassEndInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_shared_presentable_image
            case OP_vkGetSwapchainStatusKHR:
            {
                android::base::beginTrace("vkGetSwapchainStatusKHR decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_1));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetSwapchainStatusKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain);
                }
                VkResult vkGetSwapchainStatusKHR_VkResult_return = (VkResult)0;
                vkGetSwapchainStatusKHR_VkResult_return = vk->vkGetSwapchainStatusKHR(unboxed_device, swapchain);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetSwapchainStatusKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSwapchainStatusKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSwapchainStatusKHR_VkResult_return, device, swapchain);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_fence_capabilities
            case OP_vkGetPhysicalDeviceExternalFencePropertiesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceExternalFencePropertiesKHR decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
                VkExternalFenceProperties* pExternalFenceProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalFenceInfo, sizeof(const VkPhysicalDeviceExternalFenceInfo));
                reservedunmarshal_VkPhysicalDeviceExternalFenceInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pExternalFenceProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalFenceProperties, sizeof(VkExternalFenceProperties));
                reservedunmarshal_VkExternalFenceProperties(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalFenceProperties*)(pExternalFenceProperties), readStreamPtrPtr);
                if (pExternalFenceInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalFenceInfo(m_state, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                }
                if (pExternalFenceProperties)
                {
                    transform_tohost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceExternalFencePropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalFenceInfo, (unsigned long long)pExternalFenceProperties);
                }
                vk->vkGetPhysicalDeviceExternalFencePropertiesKHR(unboxed_physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                vkStream->unsetHandleMapping();
                if (pExternalFenceProperties)
                {
                    transform_fromhost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                marshal_VkExternalFenceProperties(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalFencePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
            case OP_vkImportFenceWin32HandleKHR:
            {
                android::base::beginTrace("vkImportFenceWin32HandleKHR decode");
                VkDevice device;
                const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pImportFenceWin32HandleInfo, sizeof(const VkImportFenceWin32HandleInfoKHR));
                reservedunmarshal_VkImportFenceWin32HandleInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImportFenceWin32HandleInfoKHR*)(pImportFenceWin32HandleInfo), readStreamPtrPtr);
                if (pImportFenceWin32HandleInfo)
                {
                    transform_tohost_VkImportFenceWin32HandleInfoKHR(m_state, (VkImportFenceWin32HandleInfoKHR*)(pImportFenceWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkImportFenceWin32HandleKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pImportFenceWin32HandleInfo);
                }
                VkResult vkImportFenceWin32HandleKHR_VkResult_return = (VkResult)0;
                vkImportFenceWin32HandleKHR_VkResult_return = vk->vkImportFenceWin32HandleKHR(unboxed_device, pImportFenceWin32HandleInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkImportFenceWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkImportFenceWin32HandleKHR_VkResult_return, device, pImportFenceWin32HandleInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetFenceWin32HandleKHR:
            {
                android::base::beginTrace("vkGetFenceWin32HandleKHR decode");
                VkDevice device;
                const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkFenceGetWin32HandleInfoKHR));
                reservedunmarshal_VkFenceGetWin32HandleInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFenceGetWin32HandleInfoKHR*)(pGetWin32HandleInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                memcpy((HANDLE*)pHandle, *readStreamPtrPtr, sizeof(HANDLE));
                *readStreamPtrPtr += sizeof(HANDLE);
                if (pGetWin32HandleInfo)
                {
                    transform_tohost_VkFenceGetWin32HandleInfoKHR(m_state, (VkFenceGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetFenceWin32HandleKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetWin32HandleInfo, (unsigned long long)pHandle);
                }
                VkResult vkGetFenceWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetFenceWin32HandleKHR_VkResult_return = vk->vkGetFenceWin32HandleKHR(unboxed_device, pGetWin32HandleInfo, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetFenceWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetFenceWin32HandleKHR_VkResult_return, device, pGetWin32HandleInfo, pHandle);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_external_fence_fd
            case OP_vkImportFenceFdKHR:
            {
                android::base::beginTrace("vkImportFenceFdKHR decode");
                VkDevice device;
                const VkImportFenceFdInfoKHR* pImportFenceFdInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pImportFenceFdInfo, sizeof(const VkImportFenceFdInfoKHR));
                reservedunmarshal_VkImportFenceFdInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImportFenceFdInfoKHR*)(pImportFenceFdInfo), readStreamPtrPtr);
                if (pImportFenceFdInfo)
                {
                    transform_tohost_VkImportFenceFdInfoKHR(m_state, (VkImportFenceFdInfoKHR*)(pImportFenceFdInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkImportFenceFdKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pImportFenceFdInfo);
                }
                VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
                vkImportFenceFdKHR_VkResult_return = vk->vkImportFenceFdKHR(unboxed_device, pImportFenceFdInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportFenceFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkImportFenceFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkImportFenceFdKHR_VkResult_return, device, pImportFenceFdInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetFenceFdKHR:
            {
                android::base::beginTrace("vkGetFenceFdKHR decode");
                VkDevice device;
                const VkFenceGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkFenceGetFdInfoKHR));
                reservedunmarshal_VkFenceGetFdInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFenceGetFdInfoKHR*)(pGetFdInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                memcpy((int*)pFd, *readStreamPtrPtr, sizeof(int));
                *readStreamPtrPtr += sizeof(int);
                if (pGetFdInfo)
                {
                    transform_tohost_VkFenceGetFdInfoKHR(m_state, (VkFenceGetFdInfoKHR*)(pGetFdInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetFenceFdKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetFdInfo, (unsigned long long)pFd);
                }
                VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
                vkGetFenceFdKHR_VkResult_return = vk->vkGetFenceFdKHR(unboxed_device, pGetFdInfo, pFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetFenceFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetFenceFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetFenceFdKHR_VkResult_return, device, pGetFdInfo, pFd);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_performance_query
            case OP_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR:
            {
                android::base::beginTrace("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                uint32_t* pCounterCount;
                VkPerformanceCounterKHR* pCounters;
                VkPerformanceCounterDescriptionKHR* pCounterDescriptions;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for pCounterCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pCounterCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCounterCount);
                *readStreamPtrPtr += 8;
                if (pCounterCount)
                {
                    vkReadStream->alloc((void**)&pCounterCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pCounterCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pCounters;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPerformanceCounterKHR**)&pCounters, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCounters);
                *readStreamPtrPtr += 8;
                if (pCounters)
                {
                    vkReadStream->alloc((void**)&pCounters, (*(pCounterCount)) * sizeof(VkPerformanceCounterKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
                    {
                        reservedunmarshal_VkPerformanceCounterKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceCounterKHR*)(pCounters + i), readStreamPtrPtr);
                    }
                }
                // Begin manual dispatchable handle unboxing for pCounterDescriptions;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPerformanceCounterDescriptionKHR**)&pCounterDescriptions, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCounterDescriptions);
                *readStreamPtrPtr += 8;
                if (pCounterDescriptions)
                {
                    vkReadStream->alloc((void**)&pCounterDescriptions, (*(pCounterCount)) * sizeof(VkPerformanceCounterDescriptionKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
                    {
                        reservedunmarshal_VkPerformanceCounterDescriptionKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceCounterDescriptionKHR*)(pCounterDescriptions + i), readStreamPtrPtr);
                    }
                }
                if (pCounterCount)
                {
                    if (pCounters)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
                        {
                            transform_tohost_VkPerformanceCounterKHR(m_state, (VkPerformanceCounterKHR*)(pCounters + i));
                        }
                    }
                }
                if (pCounterCount)
                {
                    if (pCounterDescriptions)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
                        {
                            transform_tohost_VkPerformanceCounterDescriptionKHR(m_state, (VkPerformanceCounterDescriptionKHR*)(pCounterDescriptions + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)pCounterCount, (unsigned long long)pCounters, (unsigned long long)pCounterDescriptions);
                }
                VkResult vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR_VkResult_return = vk->vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(unboxed_physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pCounterCount;
                vkStream->putBe64(cgen_var_4);
                if (pCounterCount)
                {
                    vkStream->write((uint32_t*)pCounterCount, sizeof(uint32_t));
                }
                if (pCounterCount)
                {
                    if (pCounters)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
                        {
                            transform_fromhost_VkPerformanceCounterKHR(m_state, (VkPerformanceCounterKHR*)(pCounters + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_5 = (uint64_t)(uintptr_t)pCounters;
                vkStream->putBe64(cgen_var_5);
                if (pCounters)
                {
                    if (pCounterCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
                        {
                            marshal_VkPerformanceCounterKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceCounterKHR*)(pCounters + i));
                        }
                    }
                }
                if (pCounterCount)
                {
                    if (pCounterDescriptions)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
                        {
                            transform_fromhost_VkPerformanceCounterDescriptionKHR(m_state, (VkPerformanceCounterDescriptionKHR*)(pCounterDescriptions + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_6 = (uint64_t)(uintptr_t)pCounterDescriptions;
                vkStream->putBe64(cgen_var_6);
                if (pCounterDescriptions)
                {
                    if (pCounterCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
                        {
                            marshal_VkPerformanceCounterDescriptionKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceCounterDescriptionKHR*)(pCounterDescriptions + i));
                        }
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR_VkResult_return, physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR decode");
                VkPhysicalDevice physicalDevice;
                const VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo;
                uint32_t* pNumPasses;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pPerformanceQueryCreateInfo, sizeof(const VkQueryPoolPerformanceCreateInfoKHR));
                reservedunmarshal_VkQueryPoolPerformanceCreateInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueryPoolPerformanceCreateInfoKHR*)(pPerformanceQueryCreateInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pNumPasses;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pNumPasses, sizeof(uint32_t));
                memcpy((uint32_t*)pNumPasses, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (pPerformanceQueryCreateInfo)
                {
                    transform_tohost_VkQueryPoolPerformanceCreateInfoKHR(m_state, (VkQueryPoolPerformanceCreateInfoKHR*)(pPerformanceQueryCreateInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPerformanceQueryCreateInfo, (unsigned long long)pNumPasses);
                }
                vk->vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(unboxed_physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
                vkStream->unsetHandleMapping();
                vkStream->write((uint32_t*)pNumPasses, sizeof(uint32_t));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkAcquireProfilingLockKHR:
            {
                android::base::beginTrace("vkAcquireProfilingLockKHR decode");
                VkDevice device;
                const VkAcquireProfilingLockInfoKHR* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkAcquireProfilingLockInfoKHR));
                reservedunmarshal_VkAcquireProfilingLockInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAcquireProfilingLockInfoKHR*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkAcquireProfilingLockInfoKHR(m_state, (VkAcquireProfilingLockInfoKHR*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAcquireProfilingLockKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo);
                }
                VkResult vkAcquireProfilingLockKHR_VkResult_return = (VkResult)0;
                vkAcquireProfilingLockKHR_VkResult_return = vk->vkAcquireProfilingLockKHR(unboxed_device, pInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkAcquireProfilingLockKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquireProfilingLockKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquireProfilingLockKHR_VkResult_return, device, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkReleaseProfilingLockKHR:
            {
                android::base::beginTrace("vkReleaseProfilingLockKHR decode");
                VkDevice device;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkReleaseProfilingLockKHR 0x%llx \n", ioStream, (unsigned long long)device);
                }
                vk->vkReleaseProfilingLockKHR(unboxed_device);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkReleaseProfilingLockKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
            case OP_vkGetPhysicalDeviceSurfaceCapabilities2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfaceCapabilities2KHR decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
                VkSurfaceCapabilities2KHR* pSurfaceCapabilities;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
                reservedunmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pSurfaceCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilities2KHR));
                reservedunmarshal_VkSurfaceCapabilities2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities), readStreamPtrPtr);
                if (pSurfaceInfo)
                {
                    transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(m_state, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                }
                if (pSurfaceCapabilities)
                {
                    transform_tohost_VkSurfaceCapabilities2KHR(m_state, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfaceCapabilities2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pSurfaceInfo, (unsigned long long)pSurfaceCapabilities);
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceCapabilities2KHR(unboxed_physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
                vkStream->unsetHandleMapping();
                if (pSurfaceCapabilities)
                {
                    transform_fromhost_VkSurfaceCapabilities2KHR(m_state, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                }
                marshal_VkSurfaceCapabilities2KHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceCapabilities2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceFormats2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfaceFormats2KHR decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
                uint32_t* pSurfaceFormatCount;
                VkSurfaceFormat2KHR* pSurfaceFormats;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
                reservedunmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pSurfaceFormatCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pSurfaceFormatCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSurfaceFormatCount);
                *readStreamPtrPtr += 8;
                if (pSurfaceFormatCount)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormatCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pSurfaceFormatCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pSurfaceFormats;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSurfaceFormat2KHR**)&pSurfaceFormats, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSurfaceFormats);
                *readStreamPtrPtr += 8;
                if (pSurfaceFormats)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormats, (*(pSurfaceFormatCount)) * sizeof(VkSurfaceFormat2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        reservedunmarshal_VkSurfaceFormat2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i), readStreamPtrPtr);
                    }
                }
                if (pSurfaceInfo)
                {
                    transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(m_state, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                }
                if (pSurfaceFormatCount)
                {
                    if (pSurfaceFormats)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                        {
                            transform_tohost_VkSurfaceFormat2KHR(m_state, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfaceFormats2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pSurfaceInfo, (unsigned long long)pSurfaceFormatCount, (unsigned long long)pSurfaceFormats);
                }
                VkResult vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceFormats2KHR(unboxed_physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
                vkStream->putBe64(cgen_var_3);
                if (pSurfaceFormatCount)
                {
                    vkStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                if (pSurfaceFormatCount)
                {
                    if (pSurfaceFormats)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                        {
                            transform_fromhost_VkSurfaceFormat2KHR(m_state, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pSurfaceFormats;
                vkStream->putBe64(cgen_var_4);
                if (pSurfaceFormats)
                {
                    if (pSurfaceFormatCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                        {
                            marshal_VkSurfaceFormat2KHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                        }
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceFormats2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
            case OP_vkGetPhysicalDeviceDisplayProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceDisplayProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayProperties2KHR* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDisplayProperties2KHR**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkDisplayProperties2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayProperties2KHR*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_tohost_VkDisplayProperties2KHR(m_state, (VkDisplayProperties2KHR*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceDisplayProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayProperties2KHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_3);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_fromhost_VkDisplayProperties2KHR(m_state, (VkDisplayProperties2KHR*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_4);
                if (pProperties)
                {
                    if (pPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            marshal_VkDisplayProperties2KHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayProperties2KHR*)(pProperties + i));
                        }
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceDisplayProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceDisplayPlaneProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPlaneProperties2KHR* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDisplayPlaneProperties2KHR**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPlaneProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkDisplayPlaneProperties2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneProperties2KHR*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_tohost_VkDisplayPlaneProperties2KHR(m_state, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceDisplayPlaneProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayPlaneProperties2KHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_3);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_fromhost_VkDisplayPlaneProperties2KHR(m_state, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_4);
                if (pProperties)
                {
                    if (pPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            marshal_VkDisplayPlaneProperties2KHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                        }
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceDisplayPlaneProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDisplayModeProperties2KHR:
            {
                android::base::beginTrace("vkGetDisplayModeProperties2KHR decode");
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                uint32_t* pPropertyCount;
                VkDisplayModeProperties2KHR* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayKHR*)&display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDisplayModeProperties2KHR**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayModeProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkDisplayModeProperties2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayModeProperties2KHR*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_tohost_VkDisplayModeProperties2KHR(m_state, (VkDisplayModeProperties2KHR*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDisplayModeProperties2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)display, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetDisplayModeProperties2KHR_VkResult_return = (VkResult)0;
                vkGetDisplayModeProperties2KHR_VkResult_return = vk->vkGetDisplayModeProperties2KHR(unboxed_physicalDevice, display, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_4);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_fromhost_VkDisplayModeProperties2KHR(m_state, (VkDisplayModeProperties2KHR*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_5 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_5);
                if (pProperties)
                {
                    if (pPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            marshal_VkDisplayModeProperties2KHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayModeProperties2KHR*)(pProperties + i));
                        }
                    }
                }
                vkStream->write(&vkGetDisplayModeProperties2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayModeProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayModeProperties2KHR_VkResult_return, physicalDevice, display, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDisplayPlaneCapabilities2KHR:
            {
                android::base::beginTrace("vkGetDisplayPlaneCapabilities2KHR decode");
                VkPhysicalDevice physicalDevice;
                const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo;
                VkDisplayPlaneCapabilities2KHR* pCapabilities;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pDisplayPlaneInfo, sizeof(const VkDisplayPlaneInfo2KHR));
                reservedunmarshal_VkDisplayPlaneInfo2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneInfo2KHR*)(pDisplayPlaneInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCapabilities, sizeof(VkDisplayPlaneCapabilities2KHR));
                reservedunmarshal_VkDisplayPlaneCapabilities2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities), readStreamPtrPtr);
                if (pDisplayPlaneInfo)
                {
                    transform_tohost_VkDisplayPlaneInfo2KHR(m_state, (VkDisplayPlaneInfo2KHR*)(pDisplayPlaneInfo));
                }
                if (pCapabilities)
                {
                    transform_tohost_VkDisplayPlaneCapabilities2KHR(m_state, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDisplayPlaneCapabilities2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pDisplayPlaneInfo, (unsigned long long)pCapabilities);
                }
                VkResult vkGetDisplayPlaneCapabilities2KHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneCapabilities2KHR_VkResult_return = vk->vkGetDisplayPlaneCapabilities2KHR(unboxed_physicalDevice, pDisplayPlaneInfo, pCapabilities);
                vkStream->unsetHandleMapping();
                if (pCapabilities)
                {
                    transform_fromhost_VkDisplayPlaneCapabilities2KHR(m_state, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                }
                marshal_VkDisplayPlaneCapabilities2KHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                vkStream->write(&vkGetDisplayPlaneCapabilities2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayPlaneCapabilities2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayPlaneCapabilities2KHR_VkResult_return, physicalDevice, pDisplayPlaneInfo, pCapabilities);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
            case OP_vkGetImageMemoryRequirements2KHR:
            {
                android::base::beginTrace("vkGetImageMemoryRequirements2KHR decode");
                VkDevice device;
                const VkImageMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
                reservedunmarshal_VkImageMemoryRequirementsInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageMemoryRequirementsInfo2*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                reservedunmarshal_VkMemoryRequirements2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkImageMemoryRequirementsInfo2(m_state, (VkImageMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageMemoryRequirements2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pMemoryRequirements);
                }
                m_state->on_vkGetImageMemoryRequirements2KHR(&m_pool, device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageMemoryRequirements2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetBufferMemoryRequirements2KHR:
            {
                android::base::beginTrace("vkGetBufferMemoryRequirements2KHR decode");
                VkDevice device;
                const VkBufferMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
                reservedunmarshal_VkBufferMemoryRequirementsInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferMemoryRequirementsInfo2*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                reservedunmarshal_VkMemoryRequirements2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkBufferMemoryRequirementsInfo2(m_state, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetBufferMemoryRequirements2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pMemoryRequirements);
                }
                vk->vkGetBufferMemoryRequirements2KHR(unboxed_device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetBufferMemoryRequirements2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements2KHR:
            {
                android::base::beginTrace("vkGetImageSparseMemoryRequirements2KHR decode");
                VkDevice device;
                const VkImageSparseMemoryRequirementsInfo2* pInfo;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageSparseMemoryRequirementsInfo2));
                reservedunmarshal_VkImageSparseMemoryRequirementsInfo2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSparseMemoryRequirementsInfo2*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pSparseMemoryRequirementCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSparseMemoryRequirementCount);
                *readStreamPtrPtr += 8;
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pSparseMemoryRequirementCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkSparseImageMemoryRequirements2**)&pSparseMemoryRequirements, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSparseMemoryRequirements);
                *readStreamPtrPtr += 8;
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        reservedunmarshal_VkSparseImageMemoryRequirements2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i), readStreamPtrPtr);
                    }
                }
                if (pInfo)
                {
                    transform_tohost_VkImageSparseMemoryRequirementsInfo2(m_state, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                }
                if (pSparseMemoryRequirementCount)
                {
                    if (pSparseMemoryRequirements)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                        {
                            transform_tohost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageSparseMemoryRequirements2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pSparseMemoryRequirementCount, (unsigned long long)pSparseMemoryRequirements);
                }
                vk->vkGetImageSparseMemoryRequirements2KHR(unboxed_device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_3);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                if (pSparseMemoryRequirementCount)
                {
                    if (pSparseMemoryRequirements)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                        {
                            transform_fromhost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_4);
                if (pSparseMemoryRequirements)
                {
                    if (pSparseMemoryRequirementCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                        {
                            marshal_VkSparseImageMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                        }
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageSparseMemoryRequirements2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
            case OP_vkCreateSamplerYcbcrConversionKHR:
            {
                android::base::beginTrace("vkCreateSamplerYcbcrConversionKHR decode");
                VkDevice device;
                const VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSamplerYcbcrConversion* pYcbcrConversion;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerYcbcrConversionCreateInfo));
                reservedunmarshal_VkSamplerYcbcrConversionCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pYcbcrConversion;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSamplerYcbcrConversion*)pYcbcrConversion = (VkSamplerYcbcrConversion)(VkSamplerYcbcrConversion)((VkSamplerYcbcrConversion)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkSamplerYcbcrConversionCreateInfo(m_state, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateSamplerYcbcrConversionKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pYcbcrConversion);
                }
                VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
                vkCreateSamplerYcbcrConversionKHR_VkResult_return = vk->vkCreateSamplerYcbcrConversionKHR(unboxed_device, pCreateInfo, pAllocator, pYcbcrConversion);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                if (vkCreateSamplerYcbcrConversionKHR_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkSamplerYcbcrConversion), "handle map overwrite requres VkSamplerYcbcrConversion to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
                vkStream->write((VkSamplerYcbcrConversion*)pYcbcrConversion, 8 * 1);
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSamplerYcbcrConversionKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSamplerYcbcrConversionKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSamplerYcbcrConversionKHR_VkResult_return, device, pCreateInfo, pAllocator, pYcbcrConversion);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroySamplerYcbcrConversionKHR:
            {
                android::base::beginTrace("vkDestroySamplerYcbcrConversionKHR decode");
                VkDevice device;
                VkSamplerYcbcrConversion ycbcrConversion;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for ycbcrConversion;
                VkSamplerYcbcrConversion boxed_ycbcrConversion_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSamplerYcbcrConversion*)&ycbcrConversion = (VkSamplerYcbcrConversion)(VkSamplerYcbcrConversion)((VkSamplerYcbcrConversion)(*&cgen_var_1));
                boxed_ycbcrConversion_preserve = ycbcrConversion;
                ycbcrConversion = unbox_VkSamplerYcbcrConversion(ycbcrConversion);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroySamplerYcbcrConversionKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)ycbcrConversion, (unsigned long long)pAllocator);
                }
                vk->vkDestroySamplerYcbcrConversionKHR(unboxed_device, ycbcrConversion, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySamplerYcbcrConversionKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_ycbcrConversion_preserve, pAllocator);
                }
                delete_VkSamplerYcbcrConversion(boxed_ycbcrConversion_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_bind_memory2
            case OP_vkBindBufferMemory2KHR:
            {
                android::base::beginTrace("vkBindBufferMemory2KHR decode");
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindBufferMemoryInfo* pBindInfos;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    reservedunmarshal_VkBindBufferMemoryInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindBufferMemoryInfo*)(pBindInfos + i), readStreamPtrPtr);
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindBufferMemoryInfo(m_state, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBindBufferMemory2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfos);
                }
                VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
                vkBindBufferMemory2KHR_VkResult_return = m_state->on_vkBindBufferMemory2KHR(&m_pool, device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindBufferMemory2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindBufferMemory2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindBufferMemory2KHR_VkResult_return, device, bindInfoCount, pBindInfos);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBindImageMemory2KHR:
            {
                android::base::beginTrace("vkBindImageMemory2KHR decode");
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindImageMemoryInfo* pBindInfos;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    reservedunmarshal_VkBindImageMemoryInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindImageMemoryInfo*)(pBindInfos + i), readStreamPtrPtr);
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindImageMemoryInfo(m_state, (VkBindImageMemoryInfo*)(pBindInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBindImageMemory2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfos);
                }
                VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
                vkBindImageMemory2KHR_VkResult_return = vk->vkBindImageMemory2KHR(unboxed_device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindImageMemory2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindImageMemory2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindImageMemory2KHR_VkResult_return, device, bindInfoCount, pBindInfos);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_portability_subset
#endif
#ifdef VK_KHR_maintenance3
            case OP_vkGetDescriptorSetLayoutSupportKHR:
            {
                android::base::beginTrace("vkGetDescriptorSetLayoutSupportKHR decode");
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                VkDescriptorSetLayoutSupport* pSupport;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                reservedunmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pSupport;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSupport, sizeof(VkDescriptorSetLayoutSupport));
                reservedunmarshal_VkDescriptorSetLayoutSupport(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutSupport*)(pSupport), readStreamPtrPtr);
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorSetLayoutCreateInfo(m_state, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                }
                if (pSupport)
                {
                    transform_tohost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDescriptorSetLayoutSupportKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pSupport);
                }
                vk->vkGetDescriptorSetLayoutSupportKHR(unboxed_device, pCreateInfo, pSupport);
                vkStream->unsetHandleMapping();
                if (pSupport)
                {
                    transform_fromhost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                marshal_VkDescriptorSetLayoutSupport(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDescriptorSetLayoutSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pCreateInfo, pSupport);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_draw_indirect_count
            case OP_vkCmdDrawIndirectCountKHR:
            {
                android::base::beginTrace("vkCmdDrawIndirectCountKHR decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&countBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_2));
                memcpy((VkDeviceSize*)&countBufferOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&maxDrawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndirectCountKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndirectCountKHR(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndirectCountKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDrawIndexedIndirectCountKHR:
            {
                android::base::beginTrace("vkCmdDrawIndexedIndirectCountKHR decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&countBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_2));
                memcpy((VkDeviceSize*)&countBufferOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&maxDrawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndexedIndirectCountKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndexedIndirectCountKHR(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndexedIndirectCountKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_shader_subgroup_extended_types
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_KHR_shader_atomic_int64
#endif
#ifdef VK_KHR_shader_clock
#endif
#ifdef VK_KHR_driver_properties
#endif
#ifdef VK_KHR_shader_float_controls
#endif
#ifdef VK_KHR_depth_stencil_resolve
#endif
#ifdef VK_KHR_swapchain_mutable_format
#endif
#ifdef VK_KHR_timeline_semaphore
            case OP_vkGetSemaphoreCounterValueKHR:
            {
                android::base::beginTrace("vkGetSemaphoreCounterValueKHR decode");
                VkDevice device;
                VkSemaphore semaphore;
                uint64_t* pValue;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSemaphore*)&semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pValue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pValue, sizeof(uint64_t));
                memcpy((uint64_t*)pValue, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetSemaphoreCounterValueKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)semaphore, (unsigned long long)pValue);
                }
                VkResult vkGetSemaphoreCounterValueKHR_VkResult_return = (VkResult)0;
                vkGetSemaphoreCounterValueKHR_VkResult_return = vk->vkGetSemaphoreCounterValueKHR(unboxed_device, semaphore, pValue);
                vkStream->unsetHandleMapping();
                vkStream->write((uint64_t*)pValue, sizeof(uint64_t));
                vkStream->write(&vkGetSemaphoreCounterValueKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSemaphoreCounterValueKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSemaphoreCounterValueKHR_VkResult_return, device, semaphore, pValue);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkWaitSemaphoresKHR:
            {
                android::base::beginTrace("vkWaitSemaphoresKHR decode");
                VkDevice device;
                const VkSemaphoreWaitInfo* pWaitInfo;
                uint64_t timeout;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pWaitInfo, sizeof(const VkSemaphoreWaitInfo));
                reservedunmarshal_VkSemaphoreWaitInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreWaitInfo*)(pWaitInfo), readStreamPtrPtr);
                memcpy((uint64_t*)&timeout, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                if (pWaitInfo)
                {
                    transform_tohost_VkSemaphoreWaitInfo(m_state, (VkSemaphoreWaitInfo*)(pWaitInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkWaitSemaphoresKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pWaitInfo, (unsigned long long)timeout);
                }
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                VkResult vkWaitSemaphoresKHR_VkResult_return = (VkResult)0;
                vkWaitSemaphoresKHR_VkResult_return = vk->vkWaitSemaphoresKHR(unboxed_device, pWaitInfo, timeout);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkWaitSemaphoresKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkWaitSemaphoresKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkWaitSemaphoresKHR_VkResult_return, device, pWaitInfo, timeout);
                }
                vkReadStream->clearPool();
                android::base::endTrace();
                break;
            }
            case OP_vkSignalSemaphoreKHR:
            {
                android::base::beginTrace("vkSignalSemaphoreKHR decode");
                VkDevice device;
                const VkSemaphoreSignalInfo* pSignalInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pSignalInfo, sizeof(const VkSemaphoreSignalInfo));
                reservedunmarshal_VkSemaphoreSignalInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreSignalInfo*)(pSignalInfo), readStreamPtrPtr);
                if (pSignalInfo)
                {
                    transform_tohost_VkSemaphoreSignalInfo(m_state, (VkSemaphoreSignalInfo*)(pSignalInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSignalSemaphoreKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pSignalInfo);
                }
                VkResult vkSignalSemaphoreKHR_VkResult_return = (VkResult)0;
                vkSignalSemaphoreKHR_VkResult_return = vk->vkSignalSemaphoreKHR(unboxed_device, pSignalInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSignalSemaphoreKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSignalSemaphoreKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkSignalSemaphoreKHR_VkResult_return, device, pSignalInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_vulkan_memory_model
#endif
#ifdef VK_KHR_shader_terminate_invocation
#endif
#ifdef VK_KHR_fragment_shading_rate
            case OP_vkGetPhysicalDeviceFragmentShadingRatesKHR:
            {
                android::base::beginTrace("vkGetPhysicalDeviceFragmentShadingRatesKHR decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pFragmentShadingRateCount;
                VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pFragmentShadingRateCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pFragmentShadingRateCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pFragmentShadingRateCount);
                *readStreamPtrPtr += 8;
                if (pFragmentShadingRateCount)
                {
                    vkReadStream->alloc((void**)&pFragmentShadingRateCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pFragmentShadingRateCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pFragmentShadingRates;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPhysicalDeviceFragmentShadingRateKHR**)&pFragmentShadingRates, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pFragmentShadingRates);
                *readStreamPtrPtr += 8;
                if (pFragmentShadingRates)
                {
                    vkReadStream->alloc((void**)&pFragmentShadingRates, (*(pFragmentShadingRateCount)) * sizeof(VkPhysicalDeviceFragmentShadingRateKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pFragmentShadingRateCount)); ++i)
                    {
                        reservedunmarshal_VkPhysicalDeviceFragmentShadingRateKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFragmentShadingRateKHR*)(pFragmentShadingRates + i), readStreamPtrPtr);
                    }
                }
                if (pFragmentShadingRateCount)
                {
                    if (pFragmentShadingRates)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pFragmentShadingRateCount)); ++i)
                        {
                            transform_tohost_VkPhysicalDeviceFragmentShadingRateKHR(m_state, (VkPhysicalDeviceFragmentShadingRateKHR*)(pFragmentShadingRates + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceFragmentShadingRatesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFragmentShadingRateCount, (unsigned long long)pFragmentShadingRates);
                }
                VkResult vkGetPhysicalDeviceFragmentShadingRatesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceFragmentShadingRatesKHR_VkResult_return = vk->vkGetPhysicalDeviceFragmentShadingRatesKHR(unboxed_physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pFragmentShadingRateCount;
                vkStream->putBe64(cgen_var_3);
                if (pFragmentShadingRateCount)
                {
                    vkStream->write((uint32_t*)pFragmentShadingRateCount, sizeof(uint32_t));
                }
                if (pFragmentShadingRateCount)
                {
                    if (pFragmentShadingRates)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pFragmentShadingRateCount)); ++i)
                        {
                            transform_fromhost_VkPhysicalDeviceFragmentShadingRateKHR(m_state, (VkPhysicalDeviceFragmentShadingRateKHR*)(pFragmentShadingRates + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pFragmentShadingRates;
                vkStream->putBe64(cgen_var_4);
                if (pFragmentShadingRates)
                {
                    if (pFragmentShadingRateCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pFragmentShadingRateCount)); ++i)
                        {
                            marshal_VkPhysicalDeviceFragmentShadingRateKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFragmentShadingRateKHR*)(pFragmentShadingRates + i));
                        }
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceFragmentShadingRatesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFragmentShadingRatesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceFragmentShadingRatesKHR_VkResult_return, physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetFragmentShadingRateKHR:
            {
                android::base::beginTrace("vkCmdSetFragmentShadingRateKHR decode");
                VkCommandBuffer commandBuffer;
                const VkExtent2D* pFragmentSize;
                VkFragmentShadingRateCombinerOpKHR combinerOps[2];
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pFragmentSize, sizeof(const VkExtent2D));
                reservedunmarshal_VkExtent2D(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtent2D*)(pFragmentSize), readStreamPtrPtr);
                memcpy((VkFragmentShadingRateCombinerOpKHR*)combinerOps, *readStreamPtrPtr, 2 * sizeof(const VkFragmentShadingRateCombinerOpKHR));
                *readStreamPtrPtr += 2 * sizeof(const VkFragmentShadingRateCombinerOpKHR);
                if (pFragmentSize)
                {
                    transform_tohost_VkExtent2D(m_state, (VkExtent2D*)(pFragmentSize));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetFragmentShadingRateKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pFragmentSize, (unsigned long long)combinerOps);
                }
                vk->vkCmdSetFragmentShadingRateKHR(unboxed_commandBuffer, pFragmentSize, combinerOps);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetFragmentShadingRateKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pFragmentSize, combinerOps);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_spirv_1_4
#endif
#ifdef VK_KHR_surface_protected_capabilities
#endif
#ifdef VK_KHR_separate_depth_stencil_layouts
#endif
#ifdef VK_KHR_uniform_buffer_standard_layout
#endif
#ifdef VK_KHR_buffer_device_address
            case OP_vkGetBufferDeviceAddressKHR:
            {
                android::base::beginTrace("vkGetBufferDeviceAddressKHR decode");
                VkDevice device;
                const VkBufferDeviceAddressInfo* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferDeviceAddressInfo));
                reservedunmarshal_VkBufferDeviceAddressInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkBufferDeviceAddressInfo(m_state, (VkBufferDeviceAddressInfo*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetBufferDeviceAddressKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo);
                }
                VkDeviceAddress vkGetBufferDeviceAddressKHR_VkDeviceAddress_return = (VkDeviceAddress)0;
                vkGetBufferDeviceAddressKHR_VkDeviceAddress_return = vk->vkGetBufferDeviceAddressKHR(unboxed_device, pInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetBufferDeviceAddressKHR_VkDeviceAddress_return, sizeof(VkDeviceAddress));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetBufferDeviceAddressKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetBufferDeviceAddressKHR_VkDeviceAddress_return, device, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetBufferOpaqueCaptureAddressKHR:
            {
                android::base::beginTrace("vkGetBufferOpaqueCaptureAddressKHR decode");
                VkDevice device;
                const VkBufferDeviceAddressInfo* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferDeviceAddressInfo));
                reservedunmarshal_VkBufferDeviceAddressInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkBufferDeviceAddressInfo(m_state, (VkBufferDeviceAddressInfo*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetBufferOpaqueCaptureAddressKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo);
                }
                uint64_t vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
                vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return = vk->vkGetBufferOpaqueCaptureAddressKHR(unboxed_device, pInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return, sizeof(uint64_t));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetBufferOpaqueCaptureAddressKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return, device, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceMemoryOpaqueCaptureAddressKHR:
            {
                android::base::beginTrace("vkGetDeviceMemoryOpaqueCaptureAddressKHR decode");
                VkDevice device;
                const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkDeviceMemoryOpaqueCaptureAddressInfo));
                reservedunmarshal_VkDeviceMemoryOpaqueCaptureAddressInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceMemoryOpaqueCaptureAddressInfo*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkDeviceMemoryOpaqueCaptureAddressInfo(m_state, (VkDeviceMemoryOpaqueCaptureAddressInfo*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceMemoryOpaqueCaptureAddressKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo);
                }
                uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
                vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return = vk->vkGetDeviceMemoryOpaqueCaptureAddressKHR(unboxed_device, pInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return, sizeof(uint64_t));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceMemoryOpaqueCaptureAddressKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return, device, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_deferred_host_operations
            case OP_vkCreateDeferredOperationKHR:
            {
                android::base::beginTrace("vkCreateDeferredOperationKHR decode");
                VkDevice device;
                const VkAllocationCallbacks* pAllocator;
                VkDeferredOperationKHR* pDeferredOperation;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pDeferredOperation;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDeferredOperation, sizeof(VkDeferredOperationKHR));
                memcpy((VkDeferredOperationKHR*)&(*pDeferredOperation), (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&(*pDeferredOperation));
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDeferredOperationKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAllocator, (unsigned long long)pDeferredOperation);
                }
                VkResult vkCreateDeferredOperationKHR_VkResult_return = (VkResult)0;
                vkCreateDeferredOperationKHR_VkResult_return = vk->vkCreateDeferredOperationKHR(unboxed_device, pAllocator, pDeferredOperation);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3 = (uint64_t)(*pDeferredOperation);
                vkStream->putBe64(cgen_var_3);
                vkStream->write(&vkCreateDeferredOperationKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDeferredOperationKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDeferredOperationKHR_VkResult_return, device, pAllocator, pDeferredOperation);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDeferredOperationKHR:
            {
                android::base::beginTrace("vkDestroyDeferredOperationKHR decode");
                VkDevice device;
                VkDeferredOperationKHR operation;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkDeferredOperationKHR*)&operation, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&operation);
                *readStreamPtrPtr += 8;
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDeferredOperationKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)operation, (unsigned long long)pAllocator);
                }
                vk->vkDestroyDeferredOperationKHR(unboxed_device, operation, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDeferredOperationKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, operation, pAllocator);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeferredOperationMaxConcurrencyKHR:
            {
                android::base::beginTrace("vkGetDeferredOperationMaxConcurrencyKHR decode");
                VkDevice device;
                VkDeferredOperationKHR operation;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkDeferredOperationKHR*)&operation, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&operation);
                *readStreamPtrPtr += 8;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeferredOperationMaxConcurrencyKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)operation);
                }
                uint32_t vkGetDeferredOperationMaxConcurrencyKHR_uint32_t_return = (uint32_t)0;
                vkGetDeferredOperationMaxConcurrencyKHR_uint32_t_return = vk->vkGetDeferredOperationMaxConcurrencyKHR(unboxed_device, operation);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetDeferredOperationMaxConcurrencyKHR_uint32_t_return, sizeof(uint32_t));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeferredOperationMaxConcurrencyKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDeferredOperationMaxConcurrencyKHR_uint32_t_return, device, operation);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeferredOperationResultKHR:
            {
                android::base::beginTrace("vkGetDeferredOperationResultKHR decode");
                VkDevice device;
                VkDeferredOperationKHR operation;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkDeferredOperationKHR*)&operation, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&operation);
                *readStreamPtrPtr += 8;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeferredOperationResultKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)operation);
                }
                VkResult vkGetDeferredOperationResultKHR_VkResult_return = (VkResult)0;
                vkGetDeferredOperationResultKHR_VkResult_return = vk->vkGetDeferredOperationResultKHR(unboxed_device, operation);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetDeferredOperationResultKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeferredOperationResultKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDeferredOperationResultKHR_VkResult_return, device, operation);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDeferredOperationJoinKHR:
            {
                android::base::beginTrace("vkDeferredOperationJoinKHR decode");
                VkDevice device;
                VkDeferredOperationKHR operation;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkDeferredOperationKHR*)&operation, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&operation);
                *readStreamPtrPtr += 8;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDeferredOperationJoinKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)operation);
                }
                VkResult vkDeferredOperationJoinKHR_VkResult_return = (VkResult)0;
                vkDeferredOperationJoinKHR_VkResult_return = vk->vkDeferredOperationJoinKHR(unboxed_device, operation);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDeferredOperationJoinKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDeferredOperationJoinKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkDeferredOperationJoinKHR_VkResult_return, device, operation);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_pipeline_executable_properties
            case OP_vkGetPipelineExecutablePropertiesKHR:
            {
                android::base::beginTrace("vkGetPipelineExecutablePropertiesKHR decode");
                VkDevice device;
                const VkPipelineInfoKHR* pPipelineInfo;
                uint32_t* pExecutableCount;
                VkPipelineExecutablePropertiesKHR* pProperties;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pPipelineInfo, sizeof(const VkPipelineInfoKHR));
                reservedunmarshal_VkPipelineInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineInfoKHR*)(pPipelineInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pExecutableCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pExecutableCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pExecutableCount);
                *readStreamPtrPtr += 8;
                if (pExecutableCount)
                {
                    vkReadStream->alloc((void**)&pExecutableCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pExecutableCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPipelineExecutablePropertiesKHR**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pExecutableCount)) * sizeof(VkPipelineExecutablePropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pExecutableCount)); ++i)
                    {
                        reservedunmarshal_VkPipelineExecutablePropertiesKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutablePropertiesKHR*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPipelineInfo)
                {
                    transform_tohost_VkPipelineInfoKHR(m_state, (VkPipelineInfoKHR*)(pPipelineInfo));
                }
                if (pExecutableCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pExecutableCount)); ++i)
                        {
                            transform_tohost_VkPipelineExecutablePropertiesKHR(m_state, (VkPipelineExecutablePropertiesKHR*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPipelineExecutablePropertiesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pPipelineInfo, (unsigned long long)pExecutableCount, (unsigned long long)pProperties);
                }
                VkResult vkGetPipelineExecutablePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetPipelineExecutablePropertiesKHR_VkResult_return = vk->vkGetPipelineExecutablePropertiesKHR(unboxed_device, pPipelineInfo, pExecutableCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pExecutableCount;
                vkStream->putBe64(cgen_var_3);
                if (pExecutableCount)
                {
                    vkStream->write((uint32_t*)pExecutableCount, sizeof(uint32_t));
                }
                if (pExecutableCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pExecutableCount)); ++i)
                        {
                            transform_fromhost_VkPipelineExecutablePropertiesKHR(m_state, (VkPipelineExecutablePropertiesKHR*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_4);
                if (pProperties)
                {
                    if (pExecutableCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pExecutableCount)); ++i)
                        {
                            marshal_VkPipelineExecutablePropertiesKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutablePropertiesKHR*)(pProperties + i));
                        }
                    }
                }
                vkStream->write(&vkGetPipelineExecutablePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPipelineExecutablePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPipelineExecutablePropertiesKHR_VkResult_return, device, pPipelineInfo, pExecutableCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPipelineExecutableStatisticsKHR:
            {
                android::base::beginTrace("vkGetPipelineExecutableStatisticsKHR decode");
                VkDevice device;
                const VkPipelineExecutableInfoKHR* pExecutableInfo;
                uint32_t* pStatisticCount;
                VkPipelineExecutableStatisticKHR* pStatistics;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pExecutableInfo, sizeof(const VkPipelineExecutableInfoKHR));
                reservedunmarshal_VkPipelineExecutableInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableInfoKHR*)(pExecutableInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pStatisticCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pStatisticCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pStatisticCount);
                *readStreamPtrPtr += 8;
                if (pStatisticCount)
                {
                    vkReadStream->alloc((void**)&pStatisticCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pStatisticCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pStatistics;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPipelineExecutableStatisticKHR**)&pStatistics, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pStatistics);
                *readStreamPtrPtr += 8;
                if (pStatistics)
                {
                    vkReadStream->alloc((void**)&pStatistics, (*(pStatisticCount)) * sizeof(VkPipelineExecutableStatisticKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pStatisticCount)); ++i)
                    {
                        reservedunmarshal_VkPipelineExecutableStatisticKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableStatisticKHR*)(pStatistics + i), readStreamPtrPtr);
                    }
                }
                if (pExecutableInfo)
                {
                    transform_tohost_VkPipelineExecutableInfoKHR(m_state, (VkPipelineExecutableInfoKHR*)(pExecutableInfo));
                }
                if (pStatisticCount)
                {
                    if (pStatistics)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pStatisticCount)); ++i)
                        {
                            transform_tohost_VkPipelineExecutableStatisticKHR(m_state, (VkPipelineExecutableStatisticKHR*)(pStatistics + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPipelineExecutableStatisticsKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pExecutableInfo, (unsigned long long)pStatisticCount, (unsigned long long)pStatistics);
                }
                VkResult vkGetPipelineExecutableStatisticsKHR_VkResult_return = (VkResult)0;
                vkGetPipelineExecutableStatisticsKHR_VkResult_return = vk->vkGetPipelineExecutableStatisticsKHR(unboxed_device, pExecutableInfo, pStatisticCount, pStatistics);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pStatisticCount;
                vkStream->putBe64(cgen_var_3);
                if (pStatisticCount)
                {
                    vkStream->write((uint32_t*)pStatisticCount, sizeof(uint32_t));
                }
                if (pStatisticCount)
                {
                    if (pStatistics)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pStatisticCount)); ++i)
                        {
                            transform_fromhost_VkPipelineExecutableStatisticKHR(m_state, (VkPipelineExecutableStatisticKHR*)(pStatistics + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pStatistics;
                vkStream->putBe64(cgen_var_4);
                if (pStatistics)
                {
                    if (pStatisticCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pStatisticCount)); ++i)
                        {
                            marshal_VkPipelineExecutableStatisticKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableStatisticKHR*)(pStatistics + i));
                        }
                    }
                }
                vkStream->write(&vkGetPipelineExecutableStatisticsKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPipelineExecutableStatisticsKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPipelineExecutableStatisticsKHR_VkResult_return, device, pExecutableInfo, pStatisticCount, pStatistics);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPipelineExecutableInternalRepresentationsKHR:
            {
                android::base::beginTrace("vkGetPipelineExecutableInternalRepresentationsKHR decode");
                VkDevice device;
                const VkPipelineExecutableInfoKHR* pExecutableInfo;
                uint32_t* pInternalRepresentationCount;
                VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pExecutableInfo, sizeof(const VkPipelineExecutableInfoKHR));
                reservedunmarshal_VkPipelineExecutableInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableInfoKHR*)(pExecutableInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pInternalRepresentationCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pInternalRepresentationCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pInternalRepresentationCount);
                *readStreamPtrPtr += 8;
                if (pInternalRepresentationCount)
                {
                    vkReadStream->alloc((void**)&pInternalRepresentationCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pInternalRepresentationCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pInternalRepresentations;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPipelineExecutableInternalRepresentationKHR**)&pInternalRepresentations, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pInternalRepresentations);
                *readStreamPtrPtr += 8;
                if (pInternalRepresentations)
                {
                    vkReadStream->alloc((void**)&pInternalRepresentations, (*(pInternalRepresentationCount)) * sizeof(VkPipelineExecutableInternalRepresentationKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pInternalRepresentationCount)); ++i)
                    {
                        reservedunmarshal_VkPipelineExecutableInternalRepresentationKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableInternalRepresentationKHR*)(pInternalRepresentations + i), readStreamPtrPtr);
                    }
                }
                if (pExecutableInfo)
                {
                    transform_tohost_VkPipelineExecutableInfoKHR(m_state, (VkPipelineExecutableInfoKHR*)(pExecutableInfo));
                }
                if (pInternalRepresentationCount)
                {
                    if (pInternalRepresentations)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pInternalRepresentationCount)); ++i)
                        {
                            transform_tohost_VkPipelineExecutableInternalRepresentationKHR(m_state, (VkPipelineExecutableInternalRepresentationKHR*)(pInternalRepresentations + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPipelineExecutableInternalRepresentationsKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pExecutableInfo, (unsigned long long)pInternalRepresentationCount, (unsigned long long)pInternalRepresentations);
                }
                VkResult vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return = (VkResult)0;
                vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return = vk->vkGetPipelineExecutableInternalRepresentationsKHR(unboxed_device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pInternalRepresentationCount;
                vkStream->putBe64(cgen_var_3);
                if (pInternalRepresentationCount)
                {
                    vkStream->write((uint32_t*)pInternalRepresentationCount, sizeof(uint32_t));
                }
                if (pInternalRepresentationCount)
                {
                    if (pInternalRepresentations)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pInternalRepresentationCount)); ++i)
                        {
                            transform_fromhost_VkPipelineExecutableInternalRepresentationKHR(m_state, (VkPipelineExecutableInternalRepresentationKHR*)(pInternalRepresentations + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pInternalRepresentations;
                vkStream->putBe64(cgen_var_4);
                if (pInternalRepresentations)
                {
                    if (pInternalRepresentationCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pInternalRepresentationCount)); ++i)
                        {
                            marshal_VkPipelineExecutableInternalRepresentationKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableInternalRepresentationKHR*)(pInternalRepresentations + i));
                        }
                    }
                }
                vkStream->write(&vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPipelineExecutableInternalRepresentationsKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return, device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_pipeline_library
#endif
#ifdef VK_KHR_shader_non_semantic_info
#endif
#ifdef VK_KHR_copy_commands2
            case OP_vkCmdCopyBuffer2KHR:
            {
                android::base::beginTrace("vkCmdCopyBuffer2KHR decode");
                VkCommandBuffer commandBuffer;
                const VkCopyBufferInfo2KHR* pCopyBufferInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pCopyBufferInfo, sizeof(const VkCopyBufferInfo2KHR));
                reservedunmarshal_VkCopyBufferInfo2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyBufferInfo2KHR*)(pCopyBufferInfo), readStreamPtrPtr);
                if (pCopyBufferInfo)
                {
                    transform_tohost_VkCopyBufferInfo2KHR(m_state, (VkCopyBufferInfo2KHR*)(pCopyBufferInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyBuffer2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pCopyBufferInfo);
                }
                vk->vkCmdCopyBuffer2KHR(unboxed_commandBuffer, pCopyBufferInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyBuffer2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pCopyBufferInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyImage2KHR:
            {
                android::base::beginTrace("vkCmdCopyImage2KHR decode");
                VkCommandBuffer commandBuffer;
                const VkCopyImageInfo2KHR* pCopyImageInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pCopyImageInfo, sizeof(const VkCopyImageInfo2KHR));
                reservedunmarshal_VkCopyImageInfo2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyImageInfo2KHR*)(pCopyImageInfo), readStreamPtrPtr);
                if (pCopyImageInfo)
                {
                    transform_tohost_VkCopyImageInfo2KHR(m_state, (VkCopyImageInfo2KHR*)(pCopyImageInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyImage2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pCopyImageInfo);
                }
                vk->vkCmdCopyImage2KHR(unboxed_commandBuffer, pCopyImageInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyImage2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pCopyImageInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyBufferToImage2KHR:
            {
                android::base::beginTrace("vkCmdCopyBufferToImage2KHR decode");
                VkCommandBuffer commandBuffer;
                const VkCopyBufferToImageInfo2KHR* pCopyBufferToImageInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pCopyBufferToImageInfo, sizeof(const VkCopyBufferToImageInfo2KHR));
                reservedunmarshal_VkCopyBufferToImageInfo2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyBufferToImageInfo2KHR*)(pCopyBufferToImageInfo), readStreamPtrPtr);
                if (pCopyBufferToImageInfo)
                {
                    transform_tohost_VkCopyBufferToImageInfo2KHR(m_state, (VkCopyBufferToImageInfo2KHR*)(pCopyBufferToImageInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyBufferToImage2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pCopyBufferToImageInfo);
                }
                vk->vkCmdCopyBufferToImage2KHR(unboxed_commandBuffer, pCopyBufferToImageInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyBufferToImage2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pCopyBufferToImageInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyImageToBuffer2KHR:
            {
                android::base::beginTrace("vkCmdCopyImageToBuffer2KHR decode");
                VkCommandBuffer commandBuffer;
                const VkCopyImageToBufferInfo2KHR* pCopyImageToBufferInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pCopyImageToBufferInfo, sizeof(const VkCopyImageToBufferInfo2KHR));
                reservedunmarshal_VkCopyImageToBufferInfo2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyImageToBufferInfo2KHR*)(pCopyImageToBufferInfo), readStreamPtrPtr);
                if (pCopyImageToBufferInfo)
                {
                    transform_tohost_VkCopyImageToBufferInfo2KHR(m_state, (VkCopyImageToBufferInfo2KHR*)(pCopyImageToBufferInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyImageToBuffer2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pCopyImageToBufferInfo);
                }
                vk->vkCmdCopyImageToBuffer2KHR(unboxed_commandBuffer, pCopyImageToBufferInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyImageToBuffer2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pCopyImageToBufferInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBlitImage2KHR:
            {
                android::base::beginTrace("vkCmdBlitImage2KHR decode");
                VkCommandBuffer commandBuffer;
                const VkBlitImageInfo2KHR* pBlitImageInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pBlitImageInfo, sizeof(const VkBlitImageInfo2KHR));
                reservedunmarshal_VkBlitImageInfo2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBlitImageInfo2KHR*)(pBlitImageInfo), readStreamPtrPtr);
                if (pBlitImageInfo)
                {
                    transform_tohost_VkBlitImageInfo2KHR(m_state, (VkBlitImageInfo2KHR*)(pBlitImageInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBlitImage2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pBlitImageInfo);
                }
                vk->vkCmdBlitImage2KHR(unboxed_commandBuffer, pBlitImageInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBlitImage2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pBlitImageInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdResolveImage2KHR:
            {
                android::base::beginTrace("vkCmdResolveImage2KHR decode");
                VkCommandBuffer commandBuffer;
                const VkResolveImageInfo2KHR* pResolveImageInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pResolveImageInfo, sizeof(const VkResolveImageInfo2KHR));
                reservedunmarshal_VkResolveImageInfo2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkResolveImageInfo2KHR*)(pResolveImageInfo), readStreamPtrPtr);
                if (pResolveImageInfo)
                {
                    transform_tohost_VkResolveImageInfo2KHR(m_state, (VkResolveImageInfo2KHR*)(pResolveImageInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdResolveImage2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pResolveImageInfo);
                }
                vk->vkCmdResolveImage2KHR(unboxed_commandBuffer, pResolveImageInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdResolveImage2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pResolveImageInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_ANDROID_native_buffer
            case OP_vkGetSwapchainGrallocUsageANDROID:
            {
                android::base::beginTrace("vkGetSwapchainGrallocUsageANDROID decode");
                VkDevice device;
                VkFormat format;
                VkImageUsageFlags imageUsage;
                int* grallocUsage;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                memcpy((VkImageUsageFlags*)&imageUsage, *readStreamPtrPtr, sizeof(VkImageUsageFlags));
                *readStreamPtrPtr += sizeof(VkImageUsageFlags);
                // Begin manual dispatchable handle unboxing for grallocUsage;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&grallocUsage, sizeof(int));
                memcpy((int*)grallocUsage, *readStreamPtrPtr, sizeof(int));
                *readStreamPtrPtr += sizeof(int);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetSwapchainGrallocUsageANDROID 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)format, (unsigned long long)imageUsage, (unsigned long long)grallocUsage);
                }
                VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
                vkGetSwapchainGrallocUsageANDROID_VkResult_return = m_state->on_vkGetSwapchainGrallocUsageANDROID(&m_pool, device, format, imageUsage, grallocUsage);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)grallocUsage, sizeof(int));
                vkStream->write(&vkGetSwapchainGrallocUsageANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSwapchainGrallocUsageANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSwapchainGrallocUsageANDROID_VkResult_return, device, format, imageUsage, grallocUsage);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkAcquireImageANDROID:
            {
                android::base::beginTrace("vkAcquireImageANDROID decode");
                VkDevice device;
                VkImage image;
                int nativeFenceFd;
                VkSemaphore semaphore;
                VkFence fence;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                memcpy((int*)&nativeFenceFd, *readStreamPtrPtr, sizeof(int));
                *readStreamPtrPtr += sizeof(int);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSemaphore*)&semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_2));
                uint64_t cgen_var_3;
                memcpy((uint64_t*)&cgen_var_3, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_3));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAcquireImageANDROID 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)nativeFenceFd, (unsigned long long)semaphore, (unsigned long long)fence);
                }
                VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
                vkAcquireImageANDROID_VkResult_return = m_state->on_vkAcquireImageANDROID(&m_pool, device, image, nativeFenceFd, semaphore, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkAcquireImageANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquireImageANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquireImageANDROID_VkResult_return, device, image, nativeFenceFd, semaphore, fence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueSignalReleaseImageANDROID:
            {
                android::base::beginTrace("vkQueueSignalReleaseImageANDROID decode");
                VkQueue queue;
                uint32_t waitSemaphoreCount;
                const VkSemaphore* pWaitSemaphores;
                VkImage image;
                int* pNativeFenceFd;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                memcpy((uint32_t*)&waitSemaphoreCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // WARNING PTR CHECK
                memcpy((VkSemaphore**)&pWaitSemaphores, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pWaitSemaphores);
                *readStreamPtrPtr += 8;
                if (pWaitSemaphores)
                {
                    vkReadStream->alloc((void**)&pWaitSemaphores, ((waitSemaphoreCount)) * sizeof(const VkSemaphore));
                    if (((waitSemaphoreCount)))
                    {
                        uint8_t* cgen_var_1_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((waitSemaphoreCount));
                        for (uint32_t k = 0; k < ((waitSemaphoreCount)); ++k)
                        {
                            uint64_t tmpval; memcpy(&tmpval, cgen_var_1_0_ptr + k * 8, sizeof(uint64_t));
                            *(((VkSemaphore*)pWaitSemaphores) + k) = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)tmpval);
                        }
                    }
                }
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_2));
                // Begin manual dispatchable handle unboxing for pNativeFenceFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pNativeFenceFd, sizeof(int));
                memcpy((int*)pNativeFenceFd, *readStreamPtrPtr, sizeof(int));
                *readStreamPtrPtr += sizeof(int);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueSignalReleaseImageANDROID 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)waitSemaphoreCount, (unsigned long long)pWaitSemaphores, (unsigned long long)image, (unsigned long long)pNativeFenceFd);
                }
                VkResult vkQueueSignalReleaseImageANDROID_VkResult_return = (VkResult)0;
                vkQueueSignalReleaseImageANDROID_VkResult_return = m_state->on_vkQueueSignalReleaseImageANDROID(&m_pool, queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pNativeFenceFd, sizeof(int));
                vkStream->write(&vkQueueSignalReleaseImageANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueSignalReleaseImageANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueueSignalReleaseImageANDROID_VkResult_return, queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_debug_report
            case OP_vkCreateDebugReportCallbackEXT:
            {
                android::base::beginTrace("vkCreateDebugReportCallbackEXT decode");
                VkInstance instance;
                const VkDebugReportCallbackCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDebugReportCallbackEXT* pCallback;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDebugReportCallbackCreateInfoEXT));
                reservedunmarshal_VkDebugReportCallbackCreateInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugReportCallbackCreateInfoEXT*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pCallback;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCallback, sizeof(VkDebugReportCallbackEXT));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDebugReportCallbackEXT*)pCallback = (VkDebugReportCallbackEXT)(VkDebugReportCallbackEXT)((VkDebugReportCallbackEXT)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkDebugReportCallbackCreateInfoEXT(m_state, (VkDebugReportCallbackCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDebugReportCallbackEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pCallback);
                }
                VkResult vkCreateDebugReportCallbackEXT_VkResult_return = (VkResult)0;
                vkCreateDebugReportCallbackEXT_VkResult_return = vk->vkCreateDebugReportCallbackEXT(unboxed_instance, pCreateInfo, pAllocator, pCallback);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pCallback;
                if (vkCreateDebugReportCallbackEXT_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkDebugReportCallbackEXT), "handle map overwrite requres VkDebugReportCallbackEXT to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDebugReportCallbackEXT((VkDebugReportCallbackEXT*)pCallback, 1);
                vkStream->write((VkDebugReportCallbackEXT*)pCallback, 8 * 1);
                // Begin auto non dispatchable handle create for pCallback;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDebugReportCallbackEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDebugReportCallbackEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDebugReportCallbackEXT_VkResult_return, instance, pCreateInfo, pAllocator, pCallback);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDebugReportCallbackEXT:
            {
                android::base::beginTrace("vkDestroyDebugReportCallbackEXT decode");
                VkInstance instance;
                VkDebugReportCallbackEXT callback;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual non dispatchable handle destroy unboxing for callback;
                VkDebugReportCallbackEXT boxed_callback_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDebugReportCallbackEXT*)&callback = (VkDebugReportCallbackEXT)(VkDebugReportCallbackEXT)((VkDebugReportCallbackEXT)(*&cgen_var_1));
                boxed_callback_preserve = callback;
                callback = unbox_VkDebugReportCallbackEXT(callback);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDebugReportCallbackEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)callback, (unsigned long long)pAllocator);
                }
                vk->vkDestroyDebugReportCallbackEXT(unboxed_instance, callback, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDebugReportCallbackEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, boxed_callback_preserve, pAllocator);
                }
                delete_VkDebugReportCallbackEXT(boxed_callback_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDebugReportMessageEXT:
            {
                android::base::beginTrace("vkDebugReportMessageEXT decode");
                VkInstance instance;
                VkDebugReportFlagsEXT flags;
                VkDebugReportObjectTypeEXT objectType;
                uint64_t object;
                size_t location;
                int32_t messageCode;
                const char* pLayerPrefix;
                const char* pMessage;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                memcpy((VkDebugReportFlagsEXT*)&flags, *readStreamPtrPtr, sizeof(VkDebugReportFlagsEXT));
                *readStreamPtrPtr += sizeof(VkDebugReportFlagsEXT);
                memcpy((VkDebugReportObjectTypeEXT*)&objectType, *readStreamPtrPtr, sizeof(VkDebugReportObjectTypeEXT));
                *readStreamPtrPtr += sizeof(VkDebugReportObjectTypeEXT);
                memcpy((uint64_t*)&object, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                memcpy((size_t*)&location, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&location);
                *readStreamPtrPtr += 8;
                memcpy((int32_t*)&messageCode, *readStreamPtrPtr, sizeof(int32_t));
                *readStreamPtrPtr += sizeof(int32_t);
                vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pLayerPrefix, readStreamPtrPtr);
                vkReadStream->loadStringInPlaceWithStreamPtr((char**)&pMessage, readStreamPtrPtr);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDebugReportMessageEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)flags, (unsigned long long)objectType, (unsigned long long)object, (unsigned long long)location, (unsigned long long)messageCode, (unsigned long long)pLayerPrefix, (unsigned long long)pMessage);
                }
                vk->vkDebugReportMessageEXT(unboxed_instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDebugReportMessageEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
            case OP_vkDebugMarkerSetObjectTagEXT:
            {
                android::base::beginTrace("vkDebugMarkerSetObjectTagEXT decode");
                VkDevice device;
                const VkDebugMarkerObjectTagInfoEXT* pTagInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pTagInfo, sizeof(const VkDebugMarkerObjectTagInfoEXT));
                reservedunmarshal_VkDebugMarkerObjectTagInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugMarkerObjectTagInfoEXT*)(pTagInfo), readStreamPtrPtr);
                if (pTagInfo)
                {
                    transform_tohost_VkDebugMarkerObjectTagInfoEXT(m_state, (VkDebugMarkerObjectTagInfoEXT*)(pTagInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDebugMarkerSetObjectTagEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pTagInfo);
                }
                VkResult vkDebugMarkerSetObjectTagEXT_VkResult_return = (VkResult)0;
                vkDebugMarkerSetObjectTagEXT_VkResult_return = vk->vkDebugMarkerSetObjectTagEXT(unboxed_device, pTagInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDebugMarkerSetObjectTagEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDebugMarkerSetObjectTagEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkDebugMarkerSetObjectTagEXT_VkResult_return, device, pTagInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDebugMarkerSetObjectNameEXT:
            {
                android::base::beginTrace("vkDebugMarkerSetObjectNameEXT decode");
                VkDevice device;
                const VkDebugMarkerObjectNameInfoEXT* pNameInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pNameInfo, sizeof(const VkDebugMarkerObjectNameInfoEXT));
                reservedunmarshal_VkDebugMarkerObjectNameInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugMarkerObjectNameInfoEXT*)(pNameInfo), readStreamPtrPtr);
                if (pNameInfo)
                {
                    transform_tohost_VkDebugMarkerObjectNameInfoEXT(m_state, (VkDebugMarkerObjectNameInfoEXT*)(pNameInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDebugMarkerSetObjectNameEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pNameInfo);
                }
                VkResult vkDebugMarkerSetObjectNameEXT_VkResult_return = (VkResult)0;
                vkDebugMarkerSetObjectNameEXT_VkResult_return = vk->vkDebugMarkerSetObjectNameEXT(unboxed_device, pNameInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDebugMarkerSetObjectNameEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDebugMarkerSetObjectNameEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkDebugMarkerSetObjectNameEXT_VkResult_return, device, pNameInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDebugMarkerBeginEXT:
            {
                android::base::beginTrace("vkCmdDebugMarkerBeginEXT decode");
                VkCommandBuffer commandBuffer;
                const VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pMarkerInfo, sizeof(const VkDebugMarkerMarkerInfoEXT));
                reservedunmarshal_VkDebugMarkerMarkerInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo), readStreamPtrPtr);
                if (pMarkerInfo)
                {
                    transform_tohost_VkDebugMarkerMarkerInfoEXT(m_state, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDebugMarkerBeginEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pMarkerInfo);
                }
                vk->vkCmdDebugMarkerBeginEXT(unboxed_commandBuffer, pMarkerInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDebugMarkerBeginEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pMarkerInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDebugMarkerEndEXT:
            {
                android::base::beginTrace("vkCmdDebugMarkerEndEXT decode");
                VkCommandBuffer commandBuffer;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDebugMarkerEndEXT 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                vk->vkCmdDebugMarkerEndEXT(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDebugMarkerEndEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDebugMarkerInsertEXT:
            {
                android::base::beginTrace("vkCmdDebugMarkerInsertEXT decode");
                VkCommandBuffer commandBuffer;
                const VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pMarkerInfo, sizeof(const VkDebugMarkerMarkerInfoEXT));
                reservedunmarshal_VkDebugMarkerMarkerInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo), readStreamPtrPtr);
                if (pMarkerInfo)
                {
                    transform_tohost_VkDebugMarkerMarkerInfoEXT(m_state, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDebugMarkerInsertEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pMarkerInfo);
                }
                vk->vkCmdDebugMarkerInsertEXT(unboxed_commandBuffer, pMarkerInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDebugMarkerInsertEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pMarkerInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
#endif
#ifdef VK_EXT_transform_feedback
            case OP_vkCmdBindTransformFeedbackBuffersEXT:
            {
                android::base::beginTrace("vkCmdBindTransformFeedbackBuffersEXT decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstBinding;
                uint32_t bindingCount;
                const VkBuffer* pBuffers;
                const VkDeviceSize* pOffsets;
                const VkDeviceSize* pSizes;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstBinding, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&bindingCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
                if (((bindingCount)))
                {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((bindingCount));
                    for (uint32_t k = 0; k < ((bindingCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkBuffer*)pBuffers) + k) = (VkBuffer)unbox_VkBuffer((VkBuffer)tmpval);
                    }
                }
                vkReadStream->alloc((void**)&pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
                memcpy((VkDeviceSize*)pOffsets, *readStreamPtrPtr, ((bindingCount)) * sizeof(const VkDeviceSize));
                *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                // WARNING PTR CHECK
                memcpy((VkDeviceSize**)&pSizes, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSizes);
                *readStreamPtrPtr += 8;
                if (pSizes)
                {
                    vkReadStream->alloc((void**)&pSizes, ((bindingCount)) * sizeof(const VkDeviceSize));
                    memcpy((VkDeviceSize*)pSizes, *readStreamPtrPtr, ((bindingCount)) * sizeof(const VkDeviceSize));
                    *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBindTransformFeedbackBuffersEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstBinding, (unsigned long long)bindingCount, (unsigned long long)pBuffers, (unsigned long long)pOffsets, (unsigned long long)pSizes);
                }
                vk->vkCmdBindTransformFeedbackBuffersEXT(unboxed_commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindTransformFeedbackBuffersEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBeginTransformFeedbackEXT:
            {
                android::base::beginTrace("vkCmdBeginTransformFeedbackEXT decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstCounterBuffer;
                uint32_t counterBufferCount;
                const VkBuffer* pCounterBuffers;
                const VkDeviceSize* pCounterBufferOffsets;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstCounterBuffer, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&counterBufferCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // WARNING PTR CHECK
                memcpy((VkBuffer**)&pCounterBuffers, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCounterBuffers);
                *readStreamPtrPtr += 8;
                if (pCounterBuffers)
                {
                    vkReadStream->alloc((void**)&pCounterBuffers, ((counterBufferCount)) * sizeof(const VkBuffer));
                    if (((counterBufferCount)))
                    {
                        uint8_t* cgen_var_1_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((counterBufferCount));
                        for (uint32_t k = 0; k < ((counterBufferCount)); ++k)
                        {
                            uint64_t tmpval; memcpy(&tmpval, cgen_var_1_0_ptr + k * 8, sizeof(uint64_t));
                            *(((VkBuffer*)pCounterBuffers) + k) = (VkBuffer)unbox_VkBuffer((VkBuffer)tmpval);
                        }
                    }
                }
                // WARNING PTR CHECK
                memcpy((VkDeviceSize**)&pCounterBufferOffsets, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCounterBufferOffsets);
                *readStreamPtrPtr += 8;
                if (pCounterBufferOffsets)
                {
                    vkReadStream->alloc((void**)&pCounterBufferOffsets, ((counterBufferCount)) * sizeof(const VkDeviceSize));
                    memcpy((VkDeviceSize*)pCounterBufferOffsets, *readStreamPtrPtr, ((counterBufferCount)) * sizeof(const VkDeviceSize));
                    *readStreamPtrPtr += ((counterBufferCount)) * sizeof(const VkDeviceSize);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBeginTransformFeedbackEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstCounterBuffer, (unsigned long long)counterBufferCount, (unsigned long long)pCounterBuffers, (unsigned long long)pCounterBufferOffsets);
                }
                vk->vkCmdBeginTransformFeedbackEXT(unboxed_commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginTransformFeedbackEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdEndTransformFeedbackEXT:
            {
                android::base::beginTrace("vkCmdEndTransformFeedbackEXT decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstCounterBuffer;
                uint32_t counterBufferCount;
                const VkBuffer* pCounterBuffers;
                const VkDeviceSize* pCounterBufferOffsets;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstCounterBuffer, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&counterBufferCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // WARNING PTR CHECK
                memcpy((VkBuffer**)&pCounterBuffers, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCounterBuffers);
                *readStreamPtrPtr += 8;
                if (pCounterBuffers)
                {
                    vkReadStream->alloc((void**)&pCounterBuffers, ((counterBufferCount)) * sizeof(const VkBuffer));
                    if (((counterBufferCount)))
                    {
                        uint8_t* cgen_var_1_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((counterBufferCount));
                        for (uint32_t k = 0; k < ((counterBufferCount)); ++k)
                        {
                            uint64_t tmpval; memcpy(&tmpval, cgen_var_1_0_ptr + k * 8, sizeof(uint64_t));
                            *(((VkBuffer*)pCounterBuffers) + k) = (VkBuffer)unbox_VkBuffer((VkBuffer)tmpval);
                        }
                    }
                }
                // WARNING PTR CHECK
                memcpy((VkDeviceSize**)&pCounterBufferOffsets, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCounterBufferOffsets);
                *readStreamPtrPtr += 8;
                if (pCounterBufferOffsets)
                {
                    vkReadStream->alloc((void**)&pCounterBufferOffsets, ((counterBufferCount)) * sizeof(const VkDeviceSize));
                    memcpy((VkDeviceSize*)pCounterBufferOffsets, *readStreamPtrPtr, ((counterBufferCount)) * sizeof(const VkDeviceSize));
                    *readStreamPtrPtr += ((counterBufferCount)) * sizeof(const VkDeviceSize);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdEndTransformFeedbackEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstCounterBuffer, (unsigned long long)counterBufferCount, (unsigned long long)pCounterBuffers, (unsigned long long)pCounterBufferOffsets);
                }
                vk->vkCmdEndTransformFeedbackEXT(unboxed_commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndTransformFeedbackEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBeginQueryIndexedEXT:
            {
                android::base::beginTrace("vkCmdBeginQueryIndexedEXT decode");
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t query;
                VkQueryControlFlags flags;
                uint32_t index;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_1));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((VkQueryControlFlags*)&flags, *readStreamPtrPtr, sizeof(VkQueryControlFlags));
                *readStreamPtrPtr += sizeof(VkQueryControlFlags);
                memcpy((uint32_t*)&index, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBeginQueryIndexedEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool, (unsigned long long)query, (unsigned long long)flags, (unsigned long long)index);
                }
                vk->vkCmdBeginQueryIndexedEXT(unboxed_commandBuffer, queryPool, query, flags, index);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginQueryIndexedEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool, query, flags, index);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdEndQueryIndexedEXT:
            {
                android::base::beginTrace("vkCmdEndQueryIndexedEXT decode");
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t query;
                uint32_t index;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_1));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&index, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdEndQueryIndexedEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool, (unsigned long long)query, (unsigned long long)index);
                }
                vk->vkCmdEndQueryIndexedEXT(unboxed_commandBuffer, queryPool, query, index);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndQueryIndexedEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool, query, index);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDrawIndirectByteCountEXT:
            {
                android::base::beginTrace("vkCmdDrawIndirectByteCountEXT decode");
                VkCommandBuffer commandBuffer;
                uint32_t instanceCount;
                uint32_t firstInstance;
                VkBuffer counterBuffer;
                VkDeviceSize counterBufferOffset;
                uint32_t counterOffset;
                uint32_t vertexStride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&instanceCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&firstInstance, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&counterBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&counterBufferOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&counterOffset, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&vertexStride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndirectByteCountEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)instanceCount, (unsigned long long)firstInstance, (unsigned long long)counterBuffer, (unsigned long long)counterBufferOffset, (unsigned long long)counterOffset, (unsigned long long)vertexStride);
                }
                vk->vkCmdDrawIndirectByteCountEXT(unboxed_commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndirectByteCountEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NVX_image_view_handle
            case OP_vkGetImageViewHandleNVX:
            {
                android::base::beginTrace("vkGetImageViewHandleNVX decode");
                VkDevice device;
                const VkImageViewHandleInfoNVX* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageViewHandleInfoNVX));
                reservedunmarshal_VkImageViewHandleInfoNVX(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageViewHandleInfoNVX*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkImageViewHandleInfoNVX(m_state, (VkImageViewHandleInfoNVX*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageViewHandleNVX 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo);
                }
                uint32_t vkGetImageViewHandleNVX_uint32_t_return = (uint32_t)0;
                vkGetImageViewHandleNVX_uint32_t_return = vk->vkGetImageViewHandleNVX(unboxed_device, pInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetImageViewHandleNVX_uint32_t_return, sizeof(uint32_t));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageViewHandleNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetImageViewHandleNVX_uint32_t_return, device, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetImageViewAddressNVX:
            {
                android::base::beginTrace("vkGetImageViewAddressNVX decode");
                VkDevice device;
                VkImageView imageView;
                VkImageViewAddressPropertiesNVX* pProperties;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImageView*)&imageView = (VkImageView)unbox_VkImageView((VkImageView)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkImageViewAddressPropertiesNVX));
                reservedunmarshal_VkImageViewAddressPropertiesNVX(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageViewAddressPropertiesNVX*)(pProperties), readStreamPtrPtr);
                if (pProperties)
                {
                    transform_tohost_VkImageViewAddressPropertiesNVX(m_state, (VkImageViewAddressPropertiesNVX*)(pProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageViewAddressNVX 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)imageView, (unsigned long long)pProperties);
                }
                VkResult vkGetImageViewAddressNVX_VkResult_return = (VkResult)0;
                vkGetImageViewAddressNVX_VkResult_return = vk->vkGetImageViewAddressNVX(unboxed_device, imageView, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkImageViewAddressPropertiesNVX(m_state, (VkImageViewAddressPropertiesNVX*)(pProperties));
                }
                marshal_VkImageViewAddressPropertiesNVX(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageViewAddressPropertiesNVX*)(pProperties));
                vkStream->write(&vkGetImageViewAddressNVX_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageViewAddressNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetImageViewAddressNVX_VkResult_return, device, imageView, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_AMD_draw_indirect_count
            case OP_vkCmdDrawIndirectCountAMD:
            {
                android::base::beginTrace("vkCmdDrawIndirectCountAMD decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&countBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_2));
                memcpy((VkDeviceSize*)&countBufferOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&maxDrawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndirectCountAMD 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndirectCountAMD(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndirectCountAMD(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDrawIndexedIndirectCountAMD:
            {
                android::base::beginTrace("vkCmdDrawIndexedIndirectCountAMD decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&countBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_2));
                memcpy((VkDeviceSize*)&countBufferOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&maxDrawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawIndexedIndirectCountAMD 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndexedIndirectCountAMD(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndexedIndirectCountAMD(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
#endif
#ifdef VK_AMD_shader_info
            case OP_vkGetShaderInfoAMD:
            {
                android::base::beginTrace("vkGetShaderInfoAMD decode");
                VkDevice device;
                VkPipeline pipeline;
                VkShaderStageFlagBits shaderStage;
                VkShaderInfoTypeAMD infoType;
                size_t* pInfoSize;
                void* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipeline*)&pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_1));
                memcpy((VkShaderStageFlagBits*)&shaderStage, *readStreamPtrPtr, sizeof(VkShaderStageFlagBits));
                *readStreamPtrPtr += sizeof(VkShaderStageFlagBits);
                memcpy((VkShaderInfoTypeAMD*)&infoType, *readStreamPtrPtr, sizeof(VkShaderInfoTypeAMD));
                *readStreamPtrPtr += sizeof(VkShaderInfoTypeAMD);
                // Begin manual dispatchable handle unboxing for pInfoSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((size_t**)&pInfoSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pInfoSize);
                *readStreamPtrPtr += 8;
                if (pInfoSize)
                {
                    vkReadStream->alloc((void**)&pInfoSize, sizeof(size_t));
                    memcpy((size_t*)&(*pInfoSize), (*readStreamPtrPtr), 8);
                    android::base::Stream::fromBe64((uint8_t*)&(*pInfoSize));
                    *readStreamPtrPtr += 8;
                }
                // Begin manual dispatchable handle unboxing for pInfo;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((void**)&pInfo, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pInfo);
                *readStreamPtrPtr += 8;
                if (pInfo)
                {
                    vkReadStream->alloc((void**)&pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                    memcpy((void*)pInfo, *readStreamPtrPtr, (*(pInfoSize)) * sizeof(uint8_t));
                    *readStreamPtrPtr += (*(pInfoSize)) * sizeof(uint8_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetShaderInfoAMD 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipeline, (unsigned long long)shaderStage, (unsigned long long)infoType, (unsigned long long)pInfoSize, (unsigned long long)pInfo);
                }
                VkResult vkGetShaderInfoAMD_VkResult_return = (VkResult)0;
                vkGetShaderInfoAMD_VkResult_return = vk->vkGetShaderInfoAMD(unboxed_device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pInfoSize;
                vkStream->putBe64(cgen_var_4);
                if (pInfoSize)
                {
                    uint64_t cgen_var_4_0 = (uint64_t)(*pInfoSize);
                    vkStream->putBe64(cgen_var_4_0);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_5 = (uint64_t)(uintptr_t)pInfo;
                vkStream->putBe64(cgen_var_5);
                if (pInfo)
                {
                    vkStream->write((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetShaderInfoAMD_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetShaderInfoAMD(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetShaderInfoAMD_VkResult_return, device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_GGP_stream_descriptor_surface
            case OP_vkCreateStreamDescriptorSurfaceGGP:
            {
                android::base::beginTrace("vkCreateStreamDescriptorSurfaceGGP decode");
                VkInstance instance;
                const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkStreamDescriptorSurfaceCreateInfoGGP));
                reservedunmarshal_VkStreamDescriptorSurfaceCreateInfoGGP(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStreamDescriptorSurfaceCreateInfoGGP*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkStreamDescriptorSurfaceCreateInfoGGP(m_state, (VkStreamDescriptorSurfaceCreateInfoGGP*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateStreamDescriptorSurfaceGGP 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateStreamDescriptorSurfaceGGP_VkResult_return = (VkResult)0;
                vkCreateStreamDescriptorSurfaceGGP_VkResult_return = vk->vkCreateStreamDescriptorSurfaceGGP(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkCreateStreamDescriptorSurfaceGGP_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateStreamDescriptorSurfaceGGP(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateStreamDescriptorSurfaceGGP_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_corner_sampled_image
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
            case OP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV:
            {
                android::base::beginTrace("vkGetPhysicalDeviceExternalImageFormatPropertiesNV decode");
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkImageTiling tiling;
                VkImageUsageFlags usage;
                VkImageCreateFlags flags;
                VkExternalMemoryHandleTypeFlagsNV externalHandleType;
                VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                memcpy((VkImageType*)&type, *readStreamPtrPtr, sizeof(VkImageType));
                *readStreamPtrPtr += sizeof(VkImageType);
                memcpy((VkImageTiling*)&tiling, *readStreamPtrPtr, sizeof(VkImageTiling));
                *readStreamPtrPtr += sizeof(VkImageTiling);
                memcpy((VkImageUsageFlags*)&usage, *readStreamPtrPtr, sizeof(VkImageUsageFlags));
                *readStreamPtrPtr += sizeof(VkImageUsageFlags);
                memcpy((VkImageCreateFlags*)&flags, *readStreamPtrPtr, sizeof(VkImageCreateFlags));
                *readStreamPtrPtr += sizeof(VkImageCreateFlags);
                memcpy((VkExternalMemoryHandleTypeFlagsNV*)&externalHandleType, *readStreamPtrPtr, sizeof(VkExternalMemoryHandleTypeFlagsNV));
                *readStreamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
                // Begin manual dispatchable handle unboxing for pExternalImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalImageFormatProperties, sizeof(VkExternalImageFormatPropertiesNV));
                reservedunmarshal_VkExternalImageFormatPropertiesNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties), readStreamPtrPtr);
                if (pExternalImageFormatProperties)
                {
                    transform_tohost_VkExternalImageFormatPropertiesNV(m_state, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceExternalImageFormatPropertiesNV 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)type, (unsigned long long)tiling, (unsigned long long)usage, (unsigned long long)flags, (unsigned long long)externalHandleType, (unsigned long long)pExternalImageFormatProperties);
                }
                VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = vk->vkGetPhysicalDeviceExternalImageFormatPropertiesNV(unboxed_physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pExternalImageFormatProperties)
                {
                    transform_fromhost_VkExternalImageFormatPropertiesNV(m_state, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                }
                marshal_VkExternalImageFormatPropertiesNV(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalImageFormatPropertiesNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_external_memory
#endif
#ifdef VK_NV_external_memory_win32
            case OP_vkGetMemoryWin32HandleNV:
            {
                android::base::beginTrace("vkGetMemoryWin32HandleNV decode");
                VkDevice device;
                VkDeviceMemory memory;
                VkExternalMemoryHandleTypeFlagsNV handleType;
                HANDLE* pHandle;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_1));
                memcpy((VkExternalMemoryHandleTypeFlagsNV*)&handleType, *readStreamPtrPtr, sizeof(VkExternalMemoryHandleTypeFlagsNV));
                *readStreamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                memcpy((HANDLE*)pHandle, *readStreamPtrPtr, sizeof(HANDLE));
                *readStreamPtrPtr += sizeof(HANDLE);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryWin32HandleNV 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)handleType, (unsigned long long)pHandle);
                }
                VkResult vkGetMemoryWin32HandleNV_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandleNV_VkResult_return = vk->vkGetMemoryWin32HandleNV(unboxed_device, memory, handleType, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetMemoryWin32HandleNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryWin32HandleNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryWin32HandleNV_VkResult_return, device, memory, handleType, pHandle);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_win32_keyed_mutex
#endif
#ifdef VK_EXT_validation_flags
#endif
#ifdef VK_NN_vi_surface
            case OP_vkCreateViSurfaceNN:
            {
                android::base::beginTrace("vkCreateViSurfaceNN decode");
                VkInstance instance;
                const VkViSurfaceCreateInfoNN* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkViSurfaceCreateInfoNN));
                reservedunmarshal_VkViSurfaceCreateInfoNN(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkViSurfaceCreateInfoNN*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkViSurfaceCreateInfoNN(m_state, (VkViSurfaceCreateInfoNN*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateViSurfaceNN 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateViSurfaceNN_VkResult_return = (VkResult)0;
                vkCreateViSurfaceNN_VkResult_return = vk->vkCreateViSurfaceNN(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkCreateViSurfaceNN_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateViSurfaceNN(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateViSurfaceNN_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
#endif
#ifdef VK_EXT_astc_decode_mode
#endif
#ifdef VK_EXT_conditional_rendering
            case OP_vkCmdBeginConditionalRenderingEXT:
            {
                android::base::beginTrace("vkCmdBeginConditionalRenderingEXT decode");
                VkCommandBuffer commandBuffer;
                const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pConditionalRenderingBegin, sizeof(const VkConditionalRenderingBeginInfoEXT));
                reservedunmarshal_VkConditionalRenderingBeginInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkConditionalRenderingBeginInfoEXT*)(pConditionalRenderingBegin), readStreamPtrPtr);
                if (pConditionalRenderingBegin)
                {
                    transform_tohost_VkConditionalRenderingBeginInfoEXT(m_state, (VkConditionalRenderingBeginInfoEXT*)(pConditionalRenderingBegin));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBeginConditionalRenderingEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pConditionalRenderingBegin);
                }
                vk->vkCmdBeginConditionalRenderingEXT(unboxed_commandBuffer, pConditionalRenderingBegin);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginConditionalRenderingEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pConditionalRenderingBegin);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdEndConditionalRenderingEXT:
            {
                android::base::beginTrace("vkCmdEndConditionalRenderingEXT decode");
                VkCommandBuffer commandBuffer;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdEndConditionalRenderingEXT 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                vk->vkCmdEndConditionalRenderingEXT(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndConditionalRenderingEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_clip_space_w_scaling
            case OP_vkCmdSetViewportWScalingNV:
            {
                android::base::beginTrace("vkCmdSetViewportWScalingNV decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstViewport;
                uint32_t viewportCount;
                const VkViewportWScalingNV* pViewportWScalings;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstViewport, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&viewportCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pViewportWScalings, ((viewportCount)) * sizeof(const VkViewportWScalingNV));
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                {
                    reservedunmarshal_VkViewportWScalingNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkViewportWScalingNV*)(pViewportWScalings + i), readStreamPtrPtr);
                }
                if (pViewportWScalings)
                {
                    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                    {
                        transform_tohost_VkViewportWScalingNV(m_state, (VkViewportWScalingNV*)(pViewportWScalings + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetViewportWScalingNV 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstViewport, (unsigned long long)viewportCount, (unsigned long long)pViewportWScalings);
                }
                vk->vkCmdSetViewportWScalingNV(unboxed_commandBuffer, firstViewport, viewportCount, pViewportWScalings);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetViewportWScalingNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstViewport, viewportCount, pViewportWScalings);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_direct_mode_display
            case OP_vkReleaseDisplayEXT:
            {
                android::base::beginTrace("vkReleaseDisplayEXT decode");
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayKHR*)&display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_1));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkReleaseDisplayEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)display);
                }
                VkResult vkReleaseDisplayEXT_VkResult_return = (VkResult)0;
                vkReleaseDisplayEXT_VkResult_return = vk->vkReleaseDisplayEXT(unboxed_physicalDevice, display);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkReleaseDisplayEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkReleaseDisplayEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkReleaseDisplayEXT_VkResult_return, physicalDevice, display);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_acquire_xlib_display
            case OP_vkAcquireXlibDisplayEXT:
            {
                android::base::beginTrace("vkAcquireXlibDisplayEXT decode");
                VkPhysicalDevice physicalDevice;
                Display* dpy;
                VkDisplayKHR display;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for dpy;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                memcpy((Display*)dpy, *readStreamPtrPtr, sizeof(Display));
                *readStreamPtrPtr += sizeof(Display);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayKHR*)&display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_1));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAcquireXlibDisplayEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)dpy, (unsigned long long)display);
                }
                VkResult vkAcquireXlibDisplayEXT_VkResult_return = (VkResult)0;
                vkAcquireXlibDisplayEXT_VkResult_return = vk->vkAcquireXlibDisplayEXT(unboxed_physicalDevice, dpy, display);
                vkStream->unsetHandleMapping();
                vkStream->write((Display*)dpy, sizeof(Display));
                vkStream->write(&vkAcquireXlibDisplayEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquireXlibDisplayEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquireXlibDisplayEXT_VkResult_return, physicalDevice, dpy, display);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetRandROutputDisplayEXT:
            {
                android::base::beginTrace("vkGetRandROutputDisplayEXT decode");
                VkPhysicalDevice physicalDevice;
                Display* dpy;
                RROutput rrOutput;
                VkDisplayKHR* pDisplay;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for dpy;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                memcpy((Display*)dpy, *readStreamPtrPtr, sizeof(Display));
                *readStreamPtrPtr += sizeof(Display);
                memcpy((RROutput*)&rrOutput, *readStreamPtrPtr, sizeof(RROutput));
                *readStreamPtrPtr += sizeof(RROutput);
                // Begin manual dispatchable handle unboxing for pDisplay;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDisplay, sizeof(VkDisplayKHR));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDisplayKHR*)pDisplay = (VkDisplayKHR)(VkDisplayKHR)((VkDisplayKHR)(*&cgen_var_1));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetRandROutputDisplayEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)dpy, (unsigned long long)rrOutput, (unsigned long long)pDisplay);
                }
                VkResult vkGetRandROutputDisplayEXT_VkResult_return = (VkResult)0;
                vkGetRandROutputDisplayEXT_VkResult_return = vk->vkGetRandROutputDisplayEXT(unboxed_physicalDevice, dpy, rrOutput, pDisplay);
                vkStream->unsetHandleMapping();
                vkStream->write((Display*)dpy, sizeof(Display));
                uint64_t cgen_var_2;
                vkStream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplay, &cgen_var_2, 1);
                vkStream->write((uint64_t*)&cgen_var_2, 8);
                vkStream->write(&vkGetRandROutputDisplayEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetRandROutputDisplayEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetRandROutputDisplayEXT_VkResult_return, physicalDevice, dpy, rrOutput, pDisplay);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_display_surface_counter
            case OP_vkGetPhysicalDeviceSurfaceCapabilities2EXT:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfaceCapabilities2EXT decode");
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                VkSurfaceCapabilities2EXT* pSurfaceCapabilities;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSurfaceKHR*)&surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pSurfaceCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilities2EXT));
                reservedunmarshal_VkSurfaceCapabilities2EXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities), readStreamPtrPtr);
                if (pSurfaceCapabilities)
                {
                    transform_tohost_VkSurfaceCapabilities2EXT(m_state, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfaceCapabilities2EXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pSurfaceCapabilities);
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = vk->vkGetPhysicalDeviceSurfaceCapabilities2EXT(unboxed_physicalDevice, surface, pSurfaceCapabilities);
                vkStream->unsetHandleMapping();
                if (pSurfaceCapabilities)
                {
                    transform_fromhost_VkSurfaceCapabilities2EXT(m_state, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                }
                marshal_VkSurfaceCapabilities2EXT(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceCapabilities2EXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, physicalDevice, surface, pSurfaceCapabilities);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_display_control
            case OP_vkDisplayPowerControlEXT:
            {
                android::base::beginTrace("vkDisplayPowerControlEXT decode");
                VkDevice device;
                VkDisplayKHR display;
                const VkDisplayPowerInfoEXT* pDisplayPowerInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayKHR*)&display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_1));
                vkReadStream->alloc((void**)&pDisplayPowerInfo, sizeof(const VkDisplayPowerInfoEXT));
                reservedunmarshal_VkDisplayPowerInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPowerInfoEXT*)(pDisplayPowerInfo), readStreamPtrPtr);
                if (pDisplayPowerInfo)
                {
                    transform_tohost_VkDisplayPowerInfoEXT(m_state, (VkDisplayPowerInfoEXT*)(pDisplayPowerInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDisplayPowerControlEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)display, (unsigned long long)pDisplayPowerInfo);
                }
                VkResult vkDisplayPowerControlEXT_VkResult_return = (VkResult)0;
                vkDisplayPowerControlEXT_VkResult_return = vk->vkDisplayPowerControlEXT(unboxed_device, display, pDisplayPowerInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDisplayPowerControlEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDisplayPowerControlEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkDisplayPowerControlEXT_VkResult_return, device, display, pDisplayPowerInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkRegisterDeviceEventEXT:
            {
                android::base::beginTrace("vkRegisterDeviceEventEXT decode");
                VkDevice device;
                const VkDeviceEventInfoEXT* pDeviceEventInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pDeviceEventInfo, sizeof(const VkDeviceEventInfoEXT));
                reservedunmarshal_VkDeviceEventInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceEventInfoEXT*)(pDeviceEventInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pFence;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkFence*)pFence = (VkFence)(VkFence)((VkFence)(*&cgen_var_2));
                if (pDeviceEventInfo)
                {
                    transform_tohost_VkDeviceEventInfoEXT(m_state, (VkDeviceEventInfoEXT*)(pDeviceEventInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkRegisterDeviceEventEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pDeviceEventInfo, (unsigned long long)pAllocator, (unsigned long long)pFence);
                }
                VkResult vkRegisterDeviceEventEXT_VkResult_return = (VkResult)0;
                vkRegisterDeviceEventEXT_VkResult_return = vk->vkRegisterDeviceEventEXT(unboxed_device, pDeviceEventInfo, pAllocator, pFence);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkRegisterDeviceEventEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkRegisterDeviceEventEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkRegisterDeviceEventEXT_VkResult_return, device, pDeviceEventInfo, pAllocator, pFence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkRegisterDisplayEventEXT:
            {
                android::base::beginTrace("vkRegisterDisplayEventEXT decode");
                VkDevice device;
                VkDisplayKHR display;
                const VkDisplayEventInfoEXT* pDisplayEventInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDisplayKHR*)&display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_1));
                vkReadStream->alloc((void**)&pDisplayEventInfo, sizeof(const VkDisplayEventInfoEXT));
                reservedunmarshal_VkDisplayEventInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayEventInfoEXT*)(pDisplayEventInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pFence;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_3;
                memcpy((uint64_t*)&cgen_var_3, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkFence*)pFence = (VkFence)(VkFence)((VkFence)(*&cgen_var_3));
                if (pDisplayEventInfo)
                {
                    transform_tohost_VkDisplayEventInfoEXT(m_state, (VkDisplayEventInfoEXT*)(pDisplayEventInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkRegisterDisplayEventEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)display, (unsigned long long)pDisplayEventInfo, (unsigned long long)pAllocator, (unsigned long long)pFence);
                }
                VkResult vkRegisterDisplayEventEXT_VkResult_return = (VkResult)0;
                vkRegisterDisplayEventEXT_VkResult_return = vk->vkRegisterDisplayEventEXT(unboxed_device, display, pDisplayEventInfo, pAllocator, pFence);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_4;
                vkStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_4, 1);
                vkStream->write((uint64_t*)&cgen_var_4, 8);
                vkStream->write(&vkRegisterDisplayEventEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkRegisterDisplayEventEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkRegisterDisplayEventEXT_VkResult_return, device, display, pDisplayEventInfo, pAllocator, pFence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetSwapchainCounterEXT:
            {
                android::base::beginTrace("vkGetSwapchainCounterEXT decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                VkSurfaceCounterFlagBitsEXT counter;
                uint64_t* pCounterValue;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_1));
                memcpy((VkSurfaceCounterFlagBitsEXT*)&counter, *readStreamPtrPtr, sizeof(VkSurfaceCounterFlagBitsEXT));
                *readStreamPtrPtr += sizeof(VkSurfaceCounterFlagBitsEXT);
                // Begin manual dispatchable handle unboxing for pCounterValue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCounterValue, sizeof(uint64_t));
                memcpy((uint64_t*)pCounterValue, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetSwapchainCounterEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)counter, (unsigned long long)pCounterValue);
                }
                VkResult vkGetSwapchainCounterEXT_VkResult_return = (VkResult)0;
                vkGetSwapchainCounterEXT_VkResult_return = vk->vkGetSwapchainCounterEXT(unboxed_device, swapchain, counter, pCounterValue);
                vkStream->unsetHandleMapping();
                vkStream->write((uint64_t*)pCounterValue, sizeof(uint64_t));
                vkStream->write(&vkGetSwapchainCounterEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSwapchainCounterEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSwapchainCounterEXT_VkResult_return, device, swapchain, counter, pCounterValue);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_GOOGLE_display_timing
            case OP_vkGetRefreshCycleDurationGOOGLE:
            {
                android::base::beginTrace("vkGetRefreshCycleDurationGOOGLE decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pDisplayTimingProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDisplayTimingProperties, sizeof(VkRefreshCycleDurationGOOGLE));
                reservedunmarshal_VkRefreshCycleDurationGOOGLE(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties), readStreamPtrPtr);
                if (pDisplayTimingProperties)
                {
                    transform_tohost_VkRefreshCycleDurationGOOGLE(m_state, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetRefreshCycleDurationGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)pDisplayTimingProperties);
                }
                VkResult vkGetRefreshCycleDurationGOOGLE_VkResult_return = (VkResult)0;
                vkGetRefreshCycleDurationGOOGLE_VkResult_return = vk->vkGetRefreshCycleDurationGOOGLE(unboxed_device, swapchain, pDisplayTimingProperties);
                vkStream->unsetHandleMapping();
                if (pDisplayTimingProperties)
                {
                    transform_fromhost_VkRefreshCycleDurationGOOGLE(m_state, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                }
                marshal_VkRefreshCycleDurationGOOGLE(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                vkStream->write(&vkGetRefreshCycleDurationGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetRefreshCycleDurationGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetRefreshCycleDurationGOOGLE_VkResult_return, device, swapchain, pDisplayTimingProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPastPresentationTimingGOOGLE:
            {
                android::base::beginTrace("vkGetPastPresentationTimingGOOGLE decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint32_t* pPresentationTimingCount;
                VkPastPresentationTimingGOOGLE* pPresentationTimings;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pPresentationTimingCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPresentationTimingCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPresentationTimingCount);
                *readStreamPtrPtr += 8;
                if (pPresentationTimingCount)
                {
                    vkReadStream->alloc((void**)&pPresentationTimingCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPresentationTimingCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pPresentationTimings;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPastPresentationTimingGOOGLE**)&pPresentationTimings, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPresentationTimings);
                *readStreamPtrPtr += 8;
                if (pPresentationTimings)
                {
                    vkReadStream->alloc((void**)&pPresentationTimings, (*(pPresentationTimingCount)) * sizeof(VkPastPresentationTimingGOOGLE));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        reservedunmarshal_VkPastPresentationTimingGOOGLE(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i), readStreamPtrPtr);
                    }
                }
                if (pPresentationTimingCount)
                {
                    if (pPresentationTimings)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                        {
                            transform_tohost_VkPastPresentationTimingGOOGLE(m_state, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPastPresentationTimingGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)pPresentationTimingCount, (unsigned long long)pPresentationTimings);
                }
                VkResult vkGetPastPresentationTimingGOOGLE_VkResult_return = (VkResult)0;
                vkGetPastPresentationTimingGOOGLE_VkResult_return = vk->vkGetPastPresentationTimingGOOGLE(unboxed_device, swapchain, pPresentationTimingCount, pPresentationTimings);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pPresentationTimingCount;
                vkStream->putBe64(cgen_var_4);
                if (pPresentationTimingCount)
                {
                    vkStream->write((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
                }
                if (pPresentationTimingCount)
                {
                    if (pPresentationTimings)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                        {
                            transform_fromhost_VkPastPresentationTimingGOOGLE(m_state, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_5 = (uint64_t)(uintptr_t)pPresentationTimings;
                vkStream->putBe64(cgen_var_5);
                if (pPresentationTimings)
                {
                    if (pPresentationTimingCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                        {
                            marshal_VkPastPresentationTimingGOOGLE(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                        }
                    }
                }
                vkStream->write(&vkGetPastPresentationTimingGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPastPresentationTimingGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPastPresentationTimingGOOGLE_VkResult_return, device, swapchain, pPresentationTimingCount, pPresentationTimings);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
#endif
#ifdef VK_NV_viewport_swizzle
#endif
#ifdef VK_EXT_discard_rectangles
            case OP_vkCmdSetDiscardRectangleEXT:
            {
                android::base::beginTrace("vkCmdSetDiscardRectangleEXT decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstDiscardRectangle;
                uint32_t discardRectangleCount;
                const VkRect2D* pDiscardRectangles;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstDiscardRectangle, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&discardRectangleCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pDiscardRectangles, ((discardRectangleCount)) * sizeof(const VkRect2D));
                for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
                {
                    reservedunmarshal_VkRect2D(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(pDiscardRectangles + i), readStreamPtrPtr);
                }
                if (pDiscardRectangles)
                {
                    for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
                    {
                        transform_tohost_VkRect2D(m_state, (VkRect2D*)(pDiscardRectangles + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetDiscardRectangleEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstDiscardRectangle, (unsigned long long)discardRectangleCount, (unsigned long long)pDiscardRectangles);
                }
                vk->vkCmdSetDiscardRectangleEXT(unboxed_commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDiscardRectangleEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_conservative_rasterization
#endif
#ifdef VK_EXT_depth_clip_enable
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
            case OP_vkSetHdrMetadataEXT:
            {
                android::base::beginTrace("vkSetHdrMetadataEXT decode");
                VkDevice device;
                uint32_t swapchainCount;
                const VkSwapchainKHR* pSwapchains;
                const VkHdrMetadataEXT* pMetadata;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&swapchainCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pSwapchains, ((swapchainCount)) * sizeof(const VkSwapchainKHR));
                if (((swapchainCount)))
                {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((swapchainCount));
                    for (uint32_t k = 0; k < ((swapchainCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkSwapchainKHR*)pSwapchains) + k) = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)tmpval);
                    }
                }
                vkReadStream->alloc((void**)&pMetadata, ((swapchainCount)) * sizeof(const VkHdrMetadataEXT));
                for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                {
                    reservedunmarshal_VkHdrMetadataEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkHdrMetadataEXT*)(pMetadata + i), readStreamPtrPtr);
                }
                if (pMetadata)
                {
                    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                    {
                        transform_tohost_VkHdrMetadataEXT(m_state, (VkHdrMetadataEXT*)(pMetadata + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSetHdrMetadataEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchainCount, (unsigned long long)pSwapchains, (unsigned long long)pMetadata);
                }
                vk->vkSetHdrMetadataEXT(unboxed_device, swapchainCount, pSwapchains, pMetadata);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetHdrMetadataEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, swapchainCount, pSwapchains, pMetadata);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_MVK_ios_surface
            case OP_vkCreateIOSSurfaceMVK:
            {
                android::base::beginTrace("vkCreateIOSSurfaceMVK decode");
                VkInstance instance;
                const VkIOSSurfaceCreateInfoMVK* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkIOSSurfaceCreateInfoMVK));
                reservedunmarshal_VkIOSSurfaceCreateInfoMVK(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkIOSSurfaceCreateInfoMVK*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkIOSSurfaceCreateInfoMVK(m_state, (VkIOSSurfaceCreateInfoMVK*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateIOSSurfaceMVK 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateIOSSurfaceMVK_VkResult_return = (VkResult)0;
                vkCreateIOSSurfaceMVK_VkResult_return = vk->vkCreateIOSSurfaceMVK(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkCreateIOSSurfaceMVK_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateIOSSurfaceMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateIOSSurfaceMVK_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_MVK_macos_surface
            case OP_vkCreateMacOSSurfaceMVK:
            {
                android::base::beginTrace("vkCreateMacOSSurfaceMVK decode");
                VkInstance instance;
                const VkMacOSSurfaceCreateInfoMVK* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkMacOSSurfaceCreateInfoMVK));
                reservedunmarshal_VkMacOSSurfaceCreateInfoMVK(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMacOSSurfaceCreateInfoMVK*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkMacOSSurfaceCreateInfoMVK(m_state, (VkMacOSSurfaceCreateInfoMVK*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateMacOSSurfaceMVK 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateMacOSSurfaceMVK_VkResult_return = (VkResult)0;
                vkCreateMacOSSurfaceMVK_VkResult_return = vk->vkCreateMacOSSurfaceMVK(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkCreateMacOSSurfaceMVK_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateMacOSSurfaceMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateMacOSSurfaceMVK_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_MVK_moltenvk
            case OP_vkGetMTLDeviceMVK:
            {
                android::base::beginTrace("vkGetMTLDeviceMVK decode");
                VkPhysicalDevice physicalDevice;
                void** pMTLDevice;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pMTLDevice;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMTLDevice, sizeof(void*));
                memcpy((void**)pMTLDevice, *readStreamPtrPtr, sizeof(void*));
                *readStreamPtrPtr += sizeof(void*);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMTLDeviceMVK 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pMTLDevice);
                }
                vk->vkGetMTLDeviceMVK(unboxed_physicalDevice, pMTLDevice);
                vkStream->unsetHandleMapping();
                vkStream->write((void**)pMTLDevice, sizeof(void*));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMTLDeviceMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pMTLDevice);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkSetMTLTextureMVK:
            {
                android::base::beginTrace("vkSetMTLTextureMVK decode");
                VkImage image;
                void* mtlTexture;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for mtlTexture;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&mtlTexture, sizeof(uint8_t));
                memcpy((void*)mtlTexture, *readStreamPtrPtr, sizeof(uint8_t));
                *readStreamPtrPtr += sizeof(uint8_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSetMTLTextureMVK 0x%llx 0x%llx \n", ioStream, (unsigned long long)image, (unsigned long long)mtlTexture);
                }
                VkResult vkSetMTLTextureMVK_VkResult_return = (VkResult)0;
                vkSetMTLTextureMVK_VkResult_return = vk->vkSetMTLTextureMVK(image, mtlTexture);
                vkStream->unsetHandleMapping();
                vkStream->write((void*)mtlTexture, sizeof(uint8_t));
                vkStream->write(&vkSetMTLTextureMVK_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetMTLTextureMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkSetMTLTextureMVK_VkResult_return, image, mtlTexture);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetMTLTextureMVK:
            {
                android::base::beginTrace("vkGetMTLTextureMVK decode");
                VkImage image;
                void** pMTLTexture;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for pMTLTexture;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMTLTexture, sizeof(void*));
                memcpy((void**)pMTLTexture, *readStreamPtrPtr, sizeof(void*));
                *readStreamPtrPtr += sizeof(void*);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMTLTextureMVK 0x%llx 0x%llx \n", ioStream, (unsigned long long)image, (unsigned long long)pMTLTexture);
                }
                vk->vkGetMTLTextureMVK(image, pMTLTexture);
                vkStream->unsetHandleMapping();
                vkStream->write((void**)pMTLTexture, sizeof(void*));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMTLTextureMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, image, pMTLTexture);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetMTLBufferMVK:
            {
                android::base::beginTrace("vkGetMTLBufferMVK decode");
                VkBuffer buffer;
                void** pMTLBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for pMTLBuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMTLBuffer, sizeof(void*));
                memcpy((void**)pMTLBuffer, *readStreamPtrPtr, sizeof(void*));
                *readStreamPtrPtr += sizeof(void*);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMTLBufferMVK 0x%llx 0x%llx \n", ioStream, (unsigned long long)buffer, (unsigned long long)pMTLBuffer);
                }
                vk->vkGetMTLBufferMVK(buffer, pMTLBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write((void**)pMTLBuffer, sizeof(void*));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMTLBufferMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, buffer, pMTLBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkUseIOSurfaceMVK:
            {
                android::base::beginTrace("vkUseIOSurfaceMVK decode");
                VkImage image;
                void* ioSurface;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for ioSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&ioSurface, sizeof(uint8_t));
                memcpy((void*)ioSurface, *readStreamPtrPtr, sizeof(uint8_t));
                *readStreamPtrPtr += sizeof(uint8_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkUseIOSurfaceMVK 0x%llx 0x%llx \n", ioStream, (unsigned long long)image, (unsigned long long)ioSurface);
                }
                VkResult vkUseIOSurfaceMVK_VkResult_return = (VkResult)0;
                vkUseIOSurfaceMVK_VkResult_return = vk->vkUseIOSurfaceMVK(image, ioSurface);
                vkStream->unsetHandleMapping();
                vkStream->write((void*)ioSurface, sizeof(uint8_t));
                vkStream->write(&vkUseIOSurfaceMVK_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUseIOSurfaceMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkUseIOSurfaceMVK_VkResult_return, image, ioSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetIOSurfaceMVK:
            {
                android::base::beginTrace("vkGetIOSurfaceMVK decode");
                VkImage image;
                void** pIOSurface;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
                // Begin manual dispatchable handle unboxing for pIOSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pIOSurface, sizeof(void*));
                memcpy((void**)pIOSurface, *readStreamPtrPtr, sizeof(void*));
                *readStreamPtrPtr += sizeof(void*);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetIOSurfaceMVK 0x%llx 0x%llx \n", ioStream, (unsigned long long)image, (unsigned long long)pIOSurface);
                }
                vk->vkGetIOSurfaceMVK(image, pIOSurface);
                vkStream->unsetHandleMapping();
                vkStream->write((void**)pIOSurface, sizeof(void*));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetIOSurfaceMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, image, pIOSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
            case OP_vkSetDebugUtilsObjectNameEXT:
            {
                android::base::beginTrace("vkSetDebugUtilsObjectNameEXT decode");
                VkDevice device;
                const VkDebugUtilsObjectNameInfoEXT* pNameInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pNameInfo, sizeof(const VkDebugUtilsObjectNameInfoEXT));
                reservedunmarshal_VkDebugUtilsObjectNameInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsObjectNameInfoEXT*)(pNameInfo), readStreamPtrPtr);
                if (pNameInfo)
                {
                    transform_tohost_VkDebugUtilsObjectNameInfoEXT(m_state, (VkDebugUtilsObjectNameInfoEXT*)(pNameInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSetDebugUtilsObjectNameEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pNameInfo);
                }
                VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = (VkResult)0;
                vkSetDebugUtilsObjectNameEXT_VkResult_return = vk->vkSetDebugUtilsObjectNameEXT(unboxed_device, pNameInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSetDebugUtilsObjectNameEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetDebugUtilsObjectNameEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkSetDebugUtilsObjectNameEXT_VkResult_return, device, pNameInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkSetDebugUtilsObjectTagEXT:
            {
                android::base::beginTrace("vkSetDebugUtilsObjectTagEXT decode");
                VkDevice device;
                const VkDebugUtilsObjectTagInfoEXT* pTagInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pTagInfo, sizeof(const VkDebugUtilsObjectTagInfoEXT));
                reservedunmarshal_VkDebugUtilsObjectTagInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsObjectTagInfoEXT*)(pTagInfo), readStreamPtrPtr);
                if (pTagInfo)
                {
                    transform_tohost_VkDebugUtilsObjectTagInfoEXT(m_state, (VkDebugUtilsObjectTagInfoEXT*)(pTagInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSetDebugUtilsObjectTagEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pTagInfo);
                }
                VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = (VkResult)0;
                vkSetDebugUtilsObjectTagEXT_VkResult_return = vk->vkSetDebugUtilsObjectTagEXT(unboxed_device, pTagInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSetDebugUtilsObjectTagEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetDebugUtilsObjectTagEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkSetDebugUtilsObjectTagEXT_VkResult_return, device, pTagInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueBeginDebugUtilsLabelEXT:
            {
                android::base::beginTrace("vkQueueBeginDebugUtilsLabelEXT decode");
                VkQueue queue;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin non wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                reservedunmarshal_VkDebugUtilsLabelEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsLabelEXT*)(pLabelInfo), readStreamPtrPtr);
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueBeginDebugUtilsLabelEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)pLabelInfo);
                }
                vk->vkQueueBeginDebugUtilsLabelEXT(unboxed_queue, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueBeginDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, pLabelInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueEndDebugUtilsLabelEXT:
            {
                android::base::beginTrace("vkQueueEndDebugUtilsLabelEXT decode");
                VkQueue queue;
                // Begin non wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                // End manual dispatchable handle unboxing for queue;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueEndDebugUtilsLabelEXT 0x%llx \n", ioStream, (unsigned long long)queue);
                }
                vk->vkQueueEndDebugUtilsLabelEXT(unboxed_queue);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueEndDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueInsertDebugUtilsLabelEXT:
            {
                android::base::beginTrace("vkQueueInsertDebugUtilsLabelEXT decode");
                VkQueue queue;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin non wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                reservedunmarshal_VkDebugUtilsLabelEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsLabelEXT*)(pLabelInfo), readStreamPtrPtr);
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueInsertDebugUtilsLabelEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)pLabelInfo);
                }
                vk->vkQueueInsertDebugUtilsLabelEXT(unboxed_queue, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueInsertDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, pLabelInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBeginDebugUtilsLabelEXT:
            {
                android::base::beginTrace("vkCmdBeginDebugUtilsLabelEXT decode");
                VkCommandBuffer commandBuffer;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                reservedunmarshal_VkDebugUtilsLabelEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsLabelEXT*)(pLabelInfo), readStreamPtrPtr);
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBeginDebugUtilsLabelEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pLabelInfo);
                }
                vk->vkCmdBeginDebugUtilsLabelEXT(unboxed_commandBuffer, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pLabelInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdEndDebugUtilsLabelEXT:
            {
                android::base::beginTrace("vkCmdEndDebugUtilsLabelEXT decode");
                VkCommandBuffer commandBuffer;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdEndDebugUtilsLabelEXT 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                vk->vkCmdEndDebugUtilsLabelEXT(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdInsertDebugUtilsLabelEXT:
            {
                android::base::beginTrace("vkCmdInsertDebugUtilsLabelEXT decode");
                VkCommandBuffer commandBuffer;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                reservedunmarshal_VkDebugUtilsLabelEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsLabelEXT*)(pLabelInfo), readStreamPtrPtr);
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdInsertDebugUtilsLabelEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pLabelInfo);
                }
                vk->vkCmdInsertDebugUtilsLabelEXT(unboxed_commandBuffer, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdInsertDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pLabelInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateDebugUtilsMessengerEXT:
            {
                android::base::beginTrace("vkCreateDebugUtilsMessengerEXT decode");
                VkInstance instance;
                const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDebugUtilsMessengerEXT* pMessenger;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDebugUtilsMessengerCreateInfoEXT));
                reservedunmarshal_VkDebugUtilsMessengerCreateInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsMessengerCreateInfoEXT*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pMessenger;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMessenger, sizeof(VkDebugUtilsMessengerEXT));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkDebugUtilsMessengerEXT*)pMessenger = (VkDebugUtilsMessengerEXT)(VkDebugUtilsMessengerEXT)((VkDebugUtilsMessengerEXT)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkDebugUtilsMessengerCreateInfoEXT(m_state, (VkDebugUtilsMessengerCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDebugUtilsMessengerEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pMessenger);
                }
                VkResult vkCreateDebugUtilsMessengerEXT_VkResult_return = (VkResult)0;
                vkCreateDebugUtilsMessengerEXT_VkResult_return = vk->vkCreateDebugUtilsMessengerEXT(unboxed_instance, pCreateInfo, pAllocator, pMessenger);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pMessenger;
                if (vkCreateDebugUtilsMessengerEXT_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkDebugUtilsMessengerEXT), "handle map overwrite requres VkDebugUtilsMessengerEXT to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDebugUtilsMessengerEXT((VkDebugUtilsMessengerEXT*)pMessenger, 1);
                vkStream->write((VkDebugUtilsMessengerEXT*)pMessenger, 8 * 1);
                // Begin auto non dispatchable handle create for pMessenger;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDebugUtilsMessengerEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDebugUtilsMessengerEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDebugUtilsMessengerEXT_VkResult_return, instance, pCreateInfo, pAllocator, pMessenger);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyDebugUtilsMessengerEXT:
            {
                android::base::beginTrace("vkDestroyDebugUtilsMessengerEXT decode");
                VkInstance instance;
                VkDebugUtilsMessengerEXT messenger;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual non dispatchable handle destroy unboxing for messenger;
                VkDebugUtilsMessengerEXT boxed_messenger_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDebugUtilsMessengerEXT*)&messenger = (VkDebugUtilsMessengerEXT)(VkDebugUtilsMessengerEXT)((VkDebugUtilsMessengerEXT)(*&cgen_var_1));
                boxed_messenger_preserve = messenger;
                messenger = unbox_VkDebugUtilsMessengerEXT(messenger);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyDebugUtilsMessengerEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)messenger, (unsigned long long)pAllocator);
                }
                vk->vkDestroyDebugUtilsMessengerEXT(unboxed_instance, messenger, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDebugUtilsMessengerEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, boxed_messenger_preserve, pAllocator);
                }
                delete_VkDebugUtilsMessengerEXT(boxed_messenger_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkSubmitDebugUtilsMessageEXT:
            {
                android::base::beginTrace("vkSubmitDebugUtilsMessageEXT decode");
                VkInstance instance;
                VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity;
                VkDebugUtilsMessageTypeFlagsEXT messageTypes;
                const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                memcpy((VkDebugUtilsMessageSeverityFlagBitsEXT*)&messageSeverity, *readStreamPtrPtr, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
                *readStreamPtrPtr += sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT);
                memcpy((VkDebugUtilsMessageTypeFlagsEXT*)&messageTypes, *readStreamPtrPtr, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
                *readStreamPtrPtr += sizeof(VkDebugUtilsMessageTypeFlagsEXT);
                vkReadStream->alloc((void**)&pCallbackData, sizeof(const VkDebugUtilsMessengerCallbackDataEXT));
                reservedunmarshal_VkDebugUtilsMessengerCallbackDataEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsMessengerCallbackDataEXT*)(pCallbackData), readStreamPtrPtr);
                if (pCallbackData)
                {
                    transform_tohost_VkDebugUtilsMessengerCallbackDataEXT(m_state, (VkDebugUtilsMessengerCallbackDataEXT*)(pCallbackData));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSubmitDebugUtilsMessageEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)messageSeverity, (unsigned long long)messageTypes, (unsigned long long)pCallbackData);
                }
                vk->vkSubmitDebugUtilsMessageEXT(unboxed_instance, messageSeverity, messageTypes, pCallbackData);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSubmitDebugUtilsMessageEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, messageSeverity, messageTypes, pCallbackData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
            case OP_vkGetAndroidHardwareBufferPropertiesANDROID:
            {
                android::base::beginTrace("vkGetAndroidHardwareBufferPropertiesANDROID decode");
                VkDevice device;
                const AHardwareBuffer* buffer;
                VkAndroidHardwareBufferPropertiesANDROID* pProperties;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&buffer, sizeof(const AHardwareBuffer));
                memcpy((AHardwareBuffer*)buffer, *readStreamPtrPtr, sizeof(const AHardwareBuffer));
                *readStreamPtrPtr += sizeof(const AHardwareBuffer);
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkAndroidHardwareBufferPropertiesANDROID));
                reservedunmarshal_VkAndroidHardwareBufferPropertiesANDROID(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties), readStreamPtrPtr);
                if (pProperties)
                {
                    transform_tohost_VkAndroidHardwareBufferPropertiesANDROID(m_state, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetAndroidHardwareBufferPropertiesANDROID 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)pProperties);
                }
                VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
                vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = vk->vkGetAndroidHardwareBufferPropertiesANDROID(unboxed_device, buffer, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkAndroidHardwareBufferPropertiesANDROID(m_state, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                }
                marshal_VkAndroidHardwareBufferPropertiesANDROID(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                vkStream->write(&vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetAndroidHardwareBufferPropertiesANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, device, buffer, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetMemoryAndroidHardwareBufferANDROID:
            {
                android::base::beginTrace("vkGetMemoryAndroidHardwareBufferANDROID decode");
                VkDevice device;
                const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo;
                AHardwareBuffer** pBuffer;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkMemoryGetAndroidHardwareBufferInfoANDROID));
                reservedunmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pBuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pBuffer, sizeof(AHardwareBuffer*));
                memcpy((AHardwareBuffer**)pBuffer, *readStreamPtrPtr, sizeof(AHardwareBuffer*));
                *readStreamPtrPtr += sizeof(AHardwareBuffer*);
                if (pInfo)
                {
                    transform_tohost_VkMemoryGetAndroidHardwareBufferInfoANDROID(m_state, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryAndroidHardwareBufferANDROID 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pBuffer);
                }
                VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
                vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = vk->vkGetMemoryAndroidHardwareBufferANDROID(unboxed_device, pInfo, pBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
                vkStream->write(&vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryAndroidHardwareBufferANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, device, pInfo, pBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_inline_uniform_block
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
            case OP_vkCmdSetSampleLocationsEXT:
            {
                android::base::beginTrace("vkCmdSetSampleLocationsEXT decode");
                VkCommandBuffer commandBuffer;
                const VkSampleLocationsInfoEXT* pSampleLocationsInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pSampleLocationsInfo, sizeof(const VkSampleLocationsInfoEXT));
                reservedunmarshal_VkSampleLocationsInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSampleLocationsInfoEXT*)(pSampleLocationsInfo), readStreamPtrPtr);
                if (pSampleLocationsInfo)
                {
                    transform_tohost_VkSampleLocationsInfoEXT(m_state, (VkSampleLocationsInfoEXT*)(pSampleLocationsInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetSampleLocationsEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pSampleLocationsInfo);
                }
                vk->vkCmdSetSampleLocationsEXT(unboxed_commandBuffer, pSampleLocationsInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetSampleLocationsEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pSampleLocationsInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceMultisamplePropertiesEXT:
            {
                android::base::beginTrace("vkGetPhysicalDeviceMultisamplePropertiesEXT decode");
                VkPhysicalDevice physicalDevice;
                VkSampleCountFlagBits samples;
                VkMultisamplePropertiesEXT* pMultisampleProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((VkSampleCountFlagBits*)&samples, *readStreamPtrPtr, sizeof(VkSampleCountFlagBits));
                *readStreamPtrPtr += sizeof(VkSampleCountFlagBits);
                // Begin manual dispatchable handle unboxing for pMultisampleProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMultisampleProperties, sizeof(VkMultisamplePropertiesEXT));
                reservedunmarshal_VkMultisamplePropertiesEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMultisamplePropertiesEXT*)(pMultisampleProperties), readStreamPtrPtr);
                if (pMultisampleProperties)
                {
                    transform_tohost_VkMultisamplePropertiesEXT(m_state, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceMultisamplePropertiesEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)samples, (unsigned long long)pMultisampleProperties);
                }
                vk->vkGetPhysicalDeviceMultisamplePropertiesEXT(unboxed_physicalDevice, samples, pMultisampleProperties);
                vkStream->unsetHandleMapping();
                if (pMultisampleProperties)
                {
                    transform_fromhost_VkMultisamplePropertiesEXT(m_state, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                }
                marshal_VkMultisamplePropertiesEXT(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceMultisamplePropertiesEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, samples, pMultisampleProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_blend_operation_advanced
#endif
#ifdef VK_NV_fragment_coverage_to_color
#endif
#ifdef VK_NV_framebuffer_mixed_samples
#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_NV_shader_sm_builtins
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_image_drm_format_modifier
            case OP_vkGetImageDrmFormatModifierPropertiesEXT:
            {
                android::base::beginTrace("vkGetImageDrmFormatModifierPropertiesEXT decode");
                VkDevice device;
                VkImage image;
                VkImageDrmFormatModifierPropertiesEXT* pProperties;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkImageDrmFormatModifierPropertiesEXT));
                reservedunmarshal_VkImageDrmFormatModifierPropertiesEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageDrmFormatModifierPropertiesEXT*)(pProperties), readStreamPtrPtr);
                if (pProperties)
                {
                    transform_tohost_VkImageDrmFormatModifierPropertiesEXT(m_state, (VkImageDrmFormatModifierPropertiesEXT*)(pProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetImageDrmFormatModifierPropertiesEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)pProperties);
                }
                VkResult vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return = (VkResult)0;
                vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return = vk->vkGetImageDrmFormatModifierPropertiesEXT(unboxed_device, image, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkImageDrmFormatModifierPropertiesEXT(m_state, (VkImageDrmFormatModifierPropertiesEXT*)(pProperties));
                }
                marshal_VkImageDrmFormatModifierPropertiesEXT(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageDrmFormatModifierPropertiesEXT*)(pProperties));
                vkStream->write(&vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageDrmFormatModifierPropertiesEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return, device, image, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_validation_cache
            case OP_vkCreateValidationCacheEXT:
            {
                android::base::beginTrace("vkCreateValidationCacheEXT decode");
                VkDevice device;
                const VkValidationCacheCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkValidationCacheEXT* pValidationCache;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkValidationCacheCreateInfoEXT));
                reservedunmarshal_VkValidationCacheCreateInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkValidationCacheCreateInfoEXT*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pValidationCache;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pValidationCache, sizeof(VkValidationCacheEXT));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkValidationCacheEXT*)pValidationCache = (VkValidationCacheEXT)(VkValidationCacheEXT)((VkValidationCacheEXT)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkValidationCacheCreateInfoEXT(m_state, (VkValidationCacheCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateValidationCacheEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pValidationCache);
                }
                VkResult vkCreateValidationCacheEXT_VkResult_return = (VkResult)0;
                vkCreateValidationCacheEXT_VkResult_return = vk->vkCreateValidationCacheEXT(unboxed_device, pCreateInfo, pAllocator, pValidationCache);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pValidationCache;
                if (vkCreateValidationCacheEXT_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkValidationCacheEXT), "handle map overwrite requres VkValidationCacheEXT to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkValidationCacheEXT((VkValidationCacheEXT*)pValidationCache, 1);
                vkStream->write((VkValidationCacheEXT*)pValidationCache, 8 * 1);
                // Begin auto non dispatchable handle create for pValidationCache;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateValidationCacheEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateValidationCacheEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateValidationCacheEXT_VkResult_return, device, pCreateInfo, pAllocator, pValidationCache);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyValidationCacheEXT:
            {
                android::base::beginTrace("vkDestroyValidationCacheEXT decode");
                VkDevice device;
                VkValidationCacheEXT validationCache;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for validationCache;
                VkValidationCacheEXT boxed_validationCache_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkValidationCacheEXT*)&validationCache = (VkValidationCacheEXT)(VkValidationCacheEXT)((VkValidationCacheEXT)(*&cgen_var_1));
                boxed_validationCache_preserve = validationCache;
                validationCache = unbox_VkValidationCacheEXT(validationCache);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyValidationCacheEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)validationCache, (unsigned long long)pAllocator);
                }
                vk->vkDestroyValidationCacheEXT(unboxed_device, validationCache, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyValidationCacheEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_validationCache_preserve, pAllocator);
                }
                delete_VkValidationCacheEXT(boxed_validationCache_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkMergeValidationCachesEXT:
            {
                android::base::beginTrace("vkMergeValidationCachesEXT decode");
                VkDevice device;
                VkValidationCacheEXT dstCache;
                uint32_t srcCacheCount;
                const VkValidationCacheEXT* pSrcCaches;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkValidationCacheEXT*)&dstCache = (VkValidationCacheEXT)unbox_VkValidationCacheEXT((VkValidationCacheEXT)(*&cgen_var_1));
                memcpy((uint32_t*)&srcCacheCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pSrcCaches, ((srcCacheCount)) * sizeof(const VkValidationCacheEXT));
                if (((srcCacheCount)))
                {
                    uint8_t* cgen_var_2_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((srcCacheCount));
                    for (uint32_t k = 0; k < ((srcCacheCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_2_ptr + k * 8, sizeof(uint64_t));
                        *(((VkValidationCacheEXT*)pSrcCaches) + k) = (VkValidationCacheEXT)unbox_VkValidationCacheEXT((VkValidationCacheEXT)tmpval);
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkMergeValidationCachesEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)dstCache, (unsigned long long)srcCacheCount, (unsigned long long)pSrcCaches);
                }
                VkResult vkMergeValidationCachesEXT_VkResult_return = (VkResult)0;
                vkMergeValidationCachesEXT_VkResult_return = vk->vkMergeValidationCachesEXT(unboxed_device, dstCache, srcCacheCount, pSrcCaches);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkMergeValidationCachesEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkMergeValidationCachesEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkMergeValidationCachesEXT_VkResult_return, device, dstCache, srcCacheCount, pSrcCaches);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetValidationCacheDataEXT:
            {
                android::base::beginTrace("vkGetValidationCacheDataEXT decode");
                VkDevice device;
                VkValidationCacheEXT validationCache;
                size_t* pDataSize;
                void* pData;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkValidationCacheEXT*)&validationCache = (VkValidationCacheEXT)unbox_VkValidationCacheEXT((VkValidationCacheEXT)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pDataSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((size_t**)&pDataSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pDataSize);
                *readStreamPtrPtr += 8;
                if (pDataSize)
                {
                    vkReadStream->alloc((void**)&pDataSize, sizeof(size_t));
                    memcpy((size_t*)&(*pDataSize), (*readStreamPtrPtr), 8);
                    android::base::Stream::fromBe64((uint8_t*)&(*pDataSize));
                    *readStreamPtrPtr += 8;
                }
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((void**)&pData, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pData);
                *readStreamPtrPtr += 8;
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, (*(pDataSize)) * sizeof(uint8_t));
                    memcpy((void*)pData, *readStreamPtrPtr, (*(pDataSize)) * sizeof(uint8_t));
                    *readStreamPtrPtr += (*(pDataSize)) * sizeof(uint8_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetValidationCacheDataEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)validationCache, (unsigned long long)pDataSize, (unsigned long long)pData);
                }
                VkResult vkGetValidationCacheDataEXT_VkResult_return = (VkResult)0;
                vkGetValidationCacheDataEXT_VkResult_return = vk->vkGetValidationCacheDataEXT(unboxed_device, validationCache, pDataSize, pData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pDataSize;
                vkStream->putBe64(cgen_var_4);
                if (pDataSize)
                {
                    uint64_t cgen_var_4_0 = (uint64_t)(*pDataSize);
                    vkStream->putBe64(cgen_var_4_0);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_5 = (uint64_t)(uintptr_t)pData;
                vkStream->putBe64(cgen_var_5);
                if (pData)
                {
                    vkStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetValidationCacheDataEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetValidationCacheDataEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetValidationCacheDataEXT_VkResult_return, device, validationCache, pDataSize, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_NV_shading_rate_image
            case OP_vkCmdBindShadingRateImageNV:
            {
                android::base::beginTrace("vkCmdBindShadingRateImageNV decode");
                VkCommandBuffer commandBuffer;
                VkImageView imageView;
                VkImageLayout imageLayout;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImageView*)&imageView = (VkImageView)unbox_VkImageView((VkImageView)(*&cgen_var_1));
                memcpy((VkImageLayout*)&imageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBindShadingRateImageNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)imageView, (unsigned long long)imageLayout);
                }
                vk->vkCmdBindShadingRateImageNV(unboxed_commandBuffer, imageView, imageLayout);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindShadingRateImageNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, imageView, imageLayout);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetViewportShadingRatePaletteNV:
            {
                android::base::beginTrace("vkCmdSetViewportShadingRatePaletteNV decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstViewport;
                uint32_t viewportCount;
                const VkShadingRatePaletteNV* pShadingRatePalettes;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstViewport, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&viewportCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pShadingRatePalettes, ((viewportCount)) * sizeof(const VkShadingRatePaletteNV));
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                {
                    reservedunmarshal_VkShadingRatePaletteNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkShadingRatePaletteNV*)(pShadingRatePalettes + i), readStreamPtrPtr);
                }
                if (pShadingRatePalettes)
                {
                    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                    {
                        transform_tohost_VkShadingRatePaletteNV(m_state, (VkShadingRatePaletteNV*)(pShadingRatePalettes + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetViewportShadingRatePaletteNV 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstViewport, (unsigned long long)viewportCount, (unsigned long long)pShadingRatePalettes);
                }
                vk->vkCmdSetViewportShadingRatePaletteNV(unboxed_commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetViewportShadingRatePaletteNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetCoarseSampleOrderNV:
            {
                android::base::beginTrace("vkCmdSetCoarseSampleOrderNV decode");
                VkCommandBuffer commandBuffer;
                VkCoarseSampleOrderTypeNV sampleOrderType;
                uint32_t customSampleOrderCount;
                const VkCoarseSampleOrderCustomNV* pCustomSampleOrders;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkCoarseSampleOrderTypeNV*)&sampleOrderType, *readStreamPtrPtr, sizeof(VkCoarseSampleOrderTypeNV));
                *readStreamPtrPtr += sizeof(VkCoarseSampleOrderTypeNV);
                memcpy((uint32_t*)&customSampleOrderCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pCustomSampleOrders, ((customSampleOrderCount)) * sizeof(const VkCoarseSampleOrderCustomNV));
                for (uint32_t i = 0; i < (uint32_t)((customSampleOrderCount)); ++i)
                {
                    reservedunmarshal_VkCoarseSampleOrderCustomNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCoarseSampleOrderCustomNV*)(pCustomSampleOrders + i), readStreamPtrPtr);
                }
                if (pCustomSampleOrders)
                {
                    for (uint32_t i = 0; i < (uint32_t)((customSampleOrderCount)); ++i)
                    {
                        transform_tohost_VkCoarseSampleOrderCustomNV(m_state, (VkCoarseSampleOrderCustomNV*)(pCustomSampleOrders + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetCoarseSampleOrderNV 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)sampleOrderType, (unsigned long long)customSampleOrderCount, (unsigned long long)pCustomSampleOrders);
                }
                vk->vkCmdSetCoarseSampleOrderNV(unboxed_commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetCoarseSampleOrderNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_ray_tracing
            case OP_vkCreateAccelerationStructureNV:
            {
                android::base::beginTrace("vkCreateAccelerationStructureNV decode");
                VkDevice device;
                const VkAccelerationStructureCreateInfoNV* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkAccelerationStructureNV* pAccelerationStructure;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkAccelerationStructureCreateInfoNV));
                reservedunmarshal_VkAccelerationStructureCreateInfoNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureCreateInfoNV*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pAccelerationStructure;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pAccelerationStructure, sizeof(VkAccelerationStructureNV));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkAccelerationStructureNV*)pAccelerationStructure = (VkAccelerationStructureNV)(VkAccelerationStructureNV)((VkAccelerationStructureNV)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkAccelerationStructureCreateInfoNV(m_state, (VkAccelerationStructureCreateInfoNV*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateAccelerationStructureNV 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pAccelerationStructure);
                }
                VkResult vkCreateAccelerationStructureNV_VkResult_return = (VkResult)0;
                vkCreateAccelerationStructureNV_VkResult_return = vk->vkCreateAccelerationStructureNV(unboxed_device, pCreateInfo, pAllocator, pAccelerationStructure);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pAccelerationStructure;
                if (vkCreateAccelerationStructureNV_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkAccelerationStructureNV), "handle map overwrite requres VkAccelerationStructureNV to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkAccelerationStructureNV((VkAccelerationStructureNV*)pAccelerationStructure, 1);
                vkStream->write((VkAccelerationStructureNV*)pAccelerationStructure, 8 * 1);
                // Begin auto non dispatchable handle create for pAccelerationStructure;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateAccelerationStructureNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateAccelerationStructureNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateAccelerationStructureNV_VkResult_return, device, pCreateInfo, pAllocator, pAccelerationStructure);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyAccelerationStructureNV:
            {
                android::base::beginTrace("vkDestroyAccelerationStructureNV decode");
                VkDevice device;
                VkAccelerationStructureNV accelerationStructure;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for accelerationStructure;
                VkAccelerationStructureNV boxed_accelerationStructure_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkAccelerationStructureNV*)&accelerationStructure = (VkAccelerationStructureNV)(VkAccelerationStructureNV)((VkAccelerationStructureNV)(*&cgen_var_1));
                boxed_accelerationStructure_preserve = accelerationStructure;
                accelerationStructure = unbox_VkAccelerationStructureNV(accelerationStructure);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyAccelerationStructureNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)accelerationStructure, (unsigned long long)pAllocator);
                }
                vk->vkDestroyAccelerationStructureNV(unboxed_device, accelerationStructure, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyAccelerationStructureNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_accelerationStructure_preserve, pAllocator);
                }
                delete_VkAccelerationStructureNV(boxed_accelerationStructure_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetAccelerationStructureMemoryRequirementsNV:
            {
                android::base::beginTrace("vkGetAccelerationStructureMemoryRequirementsNV decode");
                VkDevice device;
                const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo;
                VkMemoryRequirements2KHR* pMemoryRequirements;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkAccelerationStructureMemoryRequirementsInfoNV));
                reservedunmarshal_VkAccelerationStructureMemoryRequirementsInfoNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureMemoryRequirementsInfoNV*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2KHR));
                reservedunmarshal_VkMemoryRequirements2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2KHR*)(pMemoryRequirements), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkAccelerationStructureMemoryRequirementsInfoNV(m_state, (VkAccelerationStructureMemoryRequirementsInfoNV*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2KHR(m_state, (VkMemoryRequirements2KHR*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetAccelerationStructureMemoryRequirementsNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pMemoryRequirements);
                }
                vk->vkGetAccelerationStructureMemoryRequirementsNV(unboxed_device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2KHR(m_state, (VkMemoryRequirements2KHR*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2KHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2KHR*)(pMemoryRequirements));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetAccelerationStructureMemoryRequirementsNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBindAccelerationStructureMemoryNV:
            {
                android::base::beginTrace("vkBindAccelerationStructureMemoryNV decode");
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindAccelerationStructureMemoryInfoNV* pBindInfos;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindAccelerationStructureMemoryInfoNV));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    reservedunmarshal_VkBindAccelerationStructureMemoryInfoNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindAccelerationStructureMemoryInfoNV*)(pBindInfos + i), readStreamPtrPtr);
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindAccelerationStructureMemoryInfoNV(m_state, (VkBindAccelerationStructureMemoryInfoNV*)(pBindInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBindAccelerationStructureMemoryNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfos);
                }
                VkResult vkBindAccelerationStructureMemoryNV_VkResult_return = (VkResult)0;
                vkBindAccelerationStructureMemoryNV_VkResult_return = vk->vkBindAccelerationStructureMemoryNV(unboxed_device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindAccelerationStructureMemoryNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindAccelerationStructureMemoryNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindAccelerationStructureMemoryNV_VkResult_return, device, bindInfoCount, pBindInfos);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBuildAccelerationStructureNV:
            {
                android::base::beginTrace("vkCmdBuildAccelerationStructureNV decode");
                VkCommandBuffer commandBuffer;
                const VkAccelerationStructureInfoNV* pInfo;
                VkBuffer instanceData;
                VkDeviceSize instanceOffset;
                VkBool32 update;
                VkAccelerationStructureNV dst;
                VkAccelerationStructureNV src;
                VkBuffer scratch;
                VkDeviceSize scratchOffset;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkAccelerationStructureInfoNV));
                reservedunmarshal_VkAccelerationStructureInfoNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureInfoNV*)(pInfo), readStreamPtrPtr);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&instanceData = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&instanceOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkBool32*)&update, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkAccelerationStructureNV*)&dst = (VkAccelerationStructureNV)unbox_VkAccelerationStructureNV((VkAccelerationStructureNV)(*&cgen_var_2));
                uint64_t cgen_var_3;
                memcpy((uint64_t*)&cgen_var_3, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkAccelerationStructureNV*)&src = (VkAccelerationStructureNV)unbox_VkAccelerationStructureNV((VkAccelerationStructureNV)(*&cgen_var_3));
                uint64_t cgen_var_4;
                memcpy((uint64_t*)&cgen_var_4, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&scratch = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_4));
                memcpy((VkDeviceSize*)&scratchOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                if (pInfo)
                {
                    transform_tohost_VkAccelerationStructureInfoNV(m_state, (VkAccelerationStructureInfoNV*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBuildAccelerationStructureNV 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pInfo, (unsigned long long)instanceData, (unsigned long long)instanceOffset, (unsigned long long)update, (unsigned long long)dst, (unsigned long long)src, (unsigned long long)scratch, (unsigned long long)scratchOffset);
                }
                vk->vkCmdBuildAccelerationStructureNV(unboxed_commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBuildAccelerationStructureNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyAccelerationStructureNV:
            {
                android::base::beginTrace("vkCmdCopyAccelerationStructureNV decode");
                VkCommandBuffer commandBuffer;
                VkAccelerationStructureNV dst;
                VkAccelerationStructureNV src;
                VkCopyAccelerationStructureModeKHR mode;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkAccelerationStructureNV*)&dst = (VkAccelerationStructureNV)unbox_VkAccelerationStructureNV((VkAccelerationStructureNV)(*&cgen_var_1));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkAccelerationStructureNV*)&src = (VkAccelerationStructureNV)unbox_VkAccelerationStructureNV((VkAccelerationStructureNV)(*&cgen_var_2));
                memcpy((VkCopyAccelerationStructureModeKHR*)&mode, *readStreamPtrPtr, sizeof(VkCopyAccelerationStructureModeKHR));
                *readStreamPtrPtr += sizeof(VkCopyAccelerationStructureModeKHR);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyAccelerationStructureNV 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)dst, (unsigned long long)src, (unsigned long long)mode);
                }
                vk->vkCmdCopyAccelerationStructureNV(unboxed_commandBuffer, dst, src, mode);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyAccelerationStructureNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, dst, src, mode);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdTraceRaysNV:
            {
                android::base::beginTrace("vkCmdTraceRaysNV decode");
                VkCommandBuffer commandBuffer;
                VkBuffer raygenShaderBindingTableBuffer;
                VkDeviceSize raygenShaderBindingOffset;
                VkBuffer missShaderBindingTableBuffer;
                VkDeviceSize missShaderBindingOffset;
                VkDeviceSize missShaderBindingStride;
                VkBuffer hitShaderBindingTableBuffer;
                VkDeviceSize hitShaderBindingOffset;
                VkDeviceSize hitShaderBindingStride;
                VkBuffer callableShaderBindingTableBuffer;
                VkDeviceSize callableShaderBindingOffset;
                VkDeviceSize callableShaderBindingStride;
                uint32_t width;
                uint32_t height;
                uint32_t depth;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&raygenShaderBindingTableBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&raygenShaderBindingOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&missShaderBindingTableBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_2));
                memcpy((VkDeviceSize*)&missShaderBindingOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&missShaderBindingStride, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_3;
                memcpy((uint64_t*)&cgen_var_3, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&hitShaderBindingTableBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_3));
                memcpy((VkDeviceSize*)&hitShaderBindingOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&hitShaderBindingStride, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_4;
                memcpy((uint64_t*)&cgen_var_4, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&callableShaderBindingTableBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_4));
                memcpy((VkDeviceSize*)&callableShaderBindingOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&callableShaderBindingStride, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&width, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&height, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&depth, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdTraceRaysNV 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)raygenShaderBindingTableBuffer, (unsigned long long)raygenShaderBindingOffset, (unsigned long long)missShaderBindingTableBuffer, (unsigned long long)missShaderBindingOffset, (unsigned long long)missShaderBindingStride, (unsigned long long)hitShaderBindingTableBuffer, (unsigned long long)hitShaderBindingOffset, (unsigned long long)hitShaderBindingStride, (unsigned long long)callableShaderBindingTableBuffer, (unsigned long long)callableShaderBindingOffset, (unsigned long long)callableShaderBindingStride, (unsigned long long)width, (unsigned long long)height, (unsigned long long)depth);
                }
                vk->vkCmdTraceRaysNV(unboxed_commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdTraceRaysNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateRayTracingPipelinesNV:
            {
                android::base::beginTrace("vkCreateRayTracingPipelinesNV decode");
                VkDevice device;
                VkPipelineCache pipelineCache;
                uint32_t createInfoCount;
                const VkRayTracingPipelineCreateInfoNV* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkPipeline* pPipelines;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineCache*)&pipelineCache = (VkPipelineCache)unbox_VkPipelineCache((VkPipelineCache)(*&cgen_var_1));
                memcpy((uint32_t*)&createInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkRayTracingPipelineCreateInfoNV));
                for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                {
                    reservedunmarshal_VkRayTracingPipelineCreateInfoNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRayTracingPipelineCreateInfoNV*)(pCreateInfos + i), readStreamPtrPtr);
                }
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPipelines;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                if (((createInfoCount)))
                {
                    uint8_t* cgen_var_3_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((createInfoCount));
                    for (uint32_t k = 0; k < ((createInfoCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_3_ptr + k * 8, sizeof(uint64_t));
                        *(((VkPipeline*)pPipelines) + k) = (VkPipeline)(VkPipeline)((VkPipeline)tmpval);
                    }
                }
                if (pCreateInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                    {
                        transform_tohost_VkRayTracingPipelineCreateInfoNV(m_state, (VkRayTracingPipelineCreateInfoNV*)(pCreateInfos + i));
                    }
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateRayTracingPipelinesNV 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineCache, (unsigned long long)createInfoCount, (unsigned long long)pCreateInfos, (unsigned long long)pAllocator, (unsigned long long)pPipelines);
                }
                VkResult vkCreateRayTracingPipelinesNV_VkResult_return = (VkResult)0;
                vkCreateRayTracingPipelinesNV_VkResult_return = vk->vkCreateRayTracingPipelinesNV(unboxed_device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                vkStream->unsetHandleMapping();
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_4;
                    vkStream->alloc((void**)&cgen_var_4, ((createInfoCount)) * 8);
                    vkStream->handleMapping()->mapHandles_VkPipeline_u64(pPipelines, cgen_var_4, ((createInfoCount)));
                    vkStream->write((uint64_t*)cgen_var_4, ((createInfoCount)) * 8);
                }
                vkStream->write(&vkCreateRayTracingPipelinesNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateRayTracingPipelinesNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateRayTracingPipelinesNV_VkResult_return, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetRayTracingShaderGroupHandlesKHR:
            {
                android::base::beginTrace("vkGetRayTracingShaderGroupHandlesKHR decode");
                VkDevice device;
                VkPipeline pipeline;
                uint32_t firstGroup;
                uint32_t groupCount;
                size_t dataSize;
                void* pData;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipeline*)&pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_1));
                memcpy((uint32_t*)&firstGroup, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((size_t*)&dataSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&dataSize);
                *readStreamPtrPtr += 8;
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(uint8_t));
                memcpy((void*)pData, *readStreamPtrPtr, ((dataSize)) * sizeof(uint8_t));
                *readStreamPtrPtr += ((dataSize)) * sizeof(uint8_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetRayTracingShaderGroupHandlesKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipeline, (unsigned long long)firstGroup, (unsigned long long)groupCount, (unsigned long long)dataSize, (unsigned long long)pData);
                }
                VkResult vkGetRayTracingShaderGroupHandlesKHR_VkResult_return = (VkResult)0;
                vkGetRayTracingShaderGroupHandlesKHR_VkResult_return = vk->vkGetRayTracingShaderGroupHandlesKHR(unboxed_device, pipeline, firstGroup, groupCount, dataSize, pData);
                vkStream->unsetHandleMapping();
                vkStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkStream->write(&vkGetRayTracingShaderGroupHandlesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetRayTracingShaderGroupHandlesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetRayTracingShaderGroupHandlesKHR_VkResult_return, device, pipeline, firstGroup, groupCount, dataSize, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetRayTracingShaderGroupHandlesNV:
            {
                android::base::beginTrace("vkGetRayTracingShaderGroupHandlesNV decode");
                VkDevice device;
                VkPipeline pipeline;
                uint32_t firstGroup;
                uint32_t groupCount;
                size_t dataSize;
                void* pData;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipeline*)&pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_1));
                memcpy((uint32_t*)&firstGroup, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((size_t*)&dataSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&dataSize);
                *readStreamPtrPtr += 8;
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(uint8_t));
                memcpy((void*)pData, *readStreamPtrPtr, ((dataSize)) * sizeof(uint8_t));
                *readStreamPtrPtr += ((dataSize)) * sizeof(uint8_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetRayTracingShaderGroupHandlesNV 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipeline, (unsigned long long)firstGroup, (unsigned long long)groupCount, (unsigned long long)dataSize, (unsigned long long)pData);
                }
                VkResult vkGetRayTracingShaderGroupHandlesNV_VkResult_return = (VkResult)0;
                vkGetRayTracingShaderGroupHandlesNV_VkResult_return = vk->vkGetRayTracingShaderGroupHandlesNV(unboxed_device, pipeline, firstGroup, groupCount, dataSize, pData);
                vkStream->unsetHandleMapping();
                vkStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkStream->write(&vkGetRayTracingShaderGroupHandlesNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetRayTracingShaderGroupHandlesNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetRayTracingShaderGroupHandlesNV_VkResult_return, device, pipeline, firstGroup, groupCount, dataSize, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetAccelerationStructureHandleNV:
            {
                android::base::beginTrace("vkGetAccelerationStructureHandleNV decode");
                VkDevice device;
                VkAccelerationStructureNV accelerationStructure;
                size_t dataSize;
                void* pData;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkAccelerationStructureNV*)&accelerationStructure = (VkAccelerationStructureNV)unbox_VkAccelerationStructureNV((VkAccelerationStructureNV)(*&cgen_var_1));
                memcpy((size_t*)&dataSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&dataSize);
                *readStreamPtrPtr += 8;
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(uint8_t));
                memcpy((void*)pData, *readStreamPtrPtr, ((dataSize)) * sizeof(uint8_t));
                *readStreamPtrPtr += ((dataSize)) * sizeof(uint8_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetAccelerationStructureHandleNV 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)accelerationStructure, (unsigned long long)dataSize, (unsigned long long)pData);
                }
                VkResult vkGetAccelerationStructureHandleNV_VkResult_return = (VkResult)0;
                vkGetAccelerationStructureHandleNV_VkResult_return = vk->vkGetAccelerationStructureHandleNV(unboxed_device, accelerationStructure, dataSize, pData);
                vkStream->unsetHandleMapping();
                vkStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkStream->write(&vkGetAccelerationStructureHandleNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetAccelerationStructureHandleNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetAccelerationStructureHandleNV_VkResult_return, device, accelerationStructure, dataSize, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdWriteAccelerationStructuresPropertiesNV:
            {
                android::base::beginTrace("vkCmdWriteAccelerationStructuresPropertiesNV decode");
                VkCommandBuffer commandBuffer;
                uint32_t accelerationStructureCount;
                const VkAccelerationStructureNV* pAccelerationStructures;
                VkQueryType queryType;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&accelerationStructureCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pAccelerationStructures, ((accelerationStructureCount)) * sizeof(const VkAccelerationStructureNV));
                if (((accelerationStructureCount)))
                {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((accelerationStructureCount));
                    for (uint32_t k = 0; k < ((accelerationStructureCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkAccelerationStructureNV*)pAccelerationStructures) + k) = (VkAccelerationStructureNV)unbox_VkAccelerationStructureNV((VkAccelerationStructureNV)tmpval);
                    }
                }
                memcpy((VkQueryType*)&queryType, *readStreamPtrPtr, sizeof(VkQueryType));
                *readStreamPtrPtr += sizeof(VkQueryType);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_2));
                memcpy((uint32_t*)&firstQuery, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdWriteAccelerationStructuresPropertiesNV 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)accelerationStructureCount, (unsigned long long)pAccelerationStructures, (unsigned long long)queryType, (unsigned long long)queryPool, (unsigned long long)firstQuery);
                }
                vk->vkCmdWriteAccelerationStructuresPropertiesNV(unboxed_commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdWriteAccelerationStructuresPropertiesNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCompileDeferredNV:
            {
                android::base::beginTrace("vkCompileDeferredNV decode");
                VkDevice device;
                VkPipeline pipeline;
                uint32_t shader;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipeline*)&pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_1));
                memcpy((uint32_t*)&shader, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCompileDeferredNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipeline, (unsigned long long)shader);
                }
                VkResult vkCompileDeferredNV_VkResult_return = (VkResult)0;
                vkCompileDeferredNV_VkResult_return = vk->vkCompileDeferredNV(unboxed_device, pipeline, shader);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkCompileDeferredNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCompileDeferredNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCompileDeferredNV_VkResult_return, device, pipeline, shader);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_representative_fragment_test
#endif
#ifdef VK_EXT_filter_cubic
#endif
#ifdef VK_QCOM_render_pass_shader_resolve
#endif
#ifdef VK_EXT_global_priority
#endif
#ifdef VK_EXT_external_memory_host
            case OP_vkGetMemoryHostPointerPropertiesEXT:
            {
                android::base::beginTrace("vkGetMemoryHostPointerPropertiesEXT decode");
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                const void* pHostPointer;
                VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkExternalMemoryHandleTypeFlagBits*)&handleType, *readStreamPtrPtr, sizeof(VkExternalMemoryHandleTypeFlagBits));
                *readStreamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
                // WARNING PTR CHECK
                memcpy((void**)&pHostPointer, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pHostPointer);
                *readStreamPtrPtr += 8;
                if (pHostPointer)
                {
                    vkReadStream->alloc((void**)&pHostPointer, sizeof(const uint8_t));
                    memcpy((void*)pHostPointer, *readStreamPtrPtr, sizeof(const uint8_t));
                    *readStreamPtrPtr += sizeof(const uint8_t);
                }
                // Begin manual dispatchable handle unboxing for pMemoryHostPointerProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryHostPointerProperties, sizeof(VkMemoryHostPointerPropertiesEXT));
                reservedunmarshal_VkMemoryHostPointerPropertiesEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties), readStreamPtrPtr);
                if (pMemoryHostPointerProperties)
                {
                    transform_tohost_VkMemoryHostPointerPropertiesEXT(m_state, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryHostPointerPropertiesEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)handleType, (unsigned long long)pHostPointer, (unsigned long long)pMemoryHostPointerProperties);
                }
                VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return = (VkResult)0;
                vkGetMemoryHostPointerPropertiesEXT_VkResult_return = vk->vkGetMemoryHostPointerPropertiesEXT(unboxed_device, handleType, pHostPointer, pMemoryHostPointerProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryHostPointerProperties)
                {
                    transform_fromhost_VkMemoryHostPointerPropertiesEXT(m_state, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                }
                marshal_VkMemoryHostPointerPropertiesEXT(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                vkStream->write(&vkGetMemoryHostPointerPropertiesEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryHostPointerPropertiesEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryHostPointerPropertiesEXT_VkResult_return, device, handleType, pHostPointer, pMemoryHostPointerProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_AMD_buffer_marker
            case OP_vkCmdWriteBufferMarkerAMD:
            {
                android::base::beginTrace("vkCmdWriteBufferMarkerAMD decode");
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlagBits pipelineStage;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                uint32_t marker;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkPipelineStageFlagBits*)&pipelineStage, *readStreamPtrPtr, sizeof(VkPipelineStageFlagBits));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlagBits);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&dstOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&marker, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdWriteBufferMarkerAMD 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineStage, (unsigned long long)dstBuffer, (unsigned long long)dstOffset, (unsigned long long)marker);
                }
                vk->vkCmdWriteBufferMarkerAMD(unboxed_commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdWriteBufferMarkerAMD(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_AMD_pipeline_compiler_control
#endif
#ifdef VK_EXT_calibrated_timestamps
            case OP_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT:
            {
                android::base::beginTrace("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pTimeDomainCount;
                VkTimeDomainEXT* pTimeDomains;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pTimeDomainCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pTimeDomainCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pTimeDomainCount);
                *readStreamPtrPtr += 8;
                if (pTimeDomainCount)
                {
                    vkReadStream->alloc((void**)&pTimeDomainCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pTimeDomainCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pTimeDomains;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkTimeDomainEXT**)&pTimeDomains, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pTimeDomains);
                *readStreamPtrPtr += 8;
                if (pTimeDomains)
                {
                    vkReadStream->alloc((void**)&pTimeDomains, (*(pTimeDomainCount)) * sizeof(VkTimeDomainEXT));
                    memcpy((VkTimeDomainEXT*)pTimeDomains, *readStreamPtrPtr, (*(pTimeDomainCount)) * sizeof(VkTimeDomainEXT));
                    *readStreamPtrPtr += (*(pTimeDomainCount)) * sizeof(VkTimeDomainEXT);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceCalibrateableTimeDomainsEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pTimeDomainCount, (unsigned long long)pTimeDomains);
                }
                VkResult vkGetPhysicalDeviceCalibrateableTimeDomainsEXT_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceCalibrateableTimeDomainsEXT_VkResult_return = vk->vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(unboxed_physicalDevice, pTimeDomainCount, pTimeDomains);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pTimeDomainCount;
                vkStream->putBe64(cgen_var_3);
                if (pTimeDomainCount)
                {
                    vkStream->write((uint32_t*)pTimeDomainCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pTimeDomains;
                vkStream->putBe64(cgen_var_4);
                if (pTimeDomains)
                {
                    vkStream->write((VkTimeDomainEXT*)pTimeDomains, (*(pTimeDomainCount)) * sizeof(VkTimeDomainEXT));
                }
                vkStream->write(&vkGetPhysicalDeviceCalibrateableTimeDomainsEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceCalibrateableTimeDomainsEXT_VkResult_return, physicalDevice, pTimeDomainCount, pTimeDomains);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetCalibratedTimestampsEXT:
            {
                android::base::beginTrace("vkGetCalibratedTimestampsEXT decode");
                VkDevice device;
                uint32_t timestampCount;
                const VkCalibratedTimestampInfoEXT* pTimestampInfos;
                uint64_t* pTimestamps;
                uint64_t* pMaxDeviation;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&timestampCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pTimestampInfos, ((timestampCount)) * sizeof(const VkCalibratedTimestampInfoEXT));
                for (uint32_t i = 0; i < (uint32_t)((timestampCount)); ++i)
                {
                    reservedunmarshal_VkCalibratedTimestampInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCalibratedTimestampInfoEXT*)(pTimestampInfos + i), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pTimestamps;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pTimestamps, ((timestampCount)) * sizeof(uint64_t));
                memcpy((uint64_t*)pTimestamps, *readStreamPtrPtr, ((timestampCount)) * sizeof(uint64_t));
                *readStreamPtrPtr += ((timestampCount)) * sizeof(uint64_t);
                // Begin manual dispatchable handle unboxing for pMaxDeviation;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMaxDeviation, sizeof(uint64_t));
                memcpy((uint64_t*)pMaxDeviation, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                if (pTimestampInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((timestampCount)); ++i)
                    {
                        transform_tohost_VkCalibratedTimestampInfoEXT(m_state, (VkCalibratedTimestampInfoEXT*)(pTimestampInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetCalibratedTimestampsEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)timestampCount, (unsigned long long)pTimestampInfos, (unsigned long long)pTimestamps, (unsigned long long)pMaxDeviation);
                }
                VkResult vkGetCalibratedTimestampsEXT_VkResult_return = (VkResult)0;
                vkGetCalibratedTimestampsEXT_VkResult_return = vk->vkGetCalibratedTimestampsEXT(unboxed_device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
                vkStream->unsetHandleMapping();
                vkStream->write((uint64_t*)pTimestamps, ((timestampCount)) * sizeof(uint64_t));
                vkStream->write((uint64_t*)pMaxDeviation, sizeof(uint64_t));
                vkStream->write(&vkGetCalibratedTimestampsEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetCalibratedTimestampsEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetCalibratedTimestampsEXT_VkResult_return, device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_AMD_shader_core_properties
#endif
#ifdef VK_AMD_memory_overallocation_behavior
#endif
#ifdef VK_EXT_vertex_attribute_divisor
#endif
#ifdef VK_GGP_frame_token
#endif
#ifdef VK_EXT_pipeline_creation_feedback
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_compute_shader_derivatives
#endif
#ifdef VK_NV_mesh_shader
            case OP_vkCmdDrawMeshTasksNV:
            {
                android::base::beginTrace("vkCmdDrawMeshTasksNV decode");
                VkCommandBuffer commandBuffer;
                uint32_t taskCount;
                uint32_t firstTask;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&taskCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&firstTask, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawMeshTasksNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)taskCount, (unsigned long long)firstTask);
                }
                vk->vkCmdDrawMeshTasksNV(unboxed_commandBuffer, taskCount, firstTask);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawMeshTasksNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, taskCount, firstTask);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDrawMeshTasksIndirectNV:
            {
                android::base::beginTrace("vkCmdDrawMeshTasksIndirectNV decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&drawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawMeshTasksIndirectNV 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)drawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawMeshTasksIndirectNV(unboxed_commandBuffer, buffer, offset, drawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawMeshTasksIndirectNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, drawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdDrawMeshTasksIndirectCountNV:
            {
                android::base::beginTrace("vkCmdDrawMeshTasksIndirectCountNV decode");
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&countBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_2));
                memcpy((VkDeviceSize*)&countBufferOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&maxDrawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdDrawMeshTasksIndirectCountNV 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawMeshTasksIndirectCountNV(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawMeshTasksIndirectCountNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_fragment_shader_barycentric
#endif
#ifdef VK_NV_shader_image_footprint
#endif
#ifdef VK_NV_scissor_exclusive
            case OP_vkCmdSetExclusiveScissorNV:
            {
                android::base::beginTrace("vkCmdSetExclusiveScissorNV decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstExclusiveScissor;
                uint32_t exclusiveScissorCount;
                const VkRect2D* pExclusiveScissors;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstExclusiveScissor, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&exclusiveScissorCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pExclusiveScissors, ((exclusiveScissorCount)) * sizeof(const VkRect2D));
                for (uint32_t i = 0; i < (uint32_t)((exclusiveScissorCount)); ++i)
                {
                    reservedunmarshal_VkRect2D(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(pExclusiveScissors + i), readStreamPtrPtr);
                }
                if (pExclusiveScissors)
                {
                    for (uint32_t i = 0; i < (uint32_t)((exclusiveScissorCount)); ++i)
                    {
                        transform_tohost_VkRect2D(m_state, (VkRect2D*)(pExclusiveScissors + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetExclusiveScissorNV 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstExclusiveScissor, (unsigned long long)exclusiveScissorCount, (unsigned long long)pExclusiveScissors);
                }
                vk->vkCmdSetExclusiveScissorNV(unboxed_commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetExclusiveScissorNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
            case OP_vkCmdSetCheckpointNV:
            {
                android::base::beginTrace("vkCmdSetCheckpointNV decode");
                VkCommandBuffer commandBuffer;
                const void* pCheckpointMarker;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                // WARNING PTR CHECK
                memcpy((void**)&pCheckpointMarker, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCheckpointMarker);
                *readStreamPtrPtr += 8;
                if (pCheckpointMarker)
                {
                    vkReadStream->alloc((void**)&pCheckpointMarker, sizeof(const uint8_t));
                    memcpy((void*)pCheckpointMarker, *readStreamPtrPtr, sizeof(const uint8_t));
                    *readStreamPtrPtr += sizeof(const uint8_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetCheckpointNV 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pCheckpointMarker);
                }
                vk->vkCmdSetCheckpointNV(unboxed_commandBuffer, pCheckpointMarker);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetCheckpointNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pCheckpointMarker);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetQueueCheckpointDataNV:
            {
                android::base::beginTrace("vkGetQueueCheckpointDataNV decode");
                VkQueue queue;
                uint32_t* pCheckpointDataCount;
                VkCheckpointDataNV* pCheckpointData;
                // Begin non wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                // End manual dispatchable handle unboxing for queue;
                // Begin manual dispatchable handle unboxing for pCheckpointDataCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pCheckpointDataCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCheckpointDataCount);
                *readStreamPtrPtr += 8;
                if (pCheckpointDataCount)
                {
                    vkReadStream->alloc((void**)&pCheckpointDataCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pCheckpointDataCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pCheckpointData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkCheckpointDataNV**)&pCheckpointData, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCheckpointData);
                *readStreamPtrPtr += 8;
                if (pCheckpointData)
                {
                    vkReadStream->alloc((void**)&pCheckpointData, (*(pCheckpointDataCount)) * sizeof(VkCheckpointDataNV));
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        reservedunmarshal_VkCheckpointDataNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCheckpointDataNV*)(pCheckpointData + i), readStreamPtrPtr);
                    }
                }
                if (pCheckpointDataCount)
                {
                    if (pCheckpointData)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                        {
                            transform_tohost_VkCheckpointDataNV(m_state, (VkCheckpointDataNV*)(pCheckpointData + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetQueueCheckpointDataNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)pCheckpointDataCount, (unsigned long long)pCheckpointData);
                }
                vk->vkGetQueueCheckpointDataNV(unboxed_queue, pCheckpointDataCount, pCheckpointData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pCheckpointDataCount;
                vkStream->putBe64(cgen_var_3);
                if (pCheckpointDataCount)
                {
                    vkStream->write((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
                }
                if (pCheckpointDataCount)
                {
                    if (pCheckpointData)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                        {
                            transform_fromhost_VkCheckpointDataNV(m_state, (VkCheckpointDataNV*)(pCheckpointData + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pCheckpointData;
                vkStream->putBe64(cgen_var_4);
                if (pCheckpointData)
                {
                    if (pCheckpointDataCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                        {
                            marshal_VkCheckpointDataNV(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCheckpointDataNV*)(pCheckpointData + i));
                        }
                    }
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetQueueCheckpointDataNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, pCheckpointDataCount, pCheckpointData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_INTEL_shader_integer_functions2
#endif
#ifdef VK_INTEL_performance_query
            case OP_vkInitializePerformanceApiINTEL:
            {
                android::base::beginTrace("vkInitializePerformanceApiINTEL decode");
                VkDevice device;
                const VkInitializePerformanceApiInfoINTEL* pInitializeInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInitializeInfo, sizeof(const VkInitializePerformanceApiInfoINTEL));
                reservedunmarshal_VkInitializePerformanceApiInfoINTEL(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkInitializePerformanceApiInfoINTEL*)(pInitializeInfo), readStreamPtrPtr);
                if (pInitializeInfo)
                {
                    transform_tohost_VkInitializePerformanceApiInfoINTEL(m_state, (VkInitializePerformanceApiInfoINTEL*)(pInitializeInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkInitializePerformanceApiINTEL 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInitializeInfo);
                }
                VkResult vkInitializePerformanceApiINTEL_VkResult_return = (VkResult)0;
                vkInitializePerformanceApiINTEL_VkResult_return = vk->vkInitializePerformanceApiINTEL(unboxed_device, pInitializeInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkInitializePerformanceApiINTEL_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkInitializePerformanceApiINTEL(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkInitializePerformanceApiINTEL_VkResult_return, device, pInitializeInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkUninitializePerformanceApiINTEL:
            {
                android::base::beginTrace("vkUninitializePerformanceApiINTEL decode");
                VkDevice device;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkUninitializePerformanceApiINTEL 0x%llx \n", ioStream, (unsigned long long)device);
                }
                vk->vkUninitializePerformanceApiINTEL(unboxed_device);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUninitializePerformanceApiINTEL(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetPerformanceMarkerINTEL:
            {
                android::base::beginTrace("vkCmdSetPerformanceMarkerINTEL decode");
                VkCommandBuffer commandBuffer;
                const VkPerformanceMarkerInfoINTEL* pMarkerInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pMarkerInfo, sizeof(const VkPerformanceMarkerInfoINTEL));
                reservedunmarshal_VkPerformanceMarkerInfoINTEL(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceMarkerInfoINTEL*)(pMarkerInfo), readStreamPtrPtr);
                if (pMarkerInfo)
                {
                    transform_tohost_VkPerformanceMarkerInfoINTEL(m_state, (VkPerformanceMarkerInfoINTEL*)(pMarkerInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetPerformanceMarkerINTEL 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pMarkerInfo);
                }
                VkResult vkCmdSetPerformanceMarkerINTEL_VkResult_return = (VkResult)0;
                vkCmdSetPerformanceMarkerINTEL_VkResult_return = vk->vkCmdSetPerformanceMarkerINTEL(unboxed_commandBuffer, pMarkerInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkCmdSetPerformanceMarkerINTEL_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetPerformanceMarkerINTEL(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCmdSetPerformanceMarkerINTEL_VkResult_return, commandBuffer, pMarkerInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetPerformanceStreamMarkerINTEL:
            {
                android::base::beginTrace("vkCmdSetPerformanceStreamMarkerINTEL decode");
                VkCommandBuffer commandBuffer;
                const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pMarkerInfo, sizeof(const VkPerformanceStreamMarkerInfoINTEL));
                reservedunmarshal_VkPerformanceStreamMarkerInfoINTEL(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceStreamMarkerInfoINTEL*)(pMarkerInfo), readStreamPtrPtr);
                if (pMarkerInfo)
                {
                    transform_tohost_VkPerformanceStreamMarkerInfoINTEL(m_state, (VkPerformanceStreamMarkerInfoINTEL*)(pMarkerInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetPerformanceStreamMarkerINTEL 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pMarkerInfo);
                }
                VkResult vkCmdSetPerformanceStreamMarkerINTEL_VkResult_return = (VkResult)0;
                vkCmdSetPerformanceStreamMarkerINTEL_VkResult_return = vk->vkCmdSetPerformanceStreamMarkerINTEL(unboxed_commandBuffer, pMarkerInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkCmdSetPerformanceStreamMarkerINTEL_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetPerformanceStreamMarkerINTEL(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCmdSetPerformanceStreamMarkerINTEL_VkResult_return, commandBuffer, pMarkerInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetPerformanceOverrideINTEL:
            {
                android::base::beginTrace("vkCmdSetPerformanceOverrideINTEL decode");
                VkCommandBuffer commandBuffer;
                const VkPerformanceOverrideInfoINTEL* pOverrideInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pOverrideInfo, sizeof(const VkPerformanceOverrideInfoINTEL));
                reservedunmarshal_VkPerformanceOverrideInfoINTEL(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceOverrideInfoINTEL*)(pOverrideInfo), readStreamPtrPtr);
                if (pOverrideInfo)
                {
                    transform_tohost_VkPerformanceOverrideInfoINTEL(m_state, (VkPerformanceOverrideInfoINTEL*)(pOverrideInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetPerformanceOverrideINTEL 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pOverrideInfo);
                }
                VkResult vkCmdSetPerformanceOverrideINTEL_VkResult_return = (VkResult)0;
                vkCmdSetPerformanceOverrideINTEL_VkResult_return = vk->vkCmdSetPerformanceOverrideINTEL(unboxed_commandBuffer, pOverrideInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkCmdSetPerformanceOverrideINTEL_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetPerformanceOverrideINTEL(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCmdSetPerformanceOverrideINTEL_VkResult_return, commandBuffer, pOverrideInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkAcquirePerformanceConfigurationINTEL:
            {
                android::base::beginTrace("vkAcquirePerformanceConfigurationINTEL decode");
                VkDevice device;
                const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo;
                VkPerformanceConfigurationINTEL* pConfiguration;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pAcquireInfo, sizeof(const VkPerformanceConfigurationAcquireInfoINTEL));
                reservedunmarshal_VkPerformanceConfigurationAcquireInfoINTEL(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceConfigurationAcquireInfoINTEL*)(pAcquireInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pConfiguration;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pConfiguration, sizeof(VkPerformanceConfigurationINTEL));
                memcpy((VkPerformanceConfigurationINTEL*)&(*pConfiguration), (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&(*pConfiguration));
                *readStreamPtrPtr += 8;
                if (pAcquireInfo)
                {
                    transform_tohost_VkPerformanceConfigurationAcquireInfoINTEL(m_state, (VkPerformanceConfigurationAcquireInfoINTEL*)(pAcquireInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAcquirePerformanceConfigurationINTEL 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAcquireInfo, (unsigned long long)pConfiguration);
                }
                VkResult vkAcquirePerformanceConfigurationINTEL_VkResult_return = (VkResult)0;
                vkAcquirePerformanceConfigurationINTEL_VkResult_return = vk->vkAcquirePerformanceConfigurationINTEL(unboxed_device, pAcquireInfo, pConfiguration);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_2 = (uint64_t)(*pConfiguration);
                vkStream->putBe64(cgen_var_2);
                vkStream->write(&vkAcquirePerformanceConfigurationINTEL_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquirePerformanceConfigurationINTEL(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquirePerformanceConfigurationINTEL_VkResult_return, device, pAcquireInfo, pConfiguration);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkReleasePerformanceConfigurationINTEL:
            {
                android::base::beginTrace("vkReleasePerformanceConfigurationINTEL decode");
                VkDevice device;
                VkPerformanceConfigurationINTEL configuration;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkPerformanceConfigurationINTEL*)&configuration, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&configuration);
                *readStreamPtrPtr += 8;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkReleasePerformanceConfigurationINTEL 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)configuration);
                }
                VkResult vkReleasePerformanceConfigurationINTEL_VkResult_return = (VkResult)0;
                vkReleasePerformanceConfigurationINTEL_VkResult_return = vk->vkReleasePerformanceConfigurationINTEL(unboxed_device, configuration);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkReleasePerformanceConfigurationINTEL_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkReleasePerformanceConfigurationINTEL(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkReleasePerformanceConfigurationINTEL_VkResult_return, device, configuration);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueSetPerformanceConfigurationINTEL:
            {
                android::base::beginTrace("vkQueueSetPerformanceConfigurationINTEL decode");
                VkQueue queue;
                VkPerformanceConfigurationINTEL configuration;
                // Begin non wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                // End manual dispatchable handle unboxing for queue;
                memcpy((VkPerformanceConfigurationINTEL*)&configuration, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&configuration);
                *readStreamPtrPtr += 8;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueSetPerformanceConfigurationINTEL 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)configuration);
                }
                VkResult vkQueueSetPerformanceConfigurationINTEL_VkResult_return = (VkResult)0;
                vkQueueSetPerformanceConfigurationINTEL_VkResult_return = vk->vkQueueSetPerformanceConfigurationINTEL(unboxed_queue, configuration);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueueSetPerformanceConfigurationINTEL_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueSetPerformanceConfigurationINTEL(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueueSetPerformanceConfigurationINTEL_VkResult_return, queue, configuration);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPerformanceParameterINTEL:
            {
                android::base::beginTrace("vkGetPerformanceParameterINTEL decode");
                VkDevice device;
                VkPerformanceParameterTypeINTEL parameter;
                VkPerformanceValueINTEL* pValue;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkPerformanceParameterTypeINTEL*)&parameter, *readStreamPtrPtr, sizeof(VkPerformanceParameterTypeINTEL));
                *readStreamPtrPtr += sizeof(VkPerformanceParameterTypeINTEL);
                // Begin manual dispatchable handle unboxing for pValue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pValue, sizeof(VkPerformanceValueINTEL));
                reservedunmarshal_VkPerformanceValueINTEL(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceValueINTEL*)(pValue), readStreamPtrPtr);
                if (pValue)
                {
                    transform_tohost_VkPerformanceValueINTEL(m_state, (VkPerformanceValueINTEL*)(pValue));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPerformanceParameterINTEL 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)parameter, (unsigned long long)pValue);
                }
                VkResult vkGetPerformanceParameterINTEL_VkResult_return = (VkResult)0;
                vkGetPerformanceParameterINTEL_VkResult_return = vk->vkGetPerformanceParameterINTEL(unboxed_device, parameter, pValue);
                vkStream->unsetHandleMapping();
                if (pValue)
                {
                    transform_fromhost_VkPerformanceValueINTEL(m_state, (VkPerformanceValueINTEL*)(pValue));
                }
                marshal_VkPerformanceValueINTEL(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceValueINTEL*)(pValue));
                vkStream->write(&vkGetPerformanceParameterINTEL_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPerformanceParameterINTEL(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPerformanceParameterINTEL_VkResult_return, device, parameter, pValue);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_pci_bus_info
#endif
#ifdef VK_AMD_display_native_hdr
            case OP_vkSetLocalDimmingAMD:
            {
                android::base::beginTrace("vkSetLocalDimmingAMD decode");
                VkDevice device;
                VkSwapchainKHR swapChain;
                VkBool32 localDimmingEnable;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapChain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_1));
                memcpy((VkBool32*)&localDimmingEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSetLocalDimmingAMD 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapChain, (unsigned long long)localDimmingEnable);
                }
                vk->vkSetLocalDimmingAMD(unboxed_device, swapChain, localDimmingEnable);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetLocalDimmingAMD(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, swapChain, localDimmingEnable);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_FUCHSIA_imagepipe_surface
            case OP_vkCreateImagePipeSurfaceFUCHSIA:
            {
                android::base::beginTrace("vkCreateImagePipeSurfaceFUCHSIA decode");
                VkInstance instance;
                const VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImagePipeSurfaceCreateInfoFUCHSIA));
                reservedunmarshal_VkImagePipeSurfaceCreateInfoFUCHSIA(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImagePipeSurfaceCreateInfoFUCHSIA*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkImagePipeSurfaceCreateInfoFUCHSIA(m_state, (VkImagePipeSurfaceCreateInfoFUCHSIA*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateImagePipeSurfaceFUCHSIA 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateImagePipeSurfaceFUCHSIA_VkResult_return = (VkResult)0;
                vkCreateImagePipeSurfaceFUCHSIA_VkResult_return = vk->vkCreateImagePipeSurfaceFUCHSIA(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkCreateImagePipeSurfaceFUCHSIA_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateImagePipeSurfaceFUCHSIA(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateImagePipeSurfaceFUCHSIA_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_metal_surface
            case OP_vkCreateMetalSurfaceEXT:
            {
                android::base::beginTrace("vkCreateMetalSurfaceEXT decode");
                // Decoding vkCreateMetalSurfaceEXT is not supported. This should not run.
                fprintf(stderr, "stream %p: fatal: decoding unsupported API vkCreateMetalSurfaceEXT\n", ioStream);
                __builtin_trap();
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_fragment_density_map
#endif
#ifdef VK_EXT_scalar_block_layout
#endif
#ifdef VK_GOOGLE_hlsl_functionality1
#endif
#ifdef VK_GOOGLE_decorate_string
#endif
#ifdef VK_EXT_subgroup_size_control
#endif
#ifdef VK_AMD_shader_core_properties2
#endif
#ifdef VK_AMD_device_coherent_memory
#endif
#ifdef VK_EXT_shader_image_atomic_int64
#endif
#ifdef VK_EXT_memory_budget
#endif
#ifdef VK_EXT_memory_priority
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
#endif
#ifdef VK_EXT_buffer_device_address
            case OP_vkGetBufferDeviceAddressEXT:
            {
                android::base::beginTrace("vkGetBufferDeviceAddressEXT decode");
                VkDevice device;
                const VkBufferDeviceAddressInfo* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferDeviceAddressInfo));
                reservedunmarshal_VkBufferDeviceAddressInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkBufferDeviceAddressInfo(m_state, (VkBufferDeviceAddressInfo*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetBufferDeviceAddressEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo);
                }
                VkDeviceAddress vkGetBufferDeviceAddressEXT_VkDeviceAddress_return = (VkDeviceAddress)0;
                vkGetBufferDeviceAddressEXT_VkDeviceAddress_return = vk->vkGetBufferDeviceAddressEXT(unboxed_device, pInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetBufferDeviceAddressEXT_VkDeviceAddress_return, sizeof(VkDeviceAddress));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetBufferDeviceAddressEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetBufferDeviceAddressEXT_VkDeviceAddress_return, device, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_tooling_info
            case OP_vkGetPhysicalDeviceToolPropertiesEXT:
            {
                android::base::beginTrace("vkGetPhysicalDeviceToolPropertiesEXT decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pToolCount;
                VkPhysicalDeviceToolPropertiesEXT* pToolProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pToolCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pToolCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pToolCount);
                *readStreamPtrPtr += 8;
                if (pToolCount)
                {
                    vkReadStream->alloc((void**)&pToolCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pToolCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pToolProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPhysicalDeviceToolPropertiesEXT**)&pToolProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pToolProperties);
                *readStreamPtrPtr += 8;
                if (pToolProperties)
                {
                    vkReadStream->alloc((void**)&pToolProperties, (*(pToolCount)) * sizeof(VkPhysicalDeviceToolPropertiesEXT));
                    for (uint32_t i = 0; i < (uint32_t)(*(pToolCount)); ++i)
                    {
                        reservedunmarshal_VkPhysicalDeviceToolPropertiesEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceToolPropertiesEXT*)(pToolProperties + i), readStreamPtrPtr);
                    }
                }
                if (pToolCount)
                {
                    if (pToolProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pToolCount)); ++i)
                        {
                            transform_tohost_VkPhysicalDeviceToolPropertiesEXT(m_state, (VkPhysicalDeviceToolPropertiesEXT*)(pToolProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceToolPropertiesEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pToolCount, (unsigned long long)pToolProperties);
                }
                VkResult vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return = vk->vkGetPhysicalDeviceToolPropertiesEXT(unboxed_physicalDevice, pToolCount, pToolProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pToolCount;
                vkStream->putBe64(cgen_var_3);
                if (pToolCount)
                {
                    vkStream->write((uint32_t*)pToolCount, sizeof(uint32_t));
                }
                if (pToolCount)
                {
                    if (pToolProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pToolCount)); ++i)
                        {
                            transform_fromhost_VkPhysicalDeviceToolPropertiesEXT(m_state, (VkPhysicalDeviceToolPropertiesEXT*)(pToolProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pToolProperties;
                vkStream->putBe64(cgen_var_4);
                if (pToolProperties)
                {
                    if (pToolCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pToolCount)); ++i)
                        {
                            marshal_VkPhysicalDeviceToolPropertiesEXT(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceToolPropertiesEXT*)(pToolProperties + i));
                        }
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceToolPropertiesEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return, physicalDevice, pToolCount, pToolProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_separate_stencil_usage
#endif
#ifdef VK_EXT_validation_features
#endif
#ifdef VK_NV_cooperative_matrix
            case OP_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV:
            {
                android::base::beginTrace("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkCooperativeMatrixPropertiesNV* pProperties;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPropertyCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPropertyCount);
                *readStreamPtrPtr += 8;
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPropertyCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkCooperativeMatrixPropertiesNV**)&pProperties, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pProperties);
                *readStreamPtrPtr += 8;
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkCooperativeMatrixPropertiesNV));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        reservedunmarshal_VkCooperativeMatrixPropertiesNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCooperativeMatrixPropertiesNV*)(pProperties + i), readStreamPtrPtr);
                    }
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_tohost_VkCooperativeMatrixPropertiesNV(m_state, (VkCooperativeMatrixPropertiesNV*)(pProperties + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceCooperativeMatrixPropertiesNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesNV_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceCooperativeMatrixPropertiesNV_VkResult_return = vk->vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_3);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pPropertyCount)
                {
                    if (pProperties)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            transform_fromhost_VkCooperativeMatrixPropertiesNV(m_state, (VkCooperativeMatrixPropertiesNV*)(pProperties + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_4);
                if (pProperties)
                {
                    if (pPropertyCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                        {
                            marshal_VkCooperativeMatrixPropertiesNV(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCooperativeMatrixPropertiesNV*)(pProperties + i));
                        }
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceCooperativeMatrixPropertiesNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceCooperativeMatrixPropertiesNV_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_NV_coverage_reduction_mode
            case OP_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV decode");
                VkPhysicalDevice physicalDevice;
                uint32_t* pCombinationCount;
                VkFramebufferMixedSamplesCombinationNV* pCombinations;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pCombinationCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pCombinationCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCombinationCount);
                *readStreamPtrPtr += 8;
                if (pCombinationCount)
                {
                    vkReadStream->alloc((void**)&pCombinationCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pCombinationCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pCombinations;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkFramebufferMixedSamplesCombinationNV**)&pCombinations, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCombinations);
                *readStreamPtrPtr += 8;
                if (pCombinations)
                {
                    vkReadStream->alloc((void**)&pCombinations, (*(pCombinationCount)) * sizeof(VkFramebufferMixedSamplesCombinationNV));
                    for (uint32_t i = 0; i < (uint32_t)(*(pCombinationCount)); ++i)
                    {
                        reservedunmarshal_VkFramebufferMixedSamplesCombinationNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFramebufferMixedSamplesCombinationNV*)(pCombinations + i), readStreamPtrPtr);
                    }
                }
                if (pCombinationCount)
                {
                    if (pCombinations)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pCombinationCount)); ++i)
                        {
                            transform_tohost_VkFramebufferMixedSamplesCombinationNV(m_state, (VkFramebufferMixedSamplesCombinationNV*)(pCombinations + i));
                        }
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pCombinationCount, (unsigned long long)pCombinations);
                }
                VkResult vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV_VkResult_return = vk->vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(unboxed_physicalDevice, pCombinationCount, pCombinations);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pCombinationCount;
                vkStream->putBe64(cgen_var_3);
                if (pCombinationCount)
                {
                    vkStream->write((uint32_t*)pCombinationCount, sizeof(uint32_t));
                }
                if (pCombinationCount)
                {
                    if (pCombinations)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pCombinationCount)); ++i)
                        {
                            transform_fromhost_VkFramebufferMixedSamplesCombinationNV(m_state, (VkFramebufferMixedSamplesCombinationNV*)(pCombinations + i));
                        }
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pCombinations;
                vkStream->putBe64(cgen_var_4);
                if (pCombinations)
                {
                    if (pCombinationCount)
                    {
                        for (uint32_t i = 0; i < (uint32_t)(*(pCombinationCount)); ++i)
                        {
                            marshal_VkFramebufferMixedSamplesCombinationNV(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFramebufferMixedSamplesCombinationNV*)(pCombinations + i));
                        }
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV_VkResult_return, physicalDevice, pCombinationCount, pCombinations);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_fragment_shader_interlock
#endif
#ifdef VK_EXT_ycbcr_image_arrays
#endif
#ifdef VK_EXT_full_screen_exclusive
            case OP_vkGetPhysicalDeviceSurfacePresentModes2EXT:
            {
                android::base::beginTrace("vkGetPhysicalDeviceSurfacePresentModes2EXT decode");
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
                uint32_t* pPresentModeCount;
                VkPresentModeKHR* pPresentModes;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
                reservedunmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pPresentModeCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pPresentModeCount, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPresentModeCount);
                *readStreamPtrPtr += 8;
                if (pPresentModeCount)
                {
                    vkReadStream->alloc((void**)&pPresentModeCount, sizeof(uint32_t));
                    memcpy((uint32_t*)pPresentModeCount, *readStreamPtrPtr, sizeof(uint32_t));
                    *readStreamPtrPtr += sizeof(uint32_t);
                }
                // Begin manual dispatchable handle unboxing for pPresentModes;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkPresentModeKHR**)&pPresentModes, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPresentModes);
                *readStreamPtrPtr += 8;
                if (pPresentModes)
                {
                    vkReadStream->alloc((void**)&pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                    memcpy((VkPresentModeKHR*)pPresentModes, *readStreamPtrPtr, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                    *readStreamPtrPtr += (*(pPresentModeCount)) * sizeof(VkPresentModeKHR);
                }
                if (pSurfaceInfo)
                {
                    transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(m_state, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceSurfacePresentModes2EXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pSurfaceInfo, (unsigned long long)pPresentModeCount, (unsigned long long)pPresentModes);
                }
                VkResult vkGetPhysicalDeviceSurfacePresentModes2EXT_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfacePresentModes2EXT_VkResult_return = vk->vkGetPhysicalDeviceSurfacePresentModes2EXT(unboxed_physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPresentModeCount;
                vkStream->putBe64(cgen_var_3);
                if (pPresentModeCount)
                {
                    vkStream->write((uint32_t*)pPresentModeCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pPresentModes;
                vkStream->putBe64(cgen_var_4);
                if (pPresentModes)
                {
                    vkStream->write((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                }
                vkStream->write(&vkGetPhysicalDeviceSurfacePresentModes2EXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfacePresentModes2EXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfacePresentModes2EXT_VkResult_return, physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkAcquireFullScreenExclusiveModeEXT:
            {
                android::base::beginTrace("vkAcquireFullScreenExclusiveModeEXT decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_1));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkAcquireFullScreenExclusiveModeEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain);
                }
                VkResult vkAcquireFullScreenExclusiveModeEXT_VkResult_return = (VkResult)0;
                vkAcquireFullScreenExclusiveModeEXT_VkResult_return = vk->vkAcquireFullScreenExclusiveModeEXT(unboxed_device, swapchain);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkAcquireFullScreenExclusiveModeEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquireFullScreenExclusiveModeEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquireFullScreenExclusiveModeEXT_VkResult_return, device, swapchain);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkReleaseFullScreenExclusiveModeEXT:
            {
                android::base::beginTrace("vkReleaseFullScreenExclusiveModeEXT decode");
                VkDevice device;
                VkSwapchainKHR swapchain;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkSwapchainKHR*)&swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_1));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkReleaseFullScreenExclusiveModeEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain);
                }
                VkResult vkReleaseFullScreenExclusiveModeEXT_VkResult_return = (VkResult)0;
                vkReleaseFullScreenExclusiveModeEXT_VkResult_return = vk->vkReleaseFullScreenExclusiveModeEXT(unboxed_device, swapchain);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkReleaseFullScreenExclusiveModeEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkReleaseFullScreenExclusiveModeEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkReleaseFullScreenExclusiveModeEXT_VkResult_return, device, swapchain);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceGroupSurfacePresentModes2EXT:
            {
                android::base::beginTrace("vkGetDeviceGroupSurfacePresentModes2EXT decode");
                VkDevice device;
                const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
                VkDeviceGroupPresentModeFlagsKHR* pModes;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
                reservedunmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pModes;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((VkDeviceGroupPresentModeFlagsKHR**)&pModes, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pModes);
                *readStreamPtrPtr += 8;
                if (pModes)
                {
                    vkReadStream->alloc((void**)&pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                    memcpy((VkDeviceGroupPresentModeFlagsKHR*)pModes, *readStreamPtrPtr, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                    *readStreamPtrPtr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
                }
                if (pSurfaceInfo)
                {
                    transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(m_state, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceGroupSurfacePresentModes2EXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pSurfaceInfo, (unsigned long long)pModes);
                }
                VkResult vkGetDeviceGroupSurfacePresentModes2EXT_VkResult_return = (VkResult)0;
                vkGetDeviceGroupSurfacePresentModes2EXT_VkResult_return = vk->vkGetDeviceGroupSurfacePresentModes2EXT(unboxed_device, pSurfaceInfo, pModes);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pModes;
                vkStream->putBe64(cgen_var_2);
                if (pModes)
                {
                    vkStream->write((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                }
                vkStream->write(&vkGetDeviceGroupSurfacePresentModes2EXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceGroupSurfacePresentModes2EXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDeviceGroupSurfacePresentModes2EXT_VkResult_return, device, pSurfaceInfo, pModes);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_headless_surface
            case OP_vkCreateHeadlessSurfaceEXT:
            {
                android::base::beginTrace("vkCreateHeadlessSurfaceEXT decode");
                VkInstance instance;
                const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkHeadlessSurfaceCreateInfoEXT));
                reservedunmarshal_VkHeadlessSurfaceCreateInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkHeadlessSurfaceCreateInfoEXT*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkHeadlessSurfaceCreateInfoEXT(m_state, (VkHeadlessSurfaceCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateHeadlessSurfaceEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateHeadlessSurfaceEXT_VkResult_return = (VkResult)0;
                vkCreateHeadlessSurfaceEXT_VkResult_return = vk->vkCreateHeadlessSurfaceEXT(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkCreateHeadlessSurfaceEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateHeadlessSurfaceEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateHeadlessSurfaceEXT_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_line_rasterization
            case OP_vkCmdSetLineStippleEXT:
            {
                android::base::beginTrace("vkCmdSetLineStippleEXT decode");
                VkCommandBuffer commandBuffer;
                uint32_t lineStippleFactor;
                uint16_t lineStipplePattern;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&lineStippleFactor, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint16_t*)&lineStipplePattern, *readStreamPtrPtr, sizeof(uint16_t));
                *readStreamPtrPtr += sizeof(uint16_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetLineStippleEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)lineStippleFactor, (unsigned long long)lineStipplePattern);
                }
                vk->vkCmdSetLineStippleEXT(unboxed_commandBuffer, lineStippleFactor, lineStipplePattern);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetLineStippleEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, lineStippleFactor, lineStipplePattern);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_shader_atomic_float
#endif
#ifdef VK_EXT_host_query_reset
            case OP_vkResetQueryPoolEXT:
            {
                android::base::beginTrace("vkResetQueryPoolEXT decode");
                VkDevice device;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_1));
                memcpy((uint32_t*)&firstQuery, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&queryCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkResetQueryPoolEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)queryPool, (unsigned long long)firstQuery, (unsigned long long)queryCount);
                }
                vk->vkResetQueryPoolEXT(unboxed_device, queryPool, firstQuery, queryCount);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetQueryPoolEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, queryPool, firstQuery, queryCount);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_index_type_uint8
#endif
#ifdef VK_EXT_extended_dynamic_state
            case OP_vkCmdSetCullModeEXT:
            {
                android::base::beginTrace("vkCmdSetCullModeEXT decode");
                VkCommandBuffer commandBuffer;
                VkCullModeFlags cullMode;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkCullModeFlags*)&cullMode, *readStreamPtrPtr, sizeof(VkCullModeFlags));
                *readStreamPtrPtr += sizeof(VkCullModeFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetCullModeEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)cullMode);
                }
                vk->vkCmdSetCullModeEXT(unboxed_commandBuffer, cullMode);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetCullModeEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, cullMode);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetFrontFaceEXT:
            {
                android::base::beginTrace("vkCmdSetFrontFaceEXT decode");
                VkCommandBuffer commandBuffer;
                VkFrontFace frontFace;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkFrontFace*)&frontFace, *readStreamPtrPtr, sizeof(VkFrontFace));
                *readStreamPtrPtr += sizeof(VkFrontFace);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetFrontFaceEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)frontFace);
                }
                vk->vkCmdSetFrontFaceEXT(unboxed_commandBuffer, frontFace);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetFrontFaceEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, frontFace);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetPrimitiveTopologyEXT:
            {
                android::base::beginTrace("vkCmdSetPrimitiveTopologyEXT decode");
                VkCommandBuffer commandBuffer;
                VkPrimitiveTopology primitiveTopology;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkPrimitiveTopology*)&primitiveTopology, *readStreamPtrPtr, sizeof(VkPrimitiveTopology));
                *readStreamPtrPtr += sizeof(VkPrimitiveTopology);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetPrimitiveTopologyEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)primitiveTopology);
                }
                vk->vkCmdSetPrimitiveTopologyEXT(unboxed_commandBuffer, primitiveTopology);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetPrimitiveTopologyEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, primitiveTopology);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetViewportWithCountEXT:
            {
                android::base::beginTrace("vkCmdSetViewportWithCountEXT decode");
                VkCommandBuffer commandBuffer;
                uint32_t viewportCount;
                const VkViewport* pViewports;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&viewportCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pViewports, ((viewportCount)) * sizeof(const VkViewport));
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                {
                    reservedunmarshal_VkViewport(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkViewport*)(pViewports + i), readStreamPtrPtr);
                }
                if (pViewports)
                {
                    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                    {
                        transform_tohost_VkViewport(m_state, (VkViewport*)(pViewports + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetViewportWithCountEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)viewportCount, (unsigned long long)pViewports);
                }
                vk->vkCmdSetViewportWithCountEXT(unboxed_commandBuffer, viewportCount, pViewports);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetViewportWithCountEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, viewportCount, pViewports);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetScissorWithCountEXT:
            {
                android::base::beginTrace("vkCmdSetScissorWithCountEXT decode");
                VkCommandBuffer commandBuffer;
                uint32_t scissorCount;
                const VkRect2D* pScissors;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&scissorCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pScissors, ((scissorCount)) * sizeof(const VkRect2D));
                for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
                {
                    reservedunmarshal_VkRect2D(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(pScissors + i), readStreamPtrPtr);
                }
                if (pScissors)
                {
                    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
                    {
                        transform_tohost_VkRect2D(m_state, (VkRect2D*)(pScissors + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetScissorWithCountEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)scissorCount, (unsigned long long)pScissors);
                }
                vk->vkCmdSetScissorWithCountEXT(unboxed_commandBuffer, scissorCount, pScissors);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetScissorWithCountEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, scissorCount, pScissors);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBindVertexBuffers2EXT:
            {
                android::base::beginTrace("vkCmdBindVertexBuffers2EXT decode");
                VkCommandBuffer commandBuffer;
                uint32_t firstBinding;
                uint32_t bindingCount;
                const VkBuffer* pBuffers;
                const VkDeviceSize* pOffsets;
                const VkDeviceSize* pSizes;
                const VkDeviceSize* pStrides;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&firstBinding, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&bindingCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
                if (((bindingCount)))
                {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((bindingCount));
                    for (uint32_t k = 0; k < ((bindingCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkBuffer*)pBuffers) + k) = (VkBuffer)unbox_VkBuffer((VkBuffer)tmpval);
                    }
                }
                vkReadStream->alloc((void**)&pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
                memcpy((VkDeviceSize*)pOffsets, *readStreamPtrPtr, ((bindingCount)) * sizeof(const VkDeviceSize));
                *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                // WARNING PTR CHECK
                memcpy((VkDeviceSize**)&pSizes, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSizes);
                *readStreamPtrPtr += 8;
                if (pSizes)
                {
                    vkReadStream->alloc((void**)&pSizes, ((bindingCount)) * sizeof(const VkDeviceSize));
                    memcpy((VkDeviceSize*)pSizes, *readStreamPtrPtr, ((bindingCount)) * sizeof(const VkDeviceSize));
                    *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                }
                // WARNING PTR CHECK
                memcpy((VkDeviceSize**)&pStrides, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pStrides);
                *readStreamPtrPtr += 8;
                if (pStrides)
                {
                    vkReadStream->alloc((void**)&pStrides, ((bindingCount)) * sizeof(const VkDeviceSize));
                    memcpy((VkDeviceSize*)pStrides, *readStreamPtrPtr, ((bindingCount)) * sizeof(const VkDeviceSize));
                    *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBindVertexBuffers2EXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstBinding, (unsigned long long)bindingCount, (unsigned long long)pBuffers, (unsigned long long)pOffsets, (unsigned long long)pSizes, (unsigned long long)pStrides);
                }
                vk->vkCmdBindVertexBuffers2EXT(unboxed_commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindVertexBuffers2EXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetDepthTestEnableEXT:
            {
                android::base::beginTrace("vkCmdSetDepthTestEnableEXT decode");
                VkCommandBuffer commandBuffer;
                VkBool32 depthTestEnable;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkBool32*)&depthTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetDepthTestEnableEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)depthTestEnable);
                }
                vk->vkCmdSetDepthTestEnableEXT(unboxed_commandBuffer, depthTestEnable);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDepthTestEnableEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, depthTestEnable);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetDepthWriteEnableEXT:
            {
                android::base::beginTrace("vkCmdSetDepthWriteEnableEXT decode");
                VkCommandBuffer commandBuffer;
                VkBool32 depthWriteEnable;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkBool32*)&depthWriteEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetDepthWriteEnableEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)depthWriteEnable);
                }
                vk->vkCmdSetDepthWriteEnableEXT(unboxed_commandBuffer, depthWriteEnable);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDepthWriteEnableEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, depthWriteEnable);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetDepthCompareOpEXT:
            {
                android::base::beginTrace("vkCmdSetDepthCompareOpEXT decode");
                VkCommandBuffer commandBuffer;
                VkCompareOp depthCompareOp;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkCompareOp*)&depthCompareOp, *readStreamPtrPtr, sizeof(VkCompareOp));
                *readStreamPtrPtr += sizeof(VkCompareOp);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetDepthCompareOpEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)depthCompareOp);
                }
                vk->vkCmdSetDepthCompareOpEXT(unboxed_commandBuffer, depthCompareOp);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDepthCompareOpEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, depthCompareOp);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetDepthBoundsTestEnableEXT:
            {
                android::base::beginTrace("vkCmdSetDepthBoundsTestEnableEXT decode");
                VkCommandBuffer commandBuffer;
                VkBool32 depthBoundsTestEnable;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkBool32*)&depthBoundsTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetDepthBoundsTestEnableEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)depthBoundsTestEnable);
                }
                vk->vkCmdSetDepthBoundsTestEnableEXT(unboxed_commandBuffer, depthBoundsTestEnable);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDepthBoundsTestEnableEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, depthBoundsTestEnable);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetStencilTestEnableEXT:
            {
                android::base::beginTrace("vkCmdSetStencilTestEnableEXT decode");
                VkCommandBuffer commandBuffer;
                VkBool32 stencilTestEnable;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkBool32*)&stencilTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetStencilTestEnableEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)stencilTestEnable);
                }
                vk->vkCmdSetStencilTestEnableEXT(unboxed_commandBuffer, stencilTestEnable);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetStencilTestEnableEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, stencilTestEnable);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetStencilOpEXT:
            {
                android::base::beginTrace("vkCmdSetStencilOpEXT decode");
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                VkStencilOp failOp;
                VkStencilOp passOp;
                VkStencilOp depthFailOp;
                VkCompareOp compareOp;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkStencilFaceFlags*)&faceMask, *readStreamPtrPtr, sizeof(VkStencilFaceFlags));
                *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                memcpy((VkStencilOp*)&failOp, *readStreamPtrPtr, sizeof(VkStencilOp));
                *readStreamPtrPtr += sizeof(VkStencilOp);
                memcpy((VkStencilOp*)&passOp, *readStreamPtrPtr, sizeof(VkStencilOp));
                *readStreamPtrPtr += sizeof(VkStencilOp);
                memcpy((VkStencilOp*)&depthFailOp, *readStreamPtrPtr, sizeof(VkStencilOp));
                *readStreamPtrPtr += sizeof(VkStencilOp);
                memcpy((VkCompareOp*)&compareOp, *readStreamPtrPtr, sizeof(VkCompareOp));
                *readStreamPtrPtr += sizeof(VkCompareOp);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetStencilOpEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)faceMask, (unsigned long long)failOp, (unsigned long long)passOp, (unsigned long long)depthFailOp, (unsigned long long)compareOp);
                }
                vk->vkCmdSetStencilOpEXT(unboxed_commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetStencilOpEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
#endif
#ifdef VK_NV_device_generated_commands
            case OP_vkGetGeneratedCommandsMemoryRequirementsNV:
            {
                android::base::beginTrace("vkGetGeneratedCommandsMemoryRequirementsNV decode");
                VkDevice device;
                const VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkGeneratedCommandsMemoryRequirementsInfoNV));
                reservedunmarshal_VkGeneratedCommandsMemoryRequirementsInfoNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkGeneratedCommandsMemoryRequirementsInfoNV*)(pInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                reservedunmarshal_VkMemoryRequirements2(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkGeneratedCommandsMemoryRequirementsInfoNV(m_state, (VkGeneratedCommandsMemoryRequirementsInfoNV*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetGeneratedCommandsMemoryRequirementsNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pMemoryRequirements);
                }
                vk->vkGetGeneratedCommandsMemoryRequirementsNV(unboxed_device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetGeneratedCommandsMemoryRequirementsNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdPreprocessGeneratedCommandsNV:
            {
                android::base::beginTrace("vkCmdPreprocessGeneratedCommandsNV decode");
                VkCommandBuffer commandBuffer;
                const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pGeneratedCommandsInfo, sizeof(const VkGeneratedCommandsInfoNV));
                reservedunmarshal_VkGeneratedCommandsInfoNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkGeneratedCommandsInfoNV*)(pGeneratedCommandsInfo), readStreamPtrPtr);
                if (pGeneratedCommandsInfo)
                {
                    transform_tohost_VkGeneratedCommandsInfoNV(m_state, (VkGeneratedCommandsInfoNV*)(pGeneratedCommandsInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdPreprocessGeneratedCommandsNV 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pGeneratedCommandsInfo);
                }
                vk->vkCmdPreprocessGeneratedCommandsNV(unboxed_commandBuffer, pGeneratedCommandsInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdPreprocessGeneratedCommandsNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pGeneratedCommandsInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdExecuteGeneratedCommandsNV:
            {
                android::base::beginTrace("vkCmdExecuteGeneratedCommandsNV decode");
                VkCommandBuffer commandBuffer;
                VkBool32 isPreprocessed;
                const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkBool32*)&isPreprocessed, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vkReadStream->alloc((void**)&pGeneratedCommandsInfo, sizeof(const VkGeneratedCommandsInfoNV));
                reservedunmarshal_VkGeneratedCommandsInfoNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkGeneratedCommandsInfoNV*)(pGeneratedCommandsInfo), readStreamPtrPtr);
                if (pGeneratedCommandsInfo)
                {
                    transform_tohost_VkGeneratedCommandsInfoNV(m_state, (VkGeneratedCommandsInfoNV*)(pGeneratedCommandsInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdExecuteGeneratedCommandsNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)isPreprocessed, (unsigned long long)pGeneratedCommandsInfo);
                }
                vk->vkCmdExecuteGeneratedCommandsNV(unboxed_commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdExecuteGeneratedCommandsNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBindPipelineShaderGroupNV:
            {
                android::base::beginTrace("vkCmdBindPipelineShaderGroupNV decode");
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipeline pipeline;
                uint32_t groupIndex;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkPipelineBindPoint*)&pipelineBindPoint, *readStreamPtrPtr, sizeof(VkPipelineBindPoint));
                *readStreamPtrPtr += sizeof(VkPipelineBindPoint);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipeline*)&pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_1));
                memcpy((uint32_t*)&groupIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBindPipelineShaderGroupNV 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineBindPoint, (unsigned long long)pipeline, (unsigned long long)groupIndex);
                }
                vk->vkCmdBindPipelineShaderGroupNV(unboxed_commandBuffer, pipelineBindPoint, pipeline, groupIndex);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindPipelineShaderGroupNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineBindPoint, pipeline, groupIndex);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateIndirectCommandsLayoutNV:
            {
                android::base::beginTrace("vkCreateIndirectCommandsLayoutNV decode");
                VkDevice device;
                const VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkIndirectCommandsLayoutNV* pIndirectCommandsLayout;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkIndirectCommandsLayoutCreateInfoNV));
                reservedunmarshal_VkIndirectCommandsLayoutCreateInfoNV(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkIndirectCommandsLayoutCreateInfoNV*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pIndirectCommandsLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pIndirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNV));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkIndirectCommandsLayoutNV*)pIndirectCommandsLayout = (VkIndirectCommandsLayoutNV)(VkIndirectCommandsLayoutNV)((VkIndirectCommandsLayoutNV)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkIndirectCommandsLayoutCreateInfoNV(m_state, (VkIndirectCommandsLayoutCreateInfoNV*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateIndirectCommandsLayoutNV 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pIndirectCommandsLayout);
                }
                VkResult vkCreateIndirectCommandsLayoutNV_VkResult_return = (VkResult)0;
                vkCreateIndirectCommandsLayoutNV_VkResult_return = vk->vkCreateIndirectCommandsLayoutNV(unboxed_device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pIndirectCommandsLayout;
                if (vkCreateIndirectCommandsLayoutNV_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkIndirectCommandsLayoutNV), "handle map overwrite requres VkIndirectCommandsLayoutNV to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNV((VkIndirectCommandsLayoutNV*)pIndirectCommandsLayout, 1);
                vkStream->write((VkIndirectCommandsLayoutNV*)pIndirectCommandsLayout, 8 * 1);
                // Begin auto non dispatchable handle create for pIndirectCommandsLayout;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateIndirectCommandsLayoutNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateIndirectCommandsLayoutNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateIndirectCommandsLayoutNV_VkResult_return, device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyIndirectCommandsLayoutNV:
            {
                android::base::beginTrace("vkDestroyIndirectCommandsLayoutNV decode");
                VkDevice device;
                VkIndirectCommandsLayoutNV indirectCommandsLayout;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for indirectCommandsLayout;
                VkIndirectCommandsLayoutNV boxed_indirectCommandsLayout_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkIndirectCommandsLayoutNV*)&indirectCommandsLayout = (VkIndirectCommandsLayoutNV)(VkIndirectCommandsLayoutNV)((VkIndirectCommandsLayoutNV)(*&cgen_var_1));
                boxed_indirectCommandsLayout_preserve = indirectCommandsLayout;
                indirectCommandsLayout = unbox_VkIndirectCommandsLayoutNV(indirectCommandsLayout);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyIndirectCommandsLayoutNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)indirectCommandsLayout, (unsigned long long)pAllocator);
                }
                vk->vkDestroyIndirectCommandsLayoutNV(unboxed_device, indirectCommandsLayout, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyIndirectCommandsLayoutNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_indirectCommandsLayout_preserve, pAllocator);
                }
                delete_VkIndirectCommandsLayoutNV(boxed_indirectCommandsLayout_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_texel_buffer_alignment
#endif
#ifdef VK_QCOM_render_pass_transform
#endif
#ifdef VK_EXT_device_memory_report
#endif
#ifdef VK_EXT_robustness2
#endif
#ifdef VK_EXT_custom_border_color
#endif
#ifdef VK_GOOGLE_user_type
#endif
#ifdef VK_EXT_private_data
            case OP_vkCreatePrivateDataSlotEXT:
            {
                android::base::beginTrace("vkCreatePrivateDataSlotEXT decode");
                VkDevice device;
                const VkPrivateDataSlotCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkPrivateDataSlotEXT* pPrivateDataSlot;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPrivateDataSlotCreateInfoEXT));
                reservedunmarshal_VkPrivateDataSlotCreateInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPrivateDataSlotCreateInfoEXT*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPrivateDataSlot;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPrivateDataSlot, sizeof(VkPrivateDataSlotEXT));
                memcpy((VkPrivateDataSlotEXT*)&(*pPrivateDataSlot), (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&(*pPrivateDataSlot));
                *readStreamPtrPtr += 8;
                if (pCreateInfo)
                {
                    transform_tohost_VkPrivateDataSlotCreateInfoEXT(m_state, (VkPrivateDataSlotCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreatePrivateDataSlotEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pPrivateDataSlot);
                }
                VkResult vkCreatePrivateDataSlotEXT_VkResult_return = (VkResult)0;
                vkCreatePrivateDataSlotEXT_VkResult_return = vk->vkCreatePrivateDataSlotEXT(unboxed_device, pCreateInfo, pAllocator, pPrivateDataSlot);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3 = (uint64_t)(*pPrivateDataSlot);
                vkStream->putBe64(cgen_var_3);
                vkStream->write(&vkCreatePrivateDataSlotEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreatePrivateDataSlotEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreatePrivateDataSlotEXT_VkResult_return, device, pCreateInfo, pAllocator, pPrivateDataSlot);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyPrivateDataSlotEXT:
            {
                android::base::beginTrace("vkDestroyPrivateDataSlotEXT decode");
                VkDevice device;
                VkPrivateDataSlotEXT privateDataSlot;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkPrivateDataSlotEXT*)&privateDataSlot, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&privateDataSlot);
                *readStreamPtrPtr += 8;
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyPrivateDataSlotEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)privateDataSlot, (unsigned long long)pAllocator);
                }
                vk->vkDestroyPrivateDataSlotEXT(unboxed_device, privateDataSlot, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyPrivateDataSlotEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, privateDataSlot, pAllocator);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkSetPrivateDataEXT:
            {
                android::base::beginTrace("vkSetPrivateDataEXT decode");
                VkDevice device;
                VkObjectType objectType;
                uint64_t objectHandle;
                VkPrivateDataSlotEXT privateDataSlot;
                uint64_t data;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkObjectType*)&objectType, *readStreamPtrPtr, sizeof(VkObjectType));
                *readStreamPtrPtr += sizeof(VkObjectType);
                memcpy((uint64_t*)&objectHandle, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                memcpy((VkPrivateDataSlotEXT*)&privateDataSlot, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&privateDataSlot);
                *readStreamPtrPtr += 8;
                memcpy((uint64_t*)&data, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkSetPrivateDataEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)objectType, (unsigned long long)objectHandle, (unsigned long long)privateDataSlot, (unsigned long long)data);
                }
                VkResult vkSetPrivateDataEXT_VkResult_return = (VkResult)0;
                vkSetPrivateDataEXT_VkResult_return = vk->vkSetPrivateDataEXT(unboxed_device, objectType, objectHandle, privateDataSlot, data);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSetPrivateDataEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetPrivateDataEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkSetPrivateDataEXT_VkResult_return, device, objectType, objectHandle, privateDataSlot, data);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPrivateDataEXT:
            {
                android::base::beginTrace("vkGetPrivateDataEXT decode");
                VkDevice device;
                VkObjectType objectType;
                uint64_t objectHandle;
                VkPrivateDataSlotEXT privateDataSlot;
                uint64_t* pData;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkObjectType*)&objectType, *readStreamPtrPtr, sizeof(VkObjectType));
                *readStreamPtrPtr += sizeof(VkObjectType);
                memcpy((uint64_t*)&objectHandle, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                memcpy((VkPrivateDataSlotEXT*)&privateDataSlot, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&privateDataSlot);
                *readStreamPtrPtr += 8;
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pData, sizeof(uint64_t));
                memcpy((uint64_t*)pData, *readStreamPtrPtr, sizeof(uint64_t));
                *readStreamPtrPtr += sizeof(uint64_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPrivateDataEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)objectType, (unsigned long long)objectHandle, (unsigned long long)privateDataSlot, (unsigned long long)pData);
                }
                vk->vkGetPrivateDataEXT(unboxed_device, objectType, objectHandle, privateDataSlot, pData);
                vkStream->unsetHandleMapping();
                vkStream->write((uint64_t*)pData, sizeof(uint64_t));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPrivateDataEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, objectType, objectHandle, privateDataSlot, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_pipeline_creation_cache_control
#endif
#ifdef VK_NV_device_diagnostics_config
#endif
#ifdef VK_QCOM_render_pass_store_ops
#endif
#ifdef VK_NV_fragment_shading_rate_enums
            case OP_vkCmdSetFragmentShadingRateEnumNV:
            {
                android::base::beginTrace("vkCmdSetFragmentShadingRateEnumNV decode");
                VkCommandBuffer commandBuffer;
                VkFragmentShadingRateNV shadingRate;
                VkFragmentShadingRateCombinerOpKHR combinerOps[2];
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((VkFragmentShadingRateNV*)&shadingRate, *readStreamPtrPtr, sizeof(VkFragmentShadingRateNV));
                *readStreamPtrPtr += sizeof(VkFragmentShadingRateNV);
                memcpy((VkFragmentShadingRateCombinerOpKHR*)combinerOps, *readStreamPtrPtr, 2 * sizeof(const VkFragmentShadingRateCombinerOpKHR));
                *readStreamPtrPtr += 2 * sizeof(const VkFragmentShadingRateCombinerOpKHR);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetFragmentShadingRateEnumNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)shadingRate, (unsigned long long)combinerOps);
                }
                vk->vkCmdSetFragmentShadingRateEnumNV(unboxed_commandBuffer, shadingRate, combinerOps);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetFragmentShadingRateEnumNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, shadingRate, combinerOps);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_EXT_fragment_density_map2
#endif
#ifdef VK_QCOM_rotated_copy_commands
#endif
#ifdef VK_EXT_image_robustness
#endif
#ifdef VK_EXT_4444_formats
#endif
#ifdef VK_EXT_directfb_surface
            case OP_vkCreateDirectFBSurfaceEXT:
            {
                android::base::beginTrace("vkCreateDirectFBSurfaceEXT decode");
                VkInstance instance;
                const VkDirectFBSurfaceCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin non wrapped dispatchable handle unboxing for instance;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkInstance*)&instance = (VkInstance)(VkInstance)((VkInstance)(*&cgen_var_0));
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDirectFBSurfaceCreateInfoEXT));
                reservedunmarshal_VkDirectFBSurfaceCreateInfoEXT(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDirectFBSurfaceCreateInfoEXT*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkSurfaceKHR*)pSurface = (VkSurfaceKHR)(VkSurfaceKHR)((VkSurfaceKHR)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkDirectFBSurfaceCreateInfoEXT(m_state, (VkDirectFBSurfaceCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateDirectFBSurfaceEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateDirectFBSurfaceEXT_VkResult_return = (VkResult)0;
                vkCreateDirectFBSurfaceEXT_VkResult_return = vk->vkCreateDirectFBSurfaceEXT(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_3, 1);
                vkStream->write((uint64_t*)&cgen_var_3, 8);
                vkStream->write(&vkCreateDirectFBSurfaceEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDirectFBSurfaceEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDirectFBSurfaceEXT_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetPhysicalDeviceDirectFBPresentationSupportEXT:
            {
                android::base::beginTrace("vkGetPhysicalDeviceDirectFBPresentationSupportEXT decode");
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                IDirectFB* dfb;
                // Begin non wrapped dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPhysicalDevice*)&physicalDevice = (VkPhysicalDevice)(VkPhysicalDevice)((VkPhysicalDevice)(*&cgen_var_0));
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                // End manual dispatchable handle unboxing for physicalDevice;
                memcpy((uint32_t*)&queueFamilyIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for dfb;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&dfb, sizeof(IDirectFB));
                memcpy((IDirectFB*)dfb, *readStreamPtrPtr, sizeof(IDirectFB));
                *readStreamPtrPtr += sizeof(IDirectFB);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetPhysicalDeviceDirectFBPresentationSupportEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)dfb);
                }
                VkBool32 vkGetPhysicalDeviceDirectFBPresentationSupportEXT_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceDirectFBPresentationSupportEXT_VkBool32_return = vk->vkGetPhysicalDeviceDirectFBPresentationSupportEXT(unboxed_physicalDevice, queueFamilyIndex, dfb);
                vkStream->unsetHandleMapping();
                vkStream->write((IDirectFB*)dfb, sizeof(IDirectFB));
                vkStream->write(&vkGetPhysicalDeviceDirectFBPresentationSupportEXT_VkBool32_return, sizeof(VkBool32));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceDirectFBPresentationSupportEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceDirectFBPresentationSupportEXT_VkBool32_return, physicalDevice, queueFamilyIndex, dfb);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_GOOGLE_gfxstream
            case OP_vkRegisterImageColorBufferGOOGLE:
            {
                android::base::beginTrace("vkRegisterImageColorBufferGOOGLE decode");
                VkDevice device;
                VkImage image;
                uint32_t colorBuffer;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                memcpy((uint32_t*)&colorBuffer, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkRegisterImageColorBufferGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)colorBuffer);
                }
                VkResult vkRegisterImageColorBufferGOOGLE_VkResult_return = (VkResult)0;
                vkRegisterImageColorBufferGOOGLE_VkResult_return = m_state->on_vkRegisterImageColorBufferGOOGLE(&m_pool, device, image, colorBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkRegisterImageColorBufferGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkRegisterImageColorBufferGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkRegisterImageColorBufferGOOGLE_VkResult_return, device, image, colorBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkRegisterBufferColorBufferGOOGLE:
            {
                android::base::beginTrace("vkRegisterBufferColorBufferGOOGLE decode");
                VkDevice device;
                VkBuffer buffer;
                uint32_t colorBuffer;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((uint32_t*)&colorBuffer, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkRegisterBufferColorBufferGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)colorBuffer);
                }
                VkResult vkRegisterBufferColorBufferGOOGLE_VkResult_return = (VkResult)0;
                vkRegisterBufferColorBufferGOOGLE_VkResult_return = m_state->on_vkRegisterBufferColorBufferGOOGLE(&m_pool, device, buffer, colorBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkRegisterBufferColorBufferGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkRegisterBufferColorBufferGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkRegisterBufferColorBufferGOOGLE_VkResult_return, device, buffer, colorBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkMapMemoryIntoAddressSpaceGOOGLE:
            {
                android::base::beginTrace("vkMapMemoryIntoAddressSpaceGOOGLE decode");
                VkDevice device;
                VkDeviceMemory memory;
                uint64_t* pAddress;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pAddress;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint64_t**)&pAddress, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAddress);
                *readStreamPtrPtr += 8;
                if (pAddress)
                {
                    vkReadStream->alloc((void**)&pAddress, sizeof(uint64_t));
                    memcpy((uint64_t*)pAddress, *readStreamPtrPtr, sizeof(uint64_t));
                    *readStreamPtrPtr += sizeof(uint64_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkMapMemoryIntoAddressSpaceGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pAddress);
                }
                VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
                vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = m_state->on_vkMapMemoryIntoAddressSpaceGOOGLE(&m_pool, device, memory, pAddress);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pAddress;
                vkStream->putBe64(cgen_var_3);
                if (pAddress)
                {
                    vkStream->write((uint64_t*)pAddress, sizeof(uint64_t));
                }
                vkStream->write(&vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkMapMemoryIntoAddressSpaceGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, device, memory, pAddress);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkUpdateDescriptorSetWithTemplateSizedGOOGLE:
            {
                android::base::beginTrace("vkUpdateDescriptorSetWithTemplateSizedGOOGLE decode");
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                uint32_t imageInfoCount;
                uint32_t bufferInfoCount;
                uint32_t bufferViewCount;
                const uint32_t* pImageInfoEntryIndices;
                const uint32_t* pBufferInfoEntryIndices;
                const uint32_t* pBufferViewEntryIndices;
                const VkDescriptorImageInfo* pImageInfos;
                const VkDescriptorBufferInfo* pBufferInfos;
                const VkBufferView* pBufferViews;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorSet*)&descriptorSet = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)(*&cgen_var_1));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)unbox_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate)(*&cgen_var_2));
                memcpy((uint32_t*)&imageInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&bufferInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&bufferViewCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pImageInfoEntryIndices, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pImageInfoEntryIndices);
                *readStreamPtrPtr += 8;
                if (pImageInfoEntryIndices)
                {
                    vkReadStream->alloc((void**)&pImageInfoEntryIndices, ((imageInfoCount)) * sizeof(const uint32_t));
                    memcpy((uint32_t*)pImageInfoEntryIndices, *readStreamPtrPtr, ((imageInfoCount)) * sizeof(const uint32_t));
                    *readStreamPtrPtr += ((imageInfoCount)) * sizeof(const uint32_t);
                }
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pBufferInfoEntryIndices, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pBufferInfoEntryIndices);
                *readStreamPtrPtr += 8;
                if (pBufferInfoEntryIndices)
                {
                    vkReadStream->alloc((void**)&pBufferInfoEntryIndices, ((bufferInfoCount)) * sizeof(const uint32_t));
                    memcpy((uint32_t*)pBufferInfoEntryIndices, *readStreamPtrPtr, ((bufferInfoCount)) * sizeof(const uint32_t));
                    *readStreamPtrPtr += ((bufferInfoCount)) * sizeof(const uint32_t);
                }
                // WARNING PTR CHECK
                memcpy((uint32_t**)&pBufferViewEntryIndices, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pBufferViewEntryIndices);
                *readStreamPtrPtr += 8;
                if (pBufferViewEntryIndices)
                {
                    vkReadStream->alloc((void**)&pBufferViewEntryIndices, ((bufferViewCount)) * sizeof(const uint32_t));
                    memcpy((uint32_t*)pBufferViewEntryIndices, *readStreamPtrPtr, ((bufferViewCount)) * sizeof(const uint32_t));
                    *readStreamPtrPtr += ((bufferViewCount)) * sizeof(const uint32_t);
                }
                // WARNING PTR CHECK
                memcpy((VkDescriptorImageInfo**)&pImageInfos, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pImageInfos);
                *readStreamPtrPtr += 8;
                if (pImageInfos)
                {
                    vkReadStream->alloc((void**)&pImageInfos, ((imageInfoCount)) * sizeof(const VkDescriptorImageInfo));
                    for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
                    {
                        reservedunmarshal_VkDescriptorImageInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorImageInfo*)(pImageInfos + i), readStreamPtrPtr);
                    }
                }
                // WARNING PTR CHECK
                memcpy((VkDescriptorBufferInfo**)&pBufferInfos, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pBufferInfos);
                *readStreamPtrPtr += 8;
                if (pBufferInfos)
                {
                    vkReadStream->alloc((void**)&pBufferInfos, ((bufferInfoCount)) * sizeof(const VkDescriptorBufferInfo));
                    for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
                    {
                        reservedunmarshal_VkDescriptorBufferInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorBufferInfo*)(pBufferInfos + i), readStreamPtrPtr);
                    }
                }
                // WARNING PTR CHECK
                memcpy((VkBufferView**)&pBufferViews, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pBufferViews);
                *readStreamPtrPtr += 8;
                if (pBufferViews)
                {
                    vkReadStream->alloc((void**)&pBufferViews, ((bufferViewCount)) * sizeof(const VkBufferView));
                    if (((bufferViewCount)))
                    {
                        uint8_t* cgen_var_8_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((bufferViewCount));
                        for (uint32_t k = 0; k < ((bufferViewCount)); ++k)
                        {
                            uint64_t tmpval; memcpy(&tmpval, cgen_var_8_0_ptr + k * 8, sizeof(uint64_t));
                            *(((VkBufferView*)pBufferViews) + k) = (VkBufferView)unbox_VkBufferView((VkBufferView)tmpval);
                        }
                    }
                }
                if (pImageInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
                    {
                        transform_tohost_VkDescriptorImageInfo(m_state, (VkDescriptorImageInfo*)(pImageInfos + i));
                    }
                }
                if (pBufferInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
                    {
                        transform_tohost_VkDescriptorBufferInfo(m_state, (VkDescriptorBufferInfo*)(pBufferInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkUpdateDescriptorSetWithTemplateSizedGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorSet, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)imageInfoCount, (unsigned long long)bufferInfoCount, (unsigned long long)bufferViewCount, (unsigned long long)pImageInfoEntryIndices, (unsigned long long)pBufferInfoEntryIndices, (unsigned long long)pBufferViewEntryIndices, (unsigned long long)pImageInfos, (unsigned long long)pBufferInfos, (unsigned long long)pBufferViews);
                }
                m_state->on_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(&m_pool, device, descriptorSet, descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount, pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUpdateDescriptorSetWithTemplateSizedGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorSet, descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount, pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBeginCommandBufferAsyncGOOGLE:
            {
                android::base::beginTrace("vkBeginCommandBufferAsyncGOOGLE decode");
                VkCommandBuffer commandBuffer;
                const VkCommandBufferBeginInfo* pBeginInfo;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pBeginInfo, sizeof(const VkCommandBufferBeginInfo));
                reservedunmarshal_VkCommandBufferBeginInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCommandBufferBeginInfo*)(pBeginInfo), readStreamPtrPtr);
                if (pBeginInfo)
                {
                    transform_tohost_VkCommandBufferBeginInfo(m_state, (VkCommandBufferBeginInfo*)(pBeginInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBeginCommandBufferAsyncGOOGLE 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pBeginInfo);
                }
                m_state->on_vkBeginCommandBufferAsyncGOOGLE(&m_pool, commandBuffer, pBeginInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBeginCommandBufferAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pBeginInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkEndCommandBufferAsyncGOOGLE:
            {
                android::base::beginTrace("vkEndCommandBufferAsyncGOOGLE decode");
                VkCommandBuffer commandBuffer;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkEndCommandBufferAsyncGOOGLE 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                m_state->on_vkEndCommandBufferAsyncGOOGLE(&m_pool, commandBuffer);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEndCommandBufferAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkResetCommandBufferAsyncGOOGLE:
            {
                android::base::beginTrace("vkResetCommandBufferAsyncGOOGLE decode");
                VkCommandBuffer commandBuffer;
                VkCommandBufferResetFlags flags;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                memcpy((VkCommandBufferResetFlags*)&flags, *readStreamPtrPtr, sizeof(VkCommandBufferResetFlags));
                *readStreamPtrPtr += sizeof(VkCommandBufferResetFlags);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkResetCommandBufferAsyncGOOGLE 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)flags);
                }
                m_state->on_vkResetCommandBufferAsyncGOOGLE(&m_pool, commandBuffer, flags);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetCommandBufferAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, flags);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCommandBufferHostSyncGOOGLE:
            {
                android::base::beginTrace("vkCommandBufferHostSyncGOOGLE decode");
                VkCommandBuffer commandBuffer;
                uint32_t needHostSync;
                uint32_t sequenceNumber;
                // Begin global wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                memcpy((uint32_t*)&needHostSync, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&sequenceNumber, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCommandBufferHostSyncGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)needHostSync, (unsigned long long)sequenceNumber);
                }
                m_state->on_vkCommandBufferHostSyncGOOGLE(&m_pool, commandBuffer, needHostSync, sequenceNumber);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCommandBufferHostSyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, needHostSync, sequenceNumber);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateImageWithRequirementsGOOGLE:
            {
                android::base::beginTrace("vkCreateImageWithRequirementsGOOGLE decode");
                VkDevice device;
                const VkImageCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkImage* pImage;
                VkMemoryRequirements* pMemoryRequirements;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageCreateInfo));
                reservedunmarshal_VkImageCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pImage;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImage, sizeof(VkImage));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkImage*)pImage = (VkImage)(VkImage)((VkImage)(*&cgen_var_2));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                reservedunmarshal_VkMemoryRequirements(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements), readStreamPtrPtr);
                if (pCreateInfo)
                {
                    transform_tohost_VkImageCreateInfo(m_state, (VkImageCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateImageWithRequirementsGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pImage, (unsigned long long)pMemoryRequirements);
                }
                VkResult vkCreateImageWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
                vkCreateImageWithRequirementsGOOGLE_VkResult_return = m_state->on_vkCreateImageWithRequirementsGOOGLE(&m_pool, device, pCreateInfo, pAllocator, pImage, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pImage;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkImage), "handle map overwrite requres VkImage to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkImage((VkImage*)pImage, 1);
                vkStream->write((VkImage*)pImage, 8 * 1);
                // Begin manual non dispatchable handle create for pImage;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements));
                vkStream->write(&vkCreateImageWithRequirementsGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateImageWithRequirementsGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateImageWithRequirementsGOOGLE_VkResult_return, device, pCreateInfo, pAllocator, pImage, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateBufferWithRequirementsGOOGLE:
            {
                android::base::beginTrace("vkCreateBufferWithRequirementsGOOGLE decode");
                VkDevice device;
                const VkBufferCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkBuffer* pBuffer;
                VkMemoryRequirements* pMemoryRequirements;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferCreateInfo));
                reservedunmarshal_VkBufferCreateInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferCreateInfo*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pBuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pBuffer, sizeof(VkBuffer));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkBuffer*)pBuffer = (VkBuffer)(VkBuffer)((VkBuffer)(*&cgen_var_2));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                reservedunmarshal_VkMemoryRequirements(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements), readStreamPtrPtr);
                if (pCreateInfo)
                {
                    transform_tohost_VkBufferCreateInfo(m_state, (VkBufferCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateBufferWithRequirementsGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pBuffer, (unsigned long long)pMemoryRequirements);
                }
                VkResult vkCreateBufferWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
                vkCreateBufferWithRequirementsGOOGLE_VkResult_return = m_state->on_vkCreateBufferWithRequirementsGOOGLE(&m_pool, device, pCreateInfo, pAllocator, pBuffer, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pBuffer;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkBuffer), "handle map overwrite requres VkBuffer to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkBuffer((VkBuffer*)pBuffer, 1);
                vkStream->write((VkBuffer*)pBuffer, 8 * 1);
                // Begin manual non dispatchable handle create for pBuffer;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements));
                vkStream->write(&vkCreateBufferWithRequirementsGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateBufferWithRequirementsGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateBufferWithRequirementsGOOGLE_VkResult_return, device, pCreateInfo, pAllocator, pBuffer, pMemoryRequirements);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetMemoryHostAddressInfoGOOGLE:
            {
                android::base::beginTrace("vkGetMemoryHostAddressInfoGOOGLE decode");
                VkDevice device;
                VkDeviceMemory memory;
                uint64_t* pAddress;
                uint64_t* pSize;
                uint64_t* pHostmemId;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pAddress;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint64_t**)&pAddress, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAddress);
                *readStreamPtrPtr += 8;
                if (pAddress)
                {
                    vkReadStream->alloc((void**)&pAddress, sizeof(uint64_t));
                    memcpy((uint64_t*)pAddress, *readStreamPtrPtr, sizeof(uint64_t));
                    *readStreamPtrPtr += sizeof(uint64_t);
                }
                // Begin manual dispatchable handle unboxing for pSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint64_t**)&pSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSize);
                *readStreamPtrPtr += 8;
                if (pSize)
                {
                    vkReadStream->alloc((void**)&pSize, sizeof(uint64_t));
                    memcpy((uint64_t*)pSize, *readStreamPtrPtr, sizeof(uint64_t));
                    *readStreamPtrPtr += sizeof(uint64_t);
                }
                // Begin manual dispatchable handle unboxing for pHostmemId;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint64_t**)&pHostmemId, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pHostmemId);
                *readStreamPtrPtr += 8;
                if (pHostmemId)
                {
                    vkReadStream->alloc((void**)&pHostmemId, sizeof(uint64_t));
                    memcpy((uint64_t*)pHostmemId, *readStreamPtrPtr, sizeof(uint64_t));
                    *readStreamPtrPtr += sizeof(uint64_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetMemoryHostAddressInfoGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pAddress, (unsigned long long)pSize, (unsigned long long)pHostmemId);
                }
                VkResult vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = (VkResult)0;
                vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = m_state->on_vkGetMemoryHostAddressInfoGOOGLE(&m_pool, device, memory, pAddress, pSize, pHostmemId);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_5 = (uint64_t)(uintptr_t)pAddress;
                vkStream->putBe64(cgen_var_5);
                if (pAddress)
                {
                    vkStream->write((uint64_t*)pAddress, sizeof(uint64_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_6 = (uint64_t)(uintptr_t)pSize;
                vkStream->putBe64(cgen_var_6);
                if (pSize)
                {
                    vkStream->write((uint64_t*)pSize, sizeof(uint64_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_7 = (uint64_t)(uintptr_t)pHostmemId;
                vkStream->putBe64(cgen_var_7);
                if (pHostmemId)
                {
                    vkStream->write((uint64_t*)pHostmemId, sizeof(uint64_t));
                }
                vkStream->write(&vkGetMemoryHostAddressInfoGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryHostAddressInfoGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryHostAddressInfoGOOGLE_VkResult_return, device, memory, pAddress, pSize, pHostmemId);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkFreeMemorySyncGOOGLE:
            {
                android::base::beginTrace("vkFreeMemorySyncGOOGLE decode");
                VkDevice device;
                VkDeviceMemory memory;
                const VkAllocationCallbacks* pAllocator;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                // Begin manual non dispatchable handle destroy unboxing for memory;
                VkDeviceMemory boxed_memory_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDeviceMemory*)&memory = (VkDeviceMemory)(VkDeviceMemory)((VkDeviceMemory)(*&cgen_var_1));
                boxed_memory_preserve = memory;
                memory = unbox_VkDeviceMemory(memory);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkFreeMemorySyncGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pAllocator);
                }
                VkResult vkFreeMemorySyncGOOGLE_VkResult_return = (VkResult)0;
                vkFreeMemorySyncGOOGLE_VkResult_return = m_state->on_vkFreeMemorySyncGOOGLE(&m_pool, device, memory, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkFreeMemorySyncGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFreeMemorySyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkFreeMemorySyncGOOGLE_VkResult_return, device, boxed_memory_preserve, pAllocator);
                }
                delete_VkDeviceMemory(boxed_memory_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueHostSyncGOOGLE:
            {
                android::base::beginTrace("vkQueueHostSyncGOOGLE decode");
                VkQueue queue;
                uint32_t needHostSync;
                uint32_t sequenceNumber;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                memcpy((uint32_t*)&needHostSync, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&sequenceNumber, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueHostSyncGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)needHostSync, (unsigned long long)sequenceNumber);
                }
                m_state->on_vkQueueHostSyncGOOGLE(&m_pool, queue, needHostSync, sequenceNumber);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueHostSyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, needHostSync, sequenceNumber);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueSubmitAsyncGOOGLE:
            {
                android::base::beginTrace("vkQueueSubmitAsyncGOOGLE decode");
                VkQueue queue;
                uint32_t submitCount;
                const VkSubmitInfo* pSubmits;
                VkFence fence;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                memcpy((uint32_t*)&submitCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pSubmits, ((submitCount)) * sizeof(const VkSubmitInfo));
                for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
                {
                    reservedunmarshal_VkSubmitInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubmitInfo*)(pSubmits + i), readStreamPtrPtr);
                }
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_1));
                if (pSubmits)
                {
                    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
                    {
                        transform_tohost_VkSubmitInfo(m_state, (VkSubmitInfo*)(pSubmits + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueSubmitAsyncGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)submitCount, (unsigned long long)pSubmits, (unsigned long long)fence);
                }
                m_state->on_vkQueueSubmitAsyncGOOGLE(&m_pool, queue, submitCount, pSubmits, fence);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueSubmitAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, submitCount, pSubmits, fence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueWaitIdleAsyncGOOGLE:
            {
                android::base::beginTrace("vkQueueWaitIdleAsyncGOOGLE decode");
                VkQueue queue;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueWaitIdleAsyncGOOGLE 0x%llx \n", ioStream, (unsigned long long)queue);
                }
                m_state->on_vkQueueWaitIdleAsyncGOOGLE(&m_pool, queue);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueWaitIdleAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueBindSparseAsyncGOOGLE:
            {
                android::base::beginTrace("vkQueueBindSparseAsyncGOOGLE decode");
                VkQueue queue;
                uint32_t bindInfoCount;
                const VkBindSparseInfo* pBindInfo;
                VkFence fence;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                memcpy((uint32_t*)&bindInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pBindInfo, ((bindInfoCount)) * sizeof(const VkBindSparseInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    reservedunmarshal_VkBindSparseInfo(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindSparseInfo*)(pBindInfo + i), readStreamPtrPtr);
                }
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkFence*)&fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_1));
                if (pBindInfo)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindSparseInfo(m_state, (VkBindSparseInfo*)(pBindInfo + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueBindSparseAsyncGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfo, (unsigned long long)fence);
                }
                m_state->on_vkQueueBindSparseAsyncGOOGLE(&m_pool, queue, bindInfoCount, pBindInfo, fence);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueBindSparseAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, bindInfoCount, pBindInfo, fence);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetLinearImageLayoutGOOGLE:
            {
                android::base::beginTrace("vkGetLinearImageLayoutGOOGLE decode");
                VkDevice device;
                VkFormat format;
                VkDeviceSize* pOffset;
                VkDeviceSize* pRowPitchAlignment;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                memcpy((VkFormat*)&format, *readStreamPtrPtr, sizeof(VkFormat));
                *readStreamPtrPtr += sizeof(VkFormat);
                // Begin manual dispatchable handle unboxing for pOffset;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pOffset, sizeof(VkDeviceSize));
                memcpy((VkDeviceSize*)pOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                // Begin manual dispatchable handle unboxing for pRowPitchAlignment;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pRowPitchAlignment, sizeof(VkDeviceSize));
                memcpy((VkDeviceSize*)pRowPitchAlignment, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetLinearImageLayoutGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)format, (unsigned long long)pOffset, (unsigned long long)pRowPitchAlignment);
                }
                m_state->on_vkGetLinearImageLayoutGOOGLE(&m_pool, device, format, pOffset, pRowPitchAlignment);
                vkStream->unsetHandleMapping();
                vkStream->write((VkDeviceSize*)pOffset, sizeof(VkDeviceSize));
                vkStream->write((VkDeviceSize*)pRowPitchAlignment, sizeof(VkDeviceSize));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetLinearImageLayoutGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, format, pOffset, pRowPitchAlignment);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueFlushCommandsGOOGLE:
            {
                android::base::beginTrace("vkQueueFlushCommandsGOOGLE decode");
                VkQueue queue;
                VkCommandBuffer commandBuffer;
                VkDeviceSize dataSize;
                const void* pData;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                // No unbox for commandBuffer
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&dataSize, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(const uint8_t));
                memcpy((void*)pData, *readStreamPtrPtr, ((dataSize)) * sizeof(const uint8_t));
                *readStreamPtrPtr += ((dataSize)) * sizeof(const uint8_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueFlushCommandsGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)commandBuffer, (unsigned long long)dataSize, (unsigned long long)pData);
                }
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                m_state->on_vkQueueFlushCommandsGOOGLE(&m_pool, queue, commandBuffer, dataSize, pData);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueFlushCommandsGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, commandBuffer, dataSize, pData);
                }
                vkReadStream->clearPool();
                android::base::endTrace();
                break;
            }
            case OP_vkQueueCommitDescriptorSetUpdatesGOOGLE:
            {
                android::base::beginTrace("vkQueueCommitDescriptorSetUpdatesGOOGLE decode");
                VkQueue queue;
                uint32_t descriptorPoolCount;
                const VkDescriptorPool* pDescriptorPools;
                uint32_t descriptorSetCount;
                const VkDescriptorSetLayout* pSetLayouts;
                const uint64_t* pDescriptorSetPoolIds;
                const uint32_t* pDescriptorSetWhichPool;
                const uint32_t* pDescriptorSetPendingAllocation;
                const uint32_t* pDescriptorWriteStartingIndices;
                uint32_t pendingDescriptorWriteCount;
                const VkWriteDescriptorSet* pPendingDescriptorWrites;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                memcpy((uint32_t*)&descriptorPoolCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pDescriptorPools, ((descriptorPoolCount)) * sizeof(const VkDescriptorPool));
                if (((descriptorPoolCount)))
                {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((descriptorPoolCount));
                    for (uint32_t k = 0; k < ((descriptorPoolCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkDescriptorPool*)pDescriptorPools) + k) = (VkDescriptorPool)unbox_VkDescriptorPool((VkDescriptorPool)tmpval);
                    }
                }
                memcpy((uint32_t*)&descriptorSetCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pSetLayouts, ((descriptorSetCount)) * sizeof(const VkDescriptorSetLayout));
                if (((descriptorSetCount)))
                {
                    uint8_t* cgen_var_2_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((descriptorSetCount));
                    for (uint32_t k = 0; k < ((descriptorSetCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_2_ptr + k * 8, sizeof(uint64_t));
                        *(((VkDescriptorSetLayout*)pSetLayouts) + k) = (VkDescriptorSetLayout)unbox_VkDescriptorSetLayout((VkDescriptorSetLayout)tmpval);
                    }
                }
                vkReadStream->alloc((void**)&pDescriptorSetPoolIds, ((descriptorSetCount)) * sizeof(const uint64_t));
                memcpy((uint64_t*)pDescriptorSetPoolIds, *readStreamPtrPtr, ((descriptorSetCount)) * sizeof(const uint64_t));
                *readStreamPtrPtr += ((descriptorSetCount)) * sizeof(const uint64_t);
                vkReadStream->alloc((void**)&pDescriptorSetWhichPool, ((descriptorSetCount)) * sizeof(const uint32_t));
                memcpy((uint32_t*)pDescriptorSetWhichPool, *readStreamPtrPtr, ((descriptorSetCount)) * sizeof(const uint32_t));
                *readStreamPtrPtr += ((descriptorSetCount)) * sizeof(const uint32_t);
                vkReadStream->alloc((void**)&pDescriptorSetPendingAllocation, ((descriptorSetCount)) * sizeof(const uint32_t));
                memcpy((uint32_t*)pDescriptorSetPendingAllocation, *readStreamPtrPtr, ((descriptorSetCount)) * sizeof(const uint32_t));
                *readStreamPtrPtr += ((descriptorSetCount)) * sizeof(const uint32_t);
                vkReadStream->alloc((void**)&pDescriptorWriteStartingIndices, ((descriptorSetCount)) * sizeof(const uint32_t));
                memcpy((uint32_t*)pDescriptorWriteStartingIndices, *readStreamPtrPtr, ((descriptorSetCount)) * sizeof(const uint32_t));
                *readStreamPtrPtr += ((descriptorSetCount)) * sizeof(const uint32_t);
                memcpy((uint32_t*)&pendingDescriptorWriteCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pPendingDescriptorWrites, ((pendingDescriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((pendingDescriptorWriteCount)); ++i)
                {
                    reservedunmarshal_VkWriteDescriptorSet(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWriteDescriptorSet*)(pPendingDescriptorWrites + i), readStreamPtrPtr);
                }
                if (pPendingDescriptorWrites)
                {
                    for (uint32_t i = 0; i < (uint32_t)((pendingDescriptorWriteCount)); ++i)
                    {
                        transform_tohost_VkWriteDescriptorSet(m_state, (VkWriteDescriptorSet*)(pPendingDescriptorWrites + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueCommitDescriptorSetUpdatesGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)descriptorPoolCount, (unsigned long long)pDescriptorPools, (unsigned long long)descriptorSetCount, (unsigned long long)pSetLayouts, (unsigned long long)pDescriptorSetPoolIds, (unsigned long long)pDescriptorSetWhichPool, (unsigned long long)pDescriptorSetPendingAllocation, (unsigned long long)pDescriptorWriteStartingIndices, (unsigned long long)pendingDescriptorWriteCount, (unsigned long long)pPendingDescriptorWrites);
                }
                m_state->on_vkQueueCommitDescriptorSetUpdatesGOOGLE(&m_pool, queue, descriptorPoolCount, pDescriptorPools, descriptorSetCount, pSetLayouts, pDescriptorSetPoolIds, pDescriptorSetWhichPool, pDescriptorSetPendingAllocation, pDescriptorWriteStartingIndices, pendingDescriptorWriteCount, pPendingDescriptorWrites);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueCommitDescriptorSetUpdatesGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, descriptorPoolCount, pDescriptorPools, descriptorSetCount, pSetLayouts, pDescriptorSetPoolIds, pDescriptorSetWhichPool, pDescriptorSetPendingAllocation, pDescriptorWriteStartingIndices, pendingDescriptorWriteCount, pPendingDescriptorWrites);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCollectDescriptorPoolIdsGOOGLE:
            {
                android::base::beginTrace("vkCollectDescriptorPoolIdsGOOGLE decode");
                VkDevice device;
                VkDescriptorPool descriptorPool;
                uint32_t* pPoolIdCount;
                uint64_t* pPoolIds;
                // Begin global wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDescriptorPool*)&descriptorPool = (VkDescriptorPool)unbox_VkDescriptorPool((VkDescriptorPool)(*&cgen_var_1));
                // Begin manual dispatchable handle unboxing for pPoolIdCount;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPoolIdCount, sizeof(uint32_t));
                memcpy((uint32_t*)pPoolIdCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // Begin manual dispatchable handle unboxing for pPoolIds;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                memcpy((uint64_t**)&pPoolIds, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pPoolIds);
                *readStreamPtrPtr += 8;
                if (pPoolIds)
                {
                    vkReadStream->alloc((void**)&pPoolIds, (*(pPoolIdCount)) * sizeof(uint64_t));
                    memcpy((uint64_t*)pPoolIds, *readStreamPtrPtr, (*(pPoolIdCount)) * sizeof(uint64_t));
                    *readStreamPtrPtr += (*(pPoolIdCount)) * sizeof(uint64_t);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCollectDescriptorPoolIdsGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorPool, (unsigned long long)pPoolIdCount, (unsigned long long)pPoolIds);
                }
                m_state->on_vkCollectDescriptorPoolIdsGOOGLE(&m_pool, device, descriptorPool, pPoolIdCount, pPoolIds);
                vkStream->unsetHandleMapping();
                vkStream->write((uint32_t*)pPoolIdCount, sizeof(uint32_t));
                // WARNING PTR CHECK
                uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPoolIds;
                vkStream->putBe64(cgen_var_3);
                if (pPoolIds)
                {
                    vkStream->write((uint64_t*)pPoolIds, (*(pPoolIdCount)) * sizeof(uint64_t));
                }
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCollectDescriptorPoolIdsGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorPool, pPoolIdCount, pPoolIds);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkQueueSignalReleaseImageANDROIDAsyncGOOGLE:
            {
                android::base::beginTrace("vkQueueSignalReleaseImageANDROIDAsyncGOOGLE decode");
                VkQueue queue;
                uint32_t waitSemaphoreCount;
                const VkSemaphore* pWaitSemaphores;
                VkImage image;
                // Begin global wrapped dispatchable handle unboxing for queue;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueue*)&queue = (VkQueue)(VkQueue)((VkQueue)(*&cgen_var_0));
                memcpy((uint32_t*)&waitSemaphoreCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // WARNING PTR CHECK
                memcpy((VkSemaphore**)&pWaitSemaphores, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pWaitSemaphores);
                *readStreamPtrPtr += 8;
                if (pWaitSemaphores)
                {
                    vkReadStream->alloc((void**)&pWaitSemaphores, ((waitSemaphoreCount)) * sizeof(const VkSemaphore));
                    if (((waitSemaphoreCount)))
                    {
                        uint8_t* cgen_var_1_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((waitSemaphoreCount));
                        for (uint32_t k = 0; k < ((waitSemaphoreCount)); ++k)
                        {
                            uint64_t tmpval; memcpy(&tmpval, cgen_var_1_0_ptr + k * 8, sizeof(uint64_t));
                            *(((VkSemaphore*)pWaitSemaphores) + k) = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)tmpval);
                        }
                    }
                }
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_2));
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkQueueSignalReleaseImageANDROIDAsyncGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)waitSemaphoreCount, (unsigned long long)pWaitSemaphores, (unsigned long long)image);
                }
                m_state->on_vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(&m_pool, queue, waitSemaphoreCount, pWaitSemaphores, image);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, waitSemaphoreCount, pWaitSemaphores, image);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_acceleration_structure
            case OP_vkCreateAccelerationStructureKHR:
            {
                android::base::beginTrace("vkCreateAccelerationStructureKHR decode");
                VkDevice device;
                const VkAccelerationStructureCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkAccelerationStructureKHR* pAccelerationStructure;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkAccelerationStructureCreateInfoKHR));
                reservedunmarshal_VkAccelerationStructureCreateInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureCreateInfoKHR*)(pCreateInfo), readStreamPtrPtr);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pAccelerationStructure;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pAccelerationStructure, sizeof(VkAccelerationStructureKHR));
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 8);
                *readStreamPtrPtr += 8;
                *(VkAccelerationStructureKHR*)pAccelerationStructure = (VkAccelerationStructureKHR)(VkAccelerationStructureKHR)((VkAccelerationStructureKHR)(*&cgen_var_2));
                if (pCreateInfo)
                {
                    transform_tohost_VkAccelerationStructureCreateInfoKHR(m_state, (VkAccelerationStructureCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateAccelerationStructureKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pAccelerationStructure);
                }
                VkResult vkCreateAccelerationStructureKHR_VkResult_return = (VkResult)0;
                vkCreateAccelerationStructureKHR_VkResult_return = vk->vkCreateAccelerationStructureKHR(unboxed_device, pCreateInfo, pAllocator, pAccelerationStructure);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pAccelerationStructure;
                if (vkCreateAccelerationStructureKHR_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_3;
                static_assert(8 == sizeof(VkAccelerationStructureKHR), "handle map overwrite requres VkAccelerationStructureKHR to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkAccelerationStructureKHR((VkAccelerationStructureKHR*)pAccelerationStructure, 1);
                vkStream->write((VkAccelerationStructureKHR*)pAccelerationStructure, 8 * 1);
                // Begin auto non dispatchable handle create for pAccelerationStructure;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateAccelerationStructureKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateAccelerationStructureKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateAccelerationStructureKHR_VkResult_return, device, pCreateInfo, pAllocator, pAccelerationStructure);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkDestroyAccelerationStructureKHR:
            {
                android::base::beginTrace("vkDestroyAccelerationStructureKHR decode");
                VkDevice device;
                VkAccelerationStructureKHR accelerationStructure;
                const VkAllocationCallbacks* pAllocator;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for accelerationStructure;
                VkAccelerationStructureKHR boxed_accelerationStructure_preserve;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkAccelerationStructureKHR*)&accelerationStructure = (VkAccelerationStructureKHR)(VkAccelerationStructureKHR)((VkAccelerationStructureKHR)(*&cgen_var_1));
                boxed_accelerationStructure_preserve = accelerationStructure;
                accelerationStructure = unbox_VkAccelerationStructureKHR(accelerationStructure);
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkDestroyAccelerationStructureKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)accelerationStructure, (unsigned long long)pAllocator);
                }
                vk->vkDestroyAccelerationStructureKHR(unboxed_device, accelerationStructure, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyAccelerationStructureKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, boxed_accelerationStructure_preserve, pAllocator);
                }
                delete_VkAccelerationStructureKHR(boxed_accelerationStructure_preserve);
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBuildAccelerationStructuresKHR:
            {
                android::base::beginTrace("vkCmdBuildAccelerationStructuresKHR decode");
                VkCommandBuffer commandBuffer;
                uint32_t infoCount;
                const VkAccelerationStructureBuildGeometryInfoKHR* pInfos;
                const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&infoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pInfos, ((infoCount)) * sizeof(const VkAccelerationStructureBuildGeometryInfoKHR));
                for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
                {
                    reservedunmarshal_VkAccelerationStructureBuildGeometryInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildGeometryInfoKHR*)(pInfos + i), readStreamPtrPtr);
                }
                if (pInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
                    {
                        transform_tohost_VkAccelerationStructureBuildGeometryInfoKHR(m_state, (VkAccelerationStructureBuildGeometryInfoKHR*)(pInfos + i));
                    }
                }
                (void)ppBuildRangeInfos;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBuildAccelerationStructuresKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)infoCount, (unsigned long long)pInfos, (unsigned long long)ppBuildRangeInfos);
                }
                vk->vkCmdBuildAccelerationStructuresKHR(unboxed_commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBuildAccelerationStructuresKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdBuildAccelerationStructuresIndirectKHR:
            {
                android::base::beginTrace("vkCmdBuildAccelerationStructuresIndirectKHR decode");
                VkCommandBuffer commandBuffer;
                uint32_t infoCount;
                const VkAccelerationStructureBuildGeometryInfoKHR* pInfos;
                const VkDeviceAddress* pIndirectDeviceAddresses;
                const uint32_t* pIndirectStrides;
                const uint32_t* const* ppMaxPrimitiveCounts;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&infoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pInfos, ((infoCount)) * sizeof(const VkAccelerationStructureBuildGeometryInfoKHR));
                for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
                {
                    reservedunmarshal_VkAccelerationStructureBuildGeometryInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildGeometryInfoKHR*)(pInfos + i), readStreamPtrPtr);
                }
                vkReadStream->alloc((void**)&pIndirectDeviceAddresses, ((infoCount)) * sizeof(const VkDeviceAddress));
                memcpy((VkDeviceAddress*)pIndirectDeviceAddresses, *readStreamPtrPtr, ((infoCount)) * sizeof(const VkDeviceAddress));
                *readStreamPtrPtr += ((infoCount)) * sizeof(const VkDeviceAddress);
                vkReadStream->alloc((void**)&pIndirectStrides, ((infoCount)) * sizeof(const uint32_t));
                memcpy((uint32_t*)pIndirectStrides, *readStreamPtrPtr, ((infoCount)) * sizeof(const uint32_t));
                *readStreamPtrPtr += ((infoCount)) * sizeof(const uint32_t);
                if (pInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
                    {
                        transform_tohost_VkAccelerationStructureBuildGeometryInfoKHR(m_state, (VkAccelerationStructureBuildGeometryInfoKHR*)(pInfos + i));
                    }
                }
                (void)ppMaxPrimitiveCounts;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdBuildAccelerationStructuresIndirectKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)infoCount, (unsigned long long)pInfos, (unsigned long long)pIndirectDeviceAddresses, (unsigned long long)pIndirectStrides, (unsigned long long)ppMaxPrimitiveCounts);
                }
                vk->vkCmdBuildAccelerationStructuresIndirectKHR(unboxed_commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBuildAccelerationStructuresIndirectKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkBuildAccelerationStructuresKHR:
            {
                android::base::beginTrace("vkBuildAccelerationStructuresKHR decode");
                VkDevice device;
                VkDeferredOperationKHR deferredOperation;
                uint32_t infoCount;
                const VkAccelerationStructureBuildGeometryInfoKHR* pInfos;
                const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkDeferredOperationKHR*)&deferredOperation, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&deferredOperation);
                *readStreamPtrPtr += 8;
                memcpy((uint32_t*)&infoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pInfos, ((infoCount)) * sizeof(const VkAccelerationStructureBuildGeometryInfoKHR));
                for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
                {
                    reservedunmarshal_VkAccelerationStructureBuildGeometryInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildGeometryInfoKHR*)(pInfos + i), readStreamPtrPtr);
                }
                if (pInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
                    {
                        transform_tohost_VkAccelerationStructureBuildGeometryInfoKHR(m_state, (VkAccelerationStructureBuildGeometryInfoKHR*)(pInfos + i));
                    }
                }
                (void)ppBuildRangeInfos;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkBuildAccelerationStructuresKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)deferredOperation, (unsigned long long)infoCount, (unsigned long long)pInfos, (unsigned long long)ppBuildRangeInfos);
                }
                VkResult vkBuildAccelerationStructuresKHR_VkResult_return = (VkResult)0;
                vkBuildAccelerationStructuresKHR_VkResult_return = vk->vkBuildAccelerationStructuresKHR(unboxed_device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBuildAccelerationStructuresKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBuildAccelerationStructuresKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBuildAccelerationStructuresKHR_VkResult_return, device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCopyAccelerationStructureKHR:
            {
                android::base::beginTrace("vkCopyAccelerationStructureKHR decode");
                VkDevice device;
                VkDeferredOperationKHR deferredOperation;
                const VkCopyAccelerationStructureInfoKHR* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkDeferredOperationKHR*)&deferredOperation, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&deferredOperation);
                *readStreamPtrPtr += 8;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkCopyAccelerationStructureInfoKHR));
                reservedunmarshal_VkCopyAccelerationStructureInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyAccelerationStructureInfoKHR*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkCopyAccelerationStructureInfoKHR(m_state, (VkCopyAccelerationStructureInfoKHR*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCopyAccelerationStructureKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)deferredOperation, (unsigned long long)pInfo);
                }
                VkResult vkCopyAccelerationStructureKHR_VkResult_return = (VkResult)0;
                vkCopyAccelerationStructureKHR_VkResult_return = vk->vkCopyAccelerationStructureKHR(unboxed_device, deferredOperation, pInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkCopyAccelerationStructureKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCopyAccelerationStructureKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCopyAccelerationStructureKHR_VkResult_return, device, deferredOperation, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCopyAccelerationStructureToMemoryKHR:
            {
                android::base::beginTrace("vkCopyAccelerationStructureToMemoryKHR decode");
                VkDevice device;
                VkDeferredOperationKHR deferredOperation;
                const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkDeferredOperationKHR*)&deferredOperation, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&deferredOperation);
                *readStreamPtrPtr += 8;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkCopyAccelerationStructureToMemoryInfoKHR));
                reservedunmarshal_VkCopyAccelerationStructureToMemoryInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyAccelerationStructureToMemoryInfoKHR*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkCopyAccelerationStructureToMemoryInfoKHR(m_state, (VkCopyAccelerationStructureToMemoryInfoKHR*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCopyAccelerationStructureToMemoryKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)deferredOperation, (unsigned long long)pInfo);
                }
                VkResult vkCopyAccelerationStructureToMemoryKHR_VkResult_return = (VkResult)0;
                vkCopyAccelerationStructureToMemoryKHR_VkResult_return = vk->vkCopyAccelerationStructureToMemoryKHR(unboxed_device, deferredOperation, pInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkCopyAccelerationStructureToMemoryKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCopyAccelerationStructureToMemoryKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCopyAccelerationStructureToMemoryKHR_VkResult_return, device, deferredOperation, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCopyMemoryToAccelerationStructureKHR:
            {
                android::base::beginTrace("vkCopyMemoryToAccelerationStructureKHR decode");
                VkDevice device;
                VkDeferredOperationKHR deferredOperation;
                const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkDeferredOperationKHR*)&deferredOperation, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&deferredOperation);
                *readStreamPtrPtr += 8;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkCopyMemoryToAccelerationStructureInfoKHR));
                reservedunmarshal_VkCopyMemoryToAccelerationStructureInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyMemoryToAccelerationStructureInfoKHR*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkCopyMemoryToAccelerationStructureInfoKHR(m_state, (VkCopyMemoryToAccelerationStructureInfoKHR*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCopyMemoryToAccelerationStructureKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)deferredOperation, (unsigned long long)pInfo);
                }
                VkResult vkCopyMemoryToAccelerationStructureKHR_VkResult_return = (VkResult)0;
                vkCopyMemoryToAccelerationStructureKHR_VkResult_return = vk->vkCopyMemoryToAccelerationStructureKHR(unboxed_device, deferredOperation, pInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkCopyMemoryToAccelerationStructureKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCopyMemoryToAccelerationStructureKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCopyMemoryToAccelerationStructureKHR_VkResult_return, device, deferredOperation, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkWriteAccelerationStructuresPropertiesKHR:
            {
                android::base::beginTrace("vkWriteAccelerationStructuresPropertiesKHR decode");
                VkDevice device;
                uint32_t accelerationStructureCount;
                const VkAccelerationStructureKHR* pAccelerationStructures;
                VkQueryType queryType;
                size_t dataSize;
                void* pData;
                size_t stride;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((uint32_t*)&accelerationStructureCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pAccelerationStructures, ((accelerationStructureCount)) * sizeof(const VkAccelerationStructureKHR));
                if (((accelerationStructureCount)))
                {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((accelerationStructureCount));
                    for (uint32_t k = 0; k < ((accelerationStructureCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkAccelerationStructureKHR*)pAccelerationStructures) + k) = (VkAccelerationStructureKHR)unbox_VkAccelerationStructureKHR((VkAccelerationStructureKHR)tmpval);
                    }
                }
                memcpy((VkQueryType*)&queryType, *readStreamPtrPtr, sizeof(VkQueryType));
                *readStreamPtrPtr += sizeof(VkQueryType);
                memcpy((size_t*)&dataSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&dataSize);
                *readStreamPtrPtr += 8;
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(uint8_t));
                memcpy((void*)pData, *readStreamPtrPtr, ((dataSize)) * sizeof(uint8_t));
                *readStreamPtrPtr += ((dataSize)) * sizeof(uint8_t);
                memcpy((size_t*)&stride, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&stride);
                *readStreamPtrPtr += 8;
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkWriteAccelerationStructuresPropertiesKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)accelerationStructureCount, (unsigned long long)pAccelerationStructures, (unsigned long long)queryType, (unsigned long long)dataSize, (unsigned long long)pData, (unsigned long long)stride);
                }
                VkResult vkWriteAccelerationStructuresPropertiesKHR_VkResult_return = (VkResult)0;
                vkWriteAccelerationStructuresPropertiesKHR_VkResult_return = vk->vkWriteAccelerationStructuresPropertiesKHR(unboxed_device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
                vkStream->unsetHandleMapping();
                vkStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkStream->write(&vkWriteAccelerationStructuresPropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkWriteAccelerationStructuresPropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkWriteAccelerationStructuresPropertiesKHR_VkResult_return, device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyAccelerationStructureKHR:
            {
                android::base::beginTrace("vkCmdCopyAccelerationStructureKHR decode");
                VkCommandBuffer commandBuffer;
                const VkCopyAccelerationStructureInfoKHR* pInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkCopyAccelerationStructureInfoKHR));
                reservedunmarshal_VkCopyAccelerationStructureInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyAccelerationStructureInfoKHR*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkCopyAccelerationStructureInfoKHR(m_state, (VkCopyAccelerationStructureInfoKHR*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyAccelerationStructureKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pInfo);
                }
                vk->vkCmdCopyAccelerationStructureKHR(unboxed_commandBuffer, pInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyAccelerationStructureKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyAccelerationStructureToMemoryKHR:
            {
                android::base::beginTrace("vkCmdCopyAccelerationStructureToMemoryKHR decode");
                VkCommandBuffer commandBuffer;
                const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkCopyAccelerationStructureToMemoryInfoKHR));
                reservedunmarshal_VkCopyAccelerationStructureToMemoryInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyAccelerationStructureToMemoryInfoKHR*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkCopyAccelerationStructureToMemoryInfoKHR(m_state, (VkCopyAccelerationStructureToMemoryInfoKHR*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyAccelerationStructureToMemoryKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pInfo);
                }
                vk->vkCmdCopyAccelerationStructureToMemoryKHR(unboxed_commandBuffer, pInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyAccelerationStructureToMemoryKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdCopyMemoryToAccelerationStructureKHR:
            {
                android::base::beginTrace("vkCmdCopyMemoryToAccelerationStructureKHR decode");
                VkCommandBuffer commandBuffer;
                const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkCopyMemoryToAccelerationStructureInfoKHR));
                reservedunmarshal_VkCopyMemoryToAccelerationStructureInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyMemoryToAccelerationStructureInfoKHR*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkCopyMemoryToAccelerationStructureInfoKHR(m_state, (VkCopyMemoryToAccelerationStructureInfoKHR*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdCopyMemoryToAccelerationStructureKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pInfo);
                }
                vk->vkCmdCopyMemoryToAccelerationStructureKHR(unboxed_commandBuffer, pInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyMemoryToAccelerationStructureKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetAccelerationStructureDeviceAddressKHR:
            {
                android::base::beginTrace("vkGetAccelerationStructureDeviceAddressKHR decode");
                VkDevice device;
                const VkAccelerationStructureDeviceAddressInfoKHR* pInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkAccelerationStructureDeviceAddressInfoKHR));
                reservedunmarshal_VkAccelerationStructureDeviceAddressInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureDeviceAddressInfoKHR*)(pInfo), readStreamPtrPtr);
                if (pInfo)
                {
                    transform_tohost_VkAccelerationStructureDeviceAddressInfoKHR(m_state, (VkAccelerationStructureDeviceAddressInfoKHR*)(pInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetAccelerationStructureDeviceAddressKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo);
                }
                VkDeviceAddress vkGetAccelerationStructureDeviceAddressKHR_VkDeviceAddress_return = (VkDeviceAddress)0;
                vkGetAccelerationStructureDeviceAddressKHR_VkDeviceAddress_return = vk->vkGetAccelerationStructureDeviceAddressKHR(unboxed_device, pInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetAccelerationStructureDeviceAddressKHR_VkDeviceAddress_return, sizeof(VkDeviceAddress));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetAccelerationStructureDeviceAddressKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetAccelerationStructureDeviceAddressKHR_VkDeviceAddress_return, device, pInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdWriteAccelerationStructuresPropertiesKHR:
            {
                android::base::beginTrace("vkCmdWriteAccelerationStructuresPropertiesKHR decode");
                VkCommandBuffer commandBuffer;
                uint32_t accelerationStructureCount;
                const VkAccelerationStructureKHR* pAccelerationStructures;
                VkQueryType queryType;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&accelerationStructureCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pAccelerationStructures, ((accelerationStructureCount)) * sizeof(const VkAccelerationStructureKHR));
                if (((accelerationStructureCount)))
                {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((accelerationStructureCount));
                    for (uint32_t k = 0; k < ((accelerationStructureCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkAccelerationStructureKHR*)pAccelerationStructures) + k) = (VkAccelerationStructureKHR)unbox_VkAccelerationStructureKHR((VkAccelerationStructureKHR)tmpval);
                    }
                }
                memcpy((VkQueryType*)&queryType, *readStreamPtrPtr, sizeof(VkQueryType));
                *readStreamPtrPtr += sizeof(VkQueryType);
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool = (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_2));
                memcpy((uint32_t*)&firstQuery, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdWriteAccelerationStructuresPropertiesKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)accelerationStructureCount, (unsigned long long)pAccelerationStructures, (unsigned long long)queryType, (unsigned long long)queryPool, (unsigned long long)firstQuery);
                }
                vk->vkCmdWriteAccelerationStructuresPropertiesKHR(unboxed_commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdWriteAccelerationStructuresPropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetDeviceAccelerationStructureCompatibilityKHR:
            {
                android::base::beginTrace("vkGetDeviceAccelerationStructureCompatibilityKHR decode");
                VkDevice device;
                const VkAccelerationStructureVersionInfoKHR* pVersionInfo;
                VkAccelerationStructureCompatibilityKHR* pCompatibility;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pVersionInfo, sizeof(const VkAccelerationStructureVersionInfoKHR));
                reservedunmarshal_VkAccelerationStructureVersionInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureVersionInfoKHR*)(pVersionInfo), readStreamPtrPtr);
                // Begin manual dispatchable handle unboxing for pCompatibility;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCompatibility, sizeof(VkAccelerationStructureCompatibilityKHR));
                memcpy((VkAccelerationStructureCompatibilityKHR*)pCompatibility, *readStreamPtrPtr, sizeof(VkAccelerationStructureCompatibilityKHR));
                *readStreamPtrPtr += sizeof(VkAccelerationStructureCompatibilityKHR);
                if (pVersionInfo)
                {
                    transform_tohost_VkAccelerationStructureVersionInfoKHR(m_state, (VkAccelerationStructureVersionInfoKHR*)(pVersionInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetDeviceAccelerationStructureCompatibilityKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pVersionInfo, (unsigned long long)pCompatibility);
                }
                vk->vkGetDeviceAccelerationStructureCompatibilityKHR(unboxed_device, pVersionInfo, pCompatibility);
                vkStream->unsetHandleMapping();
                vkStream->write((VkAccelerationStructureCompatibilityKHR*)pCompatibility, sizeof(VkAccelerationStructureCompatibilityKHR));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceAccelerationStructureCompatibilityKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pVersionInfo, pCompatibility);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetAccelerationStructureBuildSizesKHR:
            {
                android::base::beginTrace("vkGetAccelerationStructureBuildSizesKHR decode");
                VkDevice device;
                VkAccelerationStructureBuildTypeKHR buildType;
                const VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo;
                const uint32_t* pMaxPrimitiveCounts;
                VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkAccelerationStructureBuildTypeKHR*)&buildType, *readStreamPtrPtr, sizeof(VkAccelerationStructureBuildTypeKHR));
                *readStreamPtrPtr += sizeof(VkAccelerationStructureBuildTypeKHR);
                vkReadStream->alloc((void**)&pBuildInfo, sizeof(const VkAccelerationStructureBuildGeometryInfoKHR));
                reservedunmarshal_VkAccelerationStructureBuildGeometryInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildGeometryInfoKHR*)(pBuildInfo), readStreamPtrPtr);
                vkReadStream->alloc((void**)&pMaxPrimitiveCounts, pBuildInfo->geometryCount * sizeof(const uint32_t));
                memcpy((uint32_t*)pMaxPrimitiveCounts, *readStreamPtrPtr, pBuildInfo->geometryCount * sizeof(const uint32_t));
                *readStreamPtrPtr += pBuildInfo->geometryCount * sizeof(const uint32_t);
                // Begin manual dispatchable handle unboxing for pSizeInfo;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSizeInfo, sizeof(VkAccelerationStructureBuildSizesInfoKHR));
                reservedunmarshal_VkAccelerationStructureBuildSizesInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildSizesInfoKHR*)(pSizeInfo), readStreamPtrPtr);
                if (pBuildInfo)
                {
                    transform_tohost_VkAccelerationStructureBuildGeometryInfoKHR(m_state, (VkAccelerationStructureBuildGeometryInfoKHR*)(pBuildInfo));
                }
                if (pSizeInfo)
                {
                    transform_tohost_VkAccelerationStructureBuildSizesInfoKHR(m_state, (VkAccelerationStructureBuildSizesInfoKHR*)(pSizeInfo));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetAccelerationStructureBuildSizesKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buildType, (unsigned long long)pBuildInfo, (unsigned long long)pMaxPrimitiveCounts, (unsigned long long)pSizeInfo);
                }
                vk->vkGetAccelerationStructureBuildSizesKHR(unboxed_device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
                vkStream->unsetHandleMapping();
                if (pSizeInfo)
                {
                    transform_fromhost_VkAccelerationStructureBuildSizesInfoKHR(m_state, (VkAccelerationStructureBuildSizesInfoKHR*)(pSizeInfo));
                }
                marshal_VkAccelerationStructureBuildSizesInfoKHR(vkStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildSizesInfoKHR*)(pSizeInfo));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetAccelerationStructureBuildSizesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
            case OP_vkCmdTraceRaysKHR:
            {
                android::base::beginTrace("vkCmdTraceRaysKHR decode");
                VkCommandBuffer commandBuffer;
                const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable;
                const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable;
                const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable;
                const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable;
                uint32_t width;
                uint32_t height;
                uint32_t depth;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pRaygenShaderBindingTable, sizeof(const VkStridedDeviceAddressRegionKHR));
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(pRaygenShaderBindingTable), readStreamPtrPtr);
                vkReadStream->alloc((void**)&pMissShaderBindingTable, sizeof(const VkStridedDeviceAddressRegionKHR));
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(pMissShaderBindingTable), readStreamPtrPtr);
                vkReadStream->alloc((void**)&pHitShaderBindingTable, sizeof(const VkStridedDeviceAddressRegionKHR));
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(pHitShaderBindingTable), readStreamPtrPtr);
                vkReadStream->alloc((void**)&pCallableShaderBindingTable, sizeof(const VkStridedDeviceAddressRegionKHR));
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(pCallableShaderBindingTable), readStreamPtrPtr);
                memcpy((uint32_t*)&width, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&height, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&depth, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (pRaygenShaderBindingTable)
                {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(m_state, (VkStridedDeviceAddressRegionKHR*)(pRaygenShaderBindingTable));
                }
                if (pMissShaderBindingTable)
                {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(m_state, (VkStridedDeviceAddressRegionKHR*)(pMissShaderBindingTable));
                }
                if (pHitShaderBindingTable)
                {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(m_state, (VkStridedDeviceAddressRegionKHR*)(pHitShaderBindingTable));
                }
                if (pCallableShaderBindingTable)
                {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(m_state, (VkStridedDeviceAddressRegionKHR*)(pCallableShaderBindingTable));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdTraceRaysKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pRaygenShaderBindingTable, (unsigned long long)pMissShaderBindingTable, (unsigned long long)pHitShaderBindingTable, (unsigned long long)pCallableShaderBindingTable, (unsigned long long)width, (unsigned long long)height, (unsigned long long)depth);
                }
                vk->vkCmdTraceRaysKHR(unboxed_commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdTraceRaysKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCreateRayTracingPipelinesKHR:
            {
                android::base::beginTrace("vkCreateRayTracingPipelinesKHR decode");
                VkDevice device;
                VkDeferredOperationKHR deferredOperation;
                VkPipelineCache pipelineCache;
                uint32_t createInfoCount;
                const VkRayTracingPipelineCreateInfoKHR* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkPipeline* pPipelines;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                memcpy((VkDeferredOperationKHR*)&deferredOperation, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&deferredOperation);
                *readStreamPtrPtr += 8;
                uint64_t cgen_var_2;
                memcpy((uint64_t*)&cgen_var_2, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineCache*)&pipelineCache = (VkPipelineCache)unbox_VkPipelineCache((VkPipelineCache)(*&cgen_var_2));
                memcpy((uint32_t*)&createInfoCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vkReadStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkRayTracingPipelineCreateInfoKHR));
                for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                {
                    reservedunmarshal_VkRayTracingPipelineCreateInfoKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRayTracingPipelineCreateInfoKHR*)(pCreateInfos + i), readStreamPtrPtr);
                }
                // WARNING PTR CHECK
                memcpy((VkAllocationCallbacks**)&pAllocator, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pAllocator);
                *readStreamPtrPtr += 8;
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    reservedunmarshal_VkAllocationCallbacks(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(pAllocator), readStreamPtrPtr);
                }
                // Begin manual dispatchable handle unboxing for pPipelines;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                if (((createInfoCount)))
                {
                    uint8_t* cgen_var_4_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((createInfoCount));
                    for (uint32_t k = 0; k < ((createInfoCount)); ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_4_ptr + k * 8, sizeof(uint64_t));
                        *(((VkPipeline*)pPipelines) + k) = (VkPipeline)(VkPipeline)((VkPipeline)tmpval);
                    }
                }
                if (pCreateInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                    {
                        transform_tohost_VkRayTracingPipelineCreateInfoKHR(m_state, (VkRayTracingPipelineCreateInfoKHR*)(pCreateInfos + i));
                    }
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCreateRayTracingPipelinesKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)deferredOperation, (unsigned long long)pipelineCache, (unsigned long long)createInfoCount, (unsigned long long)pCreateInfos, (unsigned long long)pAllocator, (unsigned long long)pPipelines);
                }
                VkResult vkCreateRayTracingPipelinesKHR_VkResult_return = (VkResult)0;
                vkCreateRayTracingPipelinesKHR_VkResult_return = vk->vkCreateRayTracingPipelinesKHR(unboxed_device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                vkStream->unsetHandleMapping();
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_5;
                    vkStream->alloc((void**)&cgen_var_5, ((createInfoCount)) * 8);
                    vkStream->handleMapping()->mapHandles_VkPipeline_u64(pPipelines, cgen_var_5, ((createInfoCount)));
                    vkStream->write((uint64_t*)cgen_var_5, ((createInfoCount)) * 8);
                }
                vkStream->write(&vkCreateRayTracingPipelinesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateRayTracingPipelinesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateRayTracingPipelinesKHR_VkResult_return, device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR:
            {
                android::base::beginTrace("vkGetRayTracingCaptureReplayShaderGroupHandlesKHR decode");
                VkDevice device;
                VkPipeline pipeline;
                uint32_t firstGroup;
                uint32_t groupCount;
                size_t dataSize;
                void* pData;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipeline*)&pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_1));
                memcpy((uint32_t*)&firstGroup, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((size_t*)&dataSize, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&dataSize);
                *readStreamPtrPtr += 8;
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(uint8_t));
                memcpy((void*)pData, *readStreamPtrPtr, ((dataSize)) * sizeof(uint8_t));
                *readStreamPtrPtr += ((dataSize)) * sizeof(uint8_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetRayTracingCaptureReplayShaderGroupHandlesKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipeline, (unsigned long long)firstGroup, (unsigned long long)groupCount, (unsigned long long)dataSize, (unsigned long long)pData);
                }
                VkResult vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return = (VkResult)0;
                vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return = vk->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(unboxed_device, pipeline, firstGroup, groupCount, dataSize, pData);
                vkStream->unsetHandleMapping();
                vkStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkStream->write(&vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return, device, pipeline, firstGroup, groupCount, dataSize, pData);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdTraceRaysIndirectKHR:
            {
                android::base::beginTrace("vkCmdTraceRaysIndirectKHR decode");
                VkCommandBuffer commandBuffer;
                const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable;
                const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable;
                const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable;
                const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable;
                VkDeviceAddress indirectDeviceAddress;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pRaygenShaderBindingTable, sizeof(const VkStridedDeviceAddressRegionKHR));
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(pRaygenShaderBindingTable), readStreamPtrPtr);
                vkReadStream->alloc((void**)&pMissShaderBindingTable, sizeof(const VkStridedDeviceAddressRegionKHR));
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(pMissShaderBindingTable), readStreamPtrPtr);
                vkReadStream->alloc((void**)&pHitShaderBindingTable, sizeof(const VkStridedDeviceAddressRegionKHR));
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(pHitShaderBindingTable), readStreamPtrPtr);
                vkReadStream->alloc((void**)&pCallableShaderBindingTable, sizeof(const VkStridedDeviceAddressRegionKHR));
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(vkReadStream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(pCallableShaderBindingTable), readStreamPtrPtr);
                memcpy((VkDeviceAddress*)&indirectDeviceAddress, *readStreamPtrPtr, sizeof(VkDeviceAddress));
                *readStreamPtrPtr += sizeof(VkDeviceAddress);
                if (pRaygenShaderBindingTable)
                {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(m_state, (VkStridedDeviceAddressRegionKHR*)(pRaygenShaderBindingTable));
                }
                if (pMissShaderBindingTable)
                {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(m_state, (VkStridedDeviceAddressRegionKHR*)(pMissShaderBindingTable));
                }
                if (pHitShaderBindingTable)
                {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(m_state, (VkStridedDeviceAddressRegionKHR*)(pHitShaderBindingTable));
                }
                if (pCallableShaderBindingTable)
                {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(m_state, (VkStridedDeviceAddressRegionKHR*)(pCallableShaderBindingTable));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdTraceRaysIndirectKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pRaygenShaderBindingTable, (unsigned long long)pMissShaderBindingTable, (unsigned long long)pHitShaderBindingTable, (unsigned long long)pCallableShaderBindingTable, (unsigned long long)indirectDeviceAddress);
                }
                vk->vkCmdTraceRaysIndirectKHR(unboxed_commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdTraceRaysIndirectKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkGetRayTracingShaderGroupStackSizeKHR:
            {
                android::base::beginTrace("vkGetRayTracingShaderGroupStackSizeKHR decode");
                VkDevice device;
                VkPipeline pipeline;
                uint32_t group;
                VkShaderGroupShaderKHR groupShader;
                // Begin non wrapped dispatchable handle unboxing for device;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkDevice*)&device = (VkDevice)(VkDevice)((VkDevice)(*&cgen_var_0));
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipeline*)&pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_1));
                memcpy((uint32_t*)&group, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((VkShaderGroupShaderKHR*)&groupShader, *readStreamPtrPtr, sizeof(VkShaderGroupShaderKHR));
                *readStreamPtrPtr += sizeof(VkShaderGroupShaderKHR);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkGetRayTracingShaderGroupStackSizeKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipeline, (unsigned long long)group, (unsigned long long)groupShader);
                }
                VkDeviceSize vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return = (VkDeviceSize)0;
                vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return = vk->vkGetRayTracingShaderGroupStackSizeKHR(unboxed_device, pipeline, group, groupShader);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return, sizeof(VkDeviceSize));
                vkStream->commitWrite();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetRayTracingShaderGroupStackSizeKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return, device, pipeline, group, groupShader);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
            case OP_vkCmdSetRayTracingPipelineStackSizeKHR:
            {
                android::base::beginTrace("vkCmdSetRayTracingPipelineStackSizeKHR decode");
                VkCommandBuffer commandBuffer;
                uint32_t pipelineStackSize;
                // Begin non wrapped dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkCommandBuffer*)&commandBuffer = (VkCommandBuffer)(VkCommandBuffer)((VkCommandBuffer)(*&cgen_var_0));
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                // End manual dispatchable handle unboxing for commandBuffer;
                memcpy((uint32_t*)&pipelineStackSize, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (m_logCalls)
                {
                    fprintf(stderr, "stream %p: call vkCmdSetRayTracingPipelineStackSizeKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineStackSize);
                }
                vk->vkCmdSetRayTracingPipelineStackSizeKHR(unboxed_commandBuffer, pipelineStackSize);
                vkStream->unsetHandleMapping();
                vkReadStream->setReadPos((uintptr_t)(*readStreamPtrPtr) - (uintptr_t)snapshotTraceBegin);
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetRayTracingPipelineStackSizeKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineStackSize);
                }
                vkReadStream->clearPool();
                if (queueSubmitWithCommandsEnabled) __atomic_fetch_add(seqnoPtr, 1, __ATOMIC_SEQ_CST);
                android::base::endTrace();
                break;
            }
#endif
#ifdef VK_KHR_ray_query
#endif
            default:
            {
                m_pool.freeAll();
                return ptr - (unsigned char *)buf;
            }
        }
        ptr += packetLen;
    }
    if (m_forSnapshotLoad)
    {
        m_state->clearCreatedHandlesForSnapshotLoad();
    }
    m_pool.freeAll();
    return ptr - (unsigned char*)buf;;
}


