// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_testing
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "goldfish_vk_testing.h"


#include "goldfish_vk_extension_structs.h"
#include "goldfish_vk_private_defs.h"


namespace goldfish_vk {

void checkEqual_extension_struct(
    const void* structExtension,
    const void* structExtension2,
    OnFailCompareFunc onFail);

#ifdef VK_VERSION_1_0
void checkEqual_VkApplicationInfo(
    const VkApplicationInfo* a,
    const VkApplicationInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pApplicationName) && !(b->pApplicationName)) || ((a->pApplicationName) && (b->pApplicationName)))) { onFail("a->pApplicationName (Error: Mismatch in string pointer nullness)"); };
    if ((a->pApplicationName) && (b->pApplicationName))
    {
        if (!((strcmp(a->pApplicationName, b->pApplicationName) == 0))) { onFail("a->pApplicationName (Error: Unequal strings)"); };
    }
    if (!((a->applicationVersion) == (b->applicationVersion))) { onFail("a->applicationVersion (Error: Value not equal)"); };
    if (!((!(a->pEngineName) && !(b->pEngineName)) || ((a->pEngineName) && (b->pEngineName)))) { onFail("a->pEngineName (Error: Mismatch in string pointer nullness)"); };
    if ((a->pEngineName) && (b->pEngineName))
    {
        if (!((strcmp(a->pEngineName, b->pEngineName) == 0))) { onFail("a->pEngineName (Error: Unequal strings)"); };
    }
    if (!((a->engineVersion) == (b->engineVersion))) { onFail("a->engineVersion (Error: Value not equal)"); };
    if (!((a->apiVersion) == (b->apiVersion))) { onFail("a->apiVersion (Error: Value not equal)"); };
}

void checkEqual_VkInstanceCreateInfo(
    const VkInstanceCreateInfo* a,
    const VkInstanceCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->pApplicationInfo) && !(b->pApplicationInfo)) || ((a->pApplicationInfo) && (b->pApplicationInfo)))) { onFail("a->pApplicationInfo (Error: Mismatch in optional field)"); };
    if (a->pApplicationInfo && b->pApplicationInfo)
    {
        if ((a->pApplicationInfo) && (b->pApplicationInfo))
        {
            checkEqual_VkApplicationInfo(a->pApplicationInfo, b->pApplicationInfo, onFail);
        }
    }
    if (!((a->enabledLayerCount) == (b->enabledLayerCount))) { onFail("a->enabledLayerCount (Error: Value not equal)"); };
    if (!((!(a->ppEnabledLayerNames) && !(b->ppEnabledLayerNames)) || ((a->ppEnabledLayerNames) && (b->ppEnabledLayerNames)))) { onFail("a->ppEnabledLayerNames (Error: Mismatch in string array pointer nullness)"); };
    if (!((a->enabledLayerCount) == (b->enabledLayerCount))) { onFail("a->ppEnabledLayerNames (Error: Lengths not equal in string array)"); };
    if (!((a->enabledLayerCount) == (b->enabledLayerCount))) { onFail("a->ppEnabledLayerNames (Error: Lengths not equal in string array)"); };
    if ((a->enabledLayerCount) == (b->enabledLayerCount) && (a->ppEnabledLayerNames) && (b->ppEnabledLayerNames))
    {
        for (uint32_t i = 0; i < (uint32_t)a->enabledLayerCount; ++i)
        {
            if (!((strcmp(*(a->ppEnabledLayerNames + i), *(b->ppEnabledLayerNames + i)) == 0))) { onFail("a->ppEnabledLayerNames (Error: Unequal string in string array)"); };
        }
    }
    if (!((a->enabledExtensionCount) == (b->enabledExtensionCount))) { onFail("a->enabledExtensionCount (Error: Value not equal)"); };
    if (!((!(a->ppEnabledExtensionNames) && !(b->ppEnabledExtensionNames)) || ((a->ppEnabledExtensionNames) && (b->ppEnabledExtensionNames)))) { onFail("a->ppEnabledExtensionNames (Error: Mismatch in string array pointer nullness)"); };
    if (!((a->enabledExtensionCount) == (b->enabledExtensionCount))) { onFail("a->ppEnabledExtensionNames (Error: Lengths not equal in string array)"); };
    if (!((a->enabledExtensionCount) == (b->enabledExtensionCount))) { onFail("a->ppEnabledExtensionNames (Error: Lengths not equal in string array)"); };
    if ((a->enabledExtensionCount) == (b->enabledExtensionCount) && (a->ppEnabledExtensionNames) && (b->ppEnabledExtensionNames))
    {
        for (uint32_t i = 0; i < (uint32_t)a->enabledExtensionCount; ++i)
        {
            if (!((strcmp(*(a->ppEnabledExtensionNames + i), *(b->ppEnabledExtensionNames + i)) == 0))) { onFail("a->ppEnabledExtensionNames (Error: Unequal string in string array)"); };
        }
    }
}

void checkEqual_VkAllocationCallbacks(
    const VkAllocationCallbacks* a,
    const VkAllocationCallbacks* b,
    OnFailCompareFunc onFail)
{
    if (!((!(a->pUserData) && !(b->pUserData)) || ((a->pUserData) && (b->pUserData)))) { onFail("a->pUserData (Error: Mismatch in optional field)"); };
    if (!((a->pfnAllocation) == (b->pfnAllocation))) { onFail("a->pfnAllocation (Error: Value not equal)"); };
    if (!((a->pfnReallocation) == (b->pfnReallocation))) { onFail("a->pfnReallocation (Error: Value not equal)"); };
    if (!((a->pfnFree) == (b->pfnFree))) { onFail("a->pfnFree (Error: Value not equal)"); };
    if (!((a->pfnInternalAllocation) == (b->pfnInternalAllocation))) { onFail("a->pfnInternalAllocation (Error: Value not equal)"); };
    if (!((a->pfnInternalFree) == (b->pfnInternalFree))) { onFail("a->pfnInternalFree (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceFeatures(
    const VkPhysicalDeviceFeatures* a,
    const VkPhysicalDeviceFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->robustBufferAccess) == (b->robustBufferAccess))) { onFail("a->robustBufferAccess (Error: Value not equal)"); };
    if (!((a->fullDrawIndexUint32) == (b->fullDrawIndexUint32))) { onFail("a->fullDrawIndexUint32 (Error: Value not equal)"); };
    if (!((a->imageCubeArray) == (b->imageCubeArray))) { onFail("a->imageCubeArray (Error: Value not equal)"); };
    if (!((a->independentBlend) == (b->independentBlend))) { onFail("a->independentBlend (Error: Value not equal)"); };
    if (!((a->geometryShader) == (b->geometryShader))) { onFail("a->geometryShader (Error: Value not equal)"); };
    if (!((a->tessellationShader) == (b->tessellationShader))) { onFail("a->tessellationShader (Error: Value not equal)"); };
    if (!((a->sampleRateShading) == (b->sampleRateShading))) { onFail("a->sampleRateShading (Error: Value not equal)"); };
    if (!((a->dualSrcBlend) == (b->dualSrcBlend))) { onFail("a->dualSrcBlend (Error: Value not equal)"); };
    if (!((a->logicOp) == (b->logicOp))) { onFail("a->logicOp (Error: Value not equal)"); };
    if (!((a->multiDrawIndirect) == (b->multiDrawIndirect))) { onFail("a->multiDrawIndirect (Error: Value not equal)"); };
    if (!((a->drawIndirectFirstInstance) == (b->drawIndirectFirstInstance))) { onFail("a->drawIndirectFirstInstance (Error: Value not equal)"); };
    if (!((a->depthClamp) == (b->depthClamp))) { onFail("a->depthClamp (Error: Value not equal)"); };
    if (!((a->depthBiasClamp) == (b->depthBiasClamp))) { onFail("a->depthBiasClamp (Error: Value not equal)"); };
    if (!((a->fillModeNonSolid) == (b->fillModeNonSolid))) { onFail("a->fillModeNonSolid (Error: Value not equal)"); };
    if (!((a->depthBounds) == (b->depthBounds))) { onFail("a->depthBounds (Error: Value not equal)"); };
    if (!((a->wideLines) == (b->wideLines))) { onFail("a->wideLines (Error: Value not equal)"); };
    if (!((a->largePoints) == (b->largePoints))) { onFail("a->largePoints (Error: Value not equal)"); };
    if (!((a->alphaToOne) == (b->alphaToOne))) { onFail("a->alphaToOne (Error: Value not equal)"); };
    if (!((a->multiViewport) == (b->multiViewport))) { onFail("a->multiViewport (Error: Value not equal)"); };
    if (!((a->samplerAnisotropy) == (b->samplerAnisotropy))) { onFail("a->samplerAnisotropy (Error: Value not equal)"); };
    if (!((a->textureCompressionETC2) == (b->textureCompressionETC2))) { onFail("a->textureCompressionETC2 (Error: Value not equal)"); };
    if (!((a->textureCompressionASTC_LDR) == (b->textureCompressionASTC_LDR))) { onFail("a->textureCompressionASTC_LDR (Error: Value not equal)"); };
    if (!((a->textureCompressionBC) == (b->textureCompressionBC))) { onFail("a->textureCompressionBC (Error: Value not equal)"); };
    if (!((a->occlusionQueryPrecise) == (b->occlusionQueryPrecise))) { onFail("a->occlusionQueryPrecise (Error: Value not equal)"); };
    if (!((a->pipelineStatisticsQuery) == (b->pipelineStatisticsQuery))) { onFail("a->pipelineStatisticsQuery (Error: Value not equal)"); };
    if (!((a->vertexPipelineStoresAndAtomics) == (b->vertexPipelineStoresAndAtomics))) { onFail("a->vertexPipelineStoresAndAtomics (Error: Value not equal)"); };
    if (!((a->fragmentStoresAndAtomics) == (b->fragmentStoresAndAtomics))) { onFail("a->fragmentStoresAndAtomics (Error: Value not equal)"); };
    if (!((a->shaderTessellationAndGeometryPointSize) == (b->shaderTessellationAndGeometryPointSize))) { onFail("a->shaderTessellationAndGeometryPointSize (Error: Value not equal)"); };
    if (!((a->shaderImageGatherExtended) == (b->shaderImageGatherExtended))) { onFail("a->shaderImageGatherExtended (Error: Value not equal)"); };
    if (!((a->shaderStorageImageExtendedFormats) == (b->shaderStorageImageExtendedFormats))) { onFail("a->shaderStorageImageExtendedFormats (Error: Value not equal)"); };
    if (!((a->shaderStorageImageMultisample) == (b->shaderStorageImageMultisample))) { onFail("a->shaderStorageImageMultisample (Error: Value not equal)"); };
    if (!((a->shaderStorageImageReadWithoutFormat) == (b->shaderStorageImageReadWithoutFormat))) { onFail("a->shaderStorageImageReadWithoutFormat (Error: Value not equal)"); };
    if (!((a->shaderStorageImageWriteWithoutFormat) == (b->shaderStorageImageWriteWithoutFormat))) { onFail("a->shaderStorageImageWriteWithoutFormat (Error: Value not equal)"); };
    if (!((a->shaderUniformBufferArrayDynamicIndexing) == (b->shaderUniformBufferArrayDynamicIndexing))) { onFail("a->shaderUniformBufferArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderSampledImageArrayDynamicIndexing) == (b->shaderSampledImageArrayDynamicIndexing))) { onFail("a->shaderSampledImageArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageBufferArrayDynamicIndexing) == (b->shaderStorageBufferArrayDynamicIndexing))) { onFail("a->shaderStorageBufferArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageImageArrayDynamicIndexing) == (b->shaderStorageImageArrayDynamicIndexing))) { onFail("a->shaderStorageImageArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderClipDistance) == (b->shaderClipDistance))) { onFail("a->shaderClipDistance (Error: Value not equal)"); };
    if (!((a->shaderCullDistance) == (b->shaderCullDistance))) { onFail("a->shaderCullDistance (Error: Value not equal)"); };
    if (!((a->shaderFloat64) == (b->shaderFloat64))) { onFail("a->shaderFloat64 (Error: Value not equal)"); };
    if (!((a->shaderInt64) == (b->shaderInt64))) { onFail("a->shaderInt64 (Error: Value not equal)"); };
    if (!((a->shaderInt16) == (b->shaderInt16))) { onFail("a->shaderInt16 (Error: Value not equal)"); };
    if (!((a->shaderResourceResidency) == (b->shaderResourceResidency))) { onFail("a->shaderResourceResidency (Error: Value not equal)"); };
    if (!((a->shaderResourceMinLod) == (b->shaderResourceMinLod))) { onFail("a->shaderResourceMinLod (Error: Value not equal)"); };
    if (!((a->sparseBinding) == (b->sparseBinding))) { onFail("a->sparseBinding (Error: Value not equal)"); };
    if (!((a->sparseResidencyBuffer) == (b->sparseResidencyBuffer))) { onFail("a->sparseResidencyBuffer (Error: Value not equal)"); };
    if (!((a->sparseResidencyImage2D) == (b->sparseResidencyImage2D))) { onFail("a->sparseResidencyImage2D (Error: Value not equal)"); };
    if (!((a->sparseResidencyImage3D) == (b->sparseResidencyImage3D))) { onFail("a->sparseResidencyImage3D (Error: Value not equal)"); };
    if (!((a->sparseResidency2Samples) == (b->sparseResidency2Samples))) { onFail("a->sparseResidency2Samples (Error: Value not equal)"); };
    if (!((a->sparseResidency4Samples) == (b->sparseResidency4Samples))) { onFail("a->sparseResidency4Samples (Error: Value not equal)"); };
    if (!((a->sparseResidency8Samples) == (b->sparseResidency8Samples))) { onFail("a->sparseResidency8Samples (Error: Value not equal)"); };
    if (!((a->sparseResidency16Samples) == (b->sparseResidency16Samples))) { onFail("a->sparseResidency16Samples (Error: Value not equal)"); };
    if (!((a->sparseResidencyAliased) == (b->sparseResidencyAliased))) { onFail("a->sparseResidencyAliased (Error: Value not equal)"); };
    if (!((a->variableMultisampleRate) == (b->variableMultisampleRate))) { onFail("a->variableMultisampleRate (Error: Value not equal)"); };
    if (!((a->inheritedQueries) == (b->inheritedQueries))) { onFail("a->inheritedQueries (Error: Value not equal)"); };
}

void checkEqual_VkFormatProperties(
    const VkFormatProperties* a,
    const VkFormatProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->linearTilingFeatures) == (b->linearTilingFeatures))) { onFail("a->linearTilingFeatures (Error: Value not equal)"); };
    if (!((a->optimalTilingFeatures) == (b->optimalTilingFeatures))) { onFail("a->optimalTilingFeatures (Error: Value not equal)"); };
    if (!((a->bufferFeatures) == (b->bufferFeatures))) { onFail("a->bufferFeatures (Error: Value not equal)"); };
}

void checkEqual_VkExtent3D(
    const VkExtent3D* a,
    const VkExtent3D* b,
    OnFailCompareFunc onFail)
{
    if (!((a->width) == (b->width))) { onFail("a->width (Error: Value not equal)"); };
    if (!((a->height) == (b->height))) { onFail("a->height (Error: Value not equal)"); };
    if (!((a->depth) == (b->depth))) { onFail("a->depth (Error: Value not equal)"); };
}

void checkEqual_VkImageFormatProperties(
    const VkImageFormatProperties* a,
    const VkImageFormatProperties* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkExtent3D(&a->maxExtent, &b->maxExtent, onFail);
    if (!((a->maxMipLevels) == (b->maxMipLevels))) { onFail("a->maxMipLevels (Error: Value not equal)"); };
    if (!((a->maxArrayLayers) == (b->maxArrayLayers))) { onFail("a->maxArrayLayers (Error: Value not equal)"); };
    if (!((a->sampleCounts) == (b->sampleCounts))) { onFail("a->sampleCounts (Error: Value not equal)"); };
    if (!((a->maxResourceSize) == (b->maxResourceSize))) { onFail("a->maxResourceSize (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceLimits(
    const VkPhysicalDeviceLimits* a,
    const VkPhysicalDeviceLimits* b,
    OnFailCompareFunc onFail)
{
    if (!((a->maxImageDimension1D) == (b->maxImageDimension1D))) { onFail("a->maxImageDimension1D (Error: Value not equal)"); };
    if (!((a->maxImageDimension2D) == (b->maxImageDimension2D))) { onFail("a->maxImageDimension2D (Error: Value not equal)"); };
    if (!((a->maxImageDimension3D) == (b->maxImageDimension3D))) { onFail("a->maxImageDimension3D (Error: Value not equal)"); };
    if (!((a->maxImageDimensionCube) == (b->maxImageDimensionCube))) { onFail("a->maxImageDimensionCube (Error: Value not equal)"); };
    if (!((a->maxImageArrayLayers) == (b->maxImageArrayLayers))) { onFail("a->maxImageArrayLayers (Error: Value not equal)"); };
    if (!((a->maxTexelBufferElements) == (b->maxTexelBufferElements))) { onFail("a->maxTexelBufferElements (Error: Value not equal)"); };
    if (!((a->maxUniformBufferRange) == (b->maxUniformBufferRange))) { onFail("a->maxUniformBufferRange (Error: Value not equal)"); };
    if (!((a->maxStorageBufferRange) == (b->maxStorageBufferRange))) { onFail("a->maxStorageBufferRange (Error: Value not equal)"); };
    if (!((a->maxPushConstantsSize) == (b->maxPushConstantsSize))) { onFail("a->maxPushConstantsSize (Error: Value not equal)"); };
    if (!((a->maxMemoryAllocationCount) == (b->maxMemoryAllocationCount))) { onFail("a->maxMemoryAllocationCount (Error: Value not equal)"); };
    if (!((a->maxSamplerAllocationCount) == (b->maxSamplerAllocationCount))) { onFail("a->maxSamplerAllocationCount (Error: Value not equal)"); };
    if (!((a->bufferImageGranularity) == (b->bufferImageGranularity))) { onFail("a->bufferImageGranularity (Error: Value not equal)"); };
    if (!((a->sparseAddressSpaceSize) == (b->sparseAddressSpaceSize))) { onFail("a->sparseAddressSpaceSize (Error: Value not equal)"); };
    if (!((a->maxBoundDescriptorSets) == (b->maxBoundDescriptorSets))) { onFail("a->maxBoundDescriptorSets (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorSamplers) == (b->maxPerStageDescriptorSamplers))) { onFail("a->maxPerStageDescriptorSamplers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUniformBuffers) == (b->maxPerStageDescriptorUniformBuffers))) { onFail("a->maxPerStageDescriptorUniformBuffers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorStorageBuffers) == (b->maxPerStageDescriptorStorageBuffers))) { onFail("a->maxPerStageDescriptorStorageBuffers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorSampledImages) == (b->maxPerStageDescriptorSampledImages))) { onFail("a->maxPerStageDescriptorSampledImages (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorStorageImages) == (b->maxPerStageDescriptorStorageImages))) { onFail("a->maxPerStageDescriptorStorageImages (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorInputAttachments) == (b->maxPerStageDescriptorInputAttachments))) { onFail("a->maxPerStageDescriptorInputAttachments (Error: Value not equal)"); };
    if (!((a->maxPerStageResources) == (b->maxPerStageResources))) { onFail("a->maxPerStageResources (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetSamplers) == (b->maxDescriptorSetSamplers))) { onFail("a->maxDescriptorSetSamplers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUniformBuffers) == (b->maxDescriptorSetUniformBuffers))) { onFail("a->maxDescriptorSetUniformBuffers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUniformBuffersDynamic) == (b->maxDescriptorSetUniformBuffersDynamic))) { onFail("a->maxDescriptorSetUniformBuffersDynamic (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetStorageBuffers) == (b->maxDescriptorSetStorageBuffers))) { onFail("a->maxDescriptorSetStorageBuffers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetStorageBuffersDynamic) == (b->maxDescriptorSetStorageBuffersDynamic))) { onFail("a->maxDescriptorSetStorageBuffersDynamic (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetSampledImages) == (b->maxDescriptorSetSampledImages))) { onFail("a->maxDescriptorSetSampledImages (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetStorageImages) == (b->maxDescriptorSetStorageImages))) { onFail("a->maxDescriptorSetStorageImages (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetInputAttachments) == (b->maxDescriptorSetInputAttachments))) { onFail("a->maxDescriptorSetInputAttachments (Error: Value not equal)"); };
    if (!((a->maxVertexInputAttributes) == (b->maxVertexInputAttributes))) { onFail("a->maxVertexInputAttributes (Error: Value not equal)"); };
    if (!((a->maxVertexInputBindings) == (b->maxVertexInputBindings))) { onFail("a->maxVertexInputBindings (Error: Value not equal)"); };
    if (!((a->maxVertexInputAttributeOffset) == (b->maxVertexInputAttributeOffset))) { onFail("a->maxVertexInputAttributeOffset (Error: Value not equal)"); };
    if (!((a->maxVertexInputBindingStride) == (b->maxVertexInputBindingStride))) { onFail("a->maxVertexInputBindingStride (Error: Value not equal)"); };
    if (!((a->maxVertexOutputComponents) == (b->maxVertexOutputComponents))) { onFail("a->maxVertexOutputComponents (Error: Value not equal)"); };
    if (!((a->maxTessellationGenerationLevel) == (b->maxTessellationGenerationLevel))) { onFail("a->maxTessellationGenerationLevel (Error: Value not equal)"); };
    if (!((a->maxTessellationPatchSize) == (b->maxTessellationPatchSize))) { onFail("a->maxTessellationPatchSize (Error: Value not equal)"); };
    if (!((a->maxTessellationControlPerVertexInputComponents) == (b->maxTessellationControlPerVertexInputComponents))) { onFail("a->maxTessellationControlPerVertexInputComponents (Error: Value not equal)"); };
    if (!((a->maxTessellationControlPerVertexOutputComponents) == (b->maxTessellationControlPerVertexOutputComponents))) { onFail("a->maxTessellationControlPerVertexOutputComponents (Error: Value not equal)"); };
    if (!((a->maxTessellationControlPerPatchOutputComponents) == (b->maxTessellationControlPerPatchOutputComponents))) { onFail("a->maxTessellationControlPerPatchOutputComponents (Error: Value not equal)"); };
    if (!((a->maxTessellationControlTotalOutputComponents) == (b->maxTessellationControlTotalOutputComponents))) { onFail("a->maxTessellationControlTotalOutputComponents (Error: Value not equal)"); };
    if (!((a->maxTessellationEvaluationInputComponents) == (b->maxTessellationEvaluationInputComponents))) { onFail("a->maxTessellationEvaluationInputComponents (Error: Value not equal)"); };
    if (!((a->maxTessellationEvaluationOutputComponents) == (b->maxTessellationEvaluationOutputComponents))) { onFail("a->maxTessellationEvaluationOutputComponents (Error: Value not equal)"); };
    if (!((a->maxGeometryShaderInvocations) == (b->maxGeometryShaderInvocations))) { onFail("a->maxGeometryShaderInvocations (Error: Value not equal)"); };
    if (!((a->maxGeometryInputComponents) == (b->maxGeometryInputComponents))) { onFail("a->maxGeometryInputComponents (Error: Value not equal)"); };
    if (!((a->maxGeometryOutputComponents) == (b->maxGeometryOutputComponents))) { onFail("a->maxGeometryOutputComponents (Error: Value not equal)"); };
    if (!((a->maxGeometryOutputVertices) == (b->maxGeometryOutputVertices))) { onFail("a->maxGeometryOutputVertices (Error: Value not equal)"); };
    if (!((a->maxGeometryTotalOutputComponents) == (b->maxGeometryTotalOutputComponents))) { onFail("a->maxGeometryTotalOutputComponents (Error: Value not equal)"); };
    if (!((a->maxFragmentInputComponents) == (b->maxFragmentInputComponents))) { onFail("a->maxFragmentInputComponents (Error: Value not equal)"); };
    if (!((a->maxFragmentOutputAttachments) == (b->maxFragmentOutputAttachments))) { onFail("a->maxFragmentOutputAttachments (Error: Value not equal)"); };
    if (!((a->maxFragmentDualSrcAttachments) == (b->maxFragmentDualSrcAttachments))) { onFail("a->maxFragmentDualSrcAttachments (Error: Value not equal)"); };
    if (!((a->maxFragmentCombinedOutputResources) == (b->maxFragmentCombinedOutputResources))) { onFail("a->maxFragmentCombinedOutputResources (Error: Value not equal)"); };
    if (!((a->maxComputeSharedMemorySize) == (b->maxComputeSharedMemorySize))) { onFail("a->maxComputeSharedMemorySize (Error: Value not equal)"); };
    if (!((memcmp(a->maxComputeWorkGroupCount, b->maxComputeWorkGroupCount, 3 * sizeof(uint32_t)) == 0))) { onFail("a->maxComputeWorkGroupCount (Error: Unequal static array)"); };
    if (!((a->maxComputeWorkGroupInvocations) == (b->maxComputeWorkGroupInvocations))) { onFail("a->maxComputeWorkGroupInvocations (Error: Value not equal)"); };
    if (!((memcmp(a->maxComputeWorkGroupSize, b->maxComputeWorkGroupSize, 3 * sizeof(uint32_t)) == 0))) { onFail("a->maxComputeWorkGroupSize (Error: Unequal static array)"); };
    if (!((a->subPixelPrecisionBits) == (b->subPixelPrecisionBits))) { onFail("a->subPixelPrecisionBits (Error: Value not equal)"); };
    if (!((a->subTexelPrecisionBits) == (b->subTexelPrecisionBits))) { onFail("a->subTexelPrecisionBits (Error: Value not equal)"); };
    if (!((a->mipmapPrecisionBits) == (b->mipmapPrecisionBits))) { onFail("a->mipmapPrecisionBits (Error: Value not equal)"); };
    if (!((a->maxDrawIndexedIndexValue) == (b->maxDrawIndexedIndexValue))) { onFail("a->maxDrawIndexedIndexValue (Error: Value not equal)"); };
    if (!((a->maxDrawIndirectCount) == (b->maxDrawIndirectCount))) { onFail("a->maxDrawIndirectCount (Error: Value not equal)"); };
    if (!((a->maxSamplerLodBias) == (b->maxSamplerLodBias))) { onFail("a->maxSamplerLodBias (Error: Value not equal)"); };
    if (!((a->maxSamplerAnisotropy) == (b->maxSamplerAnisotropy))) { onFail("a->maxSamplerAnisotropy (Error: Value not equal)"); };
    if (!((a->maxViewports) == (b->maxViewports))) { onFail("a->maxViewports (Error: Value not equal)"); };
    if (!((memcmp(a->maxViewportDimensions, b->maxViewportDimensions, 2 * sizeof(uint32_t)) == 0))) { onFail("a->maxViewportDimensions (Error: Unequal static array)"); };
    if (!((memcmp(a->viewportBoundsRange, b->viewportBoundsRange, 2 * sizeof(float)) == 0))) { onFail("a->viewportBoundsRange (Error: Unequal static array)"); };
    if (!((a->viewportSubPixelBits) == (b->viewportSubPixelBits))) { onFail("a->viewportSubPixelBits (Error: Value not equal)"); };
    if (!((a->minMemoryMapAlignment) == (b->minMemoryMapAlignment))) { onFail("a->minMemoryMapAlignment (Error: Value not equal)"); };
    if (!((a->minTexelBufferOffsetAlignment) == (b->minTexelBufferOffsetAlignment))) { onFail("a->minTexelBufferOffsetAlignment (Error: Value not equal)"); };
    if (!((a->minUniformBufferOffsetAlignment) == (b->minUniformBufferOffsetAlignment))) { onFail("a->minUniformBufferOffsetAlignment (Error: Value not equal)"); };
    if (!((a->minStorageBufferOffsetAlignment) == (b->minStorageBufferOffsetAlignment))) { onFail("a->minStorageBufferOffsetAlignment (Error: Value not equal)"); };
    if (!((a->minTexelOffset) == (b->minTexelOffset))) { onFail("a->minTexelOffset (Error: Value not equal)"); };
    if (!((a->maxTexelOffset) == (b->maxTexelOffset))) { onFail("a->maxTexelOffset (Error: Value not equal)"); };
    if (!((a->minTexelGatherOffset) == (b->minTexelGatherOffset))) { onFail("a->minTexelGatherOffset (Error: Value not equal)"); };
    if (!((a->maxTexelGatherOffset) == (b->maxTexelGatherOffset))) { onFail("a->maxTexelGatherOffset (Error: Value not equal)"); };
    if (!((a->minInterpolationOffset) == (b->minInterpolationOffset))) { onFail("a->minInterpolationOffset (Error: Value not equal)"); };
    if (!((a->maxInterpolationOffset) == (b->maxInterpolationOffset))) { onFail("a->maxInterpolationOffset (Error: Value not equal)"); };
    if (!((a->subPixelInterpolationOffsetBits) == (b->subPixelInterpolationOffsetBits))) { onFail("a->subPixelInterpolationOffsetBits (Error: Value not equal)"); };
    if (!((a->maxFramebufferWidth) == (b->maxFramebufferWidth))) { onFail("a->maxFramebufferWidth (Error: Value not equal)"); };
    if (!((a->maxFramebufferHeight) == (b->maxFramebufferHeight))) { onFail("a->maxFramebufferHeight (Error: Value not equal)"); };
    if (!((a->maxFramebufferLayers) == (b->maxFramebufferLayers))) { onFail("a->maxFramebufferLayers (Error: Value not equal)"); };
    if (!((a->framebufferColorSampleCounts) == (b->framebufferColorSampleCounts))) { onFail("a->framebufferColorSampleCounts (Error: Value not equal)"); };
    if (!((a->framebufferDepthSampleCounts) == (b->framebufferDepthSampleCounts))) { onFail("a->framebufferDepthSampleCounts (Error: Value not equal)"); };
    if (!((a->framebufferStencilSampleCounts) == (b->framebufferStencilSampleCounts))) { onFail("a->framebufferStencilSampleCounts (Error: Value not equal)"); };
    if (!((a->framebufferNoAttachmentsSampleCounts) == (b->framebufferNoAttachmentsSampleCounts))) { onFail("a->framebufferNoAttachmentsSampleCounts (Error: Value not equal)"); };
    if (!((a->maxColorAttachments) == (b->maxColorAttachments))) { onFail("a->maxColorAttachments (Error: Value not equal)"); };
    if (!((a->sampledImageColorSampleCounts) == (b->sampledImageColorSampleCounts))) { onFail("a->sampledImageColorSampleCounts (Error: Value not equal)"); };
    if (!((a->sampledImageIntegerSampleCounts) == (b->sampledImageIntegerSampleCounts))) { onFail("a->sampledImageIntegerSampleCounts (Error: Value not equal)"); };
    if (!((a->sampledImageDepthSampleCounts) == (b->sampledImageDepthSampleCounts))) { onFail("a->sampledImageDepthSampleCounts (Error: Value not equal)"); };
    if (!((a->sampledImageStencilSampleCounts) == (b->sampledImageStencilSampleCounts))) { onFail("a->sampledImageStencilSampleCounts (Error: Value not equal)"); };
    if (!((a->storageImageSampleCounts) == (b->storageImageSampleCounts))) { onFail("a->storageImageSampleCounts (Error: Value not equal)"); };
    if (!((a->maxSampleMaskWords) == (b->maxSampleMaskWords))) { onFail("a->maxSampleMaskWords (Error: Value not equal)"); };
    if (!((a->timestampComputeAndGraphics) == (b->timestampComputeAndGraphics))) { onFail("a->timestampComputeAndGraphics (Error: Value not equal)"); };
    if (!((a->timestampPeriod) == (b->timestampPeriod))) { onFail("a->timestampPeriod (Error: Value not equal)"); };
    if (!((a->maxClipDistances) == (b->maxClipDistances))) { onFail("a->maxClipDistances (Error: Value not equal)"); };
    if (!((a->maxCullDistances) == (b->maxCullDistances))) { onFail("a->maxCullDistances (Error: Value not equal)"); };
    if (!((a->maxCombinedClipAndCullDistances) == (b->maxCombinedClipAndCullDistances))) { onFail("a->maxCombinedClipAndCullDistances (Error: Value not equal)"); };
    if (!((a->discreteQueuePriorities) == (b->discreteQueuePriorities))) { onFail("a->discreteQueuePriorities (Error: Value not equal)"); };
    if (!((memcmp(a->pointSizeRange, b->pointSizeRange, 2 * sizeof(float)) == 0))) { onFail("a->pointSizeRange (Error: Unequal static array)"); };
    if (!((memcmp(a->lineWidthRange, b->lineWidthRange, 2 * sizeof(float)) == 0))) { onFail("a->lineWidthRange (Error: Unequal static array)"); };
    if (!((a->pointSizeGranularity) == (b->pointSizeGranularity))) { onFail("a->pointSizeGranularity (Error: Value not equal)"); };
    if (!((a->lineWidthGranularity) == (b->lineWidthGranularity))) { onFail("a->lineWidthGranularity (Error: Value not equal)"); };
    if (!((a->strictLines) == (b->strictLines))) { onFail("a->strictLines (Error: Value not equal)"); };
    if (!((a->standardSampleLocations) == (b->standardSampleLocations))) { onFail("a->standardSampleLocations (Error: Value not equal)"); };
    if (!((a->optimalBufferCopyOffsetAlignment) == (b->optimalBufferCopyOffsetAlignment))) { onFail("a->optimalBufferCopyOffsetAlignment (Error: Value not equal)"); };
    if (!((a->optimalBufferCopyRowPitchAlignment) == (b->optimalBufferCopyRowPitchAlignment))) { onFail("a->optimalBufferCopyRowPitchAlignment (Error: Value not equal)"); };
    if (!((a->nonCoherentAtomSize) == (b->nonCoherentAtomSize))) { onFail("a->nonCoherentAtomSize (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceSparseProperties(
    const VkPhysicalDeviceSparseProperties* a,
    const VkPhysicalDeviceSparseProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->residencyStandard2DBlockShape) == (b->residencyStandard2DBlockShape))) { onFail("a->residencyStandard2DBlockShape (Error: Value not equal)"); };
    if (!((a->residencyStandard2DMultisampleBlockShape) == (b->residencyStandard2DMultisampleBlockShape))) { onFail("a->residencyStandard2DMultisampleBlockShape (Error: Value not equal)"); };
    if (!((a->residencyStandard3DBlockShape) == (b->residencyStandard3DBlockShape))) { onFail("a->residencyStandard3DBlockShape (Error: Value not equal)"); };
    if (!((a->residencyAlignedMipSize) == (b->residencyAlignedMipSize))) { onFail("a->residencyAlignedMipSize (Error: Value not equal)"); };
    if (!((a->residencyNonResidentStrict) == (b->residencyNonResidentStrict))) { onFail("a->residencyNonResidentStrict (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceProperties(
    const VkPhysicalDeviceProperties* a,
    const VkPhysicalDeviceProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->apiVersion) == (b->apiVersion))) { onFail("a->apiVersion (Error: Value not equal)"); };
    if (!((a->driverVersion) == (b->driverVersion))) { onFail("a->driverVersion (Error: Value not equal)"); };
    if (!((a->vendorID) == (b->vendorID))) { onFail("a->vendorID (Error: Value not equal)"); };
    if (!((a->deviceID) == (b->deviceID))) { onFail("a->deviceID (Error: Value not equal)"); };
    if (!((a->deviceType) == (b->deviceType))) { onFail("a->deviceType (Error: Value not equal)"); };
    if (!((memcmp(a->deviceName, b->deviceName, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char)) == 0))) { onFail("a->deviceName (Error: Unequal static array)"); };
    if (!((memcmp(a->pipelineCacheUUID, b->pipelineCacheUUID, VK_UUID_SIZE * sizeof(uint8_t)) == 0))) { onFail("a->pipelineCacheUUID (Error: Unequal static array)"); };
    checkEqual_VkPhysicalDeviceLimits(&a->limits, &b->limits, onFail);
    checkEqual_VkPhysicalDeviceSparseProperties(&a->sparseProperties, &b->sparseProperties, onFail);
}

void checkEqual_VkQueueFamilyProperties(
    const VkQueueFamilyProperties* a,
    const VkQueueFamilyProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->queueFlags) == (b->queueFlags))) { onFail("a->queueFlags (Error: Value not equal)"); };
    if (!((a->queueCount) == (b->queueCount))) { onFail("a->queueCount (Error: Value not equal)"); };
    if (!((a->timestampValidBits) == (b->timestampValidBits))) { onFail("a->timestampValidBits (Error: Value not equal)"); };
    checkEqual_VkExtent3D(&a->minImageTransferGranularity, &b->minImageTransferGranularity, onFail);
}

void checkEqual_VkMemoryType(
    const VkMemoryType* a,
    const VkMemoryType* b,
    OnFailCompareFunc onFail)
{
    if (!((a->propertyFlags) == (b->propertyFlags))) { onFail("a->propertyFlags (Error: Value not equal)"); };
    if (!((a->heapIndex) == (b->heapIndex))) { onFail("a->heapIndex (Error: Value not equal)"); };
}

void checkEqual_VkMemoryHeap(
    const VkMemoryHeap* a,
    const VkMemoryHeap* b,
    OnFailCompareFunc onFail)
{
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceMemoryProperties(
    const VkPhysicalDeviceMemoryProperties* a,
    const VkPhysicalDeviceMemoryProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->memoryTypeCount) == (b->memoryTypeCount))) { onFail("a->memoryTypeCount (Error: Value not equal)"); };
    if (!((VK_MAX_MEMORY_TYPES) == (VK_MAX_MEMORY_TYPES))) { onFail("a->memoryTypes (Error: Lengths not equal)"); };
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        checkEqual_VkMemoryType(a->memoryTypes + i, b->memoryTypes + i, onFail);
    }
    if (!((a->memoryHeapCount) == (b->memoryHeapCount))) { onFail("a->memoryHeapCount (Error: Value not equal)"); };
    if (!((VK_MAX_MEMORY_HEAPS) == (VK_MAX_MEMORY_HEAPS))) { onFail("a->memoryHeaps (Error: Lengths not equal)"); };
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        checkEqual_VkMemoryHeap(a->memoryHeaps + i, b->memoryHeaps + i, onFail);
    }
}

void checkEqual_VkDeviceQueueCreateInfo(
    const VkDeviceQueueCreateInfo* a,
    const VkDeviceQueueCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->queueFamilyIndex) == (b->queueFamilyIndex))) { onFail("a->queueFamilyIndex (Error: Value not equal)"); };
    if (!((a->queueCount) == (b->queueCount))) { onFail("a->queueCount (Error: Value not equal)"); };
    if (!((a->queueCount) == (b->queueCount))) { onFail("a->pQueuePriorities (Error: Lengths not equal)"); };
    if (!((memcmp(a->pQueuePriorities, b->pQueuePriorities, a->queueCount * sizeof(const float)) == 0))) { onFail("a->pQueuePriorities (Error: Unequal dyn array)"); };
}

void checkEqual_VkDeviceCreateInfo(
    const VkDeviceCreateInfo* a,
    const VkDeviceCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->queueCreateInfoCount) == (b->queueCreateInfoCount))) { onFail("a->queueCreateInfoCount (Error: Value not equal)"); };
    if ((a->pQueueCreateInfos) && (b->pQueueCreateInfos))
    {
        if (!((a->queueCreateInfoCount) == (b->queueCreateInfoCount))) { onFail("a->pQueueCreateInfos (Error: Lengths not equal)"); };
        if ((a->queueCreateInfoCount) == (b->queueCreateInfoCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->queueCreateInfoCount; ++i)
            {
                checkEqual_VkDeviceQueueCreateInfo(a->pQueueCreateInfos + i, b->pQueueCreateInfos + i, onFail);
            }
        }
    }
    if (!((a->enabledLayerCount) == (b->enabledLayerCount))) { onFail("a->enabledLayerCount (Error: Value not equal)"); };
    if (!((!(a->ppEnabledLayerNames) && !(b->ppEnabledLayerNames)) || ((a->ppEnabledLayerNames) && (b->ppEnabledLayerNames)))) { onFail("a->ppEnabledLayerNames (Error: Mismatch in string array pointer nullness)"); };
    if (!((a->enabledLayerCount) == (b->enabledLayerCount))) { onFail("a->ppEnabledLayerNames (Error: Lengths not equal in string array)"); };
    if (!((a->enabledLayerCount) == (b->enabledLayerCount))) { onFail("a->ppEnabledLayerNames (Error: Lengths not equal in string array)"); };
    if ((a->enabledLayerCount) == (b->enabledLayerCount) && (a->ppEnabledLayerNames) && (b->ppEnabledLayerNames))
    {
        for (uint32_t i = 0; i < (uint32_t)a->enabledLayerCount; ++i)
        {
            if (!((strcmp(*(a->ppEnabledLayerNames + i), *(b->ppEnabledLayerNames + i)) == 0))) { onFail("a->ppEnabledLayerNames (Error: Unequal string in string array)"); };
        }
    }
    if (!((a->enabledExtensionCount) == (b->enabledExtensionCount))) { onFail("a->enabledExtensionCount (Error: Value not equal)"); };
    if (!((!(a->ppEnabledExtensionNames) && !(b->ppEnabledExtensionNames)) || ((a->ppEnabledExtensionNames) && (b->ppEnabledExtensionNames)))) { onFail("a->ppEnabledExtensionNames (Error: Mismatch in string array pointer nullness)"); };
    if (!((a->enabledExtensionCount) == (b->enabledExtensionCount))) { onFail("a->ppEnabledExtensionNames (Error: Lengths not equal in string array)"); };
    if (!((a->enabledExtensionCount) == (b->enabledExtensionCount))) { onFail("a->ppEnabledExtensionNames (Error: Lengths not equal in string array)"); };
    if ((a->enabledExtensionCount) == (b->enabledExtensionCount) && (a->ppEnabledExtensionNames) && (b->ppEnabledExtensionNames))
    {
        for (uint32_t i = 0; i < (uint32_t)a->enabledExtensionCount; ++i)
        {
            if (!((strcmp(*(a->ppEnabledExtensionNames + i), *(b->ppEnabledExtensionNames + i)) == 0))) { onFail("a->ppEnabledExtensionNames (Error: Unequal string in string array)"); };
        }
    }
    if (!((!(a->pEnabledFeatures) && !(b->pEnabledFeatures)) || ((a->pEnabledFeatures) && (b->pEnabledFeatures)))) { onFail("a->pEnabledFeatures (Error: Mismatch in optional field)"); };
    if (a->pEnabledFeatures && b->pEnabledFeatures)
    {
        if ((a->pEnabledFeatures) && (b->pEnabledFeatures))
        {
            checkEqual_VkPhysicalDeviceFeatures(a->pEnabledFeatures, b->pEnabledFeatures, onFail);
        }
    }
}

void checkEqual_VkExtensionProperties(
    const VkExtensionProperties* a,
    const VkExtensionProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((memcmp(a->extensionName, b->extensionName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char)) == 0))) { onFail("a->extensionName (Error: Unequal static array)"); };
    if (!((a->specVersion) == (b->specVersion))) { onFail("a->specVersion (Error: Value not equal)"); };
}

void checkEqual_VkLayerProperties(
    const VkLayerProperties* a,
    const VkLayerProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((memcmp(a->layerName, b->layerName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char)) == 0))) { onFail("a->layerName (Error: Unequal static array)"); };
    if (!((a->specVersion) == (b->specVersion))) { onFail("a->specVersion (Error: Value not equal)"); };
    if (!((a->implementationVersion) == (b->implementationVersion))) { onFail("a->implementationVersion (Error: Value not equal)"); };
    if (!((memcmp(a->description, b->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char)) == 0))) { onFail("a->description (Error: Unequal static array)"); };
}

void checkEqual_VkSubmitInfo(
    const VkSubmitInfo* a,
    const VkSubmitInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->waitSemaphoreCount (Error: Value not equal)"); };
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->pWaitSemaphores (Error: Lengths not equal)"); };
    if (!((memcmp(a->pWaitSemaphores, b->pWaitSemaphores, a->waitSemaphoreCount * sizeof(const VkSemaphore)) == 0))) { onFail("a->pWaitSemaphores (Error: Unequal dyn array)"); };
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->pWaitDstStageMask (Error: Lengths not equal)"); };
    if (!((memcmp(a->pWaitDstStageMask, b->pWaitDstStageMask, a->waitSemaphoreCount * sizeof(const VkPipelineStageFlags)) == 0))) { onFail("a->pWaitDstStageMask (Error: Unequal dyn array)"); };
    if (!((a->commandBufferCount) == (b->commandBufferCount))) { onFail("a->commandBufferCount (Error: Value not equal)"); };
    if (!((a->commandBufferCount) == (b->commandBufferCount))) { onFail("a->pCommandBuffers (Error: Lengths not equal)"); };
    if (!((memcmp(a->pCommandBuffers, b->pCommandBuffers, a->commandBufferCount * sizeof(const VkCommandBuffer)) == 0))) { onFail("a->pCommandBuffers (Error: Unequal dyn array)"); };
    if (!((a->signalSemaphoreCount) == (b->signalSemaphoreCount))) { onFail("a->signalSemaphoreCount (Error: Value not equal)"); };
    if (!((a->signalSemaphoreCount) == (b->signalSemaphoreCount))) { onFail("a->pSignalSemaphores (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSignalSemaphores, b->pSignalSemaphores, a->signalSemaphoreCount * sizeof(const VkSemaphore)) == 0))) { onFail("a->pSignalSemaphores (Error: Unequal dyn array)"); };
}

void checkEqual_VkMemoryAllocateInfo(
    const VkMemoryAllocateInfo* a,
    const VkMemoryAllocateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->allocationSize) == (b->allocationSize))) { onFail("a->allocationSize (Error: Value not equal)"); };
    if (!((a->memoryTypeIndex) == (b->memoryTypeIndex))) { onFail("a->memoryTypeIndex (Error: Value not equal)"); };
}

void checkEqual_VkMappedMemoryRange(
    const VkMappedMemoryRange* a,
    const VkMappedMemoryRange* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
}

void checkEqual_VkMemoryRequirements(
    const VkMemoryRequirements* a,
    const VkMemoryRequirements* b,
    OnFailCompareFunc onFail)
{
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->alignment) == (b->alignment))) { onFail("a->alignment (Error: Value not equal)"); };
    if (!((a->memoryTypeBits) == (b->memoryTypeBits))) { onFail("a->memoryTypeBits (Error: Value not equal)"); };
}

void checkEqual_VkSparseImageFormatProperties(
    const VkSparseImageFormatProperties* a,
    const VkSparseImageFormatProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->aspectMask) == (b->aspectMask))) { onFail("a->aspectMask (Error: Value not equal)"); };
    checkEqual_VkExtent3D(&a->imageGranularity, &b->imageGranularity, onFail);
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkSparseImageMemoryRequirements(
    const VkSparseImageMemoryRequirements* a,
    const VkSparseImageMemoryRequirements* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkSparseImageFormatProperties(&a->formatProperties, &b->formatProperties, onFail);
    if (!((a->imageMipTailFirstLod) == (b->imageMipTailFirstLod))) { onFail("a->imageMipTailFirstLod (Error: Value not equal)"); };
    if (!((a->imageMipTailSize) == (b->imageMipTailSize))) { onFail("a->imageMipTailSize (Error: Value not equal)"); };
    if (!((a->imageMipTailOffset) == (b->imageMipTailOffset))) { onFail("a->imageMipTailOffset (Error: Value not equal)"); };
    if (!((a->imageMipTailStride) == (b->imageMipTailStride))) { onFail("a->imageMipTailStride (Error: Value not equal)"); };
}

void checkEqual_VkSparseMemoryBind(
    const VkSparseMemoryBind* a,
    const VkSparseMemoryBind* b,
    OnFailCompareFunc onFail)
{
    if (!((a->resourceOffset) == (b->resourceOffset))) { onFail("a->resourceOffset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->memoryOffset) == (b->memoryOffset))) { onFail("a->memoryOffset (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkSparseBufferMemoryBindInfo(
    const VkSparseBufferMemoryBindInfo* a,
    const VkSparseBufferMemoryBindInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->bindCount) == (b->bindCount))) { onFail("a->bindCount (Error: Value not equal)"); };
    if ((a->pBinds) && (b->pBinds))
    {
        if (!((a->bindCount) == (b->bindCount))) { onFail("a->pBinds (Error: Lengths not equal)"); };
        if ((a->bindCount) == (b->bindCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->bindCount; ++i)
            {
                checkEqual_VkSparseMemoryBind(a->pBinds + i, b->pBinds + i, onFail);
            }
        }
    }
}

void checkEqual_VkSparseImageOpaqueMemoryBindInfo(
    const VkSparseImageOpaqueMemoryBindInfo* a,
    const VkSparseImageOpaqueMemoryBindInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    if (!((a->bindCount) == (b->bindCount))) { onFail("a->bindCount (Error: Value not equal)"); };
    if ((a->pBinds) && (b->pBinds))
    {
        if (!((a->bindCount) == (b->bindCount))) { onFail("a->pBinds (Error: Lengths not equal)"); };
        if ((a->bindCount) == (b->bindCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->bindCount; ++i)
            {
                checkEqual_VkSparseMemoryBind(a->pBinds + i, b->pBinds + i, onFail);
            }
        }
    }
}

void checkEqual_VkImageSubresource(
    const VkImageSubresource* a,
    const VkImageSubresource* b,
    OnFailCompareFunc onFail)
{
    if (!((a->aspectMask) == (b->aspectMask))) { onFail("a->aspectMask (Error: Value not equal)"); };
    if (!((a->mipLevel) == (b->mipLevel))) { onFail("a->mipLevel (Error: Value not equal)"); };
    if (!((a->arrayLayer) == (b->arrayLayer))) { onFail("a->arrayLayer (Error: Value not equal)"); };
}

void checkEqual_VkOffset3D(
    const VkOffset3D* a,
    const VkOffset3D* b,
    OnFailCompareFunc onFail)
{
    if (!((a->x) == (b->x))) { onFail("a->x (Error: Value not equal)"); };
    if (!((a->y) == (b->y))) { onFail("a->y (Error: Value not equal)"); };
    if (!((a->z) == (b->z))) { onFail("a->z (Error: Value not equal)"); };
}

void checkEqual_VkSparseImageMemoryBind(
    const VkSparseImageMemoryBind* a,
    const VkSparseImageMemoryBind* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkImageSubresource(&a->subresource, &b->subresource, onFail);
    checkEqual_VkOffset3D(&a->offset, &b->offset, onFail);
    checkEqual_VkExtent3D(&a->extent, &b->extent, onFail);
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->memoryOffset) == (b->memoryOffset))) { onFail("a->memoryOffset (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkSparseImageMemoryBindInfo(
    const VkSparseImageMemoryBindInfo* a,
    const VkSparseImageMemoryBindInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    if (!((a->bindCount) == (b->bindCount))) { onFail("a->bindCount (Error: Value not equal)"); };
    if ((a->pBinds) && (b->pBinds))
    {
        if (!((a->bindCount) == (b->bindCount))) { onFail("a->pBinds (Error: Lengths not equal)"); };
        if ((a->bindCount) == (b->bindCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->bindCount; ++i)
            {
                checkEqual_VkSparseImageMemoryBind(a->pBinds + i, b->pBinds + i, onFail);
            }
        }
    }
}

void checkEqual_VkBindSparseInfo(
    const VkBindSparseInfo* a,
    const VkBindSparseInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->waitSemaphoreCount (Error: Value not equal)"); };
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->pWaitSemaphores (Error: Lengths not equal)"); };
    if (!((memcmp(a->pWaitSemaphores, b->pWaitSemaphores, a->waitSemaphoreCount * sizeof(const VkSemaphore)) == 0))) { onFail("a->pWaitSemaphores (Error: Unequal dyn array)"); };
    if (!((a->bufferBindCount) == (b->bufferBindCount))) { onFail("a->bufferBindCount (Error: Value not equal)"); };
    if ((a->pBufferBinds) && (b->pBufferBinds))
    {
        if (!((a->bufferBindCount) == (b->bufferBindCount))) { onFail("a->pBufferBinds (Error: Lengths not equal)"); };
        if ((a->bufferBindCount) == (b->bufferBindCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->bufferBindCount; ++i)
            {
                checkEqual_VkSparseBufferMemoryBindInfo(a->pBufferBinds + i, b->pBufferBinds + i, onFail);
            }
        }
    }
    if (!((a->imageOpaqueBindCount) == (b->imageOpaqueBindCount))) { onFail("a->imageOpaqueBindCount (Error: Value not equal)"); };
    if ((a->pImageOpaqueBinds) && (b->pImageOpaqueBinds))
    {
        if (!((a->imageOpaqueBindCount) == (b->imageOpaqueBindCount))) { onFail("a->pImageOpaqueBinds (Error: Lengths not equal)"); };
        if ((a->imageOpaqueBindCount) == (b->imageOpaqueBindCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->imageOpaqueBindCount; ++i)
            {
                checkEqual_VkSparseImageOpaqueMemoryBindInfo(a->pImageOpaqueBinds + i, b->pImageOpaqueBinds + i, onFail);
            }
        }
    }
    if (!((a->imageBindCount) == (b->imageBindCount))) { onFail("a->imageBindCount (Error: Value not equal)"); };
    if ((a->pImageBinds) && (b->pImageBinds))
    {
        if (!((a->imageBindCount) == (b->imageBindCount))) { onFail("a->pImageBinds (Error: Lengths not equal)"); };
        if ((a->imageBindCount) == (b->imageBindCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->imageBindCount; ++i)
            {
                checkEqual_VkSparseImageMemoryBindInfo(a->pImageBinds + i, b->pImageBinds + i, onFail);
            }
        }
    }
    if (!((a->signalSemaphoreCount) == (b->signalSemaphoreCount))) { onFail("a->signalSemaphoreCount (Error: Value not equal)"); };
    if (!((a->signalSemaphoreCount) == (b->signalSemaphoreCount))) { onFail("a->pSignalSemaphores (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSignalSemaphores, b->pSignalSemaphores, a->signalSemaphoreCount * sizeof(const VkSemaphore)) == 0))) { onFail("a->pSignalSemaphores (Error: Unequal dyn array)"); };
}

void checkEqual_VkFenceCreateInfo(
    const VkFenceCreateInfo* a,
    const VkFenceCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkSemaphoreCreateInfo(
    const VkSemaphoreCreateInfo* a,
    const VkSemaphoreCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkEventCreateInfo(
    const VkEventCreateInfo* a,
    const VkEventCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkQueryPoolCreateInfo(
    const VkQueryPoolCreateInfo* a,
    const VkQueryPoolCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->queryType) == (b->queryType))) { onFail("a->queryType (Error: Value not equal)"); };
    if (!((a->queryCount) == (b->queryCount))) { onFail("a->queryCount (Error: Value not equal)"); };
    if (!((a->pipelineStatistics) == (b->pipelineStatistics))) { onFail("a->pipelineStatistics (Error: Value not equal)"); };
}

void checkEqual_VkBufferCreateInfo(
    const VkBufferCreateInfo* a,
    const VkBufferCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
    if (!((a->sharingMode) == (b->sharingMode))) { onFail("a->sharingMode (Error: Value not equal)"); };
    if (!((a->queueFamilyIndexCount) == (b->queueFamilyIndexCount))) { onFail("a->queueFamilyIndexCount (Error: Value not equal)"); };
    if (!((!(a->pQueueFamilyIndices) && !(b->pQueueFamilyIndices)) || ((a->pQueueFamilyIndices) && (b->pQueueFamilyIndices)))) { onFail("a->pQueueFamilyIndices (Error: Mismatch in optional field)"); };
    if (a->pQueueFamilyIndices && b->pQueueFamilyIndices)
    {
        if (!((a->queueFamilyIndexCount) == (b->queueFamilyIndexCount))) { onFail("a->pQueueFamilyIndices (Error: Lengths not equal)"); };
        if (!((memcmp(a->pQueueFamilyIndices, b->pQueueFamilyIndices, a->queueFamilyIndexCount * sizeof(const uint32_t)) == 0))) { onFail("a->pQueueFamilyIndices (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkBufferViewCreateInfo(
    const VkBufferViewCreateInfo* a,
    const VkBufferViewCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->range) == (b->range))) { onFail("a->range (Error: Value not equal)"); };
}

void checkEqual_VkImageCreateInfo(
    const VkImageCreateInfo* a,
    const VkImageCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->imageType) == (b->imageType))) { onFail("a->imageType (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    checkEqual_VkExtent3D(&a->extent, &b->extent, onFail);
    if (!((a->mipLevels) == (b->mipLevels))) { onFail("a->mipLevels (Error: Value not equal)"); };
    if (!((a->arrayLayers) == (b->arrayLayers))) { onFail("a->arrayLayers (Error: Value not equal)"); };
    if (!((a->samples) == (b->samples))) { onFail("a->samples (Error: Value not equal)"); };
    if (!((a->tiling) == (b->tiling))) { onFail("a->tiling (Error: Value not equal)"); };
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
    if (!((a->sharingMode) == (b->sharingMode))) { onFail("a->sharingMode (Error: Value not equal)"); };
    if (!((a->queueFamilyIndexCount) == (b->queueFamilyIndexCount))) { onFail("a->queueFamilyIndexCount (Error: Value not equal)"); };
    if (!((!(a->pQueueFamilyIndices) && !(b->pQueueFamilyIndices)) || ((a->pQueueFamilyIndices) && (b->pQueueFamilyIndices)))) { onFail("a->pQueueFamilyIndices (Error: Mismatch in optional field)"); };
    if (a->pQueueFamilyIndices && b->pQueueFamilyIndices)
    {
        if (!((a->queueFamilyIndexCount) == (b->queueFamilyIndexCount))) { onFail("a->pQueueFamilyIndices (Error: Lengths not equal)"); };
        if (!((memcmp(a->pQueueFamilyIndices, b->pQueueFamilyIndices, a->queueFamilyIndexCount * sizeof(const uint32_t)) == 0))) { onFail("a->pQueueFamilyIndices (Error: Unequal dyn array)"); };
    }
    if (!((a->initialLayout) == (b->initialLayout))) { onFail("a->initialLayout (Error: Value not equal)"); };
}

void checkEqual_VkSubresourceLayout(
    const VkSubresourceLayout* a,
    const VkSubresourceLayout* b,
    OnFailCompareFunc onFail)
{
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->rowPitch) == (b->rowPitch))) { onFail("a->rowPitch (Error: Value not equal)"); };
    if (!((a->arrayPitch) == (b->arrayPitch))) { onFail("a->arrayPitch (Error: Value not equal)"); };
    if (!((a->depthPitch) == (b->depthPitch))) { onFail("a->depthPitch (Error: Value not equal)"); };
}

void checkEqual_VkComponentMapping(
    const VkComponentMapping* a,
    const VkComponentMapping* b,
    OnFailCompareFunc onFail)
{
    if (!((a->r) == (b->r))) { onFail("a->r (Error: Value not equal)"); };
    if (!((a->g) == (b->g))) { onFail("a->g (Error: Value not equal)"); };
    if (!((a->b) == (b->b))) { onFail("a->b (Error: Value not equal)"); };
    if (!((a->a) == (b->a))) { onFail("a->a (Error: Value not equal)"); };
}

void checkEqual_VkImageSubresourceRange(
    const VkImageSubresourceRange* a,
    const VkImageSubresourceRange* b,
    OnFailCompareFunc onFail)
{
    if (!((a->aspectMask) == (b->aspectMask))) { onFail("a->aspectMask (Error: Value not equal)"); };
    if (!((a->baseMipLevel) == (b->baseMipLevel))) { onFail("a->baseMipLevel (Error: Value not equal)"); };
    if (!((a->levelCount) == (b->levelCount))) { onFail("a->levelCount (Error: Value not equal)"); };
    if (!((a->baseArrayLayer) == (b->baseArrayLayer))) { onFail("a->baseArrayLayer (Error: Value not equal)"); };
    if (!((a->layerCount) == (b->layerCount))) { onFail("a->layerCount (Error: Value not equal)"); };
}

void checkEqual_VkImageViewCreateInfo(
    const VkImageViewCreateInfo* a,
    const VkImageViewCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    if (!((a->viewType) == (b->viewType))) { onFail("a->viewType (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    checkEqual_VkComponentMapping(&a->components, &b->components, onFail);
    checkEqual_VkImageSubresourceRange(&a->subresourceRange, &b->subresourceRange, onFail);
}

void checkEqual_VkShaderModuleCreateInfo(
    const VkShaderModuleCreateInfo* a,
    const VkShaderModuleCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->codeSize) == (b->codeSize))) { onFail("a->codeSize (Error: Value not equal)"); };
    if (!(((a->codeSize / 4)) == ((b->codeSize / 4)))) { onFail("a->pCode (Error: Lengths not equal)"); };
    if (!((memcmp(a->pCode, b->pCode, (a->codeSize / 4) * sizeof(const uint32_t)) == 0))) { onFail("a->pCode (Error: Unequal dyn array)"); };
}

void checkEqual_VkPipelineCacheCreateInfo(
    const VkPipelineCacheCreateInfo* a,
    const VkPipelineCacheCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->initialDataSize) == (b->initialDataSize))) { onFail("a->initialDataSize (Error: Value not equal)"); };
}

void checkEqual_VkSpecializationMapEntry(
    const VkSpecializationMapEntry* a,
    const VkSpecializationMapEntry* b,
    OnFailCompareFunc onFail)
{
    if (!((a->constantID) == (b->constantID))) { onFail("a->constantID (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
}

void checkEqual_VkSpecializationInfo(
    const VkSpecializationInfo* a,
    const VkSpecializationInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->mapEntryCount) == (b->mapEntryCount))) { onFail("a->mapEntryCount (Error: Value not equal)"); };
    if ((a->pMapEntries) && (b->pMapEntries))
    {
        if (!((a->mapEntryCount) == (b->mapEntryCount))) { onFail("a->pMapEntries (Error: Lengths not equal)"); };
        if ((a->mapEntryCount) == (b->mapEntryCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->mapEntryCount; ++i)
            {
                checkEqual_VkSpecializationMapEntry(a->pMapEntries + i, b->pMapEntries + i, onFail);
            }
        }
    }
    if (!((a->dataSize) == (b->dataSize))) { onFail("a->dataSize (Error: Value not equal)"); };
}

void checkEqual_VkPipelineShaderStageCreateInfo(
    const VkPipelineShaderStageCreateInfo* a,
    const VkPipelineShaderStageCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->stage) == (b->stage))) { onFail("a->stage (Error: Value not equal)"); };
    if (!((a->module) == (b->module))) { onFail("a->module (Error: Value not equal)"); };
    if (!((!(a->pName) && !(b->pName)) || ((a->pName) && (b->pName)))) { onFail("a->pName (Error: Mismatch in string pointer nullness)"); };
    if ((a->pName) && (b->pName))
    {
        if (!((strcmp(a->pName, b->pName) == 0))) { onFail("a->pName (Error: Unequal strings)"); };
    }
    if (!((!(a->pSpecializationInfo) && !(b->pSpecializationInfo)) || ((a->pSpecializationInfo) && (b->pSpecializationInfo)))) { onFail("a->pSpecializationInfo (Error: Mismatch in optional field)"); };
    if (a->pSpecializationInfo && b->pSpecializationInfo)
    {
        if ((a->pSpecializationInfo) && (b->pSpecializationInfo))
        {
            checkEqual_VkSpecializationInfo(a->pSpecializationInfo, b->pSpecializationInfo, onFail);
        }
    }
}

void checkEqual_VkVertexInputBindingDescription(
    const VkVertexInputBindingDescription* a,
    const VkVertexInputBindingDescription* b,
    OnFailCompareFunc onFail)
{
    if (!((a->binding) == (b->binding))) { onFail("a->binding (Error: Value not equal)"); };
    if (!((a->stride) == (b->stride))) { onFail("a->stride (Error: Value not equal)"); };
    if (!((a->inputRate) == (b->inputRate))) { onFail("a->inputRate (Error: Value not equal)"); };
}

void checkEqual_VkVertexInputAttributeDescription(
    const VkVertexInputAttributeDescription* a,
    const VkVertexInputAttributeDescription* b,
    OnFailCompareFunc onFail)
{
    if (!((a->location) == (b->location))) { onFail("a->location (Error: Value not equal)"); };
    if (!((a->binding) == (b->binding))) { onFail("a->binding (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
}

void checkEqual_VkPipelineVertexInputStateCreateInfo(
    const VkPipelineVertexInputStateCreateInfo* a,
    const VkPipelineVertexInputStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->vertexBindingDescriptionCount) == (b->vertexBindingDescriptionCount))) { onFail("a->vertexBindingDescriptionCount (Error: Value not equal)"); };
    if ((a->pVertexBindingDescriptions) && (b->pVertexBindingDescriptions))
    {
        if (!((a->vertexBindingDescriptionCount) == (b->vertexBindingDescriptionCount))) { onFail("a->pVertexBindingDescriptions (Error: Lengths not equal)"); };
        if ((a->vertexBindingDescriptionCount) == (b->vertexBindingDescriptionCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->vertexBindingDescriptionCount; ++i)
            {
                checkEqual_VkVertexInputBindingDescription(a->pVertexBindingDescriptions + i, b->pVertexBindingDescriptions + i, onFail);
            }
        }
    }
    if (!((a->vertexAttributeDescriptionCount) == (b->vertexAttributeDescriptionCount))) { onFail("a->vertexAttributeDescriptionCount (Error: Value not equal)"); };
    if ((a->pVertexAttributeDescriptions) && (b->pVertexAttributeDescriptions))
    {
        if (!((a->vertexAttributeDescriptionCount) == (b->vertexAttributeDescriptionCount))) { onFail("a->pVertexAttributeDescriptions (Error: Lengths not equal)"); };
        if ((a->vertexAttributeDescriptionCount) == (b->vertexAttributeDescriptionCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->vertexAttributeDescriptionCount; ++i)
            {
                checkEqual_VkVertexInputAttributeDescription(a->pVertexAttributeDescriptions + i, b->pVertexAttributeDescriptions + i, onFail);
            }
        }
    }
}

void checkEqual_VkPipelineInputAssemblyStateCreateInfo(
    const VkPipelineInputAssemblyStateCreateInfo* a,
    const VkPipelineInputAssemblyStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->topology) == (b->topology))) { onFail("a->topology (Error: Value not equal)"); };
    if (!((a->primitiveRestartEnable) == (b->primitiveRestartEnable))) { onFail("a->primitiveRestartEnable (Error: Value not equal)"); };
}

void checkEqual_VkPipelineTessellationStateCreateInfo(
    const VkPipelineTessellationStateCreateInfo* a,
    const VkPipelineTessellationStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->patchControlPoints) == (b->patchControlPoints))) { onFail("a->patchControlPoints (Error: Value not equal)"); };
}

void checkEqual_VkViewport(
    const VkViewport* a,
    const VkViewport* b,
    OnFailCompareFunc onFail)
{
    if (!((a->x) == (b->x))) { onFail("a->x (Error: Value not equal)"); };
    if (!((a->y) == (b->y))) { onFail("a->y (Error: Value not equal)"); };
    if (!((a->width) == (b->width))) { onFail("a->width (Error: Value not equal)"); };
    if (!((a->height) == (b->height))) { onFail("a->height (Error: Value not equal)"); };
    if (!((a->minDepth) == (b->minDepth))) { onFail("a->minDepth (Error: Value not equal)"); };
    if (!((a->maxDepth) == (b->maxDepth))) { onFail("a->maxDepth (Error: Value not equal)"); };
}

void checkEqual_VkOffset2D(
    const VkOffset2D* a,
    const VkOffset2D* b,
    OnFailCompareFunc onFail)
{
    if (!((a->x) == (b->x))) { onFail("a->x (Error: Value not equal)"); };
    if (!((a->y) == (b->y))) { onFail("a->y (Error: Value not equal)"); };
}

void checkEqual_VkExtent2D(
    const VkExtent2D* a,
    const VkExtent2D* b,
    OnFailCompareFunc onFail)
{
    if (!((a->width) == (b->width))) { onFail("a->width (Error: Value not equal)"); };
    if (!((a->height) == (b->height))) { onFail("a->height (Error: Value not equal)"); };
}

void checkEqual_VkRect2D(
    const VkRect2D* a,
    const VkRect2D* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkOffset2D(&a->offset, &b->offset, onFail);
    checkEqual_VkExtent2D(&a->extent, &b->extent, onFail);
}

void checkEqual_VkPipelineViewportStateCreateInfo(
    const VkPipelineViewportStateCreateInfo* a,
    const VkPipelineViewportStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->viewportCount) == (b->viewportCount))) { onFail("a->viewportCount (Error: Value not equal)"); };
    if (!((!(a->pViewports) && !(b->pViewports)) || ((a->pViewports) && (b->pViewports)))) { onFail("a->pViewports (Error: Mismatch in optional field)"); };
    if (a->pViewports && b->pViewports)
    {
        if ((a->pViewports) && (b->pViewports))
        {
            if (!((a->viewportCount) == (b->viewportCount))) { onFail("a->pViewports (Error: Lengths not equal)"); };
            if ((a->viewportCount) == (b->viewportCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->viewportCount; ++i)
                {
                    checkEqual_VkViewport(a->pViewports + i, b->pViewports + i, onFail);
                }
            }
        }
    }
    if (!((a->scissorCount) == (b->scissorCount))) { onFail("a->scissorCount (Error: Value not equal)"); };
    if (!((!(a->pScissors) && !(b->pScissors)) || ((a->pScissors) && (b->pScissors)))) { onFail("a->pScissors (Error: Mismatch in optional field)"); };
    if (a->pScissors && b->pScissors)
    {
        if ((a->pScissors) && (b->pScissors))
        {
            if (!((a->scissorCount) == (b->scissorCount))) { onFail("a->pScissors (Error: Lengths not equal)"); };
            if ((a->scissorCount) == (b->scissorCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->scissorCount; ++i)
                {
                    checkEqual_VkRect2D(a->pScissors + i, b->pScissors + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkPipelineRasterizationStateCreateInfo(
    const VkPipelineRasterizationStateCreateInfo* a,
    const VkPipelineRasterizationStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->depthClampEnable) == (b->depthClampEnable))) { onFail("a->depthClampEnable (Error: Value not equal)"); };
    if (!((a->rasterizerDiscardEnable) == (b->rasterizerDiscardEnable))) { onFail("a->rasterizerDiscardEnable (Error: Value not equal)"); };
    if (!((a->polygonMode) == (b->polygonMode))) { onFail("a->polygonMode (Error: Value not equal)"); };
    if (!((a->cullMode) == (b->cullMode))) { onFail("a->cullMode (Error: Value not equal)"); };
    if (!((a->frontFace) == (b->frontFace))) { onFail("a->frontFace (Error: Value not equal)"); };
    if (!((a->depthBiasEnable) == (b->depthBiasEnable))) { onFail("a->depthBiasEnable (Error: Value not equal)"); };
    if (!((a->depthBiasConstantFactor) == (b->depthBiasConstantFactor))) { onFail("a->depthBiasConstantFactor (Error: Value not equal)"); };
    if (!((a->depthBiasClamp) == (b->depthBiasClamp))) { onFail("a->depthBiasClamp (Error: Value not equal)"); };
    if (!((a->depthBiasSlopeFactor) == (b->depthBiasSlopeFactor))) { onFail("a->depthBiasSlopeFactor (Error: Value not equal)"); };
    if (!((a->lineWidth) == (b->lineWidth))) { onFail("a->lineWidth (Error: Value not equal)"); };
}

void checkEqual_VkPipelineMultisampleStateCreateInfo(
    const VkPipelineMultisampleStateCreateInfo* a,
    const VkPipelineMultisampleStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->rasterizationSamples) == (b->rasterizationSamples))) { onFail("a->rasterizationSamples (Error: Value not equal)"); };
    if (!((a->sampleShadingEnable) == (b->sampleShadingEnable))) { onFail("a->sampleShadingEnable (Error: Value not equal)"); };
    if (!((a->minSampleShading) == (b->minSampleShading))) { onFail("a->minSampleShading (Error: Value not equal)"); };
    if (!((!(a->pSampleMask) && !(b->pSampleMask)) || ((a->pSampleMask) && (b->pSampleMask)))) { onFail("a->pSampleMask (Error: Mismatch in optional field)"); };
    if (a->pSampleMask && b->pSampleMask)
    {
        if (!(((((a->rasterizationSamples) + 31) / 32)) == ((((b->rasterizationSamples) + 31) / 32)))) { onFail("a->pSampleMask (Error: Lengths not equal)"); };
        if (!((memcmp(a->pSampleMask, b->pSampleMask, (((a->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask)) == 0))) { onFail("a->pSampleMask (Error: Unequal dyn array)"); };
    }
    if (!((a->alphaToCoverageEnable) == (b->alphaToCoverageEnable))) { onFail("a->alphaToCoverageEnable (Error: Value not equal)"); };
    if (!((a->alphaToOneEnable) == (b->alphaToOneEnable))) { onFail("a->alphaToOneEnable (Error: Value not equal)"); };
}

void checkEqual_VkStencilOpState(
    const VkStencilOpState* a,
    const VkStencilOpState* b,
    OnFailCompareFunc onFail)
{
    if (!((a->failOp) == (b->failOp))) { onFail("a->failOp (Error: Value not equal)"); };
    if (!((a->passOp) == (b->passOp))) { onFail("a->passOp (Error: Value not equal)"); };
    if (!((a->depthFailOp) == (b->depthFailOp))) { onFail("a->depthFailOp (Error: Value not equal)"); };
    if (!((a->compareOp) == (b->compareOp))) { onFail("a->compareOp (Error: Value not equal)"); };
    if (!((a->compareMask) == (b->compareMask))) { onFail("a->compareMask (Error: Value not equal)"); };
    if (!((a->writeMask) == (b->writeMask))) { onFail("a->writeMask (Error: Value not equal)"); };
    if (!((a->reference) == (b->reference))) { onFail("a->reference (Error: Value not equal)"); };
}

void checkEqual_VkPipelineDepthStencilStateCreateInfo(
    const VkPipelineDepthStencilStateCreateInfo* a,
    const VkPipelineDepthStencilStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->depthTestEnable) == (b->depthTestEnable))) { onFail("a->depthTestEnable (Error: Value not equal)"); };
    if (!((a->depthWriteEnable) == (b->depthWriteEnable))) { onFail("a->depthWriteEnable (Error: Value not equal)"); };
    if (!((a->depthCompareOp) == (b->depthCompareOp))) { onFail("a->depthCompareOp (Error: Value not equal)"); };
    if (!((a->depthBoundsTestEnable) == (b->depthBoundsTestEnable))) { onFail("a->depthBoundsTestEnable (Error: Value not equal)"); };
    if (!((a->stencilTestEnable) == (b->stencilTestEnable))) { onFail("a->stencilTestEnable (Error: Value not equal)"); };
    checkEqual_VkStencilOpState(&a->front, &b->front, onFail);
    checkEqual_VkStencilOpState(&a->back, &b->back, onFail);
    if (!((a->minDepthBounds) == (b->minDepthBounds))) { onFail("a->minDepthBounds (Error: Value not equal)"); };
    if (!((a->maxDepthBounds) == (b->maxDepthBounds))) { onFail("a->maxDepthBounds (Error: Value not equal)"); };
}

void checkEqual_VkPipelineColorBlendAttachmentState(
    const VkPipelineColorBlendAttachmentState* a,
    const VkPipelineColorBlendAttachmentState* b,
    OnFailCompareFunc onFail)
{
    if (!((a->blendEnable) == (b->blendEnable))) { onFail("a->blendEnable (Error: Value not equal)"); };
    if (!((a->srcColorBlendFactor) == (b->srcColorBlendFactor))) { onFail("a->srcColorBlendFactor (Error: Value not equal)"); };
    if (!((a->dstColorBlendFactor) == (b->dstColorBlendFactor))) { onFail("a->dstColorBlendFactor (Error: Value not equal)"); };
    if (!((a->colorBlendOp) == (b->colorBlendOp))) { onFail("a->colorBlendOp (Error: Value not equal)"); };
    if (!((a->srcAlphaBlendFactor) == (b->srcAlphaBlendFactor))) { onFail("a->srcAlphaBlendFactor (Error: Value not equal)"); };
    if (!((a->dstAlphaBlendFactor) == (b->dstAlphaBlendFactor))) { onFail("a->dstAlphaBlendFactor (Error: Value not equal)"); };
    if (!((a->alphaBlendOp) == (b->alphaBlendOp))) { onFail("a->alphaBlendOp (Error: Value not equal)"); };
    if (!((a->colorWriteMask) == (b->colorWriteMask))) { onFail("a->colorWriteMask (Error: Value not equal)"); };
}

void checkEqual_VkPipelineColorBlendStateCreateInfo(
    const VkPipelineColorBlendStateCreateInfo* a,
    const VkPipelineColorBlendStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->logicOpEnable) == (b->logicOpEnable))) { onFail("a->logicOpEnable (Error: Value not equal)"); };
    if (!((a->logicOp) == (b->logicOp))) { onFail("a->logicOp (Error: Value not equal)"); };
    if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->attachmentCount (Error: Value not equal)"); };
    if ((a->pAttachments) && (b->pAttachments))
    {
        if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->pAttachments (Error: Lengths not equal)"); };
        if ((a->attachmentCount) == (b->attachmentCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->attachmentCount; ++i)
            {
                checkEqual_VkPipelineColorBlendAttachmentState(a->pAttachments + i, b->pAttachments + i, onFail);
            }
        }
    }
    if (!((memcmp(a->blendConstants, b->blendConstants, 4 * sizeof(float)) == 0))) { onFail("a->blendConstants (Error: Unequal static array)"); };
}

void checkEqual_VkPipelineDynamicStateCreateInfo(
    const VkPipelineDynamicStateCreateInfo* a,
    const VkPipelineDynamicStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->dynamicStateCount) == (b->dynamicStateCount))) { onFail("a->dynamicStateCount (Error: Value not equal)"); };
    if (!((a->dynamicStateCount) == (b->dynamicStateCount))) { onFail("a->pDynamicStates (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDynamicStates, b->pDynamicStates, a->dynamicStateCount * sizeof(const VkDynamicState)) == 0))) { onFail("a->pDynamicStates (Error: Unequal dyn array)"); };
}

void checkEqual_VkGraphicsPipelineCreateInfo(
    const VkGraphicsPipelineCreateInfo* a,
    const VkGraphicsPipelineCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->stageCount) == (b->stageCount))) { onFail("a->stageCount (Error: Value not equal)"); };
    if ((a->pStages) && (b->pStages))
    {
        if (!((a->stageCount) == (b->stageCount))) { onFail("a->pStages (Error: Lengths not equal)"); };
        if ((a->stageCount) == (b->stageCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->stageCount; ++i)
            {
                checkEqual_VkPipelineShaderStageCreateInfo(a->pStages + i, b->pStages + i, onFail);
            }
        }
    }
    if ((a->pVertexInputState) && (b->pVertexInputState))
    {
        checkEqual_VkPipelineVertexInputStateCreateInfo(a->pVertexInputState, b->pVertexInputState, onFail);
    }
    if ((a->pInputAssemblyState) && (b->pInputAssemblyState))
    {
        checkEqual_VkPipelineInputAssemblyStateCreateInfo(a->pInputAssemblyState, b->pInputAssemblyState, onFail);
    }
    if (!((!(a->pTessellationState) && !(b->pTessellationState)) || ((a->pTessellationState) && (b->pTessellationState)))) { onFail("a->pTessellationState (Error: Mismatch in optional field)"); };
    if (a->pTessellationState && b->pTessellationState)
    {
        if ((a->pTessellationState) && (b->pTessellationState))
        {
            checkEqual_VkPipelineTessellationStateCreateInfo(a->pTessellationState, b->pTessellationState, onFail);
        }
    }
    if (!((!(a->pViewportState) && !(b->pViewportState)) || ((a->pViewportState) && (b->pViewportState)))) { onFail("a->pViewportState (Error: Mismatch in optional field)"); };
    if (a->pViewportState && b->pViewportState)
    {
        if ((a->pViewportState) && (b->pViewportState))
        {
            checkEqual_VkPipelineViewportStateCreateInfo(a->pViewportState, b->pViewportState, onFail);
        }
    }
    if ((a->pRasterizationState) && (b->pRasterizationState))
    {
        checkEqual_VkPipelineRasterizationStateCreateInfo(a->pRasterizationState, b->pRasterizationState, onFail);
    }
    if (!((!(a->pMultisampleState) && !(b->pMultisampleState)) || ((a->pMultisampleState) && (b->pMultisampleState)))) { onFail("a->pMultisampleState (Error: Mismatch in optional field)"); };
    if (a->pMultisampleState && b->pMultisampleState)
    {
        if ((a->pMultisampleState) && (b->pMultisampleState))
        {
            checkEqual_VkPipelineMultisampleStateCreateInfo(a->pMultisampleState, b->pMultisampleState, onFail);
        }
    }
    if (!((!(a->pDepthStencilState) && !(b->pDepthStencilState)) || ((a->pDepthStencilState) && (b->pDepthStencilState)))) { onFail("a->pDepthStencilState (Error: Mismatch in optional field)"); };
    if (a->pDepthStencilState && b->pDepthStencilState)
    {
        if ((a->pDepthStencilState) && (b->pDepthStencilState))
        {
            checkEqual_VkPipelineDepthStencilStateCreateInfo(a->pDepthStencilState, b->pDepthStencilState, onFail);
        }
    }
    if (!((!(a->pColorBlendState) && !(b->pColorBlendState)) || ((a->pColorBlendState) && (b->pColorBlendState)))) { onFail("a->pColorBlendState (Error: Mismatch in optional field)"); };
    if (a->pColorBlendState && b->pColorBlendState)
    {
        if ((a->pColorBlendState) && (b->pColorBlendState))
        {
            checkEqual_VkPipelineColorBlendStateCreateInfo(a->pColorBlendState, b->pColorBlendState, onFail);
        }
    }
    if (!((!(a->pDynamicState) && !(b->pDynamicState)) || ((a->pDynamicState) && (b->pDynamicState)))) { onFail("a->pDynamicState (Error: Mismatch in optional field)"); };
    if (a->pDynamicState && b->pDynamicState)
    {
        if ((a->pDynamicState) && (b->pDynamicState))
        {
            checkEqual_VkPipelineDynamicStateCreateInfo(a->pDynamicState, b->pDynamicState, onFail);
        }
    }
    if (!((a->layout) == (b->layout))) { onFail("a->layout (Error: Value not equal)"); };
    if (!((a->renderPass) == (b->renderPass))) { onFail("a->renderPass (Error: Value not equal)"); };
    if (!((a->subpass) == (b->subpass))) { onFail("a->subpass (Error: Value not equal)"); };
    if (!((a->basePipelineHandle) == (b->basePipelineHandle))) { onFail("a->basePipelineHandle (Error: Value not equal)"); };
    if (!((a->basePipelineIndex) == (b->basePipelineIndex))) { onFail("a->basePipelineIndex (Error: Value not equal)"); };
}

void checkEqual_VkComputePipelineCreateInfo(
    const VkComputePipelineCreateInfo* a,
    const VkComputePipelineCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    checkEqual_VkPipelineShaderStageCreateInfo(&a->stage, &b->stage, onFail);
    if (!((a->layout) == (b->layout))) { onFail("a->layout (Error: Value not equal)"); };
    if (!((a->basePipelineHandle) == (b->basePipelineHandle))) { onFail("a->basePipelineHandle (Error: Value not equal)"); };
    if (!((a->basePipelineIndex) == (b->basePipelineIndex))) { onFail("a->basePipelineIndex (Error: Value not equal)"); };
}

void checkEqual_VkPushConstantRange(
    const VkPushConstantRange* a,
    const VkPushConstantRange* b,
    OnFailCompareFunc onFail)
{
    if (!((a->stageFlags) == (b->stageFlags))) { onFail("a->stageFlags (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
}

void checkEqual_VkPipelineLayoutCreateInfo(
    const VkPipelineLayoutCreateInfo* a,
    const VkPipelineLayoutCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->setLayoutCount) == (b->setLayoutCount))) { onFail("a->setLayoutCount (Error: Value not equal)"); };
    if (!((a->setLayoutCount) == (b->setLayoutCount))) { onFail("a->pSetLayouts (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSetLayouts, b->pSetLayouts, a->setLayoutCount * sizeof(const VkDescriptorSetLayout)) == 0))) { onFail("a->pSetLayouts (Error: Unequal dyn array)"); };
    if (!((a->pushConstantRangeCount) == (b->pushConstantRangeCount))) { onFail("a->pushConstantRangeCount (Error: Value not equal)"); };
    if ((a->pPushConstantRanges) && (b->pPushConstantRanges))
    {
        if (!((a->pushConstantRangeCount) == (b->pushConstantRangeCount))) { onFail("a->pPushConstantRanges (Error: Lengths not equal)"); };
        if ((a->pushConstantRangeCount) == (b->pushConstantRangeCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->pushConstantRangeCount; ++i)
            {
                checkEqual_VkPushConstantRange(a->pPushConstantRanges + i, b->pPushConstantRanges + i, onFail);
            }
        }
    }
}

void checkEqual_VkSamplerCreateInfo(
    const VkSamplerCreateInfo* a,
    const VkSamplerCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->magFilter) == (b->magFilter))) { onFail("a->magFilter (Error: Value not equal)"); };
    if (!((a->minFilter) == (b->minFilter))) { onFail("a->minFilter (Error: Value not equal)"); };
    if (!((a->mipmapMode) == (b->mipmapMode))) { onFail("a->mipmapMode (Error: Value not equal)"); };
    if (!((a->addressModeU) == (b->addressModeU))) { onFail("a->addressModeU (Error: Value not equal)"); };
    if (!((a->addressModeV) == (b->addressModeV))) { onFail("a->addressModeV (Error: Value not equal)"); };
    if (!((a->addressModeW) == (b->addressModeW))) { onFail("a->addressModeW (Error: Value not equal)"); };
    if (!((a->mipLodBias) == (b->mipLodBias))) { onFail("a->mipLodBias (Error: Value not equal)"); };
    if (!((a->anisotropyEnable) == (b->anisotropyEnable))) { onFail("a->anisotropyEnable (Error: Value not equal)"); };
    if (!((a->maxAnisotropy) == (b->maxAnisotropy))) { onFail("a->maxAnisotropy (Error: Value not equal)"); };
    if (!((a->compareEnable) == (b->compareEnable))) { onFail("a->compareEnable (Error: Value not equal)"); };
    if (!((a->compareOp) == (b->compareOp))) { onFail("a->compareOp (Error: Value not equal)"); };
    if (!((a->minLod) == (b->minLod))) { onFail("a->minLod (Error: Value not equal)"); };
    if (!((a->maxLod) == (b->maxLod))) { onFail("a->maxLod (Error: Value not equal)"); };
    if (!((a->borderColor) == (b->borderColor))) { onFail("a->borderColor (Error: Value not equal)"); };
    if (!((a->unnormalizedCoordinates) == (b->unnormalizedCoordinates))) { onFail("a->unnormalizedCoordinates (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorSetLayoutBinding(
    const VkDescriptorSetLayoutBinding* a,
    const VkDescriptorSetLayoutBinding* b,
    OnFailCompareFunc onFail)
{
    if (!((a->binding) == (b->binding))) { onFail("a->binding (Error: Value not equal)"); };
    if (!((a->descriptorType) == (b->descriptorType))) { onFail("a->descriptorType (Error: Value not equal)"); };
    if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->descriptorCount (Error: Value not equal)"); };
    if (!((a->stageFlags) == (b->stageFlags))) { onFail("a->stageFlags (Error: Value not equal)"); };
    if (!((!(a->pImmutableSamplers) && !(b->pImmutableSamplers)) || ((a->pImmutableSamplers) && (b->pImmutableSamplers)))) { onFail("a->pImmutableSamplers (Error: Mismatch in optional field)"); };
    if (a->pImmutableSamplers && b->pImmutableSamplers)
    {
        if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->pImmutableSamplers (Error: Lengths not equal)"); };
        if (!((memcmp(a->pImmutableSamplers, b->pImmutableSamplers, a->descriptorCount * sizeof(const VkSampler)) == 0))) { onFail("a->pImmutableSamplers (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkDescriptorSetLayoutCreateInfo(
    const VkDescriptorSetLayoutCreateInfo* a,
    const VkDescriptorSetLayoutCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->bindingCount) == (b->bindingCount))) { onFail("a->bindingCount (Error: Value not equal)"); };
    if ((a->pBindings) && (b->pBindings))
    {
        if (!((a->bindingCount) == (b->bindingCount))) { onFail("a->pBindings (Error: Lengths not equal)"); };
        if ((a->bindingCount) == (b->bindingCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->bindingCount; ++i)
            {
                checkEqual_VkDescriptorSetLayoutBinding(a->pBindings + i, b->pBindings + i, onFail);
            }
        }
    }
}

void checkEqual_VkDescriptorPoolSize(
    const VkDescriptorPoolSize* a,
    const VkDescriptorPoolSize* b,
    OnFailCompareFunc onFail)
{
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->descriptorCount (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorPoolCreateInfo(
    const VkDescriptorPoolCreateInfo* a,
    const VkDescriptorPoolCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->maxSets) == (b->maxSets))) { onFail("a->maxSets (Error: Value not equal)"); };
    if (!((a->poolSizeCount) == (b->poolSizeCount))) { onFail("a->poolSizeCount (Error: Value not equal)"); };
    if ((a->pPoolSizes) && (b->pPoolSizes))
    {
        if (!((a->poolSizeCount) == (b->poolSizeCount))) { onFail("a->pPoolSizes (Error: Lengths not equal)"); };
        if ((a->poolSizeCount) == (b->poolSizeCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->poolSizeCount; ++i)
            {
                checkEqual_VkDescriptorPoolSize(a->pPoolSizes + i, b->pPoolSizes + i, onFail);
            }
        }
    }
}

void checkEqual_VkDescriptorSetAllocateInfo(
    const VkDescriptorSetAllocateInfo* a,
    const VkDescriptorSetAllocateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->descriptorPool) == (b->descriptorPool))) { onFail("a->descriptorPool (Error: Value not equal)"); };
    if (!((a->descriptorSetCount) == (b->descriptorSetCount))) { onFail("a->descriptorSetCount (Error: Value not equal)"); };
    if (!((a->descriptorSetCount) == (b->descriptorSetCount))) { onFail("a->pSetLayouts (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSetLayouts, b->pSetLayouts, a->descriptorSetCount * sizeof(const VkDescriptorSetLayout)) == 0))) { onFail("a->pSetLayouts (Error: Unequal dyn array)"); };
}

void checkEqual_VkDescriptorImageInfo(
    const VkDescriptorImageInfo* a,
    const VkDescriptorImageInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sampler) == (b->sampler))) { onFail("a->sampler (Error: Value not equal)"); };
    if (!((a->imageView) == (b->imageView))) { onFail("a->imageView (Error: Value not equal)"); };
    if (!((a->imageLayout) == (b->imageLayout))) { onFail("a->imageLayout (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorBufferInfo(
    const VkDescriptorBufferInfo* a,
    const VkDescriptorBufferInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->range) == (b->range))) { onFail("a->range (Error: Value not equal)"); };
}

void checkEqual_VkWriteDescriptorSet(
    const VkWriteDescriptorSet* a,
    const VkWriteDescriptorSet* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->dstSet) == (b->dstSet))) { onFail("a->dstSet (Error: Value not equal)"); };
    if (!((a->dstBinding) == (b->dstBinding))) { onFail("a->dstBinding (Error: Value not equal)"); };
    if (!((a->dstArrayElement) == (b->dstArrayElement))) { onFail("a->dstArrayElement (Error: Value not equal)"); };
    if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->descriptorCount (Error: Value not equal)"); };
    if (!((a->descriptorType) == (b->descriptorType))) { onFail("a->descriptorType (Error: Value not equal)"); };
    if (!((!(a->pImageInfo) && !(b->pImageInfo)) || ((a->pImageInfo) && (b->pImageInfo)))) { onFail("a->pImageInfo (Error: Mismatch in optional field)"); };
    if (a->pImageInfo && b->pImageInfo)
    {
        if ((a->pImageInfo) && (b->pImageInfo))
        {
            if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->pImageInfo (Error: Lengths not equal)"); };
            if ((a->descriptorCount) == (b->descriptorCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->descriptorCount; ++i)
                {
                    checkEqual_VkDescriptorImageInfo(a->pImageInfo + i, b->pImageInfo + i, onFail);
                }
            }
        }
    }
    if (!((!(a->pBufferInfo) && !(b->pBufferInfo)) || ((a->pBufferInfo) && (b->pBufferInfo)))) { onFail("a->pBufferInfo (Error: Mismatch in optional field)"); };
    if (a->pBufferInfo && b->pBufferInfo)
    {
        if ((a->pBufferInfo) && (b->pBufferInfo))
        {
            if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->pBufferInfo (Error: Lengths not equal)"); };
            if ((a->descriptorCount) == (b->descriptorCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->descriptorCount; ++i)
                {
                    checkEqual_VkDescriptorBufferInfo(a->pBufferInfo + i, b->pBufferInfo + i, onFail);
                }
            }
        }
    }
    if (!((!(a->pTexelBufferView) && !(b->pTexelBufferView)) || ((a->pTexelBufferView) && (b->pTexelBufferView)))) { onFail("a->pTexelBufferView (Error: Mismatch in optional field)"); };
    if (a->pTexelBufferView && b->pTexelBufferView)
    {
        if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->pTexelBufferView (Error: Lengths not equal)"); };
        if (!((memcmp(a->pTexelBufferView, b->pTexelBufferView, a->descriptorCount * sizeof(const VkBufferView)) == 0))) { onFail("a->pTexelBufferView (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkCopyDescriptorSet(
    const VkCopyDescriptorSet* a,
    const VkCopyDescriptorSet* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcSet) == (b->srcSet))) { onFail("a->srcSet (Error: Value not equal)"); };
    if (!((a->srcBinding) == (b->srcBinding))) { onFail("a->srcBinding (Error: Value not equal)"); };
    if (!((a->srcArrayElement) == (b->srcArrayElement))) { onFail("a->srcArrayElement (Error: Value not equal)"); };
    if (!((a->dstSet) == (b->dstSet))) { onFail("a->dstSet (Error: Value not equal)"); };
    if (!((a->dstBinding) == (b->dstBinding))) { onFail("a->dstBinding (Error: Value not equal)"); };
    if (!((a->dstArrayElement) == (b->dstArrayElement))) { onFail("a->dstArrayElement (Error: Value not equal)"); };
    if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->descriptorCount (Error: Value not equal)"); };
}

void checkEqual_VkFramebufferCreateInfo(
    const VkFramebufferCreateInfo* a,
    const VkFramebufferCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->renderPass) == (b->renderPass))) { onFail("a->renderPass (Error: Value not equal)"); };
    if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->attachmentCount (Error: Value not equal)"); };
    if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->pAttachments (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAttachments, b->pAttachments, a->attachmentCount * sizeof(const VkImageView)) == 0))) { onFail("a->pAttachments (Error: Unequal dyn array)"); };
    if (!((a->width) == (b->width))) { onFail("a->width (Error: Value not equal)"); };
    if (!((a->height) == (b->height))) { onFail("a->height (Error: Value not equal)"); };
    if (!((a->layers) == (b->layers))) { onFail("a->layers (Error: Value not equal)"); };
}

void checkEqual_VkAttachmentDescription(
    const VkAttachmentDescription* a,
    const VkAttachmentDescription* b,
    OnFailCompareFunc onFail)
{
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->samples) == (b->samples))) { onFail("a->samples (Error: Value not equal)"); };
    if (!((a->loadOp) == (b->loadOp))) { onFail("a->loadOp (Error: Value not equal)"); };
    if (!((a->storeOp) == (b->storeOp))) { onFail("a->storeOp (Error: Value not equal)"); };
    if (!((a->stencilLoadOp) == (b->stencilLoadOp))) { onFail("a->stencilLoadOp (Error: Value not equal)"); };
    if (!((a->stencilStoreOp) == (b->stencilStoreOp))) { onFail("a->stencilStoreOp (Error: Value not equal)"); };
    if (!((a->initialLayout) == (b->initialLayout))) { onFail("a->initialLayout (Error: Value not equal)"); };
    if (!((a->finalLayout) == (b->finalLayout))) { onFail("a->finalLayout (Error: Value not equal)"); };
}

void checkEqual_VkAttachmentReference(
    const VkAttachmentReference* a,
    const VkAttachmentReference* b,
    OnFailCompareFunc onFail)
{
    if (!((a->attachment) == (b->attachment))) { onFail("a->attachment (Error: Value not equal)"); };
    if (!((a->layout) == (b->layout))) { onFail("a->layout (Error: Value not equal)"); };
}

void checkEqual_VkSubpassDescription(
    const VkSubpassDescription* a,
    const VkSubpassDescription* b,
    OnFailCompareFunc onFail)
{
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->pipelineBindPoint) == (b->pipelineBindPoint))) { onFail("a->pipelineBindPoint (Error: Value not equal)"); };
    if (!((a->inputAttachmentCount) == (b->inputAttachmentCount))) { onFail("a->inputAttachmentCount (Error: Value not equal)"); };
    if ((a->pInputAttachments) && (b->pInputAttachments))
    {
        if (!((a->inputAttachmentCount) == (b->inputAttachmentCount))) { onFail("a->pInputAttachments (Error: Lengths not equal)"); };
        if ((a->inputAttachmentCount) == (b->inputAttachmentCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->inputAttachmentCount; ++i)
            {
                checkEqual_VkAttachmentReference(a->pInputAttachments + i, b->pInputAttachments + i, onFail);
            }
        }
    }
    if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->colorAttachmentCount (Error: Value not equal)"); };
    if ((a->pColorAttachments) && (b->pColorAttachments))
    {
        if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->pColorAttachments (Error: Lengths not equal)"); };
        if ((a->colorAttachmentCount) == (b->colorAttachmentCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->colorAttachmentCount; ++i)
            {
                checkEqual_VkAttachmentReference(a->pColorAttachments + i, b->pColorAttachments + i, onFail);
            }
        }
    }
    if (!((!(a->pResolveAttachments) && !(b->pResolveAttachments)) || ((a->pResolveAttachments) && (b->pResolveAttachments)))) { onFail("a->pResolveAttachments (Error: Mismatch in optional field)"); };
    if (a->pResolveAttachments && b->pResolveAttachments)
    {
        if ((a->pResolveAttachments) && (b->pResolveAttachments))
        {
            if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->pResolveAttachments (Error: Lengths not equal)"); };
            if ((a->colorAttachmentCount) == (b->colorAttachmentCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->colorAttachmentCount; ++i)
                {
                    checkEqual_VkAttachmentReference(a->pResolveAttachments + i, b->pResolveAttachments + i, onFail);
                }
            }
        }
    }
    if (!((!(a->pDepthStencilAttachment) && !(b->pDepthStencilAttachment)) || ((a->pDepthStencilAttachment) && (b->pDepthStencilAttachment)))) { onFail("a->pDepthStencilAttachment (Error: Mismatch in optional field)"); };
    if (a->pDepthStencilAttachment && b->pDepthStencilAttachment)
    {
        if ((a->pDepthStencilAttachment) && (b->pDepthStencilAttachment))
        {
            checkEqual_VkAttachmentReference(a->pDepthStencilAttachment, b->pDepthStencilAttachment, onFail);
        }
    }
    if (!((a->preserveAttachmentCount) == (b->preserveAttachmentCount))) { onFail("a->preserveAttachmentCount (Error: Value not equal)"); };
    if (!((a->preserveAttachmentCount) == (b->preserveAttachmentCount))) { onFail("a->pPreserveAttachments (Error: Lengths not equal)"); };
    if (!((memcmp(a->pPreserveAttachments, b->pPreserveAttachments, a->preserveAttachmentCount * sizeof(const uint32_t)) == 0))) { onFail("a->pPreserveAttachments (Error: Unequal dyn array)"); };
}

void checkEqual_VkSubpassDependency(
    const VkSubpassDependency* a,
    const VkSubpassDependency* b,
    OnFailCompareFunc onFail)
{
    if (!((a->srcSubpass) == (b->srcSubpass))) { onFail("a->srcSubpass (Error: Value not equal)"); };
    if (!((a->dstSubpass) == (b->dstSubpass))) { onFail("a->dstSubpass (Error: Value not equal)"); };
    if (!((a->srcStageMask) == (b->srcStageMask))) { onFail("a->srcStageMask (Error: Value not equal)"); };
    if (!((a->dstStageMask) == (b->dstStageMask))) { onFail("a->dstStageMask (Error: Value not equal)"); };
    if (!((a->srcAccessMask) == (b->srcAccessMask))) { onFail("a->srcAccessMask (Error: Value not equal)"); };
    if (!((a->dstAccessMask) == (b->dstAccessMask))) { onFail("a->dstAccessMask (Error: Value not equal)"); };
    if (!((a->dependencyFlags) == (b->dependencyFlags))) { onFail("a->dependencyFlags (Error: Value not equal)"); };
}

void checkEqual_VkRenderPassCreateInfo(
    const VkRenderPassCreateInfo* a,
    const VkRenderPassCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->attachmentCount (Error: Value not equal)"); };
    if ((a->pAttachments) && (b->pAttachments))
    {
        if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->pAttachments (Error: Lengths not equal)"); };
        if ((a->attachmentCount) == (b->attachmentCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->attachmentCount; ++i)
            {
                checkEqual_VkAttachmentDescription(a->pAttachments + i, b->pAttachments + i, onFail);
            }
        }
    }
    if (!((a->subpassCount) == (b->subpassCount))) { onFail("a->subpassCount (Error: Value not equal)"); };
    if ((a->pSubpasses) && (b->pSubpasses))
    {
        if (!((a->subpassCount) == (b->subpassCount))) { onFail("a->pSubpasses (Error: Lengths not equal)"); };
        if ((a->subpassCount) == (b->subpassCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->subpassCount; ++i)
            {
                checkEqual_VkSubpassDescription(a->pSubpasses + i, b->pSubpasses + i, onFail);
            }
        }
    }
    if (!((a->dependencyCount) == (b->dependencyCount))) { onFail("a->dependencyCount (Error: Value not equal)"); };
    if ((a->pDependencies) && (b->pDependencies))
    {
        if (!((a->dependencyCount) == (b->dependencyCount))) { onFail("a->pDependencies (Error: Lengths not equal)"); };
        if ((a->dependencyCount) == (b->dependencyCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->dependencyCount; ++i)
            {
                checkEqual_VkSubpassDependency(a->pDependencies + i, b->pDependencies + i, onFail);
            }
        }
    }
}

void checkEqual_VkCommandPoolCreateInfo(
    const VkCommandPoolCreateInfo* a,
    const VkCommandPoolCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->queueFamilyIndex) == (b->queueFamilyIndex))) { onFail("a->queueFamilyIndex (Error: Value not equal)"); };
}

void checkEqual_VkCommandBufferAllocateInfo(
    const VkCommandBufferAllocateInfo* a,
    const VkCommandBufferAllocateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->commandPool) == (b->commandPool))) { onFail("a->commandPool (Error: Value not equal)"); };
    if (!((a->level) == (b->level))) { onFail("a->level (Error: Value not equal)"); };
    if (!((a->commandBufferCount) == (b->commandBufferCount))) { onFail("a->commandBufferCount (Error: Value not equal)"); };
}

void checkEqual_VkCommandBufferInheritanceInfo(
    const VkCommandBufferInheritanceInfo* a,
    const VkCommandBufferInheritanceInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->renderPass) == (b->renderPass))) { onFail("a->renderPass (Error: Value not equal)"); };
    if (!((a->subpass) == (b->subpass))) { onFail("a->subpass (Error: Value not equal)"); };
    if (!((a->framebuffer) == (b->framebuffer))) { onFail("a->framebuffer (Error: Value not equal)"); };
    if (!((a->occlusionQueryEnable) == (b->occlusionQueryEnable))) { onFail("a->occlusionQueryEnable (Error: Value not equal)"); };
    if (!((a->queryFlags) == (b->queryFlags))) { onFail("a->queryFlags (Error: Value not equal)"); };
    if (!((a->pipelineStatistics) == (b->pipelineStatistics))) { onFail("a->pipelineStatistics (Error: Value not equal)"); };
}

void checkEqual_VkCommandBufferBeginInfo(
    const VkCommandBufferBeginInfo* a,
    const VkCommandBufferBeginInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->pInheritanceInfo) && !(b->pInheritanceInfo)) || ((a->pInheritanceInfo) && (b->pInheritanceInfo)))) { onFail("a->pInheritanceInfo (Error: Mismatch in optional field)"); };
    if (a->pInheritanceInfo && b->pInheritanceInfo)
    {
        if ((a->pInheritanceInfo) && (b->pInheritanceInfo))
        {
            checkEqual_VkCommandBufferInheritanceInfo(a->pInheritanceInfo, b->pInheritanceInfo, onFail);
        }
    }
}

void checkEqual_VkBufferCopy(
    const VkBufferCopy* a,
    const VkBufferCopy* b,
    OnFailCompareFunc onFail)
{
    if (!((a->srcOffset) == (b->srcOffset))) { onFail("a->srcOffset (Error: Value not equal)"); };
    if (!((a->dstOffset) == (b->dstOffset))) { onFail("a->dstOffset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
}

void checkEqual_VkImageSubresourceLayers(
    const VkImageSubresourceLayers* a,
    const VkImageSubresourceLayers* b,
    OnFailCompareFunc onFail)
{
    if (!((a->aspectMask) == (b->aspectMask))) { onFail("a->aspectMask (Error: Value not equal)"); };
    if (!((a->mipLevel) == (b->mipLevel))) { onFail("a->mipLevel (Error: Value not equal)"); };
    if (!((a->baseArrayLayer) == (b->baseArrayLayer))) { onFail("a->baseArrayLayer (Error: Value not equal)"); };
    if (!((a->layerCount) == (b->layerCount))) { onFail("a->layerCount (Error: Value not equal)"); };
}

void checkEqual_VkImageCopy(
    const VkImageCopy* a,
    const VkImageCopy* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkImageSubresourceLayers(&a->srcSubresource, &b->srcSubresource, onFail);
    checkEqual_VkOffset3D(&a->srcOffset, &b->srcOffset, onFail);
    checkEqual_VkImageSubresourceLayers(&a->dstSubresource, &b->dstSubresource, onFail);
    checkEqual_VkOffset3D(&a->dstOffset, &b->dstOffset, onFail);
    checkEqual_VkExtent3D(&a->extent, &b->extent, onFail);
}

void checkEqual_VkImageBlit(
    const VkImageBlit* a,
    const VkImageBlit* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkImageSubresourceLayers(&a->srcSubresource, &b->srcSubresource, onFail);
    if (!((2) == (2))) { onFail("a->srcOffsets (Error: Lengths not equal)"); };
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        checkEqual_VkOffset3D(a->srcOffsets + i, b->srcOffsets + i, onFail);
    }
    checkEqual_VkImageSubresourceLayers(&a->dstSubresource, &b->dstSubresource, onFail);
    if (!((2) == (2))) { onFail("a->dstOffsets (Error: Lengths not equal)"); };
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        checkEqual_VkOffset3D(a->dstOffsets + i, b->dstOffsets + i, onFail);
    }
}

void checkEqual_VkBufferImageCopy(
    const VkBufferImageCopy* a,
    const VkBufferImageCopy* b,
    OnFailCompareFunc onFail)
{
    if (!((a->bufferOffset) == (b->bufferOffset))) { onFail("a->bufferOffset (Error: Value not equal)"); };
    if (!((a->bufferRowLength) == (b->bufferRowLength))) { onFail("a->bufferRowLength (Error: Value not equal)"); };
    if (!((a->bufferImageHeight) == (b->bufferImageHeight))) { onFail("a->bufferImageHeight (Error: Value not equal)"); };
    checkEqual_VkImageSubresourceLayers(&a->imageSubresource, &b->imageSubresource, onFail);
    checkEqual_VkOffset3D(&a->imageOffset, &b->imageOffset, onFail);
    checkEqual_VkExtent3D(&a->imageExtent, &b->imageExtent, onFail);
}

void checkEqual_VkClearColorValue(
    const VkClearColorValue* a,
    const VkClearColorValue* b,
    OnFailCompareFunc onFail)
{
    if (!((memcmp(a->float32, b->float32, 4 * sizeof(float)) == 0))) { onFail("a->float32 (Error: Unequal static array)"); };
    if (!((memcmp(a->int32, b->int32, 4 * sizeof(int32_t)) == 0))) { onFail("a->int32 (Error: Unequal static array)"); };
    if (!((memcmp(a->uint32, b->uint32, 4 * sizeof(uint32_t)) == 0))) { onFail("a->uint32 (Error: Unequal static array)"); };
}

void checkEqual_VkClearDepthStencilValue(
    const VkClearDepthStencilValue* a,
    const VkClearDepthStencilValue* b,
    OnFailCompareFunc onFail)
{
    if (!((a->depth) == (b->depth))) { onFail("a->depth (Error: Value not equal)"); };
    if (!((a->stencil) == (b->stencil))) { onFail("a->stencil (Error: Value not equal)"); };
}

void checkEqual_VkClearValue(
    const VkClearValue* a,
    const VkClearValue* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkClearColorValue(&a->color, &b->color, onFail);
    checkEqual_VkClearDepthStencilValue(&a->depthStencil, &b->depthStencil, onFail);
}

void checkEqual_VkClearAttachment(
    const VkClearAttachment* a,
    const VkClearAttachment* b,
    OnFailCompareFunc onFail)
{
    if (!((a->aspectMask) == (b->aspectMask))) { onFail("a->aspectMask (Error: Value not equal)"); };
    if (!((a->colorAttachment) == (b->colorAttachment))) { onFail("a->colorAttachment (Error: Value not equal)"); };
    checkEqual_VkClearValue(&a->clearValue, &b->clearValue, onFail);
}

void checkEqual_VkClearRect(
    const VkClearRect* a,
    const VkClearRect* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkRect2D(&a->rect, &b->rect, onFail);
    if (!((a->baseArrayLayer) == (b->baseArrayLayer))) { onFail("a->baseArrayLayer (Error: Value not equal)"); };
    if (!((a->layerCount) == (b->layerCount))) { onFail("a->layerCount (Error: Value not equal)"); };
}

void checkEqual_VkImageResolve(
    const VkImageResolve* a,
    const VkImageResolve* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkImageSubresourceLayers(&a->srcSubresource, &b->srcSubresource, onFail);
    checkEqual_VkOffset3D(&a->srcOffset, &b->srcOffset, onFail);
    checkEqual_VkImageSubresourceLayers(&a->dstSubresource, &b->dstSubresource, onFail);
    checkEqual_VkOffset3D(&a->dstOffset, &b->dstOffset, onFail);
    checkEqual_VkExtent3D(&a->extent, &b->extent, onFail);
}

void checkEqual_VkMemoryBarrier(
    const VkMemoryBarrier* a,
    const VkMemoryBarrier* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcAccessMask) == (b->srcAccessMask))) { onFail("a->srcAccessMask (Error: Value not equal)"); };
    if (!((a->dstAccessMask) == (b->dstAccessMask))) { onFail("a->dstAccessMask (Error: Value not equal)"); };
}

void checkEqual_VkBufferMemoryBarrier(
    const VkBufferMemoryBarrier* a,
    const VkBufferMemoryBarrier* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcAccessMask) == (b->srcAccessMask))) { onFail("a->srcAccessMask (Error: Value not equal)"); };
    if (!((a->dstAccessMask) == (b->dstAccessMask))) { onFail("a->dstAccessMask (Error: Value not equal)"); };
    if (!((a->srcQueueFamilyIndex) == (b->srcQueueFamilyIndex))) { onFail("a->srcQueueFamilyIndex (Error: Value not equal)"); };
    if (!((a->dstQueueFamilyIndex) == (b->dstQueueFamilyIndex))) { onFail("a->dstQueueFamilyIndex (Error: Value not equal)"); };
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
}

void checkEqual_VkImageMemoryBarrier(
    const VkImageMemoryBarrier* a,
    const VkImageMemoryBarrier* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcAccessMask) == (b->srcAccessMask))) { onFail("a->srcAccessMask (Error: Value not equal)"); };
    if (!((a->dstAccessMask) == (b->dstAccessMask))) { onFail("a->dstAccessMask (Error: Value not equal)"); };
    if (!((a->oldLayout) == (b->oldLayout))) { onFail("a->oldLayout (Error: Value not equal)"); };
    if (!((a->newLayout) == (b->newLayout))) { onFail("a->newLayout (Error: Value not equal)"); };
    if (!((a->srcQueueFamilyIndex) == (b->srcQueueFamilyIndex))) { onFail("a->srcQueueFamilyIndex (Error: Value not equal)"); };
    if (!((a->dstQueueFamilyIndex) == (b->dstQueueFamilyIndex))) { onFail("a->dstQueueFamilyIndex (Error: Value not equal)"); };
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    checkEqual_VkImageSubresourceRange(&a->subresourceRange, &b->subresourceRange, onFail);
}

void checkEqual_VkRenderPassBeginInfo(
    const VkRenderPassBeginInfo* a,
    const VkRenderPassBeginInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->renderPass) == (b->renderPass))) { onFail("a->renderPass (Error: Value not equal)"); };
    if (!((a->framebuffer) == (b->framebuffer))) { onFail("a->framebuffer (Error: Value not equal)"); };
    checkEqual_VkRect2D(&a->renderArea, &b->renderArea, onFail);
    if (!((a->clearValueCount) == (b->clearValueCount))) { onFail("a->clearValueCount (Error: Value not equal)"); };
    if (!((!(a->pClearValues) && !(b->pClearValues)) || ((a->pClearValues) && (b->pClearValues)))) { onFail("a->pClearValues (Error: Mismatch in optional field)"); };
    if (a->pClearValues && b->pClearValues)
    {
        if ((a->pClearValues) && (b->pClearValues))
        {
            if (!((a->clearValueCount) == (b->clearValueCount))) { onFail("a->pClearValues (Error: Lengths not equal)"); };
            if ((a->clearValueCount) == (b->clearValueCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->clearValueCount; ++i)
                {
                    checkEqual_VkClearValue(a->pClearValues + i, b->pClearValues + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkDispatchIndirectCommand(
    const VkDispatchIndirectCommand* a,
    const VkDispatchIndirectCommand* b,
    OnFailCompareFunc onFail)
{
    if (!((a->x) == (b->x))) { onFail("a->x (Error: Value not equal)"); };
    if (!((a->y) == (b->y))) { onFail("a->y (Error: Value not equal)"); };
    if (!((a->z) == (b->z))) { onFail("a->z (Error: Value not equal)"); };
}

void checkEqual_VkDrawIndexedIndirectCommand(
    const VkDrawIndexedIndirectCommand* a,
    const VkDrawIndexedIndirectCommand* b,
    OnFailCompareFunc onFail)
{
    if (!((a->indexCount) == (b->indexCount))) { onFail("a->indexCount (Error: Value not equal)"); };
    if (!((a->instanceCount) == (b->instanceCount))) { onFail("a->instanceCount (Error: Value not equal)"); };
    if (!((a->firstIndex) == (b->firstIndex))) { onFail("a->firstIndex (Error: Value not equal)"); };
    if (!((a->vertexOffset) == (b->vertexOffset))) { onFail("a->vertexOffset (Error: Value not equal)"); };
    if (!((a->firstInstance) == (b->firstInstance))) { onFail("a->firstInstance (Error: Value not equal)"); };
}

void checkEqual_VkDrawIndirectCommand(
    const VkDrawIndirectCommand* a,
    const VkDrawIndirectCommand* b,
    OnFailCompareFunc onFail)
{
    if (!((a->vertexCount) == (b->vertexCount))) { onFail("a->vertexCount (Error: Value not equal)"); };
    if (!((a->instanceCount) == (b->instanceCount))) { onFail("a->instanceCount (Error: Value not equal)"); };
    if (!((a->firstVertex) == (b->firstVertex))) { onFail("a->firstVertex (Error: Value not equal)"); };
    if (!((a->firstInstance) == (b->firstInstance))) { onFail("a->firstInstance (Error: Value not equal)"); };
}

void checkEqual_VkBaseOutStructure(
    const VkBaseOutStructure* a,
    const VkBaseOutStructure* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
}

void checkEqual_VkBaseInStructure(
    const VkBaseInStructure* a,
    const VkBaseInStructure* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
}

#endif
#ifdef VK_VERSION_1_1
void checkEqual_VkPhysicalDeviceSubgroupProperties(
    const VkPhysicalDeviceSubgroupProperties* a,
    const VkPhysicalDeviceSubgroupProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->subgroupSize) == (b->subgroupSize))) { onFail("a->subgroupSize (Error: Value not equal)"); };
    if (!((a->supportedStages) == (b->supportedStages))) { onFail("a->supportedStages (Error: Value not equal)"); };
    if (!((a->supportedOperations) == (b->supportedOperations))) { onFail("a->supportedOperations (Error: Value not equal)"); };
    if (!((a->quadOperationsInAllStages) == (b->quadOperationsInAllStages))) { onFail("a->quadOperationsInAllStages (Error: Value not equal)"); };
}

void checkEqual_VkBindBufferMemoryInfo(
    const VkBindBufferMemoryInfo* a,
    const VkBindBufferMemoryInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->memoryOffset) == (b->memoryOffset))) { onFail("a->memoryOffset (Error: Value not equal)"); };
}

void checkEqual_VkBindImageMemoryInfo(
    const VkBindImageMemoryInfo* a,
    const VkBindImageMemoryInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->memoryOffset) == (b->memoryOffset))) { onFail("a->memoryOffset (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDevice16BitStorageFeatures(
    const VkPhysicalDevice16BitStorageFeatures* a,
    const VkPhysicalDevice16BitStorageFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->storageBuffer16BitAccess) == (b->storageBuffer16BitAccess))) { onFail("a->storageBuffer16BitAccess (Error: Value not equal)"); };
    if (!((a->uniformAndStorageBuffer16BitAccess) == (b->uniformAndStorageBuffer16BitAccess))) { onFail("a->uniformAndStorageBuffer16BitAccess (Error: Value not equal)"); };
    if (!((a->storagePushConstant16) == (b->storagePushConstant16))) { onFail("a->storagePushConstant16 (Error: Value not equal)"); };
    if (!((a->storageInputOutput16) == (b->storageInputOutput16))) { onFail("a->storageInputOutput16 (Error: Value not equal)"); };
}

void checkEqual_VkMemoryDedicatedRequirements(
    const VkMemoryDedicatedRequirements* a,
    const VkMemoryDedicatedRequirements* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->prefersDedicatedAllocation) == (b->prefersDedicatedAllocation))) { onFail("a->prefersDedicatedAllocation (Error: Value not equal)"); };
    if (!((a->requiresDedicatedAllocation) == (b->requiresDedicatedAllocation))) { onFail("a->requiresDedicatedAllocation (Error: Value not equal)"); };
}

void checkEqual_VkMemoryDedicatedAllocateInfo(
    const VkMemoryDedicatedAllocateInfo* a,
    const VkMemoryDedicatedAllocateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
}

void checkEqual_VkMemoryAllocateFlagsInfo(
    const VkMemoryAllocateFlagsInfo* a,
    const VkMemoryAllocateFlagsInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->deviceMask) == (b->deviceMask))) { onFail("a->deviceMask (Error: Value not equal)"); };
}

void checkEqual_VkDeviceGroupRenderPassBeginInfo(
    const VkDeviceGroupRenderPassBeginInfo* a,
    const VkDeviceGroupRenderPassBeginInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceMask) == (b->deviceMask))) { onFail("a->deviceMask (Error: Value not equal)"); };
    if (!((a->deviceRenderAreaCount) == (b->deviceRenderAreaCount))) { onFail("a->deviceRenderAreaCount (Error: Value not equal)"); };
    if ((a->pDeviceRenderAreas) && (b->pDeviceRenderAreas))
    {
        if (!((a->deviceRenderAreaCount) == (b->deviceRenderAreaCount))) { onFail("a->pDeviceRenderAreas (Error: Lengths not equal)"); };
        if ((a->deviceRenderAreaCount) == (b->deviceRenderAreaCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->deviceRenderAreaCount; ++i)
            {
                checkEqual_VkRect2D(a->pDeviceRenderAreas + i, b->pDeviceRenderAreas + i, onFail);
            }
        }
    }
}

void checkEqual_VkDeviceGroupCommandBufferBeginInfo(
    const VkDeviceGroupCommandBufferBeginInfo* a,
    const VkDeviceGroupCommandBufferBeginInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceMask) == (b->deviceMask))) { onFail("a->deviceMask (Error: Value not equal)"); };
}

void checkEqual_VkDeviceGroupSubmitInfo(
    const VkDeviceGroupSubmitInfo* a,
    const VkDeviceGroupSubmitInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->waitSemaphoreCount (Error: Value not equal)"); };
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->pWaitSemaphoreDeviceIndices (Error: Lengths not equal)"); };
    if (!((memcmp(a->pWaitSemaphoreDeviceIndices, b->pWaitSemaphoreDeviceIndices, a->waitSemaphoreCount * sizeof(const uint32_t)) == 0))) { onFail("a->pWaitSemaphoreDeviceIndices (Error: Unequal dyn array)"); };
    if (!((a->commandBufferCount) == (b->commandBufferCount))) { onFail("a->commandBufferCount (Error: Value not equal)"); };
    if (!((a->commandBufferCount) == (b->commandBufferCount))) { onFail("a->pCommandBufferDeviceMasks (Error: Lengths not equal)"); };
    if (!((memcmp(a->pCommandBufferDeviceMasks, b->pCommandBufferDeviceMasks, a->commandBufferCount * sizeof(const uint32_t)) == 0))) { onFail("a->pCommandBufferDeviceMasks (Error: Unequal dyn array)"); };
    if (!((a->signalSemaphoreCount) == (b->signalSemaphoreCount))) { onFail("a->signalSemaphoreCount (Error: Value not equal)"); };
    if (!((a->signalSemaphoreCount) == (b->signalSemaphoreCount))) { onFail("a->pSignalSemaphoreDeviceIndices (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSignalSemaphoreDeviceIndices, b->pSignalSemaphoreDeviceIndices, a->signalSemaphoreCount * sizeof(const uint32_t)) == 0))) { onFail("a->pSignalSemaphoreDeviceIndices (Error: Unequal dyn array)"); };
}

void checkEqual_VkDeviceGroupBindSparseInfo(
    const VkDeviceGroupBindSparseInfo* a,
    const VkDeviceGroupBindSparseInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->resourceDeviceIndex) == (b->resourceDeviceIndex))) { onFail("a->resourceDeviceIndex (Error: Value not equal)"); };
    if (!((a->memoryDeviceIndex) == (b->memoryDeviceIndex))) { onFail("a->memoryDeviceIndex (Error: Value not equal)"); };
}

void checkEqual_VkBindBufferMemoryDeviceGroupInfo(
    const VkBindBufferMemoryDeviceGroupInfo* a,
    const VkBindBufferMemoryDeviceGroupInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceIndexCount) == (b->deviceIndexCount))) { onFail("a->deviceIndexCount (Error: Value not equal)"); };
    if (!((a->deviceIndexCount) == (b->deviceIndexCount))) { onFail("a->pDeviceIndices (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDeviceIndices, b->pDeviceIndices, a->deviceIndexCount * sizeof(const uint32_t)) == 0))) { onFail("a->pDeviceIndices (Error: Unequal dyn array)"); };
}

void checkEqual_VkBindImageMemoryDeviceGroupInfo(
    const VkBindImageMemoryDeviceGroupInfo* a,
    const VkBindImageMemoryDeviceGroupInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceIndexCount) == (b->deviceIndexCount))) { onFail("a->deviceIndexCount (Error: Value not equal)"); };
    if (!((a->deviceIndexCount) == (b->deviceIndexCount))) { onFail("a->pDeviceIndices (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDeviceIndices, b->pDeviceIndices, a->deviceIndexCount * sizeof(const uint32_t)) == 0))) { onFail("a->pDeviceIndices (Error: Unequal dyn array)"); };
    if (!((a->splitInstanceBindRegionCount) == (b->splitInstanceBindRegionCount))) { onFail("a->splitInstanceBindRegionCount (Error: Value not equal)"); };
    if ((a->pSplitInstanceBindRegions) && (b->pSplitInstanceBindRegions))
    {
        if (!((a->splitInstanceBindRegionCount) == (b->splitInstanceBindRegionCount))) { onFail("a->pSplitInstanceBindRegions (Error: Lengths not equal)"); };
        if ((a->splitInstanceBindRegionCount) == (b->splitInstanceBindRegionCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->splitInstanceBindRegionCount; ++i)
            {
                checkEqual_VkRect2D(a->pSplitInstanceBindRegions + i, b->pSplitInstanceBindRegions + i, onFail);
            }
        }
    }
}

void checkEqual_VkPhysicalDeviceGroupProperties(
    const VkPhysicalDeviceGroupProperties* a,
    const VkPhysicalDeviceGroupProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->physicalDeviceCount) == (b->physicalDeviceCount))) { onFail("a->physicalDeviceCount (Error: Value not equal)"); };
    if (!((memcmp(a->physicalDevices, b->physicalDevices, VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice)) == 0))) { onFail("a->physicalDevices (Error: Unequal static array)"); };
    if (!((a->subsetAllocation) == (b->subsetAllocation))) { onFail("a->subsetAllocation (Error: Value not equal)"); };
}

void checkEqual_VkDeviceGroupDeviceCreateInfo(
    const VkDeviceGroupDeviceCreateInfo* a,
    const VkDeviceGroupDeviceCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->physicalDeviceCount) == (b->physicalDeviceCount))) { onFail("a->physicalDeviceCount (Error: Value not equal)"); };
    if (!((a->physicalDeviceCount) == (b->physicalDeviceCount))) { onFail("a->pPhysicalDevices (Error: Lengths not equal)"); };
    if (!((memcmp(a->pPhysicalDevices, b->pPhysicalDevices, a->physicalDeviceCount * sizeof(const VkPhysicalDevice)) == 0))) { onFail("a->pPhysicalDevices (Error: Unequal dyn array)"); };
}

void checkEqual_VkBufferMemoryRequirementsInfo2(
    const VkBufferMemoryRequirementsInfo2* a,
    const VkBufferMemoryRequirementsInfo2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
}

void checkEqual_VkImageMemoryRequirementsInfo2(
    const VkImageMemoryRequirementsInfo2* a,
    const VkImageMemoryRequirementsInfo2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
}

void checkEqual_VkImageSparseMemoryRequirementsInfo2(
    const VkImageSparseMemoryRequirementsInfo2* a,
    const VkImageSparseMemoryRequirementsInfo2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
}

void checkEqual_VkMemoryRequirements2(
    const VkMemoryRequirements2* a,
    const VkMemoryRequirements2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkMemoryRequirements(&a->memoryRequirements, &b->memoryRequirements, onFail);
}

void checkEqual_VkSparseImageMemoryRequirements2(
    const VkSparseImageMemoryRequirements2* a,
    const VkSparseImageMemoryRequirements2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkSparseImageMemoryRequirements(&a->memoryRequirements, &b->memoryRequirements, onFail);
}

void checkEqual_VkPhysicalDeviceFeatures2(
    const VkPhysicalDeviceFeatures2* a,
    const VkPhysicalDeviceFeatures2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkPhysicalDeviceFeatures(&a->features, &b->features, onFail);
}

void checkEqual_VkPhysicalDeviceProperties2(
    const VkPhysicalDeviceProperties2* a,
    const VkPhysicalDeviceProperties2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkPhysicalDeviceProperties(&a->properties, &b->properties, onFail);
}

void checkEqual_VkFormatProperties2(
    const VkFormatProperties2* a,
    const VkFormatProperties2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkFormatProperties(&a->formatProperties, &b->formatProperties, onFail);
}

void checkEqual_VkImageFormatProperties2(
    const VkImageFormatProperties2* a,
    const VkImageFormatProperties2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkImageFormatProperties(&a->imageFormatProperties, &b->imageFormatProperties, onFail);
}

void checkEqual_VkPhysicalDeviceImageFormatInfo2(
    const VkPhysicalDeviceImageFormatInfo2* a,
    const VkPhysicalDeviceImageFormatInfo2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->tiling) == (b->tiling))) { onFail("a->tiling (Error: Value not equal)"); };
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkQueueFamilyProperties2(
    const VkQueueFamilyProperties2* a,
    const VkQueueFamilyProperties2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkQueueFamilyProperties(&a->queueFamilyProperties, &b->queueFamilyProperties, onFail);
}

void checkEqual_VkPhysicalDeviceMemoryProperties2(
    const VkPhysicalDeviceMemoryProperties2* a,
    const VkPhysicalDeviceMemoryProperties2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkPhysicalDeviceMemoryProperties(&a->memoryProperties, &b->memoryProperties, onFail);
}

void checkEqual_VkSparseImageFormatProperties2(
    const VkSparseImageFormatProperties2* a,
    const VkSparseImageFormatProperties2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkSparseImageFormatProperties(&a->properties, &b->properties, onFail);
}

void checkEqual_VkPhysicalDeviceSparseImageFormatInfo2(
    const VkPhysicalDeviceSparseImageFormatInfo2* a,
    const VkPhysicalDeviceSparseImageFormatInfo2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->samples) == (b->samples))) { onFail("a->samples (Error: Value not equal)"); };
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
    if (!((a->tiling) == (b->tiling))) { onFail("a->tiling (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDevicePointClippingProperties(
    const VkPhysicalDevicePointClippingProperties* a,
    const VkPhysicalDevicePointClippingProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->pointClippingBehavior) == (b->pointClippingBehavior))) { onFail("a->pointClippingBehavior (Error: Value not equal)"); };
}

void checkEqual_VkInputAttachmentAspectReference(
    const VkInputAttachmentAspectReference* a,
    const VkInputAttachmentAspectReference* b,
    OnFailCompareFunc onFail)
{
    if (!((a->subpass) == (b->subpass))) { onFail("a->subpass (Error: Value not equal)"); };
    if (!((a->inputAttachmentIndex) == (b->inputAttachmentIndex))) { onFail("a->inputAttachmentIndex (Error: Value not equal)"); };
    if (!((a->aspectMask) == (b->aspectMask))) { onFail("a->aspectMask (Error: Value not equal)"); };
}

void checkEqual_VkRenderPassInputAttachmentAspectCreateInfo(
    const VkRenderPassInputAttachmentAspectCreateInfo* a,
    const VkRenderPassInputAttachmentAspectCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->aspectReferenceCount) == (b->aspectReferenceCount))) { onFail("a->aspectReferenceCount (Error: Value not equal)"); };
    if ((a->pAspectReferences) && (b->pAspectReferences))
    {
        if (!((a->aspectReferenceCount) == (b->aspectReferenceCount))) { onFail("a->pAspectReferences (Error: Lengths not equal)"); };
        if ((a->aspectReferenceCount) == (b->aspectReferenceCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->aspectReferenceCount; ++i)
            {
                checkEqual_VkInputAttachmentAspectReference(a->pAspectReferences + i, b->pAspectReferences + i, onFail);
            }
        }
    }
}

void checkEqual_VkImageViewUsageCreateInfo(
    const VkImageViewUsageCreateInfo* a,
    const VkImageViewUsageCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
}

void checkEqual_VkPipelineTessellationDomainOriginStateCreateInfo(
    const VkPipelineTessellationDomainOriginStateCreateInfo* a,
    const VkPipelineTessellationDomainOriginStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->domainOrigin) == (b->domainOrigin))) { onFail("a->domainOrigin (Error: Value not equal)"); };
}

void checkEqual_VkRenderPassMultiviewCreateInfo(
    const VkRenderPassMultiviewCreateInfo* a,
    const VkRenderPassMultiviewCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->subpassCount) == (b->subpassCount))) { onFail("a->subpassCount (Error: Value not equal)"); };
    if (!((a->subpassCount) == (b->subpassCount))) { onFail("a->pViewMasks (Error: Lengths not equal)"); };
    if (!((memcmp(a->pViewMasks, b->pViewMasks, a->subpassCount * sizeof(const uint32_t)) == 0))) { onFail("a->pViewMasks (Error: Unequal dyn array)"); };
    if (!((a->dependencyCount) == (b->dependencyCount))) { onFail("a->dependencyCount (Error: Value not equal)"); };
    if (!((a->dependencyCount) == (b->dependencyCount))) { onFail("a->pViewOffsets (Error: Lengths not equal)"); };
    if (!((memcmp(a->pViewOffsets, b->pViewOffsets, a->dependencyCount * sizeof(const int32_t)) == 0))) { onFail("a->pViewOffsets (Error: Unequal dyn array)"); };
    if (!((a->correlationMaskCount) == (b->correlationMaskCount))) { onFail("a->correlationMaskCount (Error: Value not equal)"); };
    if (!((a->correlationMaskCount) == (b->correlationMaskCount))) { onFail("a->pCorrelationMasks (Error: Lengths not equal)"); };
    if (!((memcmp(a->pCorrelationMasks, b->pCorrelationMasks, a->correlationMaskCount * sizeof(const uint32_t)) == 0))) { onFail("a->pCorrelationMasks (Error: Unequal dyn array)"); };
}

void checkEqual_VkPhysicalDeviceMultiviewFeatures(
    const VkPhysicalDeviceMultiviewFeatures* a,
    const VkPhysicalDeviceMultiviewFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->multiview) == (b->multiview))) { onFail("a->multiview (Error: Value not equal)"); };
    if (!((a->multiviewGeometryShader) == (b->multiviewGeometryShader))) { onFail("a->multiviewGeometryShader (Error: Value not equal)"); };
    if (!((a->multiviewTessellationShader) == (b->multiviewTessellationShader))) { onFail("a->multiviewTessellationShader (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceMultiviewProperties(
    const VkPhysicalDeviceMultiviewProperties* a,
    const VkPhysicalDeviceMultiviewProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxMultiviewViewCount) == (b->maxMultiviewViewCount))) { onFail("a->maxMultiviewViewCount (Error: Value not equal)"); };
    if (!((a->maxMultiviewInstanceIndex) == (b->maxMultiviewInstanceIndex))) { onFail("a->maxMultiviewInstanceIndex (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceVariablePointerFeatures(
    const VkPhysicalDeviceVariablePointerFeatures* a,
    const VkPhysicalDeviceVariablePointerFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->variablePointersStorageBuffer) == (b->variablePointersStorageBuffer))) { onFail("a->variablePointersStorageBuffer (Error: Value not equal)"); };
    if (!((a->variablePointers) == (b->variablePointers))) { onFail("a->variablePointers (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceProtectedMemoryFeatures(
    const VkPhysicalDeviceProtectedMemoryFeatures* a,
    const VkPhysicalDeviceProtectedMemoryFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->protectedMemory) == (b->protectedMemory))) { onFail("a->protectedMemory (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceProtectedMemoryProperties(
    const VkPhysicalDeviceProtectedMemoryProperties* a,
    const VkPhysicalDeviceProtectedMemoryProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->protectedNoFault) == (b->protectedNoFault))) { onFail("a->protectedNoFault (Error: Value not equal)"); };
}

void checkEqual_VkDeviceQueueInfo2(
    const VkDeviceQueueInfo2* a,
    const VkDeviceQueueInfo2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->queueFamilyIndex) == (b->queueFamilyIndex))) { onFail("a->queueFamilyIndex (Error: Value not equal)"); };
    if (!((a->queueIndex) == (b->queueIndex))) { onFail("a->queueIndex (Error: Value not equal)"); };
}

void checkEqual_VkProtectedSubmitInfo(
    const VkProtectedSubmitInfo* a,
    const VkProtectedSubmitInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->protectedSubmit) == (b->protectedSubmit))) { onFail("a->protectedSubmit (Error: Value not equal)"); };
}

void checkEqual_VkSamplerYcbcrConversionCreateInfo(
    const VkSamplerYcbcrConversionCreateInfo* a,
    const VkSamplerYcbcrConversionCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->ycbcrModel) == (b->ycbcrModel))) { onFail("a->ycbcrModel (Error: Value not equal)"); };
    if (!((a->ycbcrRange) == (b->ycbcrRange))) { onFail("a->ycbcrRange (Error: Value not equal)"); };
    checkEqual_VkComponentMapping(&a->components, &b->components, onFail);
    if (!((a->xChromaOffset) == (b->xChromaOffset))) { onFail("a->xChromaOffset (Error: Value not equal)"); };
    if (!((a->yChromaOffset) == (b->yChromaOffset))) { onFail("a->yChromaOffset (Error: Value not equal)"); };
    if (!((a->chromaFilter) == (b->chromaFilter))) { onFail("a->chromaFilter (Error: Value not equal)"); };
    if (!((a->forceExplicitReconstruction) == (b->forceExplicitReconstruction))) { onFail("a->forceExplicitReconstruction (Error: Value not equal)"); };
}

void checkEqual_VkSamplerYcbcrConversionInfo(
    const VkSamplerYcbcrConversionInfo* a,
    const VkSamplerYcbcrConversionInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->conversion) == (b->conversion))) { onFail("a->conversion (Error: Value not equal)"); };
}

void checkEqual_VkBindImagePlaneMemoryInfo(
    const VkBindImagePlaneMemoryInfo* a,
    const VkBindImagePlaneMemoryInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->planeAspect) == (b->planeAspect))) { onFail("a->planeAspect (Error: Value not equal)"); };
}

void checkEqual_VkImagePlaneMemoryRequirementsInfo(
    const VkImagePlaneMemoryRequirementsInfo* a,
    const VkImagePlaneMemoryRequirementsInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->planeAspect) == (b->planeAspect))) { onFail("a->planeAspect (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures* a,
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->samplerYcbcrConversion) == (b->samplerYcbcrConversion))) { onFail("a->samplerYcbcrConversion (Error: Value not equal)"); };
}

void checkEqual_VkSamplerYcbcrConversionImageFormatProperties(
    const VkSamplerYcbcrConversionImageFormatProperties* a,
    const VkSamplerYcbcrConversionImageFormatProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->combinedImageSamplerDescriptorCount) == (b->combinedImageSamplerDescriptorCount))) { onFail("a->combinedImageSamplerDescriptorCount (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorUpdateTemplateEntry(
    const VkDescriptorUpdateTemplateEntry* a,
    const VkDescriptorUpdateTemplateEntry* b,
    OnFailCompareFunc onFail)
{
    if (!((a->dstBinding) == (b->dstBinding))) { onFail("a->dstBinding (Error: Value not equal)"); };
    if (!((a->dstArrayElement) == (b->dstArrayElement))) { onFail("a->dstArrayElement (Error: Value not equal)"); };
    if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->descriptorCount (Error: Value not equal)"); };
    if (!((a->descriptorType) == (b->descriptorType))) { onFail("a->descriptorType (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->stride) == (b->stride))) { onFail("a->stride (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorUpdateTemplateCreateInfo(
    const VkDescriptorUpdateTemplateCreateInfo* a,
    const VkDescriptorUpdateTemplateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->descriptorUpdateEntryCount) == (b->descriptorUpdateEntryCount))) { onFail("a->descriptorUpdateEntryCount (Error: Value not equal)"); };
    if ((a->pDescriptorUpdateEntries) && (b->pDescriptorUpdateEntries))
    {
        if (!((a->descriptorUpdateEntryCount) == (b->descriptorUpdateEntryCount))) { onFail("a->pDescriptorUpdateEntries (Error: Lengths not equal)"); };
        if ((a->descriptorUpdateEntryCount) == (b->descriptorUpdateEntryCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->descriptorUpdateEntryCount; ++i)
            {
                checkEqual_VkDescriptorUpdateTemplateEntry(a->pDescriptorUpdateEntries + i, b->pDescriptorUpdateEntries + i, onFail);
            }
        }
    }
    if (!((a->templateType) == (b->templateType))) { onFail("a->templateType (Error: Value not equal)"); };
    if (!((a->descriptorSetLayout) == (b->descriptorSetLayout))) { onFail("a->descriptorSetLayout (Error: Value not equal)"); };
    if (!((a->pipelineBindPoint) == (b->pipelineBindPoint))) { onFail("a->pipelineBindPoint (Error: Value not equal)"); };
    if (!((a->pipelineLayout) == (b->pipelineLayout))) { onFail("a->pipelineLayout (Error: Value not equal)"); };
    if (!((a->set) == (b->set))) { onFail("a->set (Error: Value not equal)"); };
}

void checkEqual_VkExternalMemoryProperties(
    const VkExternalMemoryProperties* a,
    const VkExternalMemoryProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->externalMemoryFeatures) == (b->externalMemoryFeatures))) { onFail("a->externalMemoryFeatures (Error: Value not equal)"); };
    if (!((a->exportFromImportedHandleTypes) == (b->exportFromImportedHandleTypes))) { onFail("a->exportFromImportedHandleTypes (Error: Value not equal)"); };
    if (!((a->compatibleHandleTypes) == (b->compatibleHandleTypes))) { onFail("a->compatibleHandleTypes (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceExternalImageFormatInfo(
    const VkPhysicalDeviceExternalImageFormatInfo* a,
    const VkPhysicalDeviceExternalImageFormatInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

void checkEqual_VkExternalImageFormatProperties(
    const VkExternalImageFormatProperties* a,
    const VkExternalImageFormatProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkExternalMemoryProperties(&a->externalMemoryProperties, &b->externalMemoryProperties, onFail);
}

void checkEqual_VkPhysicalDeviceExternalBufferInfo(
    const VkPhysicalDeviceExternalBufferInfo* a,
    const VkPhysicalDeviceExternalBufferInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

void checkEqual_VkExternalBufferProperties(
    const VkExternalBufferProperties* a,
    const VkExternalBufferProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkExternalMemoryProperties(&a->externalMemoryProperties, &b->externalMemoryProperties, onFail);
}

void checkEqual_VkPhysicalDeviceIDProperties(
    const VkPhysicalDeviceIDProperties* a,
    const VkPhysicalDeviceIDProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->deviceUUID, b->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t)) == 0))) { onFail("a->deviceUUID (Error: Unequal static array)"); };
    if (!((memcmp(a->driverUUID, b->driverUUID, VK_UUID_SIZE * sizeof(uint8_t)) == 0))) { onFail("a->driverUUID (Error: Unequal static array)"); };
    if (!((memcmp(a->deviceLUID, b->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t)) == 0))) { onFail("a->deviceLUID (Error: Unequal static array)"); };
    if (!((a->deviceNodeMask) == (b->deviceNodeMask))) { onFail("a->deviceNodeMask (Error: Value not equal)"); };
    if (!((a->deviceLUIDValid) == (b->deviceLUIDValid))) { onFail("a->deviceLUIDValid (Error: Value not equal)"); };
}

void checkEqual_VkExternalMemoryImageCreateInfo(
    const VkExternalMemoryImageCreateInfo* a,
    const VkExternalMemoryImageCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleTypes) == (b->handleTypes))) { onFail("a->handleTypes (Error: Value not equal)"); };
}

void checkEqual_VkExternalMemoryBufferCreateInfo(
    const VkExternalMemoryBufferCreateInfo* a,
    const VkExternalMemoryBufferCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleTypes) == (b->handleTypes))) { onFail("a->handleTypes (Error: Value not equal)"); };
}

void checkEqual_VkExportMemoryAllocateInfo(
    const VkExportMemoryAllocateInfo* a,
    const VkExportMemoryAllocateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleTypes) == (b->handleTypes))) { onFail("a->handleTypes (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceExternalFenceInfo(
    const VkPhysicalDeviceExternalFenceInfo* a,
    const VkPhysicalDeviceExternalFenceInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

void checkEqual_VkExternalFenceProperties(
    const VkExternalFenceProperties* a,
    const VkExternalFenceProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->exportFromImportedHandleTypes) == (b->exportFromImportedHandleTypes))) { onFail("a->exportFromImportedHandleTypes (Error: Value not equal)"); };
    if (!((a->compatibleHandleTypes) == (b->compatibleHandleTypes))) { onFail("a->compatibleHandleTypes (Error: Value not equal)"); };
    if (!((a->externalFenceFeatures) == (b->externalFenceFeatures))) { onFail("a->externalFenceFeatures (Error: Value not equal)"); };
}

void checkEqual_VkExportFenceCreateInfo(
    const VkExportFenceCreateInfo* a,
    const VkExportFenceCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleTypes) == (b->handleTypes))) { onFail("a->handleTypes (Error: Value not equal)"); };
}

void checkEqual_VkExportSemaphoreCreateInfo(
    const VkExportSemaphoreCreateInfo* a,
    const VkExportSemaphoreCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleTypes) == (b->handleTypes))) { onFail("a->handleTypes (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceExternalSemaphoreInfo(
    const VkPhysicalDeviceExternalSemaphoreInfo* a,
    const VkPhysicalDeviceExternalSemaphoreInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

void checkEqual_VkExternalSemaphoreProperties(
    const VkExternalSemaphoreProperties* a,
    const VkExternalSemaphoreProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->exportFromImportedHandleTypes) == (b->exportFromImportedHandleTypes))) { onFail("a->exportFromImportedHandleTypes (Error: Value not equal)"); };
    if (!((a->compatibleHandleTypes) == (b->compatibleHandleTypes))) { onFail("a->compatibleHandleTypes (Error: Value not equal)"); };
    if (!((a->externalSemaphoreFeatures) == (b->externalSemaphoreFeatures))) { onFail("a->externalSemaphoreFeatures (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceMaintenance3Properties(
    const VkPhysicalDeviceMaintenance3Properties* a,
    const VkPhysicalDeviceMaintenance3Properties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxPerSetDescriptors) == (b->maxPerSetDescriptors))) { onFail("a->maxPerSetDescriptors (Error: Value not equal)"); };
    if (!((a->maxMemoryAllocationSize) == (b->maxMemoryAllocationSize))) { onFail("a->maxMemoryAllocationSize (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorSetLayoutSupport(
    const VkDescriptorSetLayoutSupport* a,
    const VkDescriptorSetLayoutSupport* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->supported) == (b->supported))) { onFail("a->supported (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceShaderDrawParameterFeatures(
    const VkPhysicalDeviceShaderDrawParameterFeatures* a,
    const VkPhysicalDeviceShaderDrawParameterFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderDrawParameters) == (b->shaderDrawParameters))) { onFail("a->shaderDrawParameters (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_surface
void checkEqual_VkSurfaceCapabilitiesKHR(
    const VkSurfaceCapabilitiesKHR* a,
    const VkSurfaceCapabilitiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->minImageCount) == (b->minImageCount))) { onFail("a->minImageCount (Error: Value not equal)"); };
    if (!((a->maxImageCount) == (b->maxImageCount))) { onFail("a->maxImageCount (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->currentExtent, &b->currentExtent, onFail);
    checkEqual_VkExtent2D(&a->minImageExtent, &b->minImageExtent, onFail);
    checkEqual_VkExtent2D(&a->maxImageExtent, &b->maxImageExtent, onFail);
    if (!((a->maxImageArrayLayers) == (b->maxImageArrayLayers))) { onFail("a->maxImageArrayLayers (Error: Value not equal)"); };
    if (!((a->supportedTransforms) == (b->supportedTransforms))) { onFail("a->supportedTransforms (Error: Value not equal)"); };
    if (!((a->currentTransform) == (b->currentTransform))) { onFail("a->currentTransform (Error: Value not equal)"); };
    if (!((a->supportedCompositeAlpha) == (b->supportedCompositeAlpha))) { onFail("a->supportedCompositeAlpha (Error: Value not equal)"); };
    if (!((a->supportedUsageFlags) == (b->supportedUsageFlags))) { onFail("a->supportedUsageFlags (Error: Value not equal)"); };
}

void checkEqual_VkSurfaceFormatKHR(
    const VkSurfaceFormatKHR* a,
    const VkSurfaceFormatKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->colorSpace) == (b->colorSpace))) { onFail("a->colorSpace (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_swapchain
void checkEqual_VkSwapchainCreateInfoKHR(
    const VkSwapchainCreateInfoKHR* a,
    const VkSwapchainCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->surface) == (b->surface))) { onFail("a->surface (Error: Value not equal)"); };
    if (!((a->minImageCount) == (b->minImageCount))) { onFail("a->minImageCount (Error: Value not equal)"); };
    if (!((a->imageFormat) == (b->imageFormat))) { onFail("a->imageFormat (Error: Value not equal)"); };
    if (!((a->imageColorSpace) == (b->imageColorSpace))) { onFail("a->imageColorSpace (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->imageExtent, &b->imageExtent, onFail);
    if (!((a->imageArrayLayers) == (b->imageArrayLayers))) { onFail("a->imageArrayLayers (Error: Value not equal)"); };
    if (!((a->imageUsage) == (b->imageUsage))) { onFail("a->imageUsage (Error: Value not equal)"); };
    if (!((a->imageSharingMode) == (b->imageSharingMode))) { onFail("a->imageSharingMode (Error: Value not equal)"); };
    if (!((a->queueFamilyIndexCount) == (b->queueFamilyIndexCount))) { onFail("a->queueFamilyIndexCount (Error: Value not equal)"); };
    if (!((!(a->pQueueFamilyIndices) && !(b->pQueueFamilyIndices)) || ((a->pQueueFamilyIndices) && (b->pQueueFamilyIndices)))) { onFail("a->pQueueFamilyIndices (Error: Mismatch in optional field)"); };
    if (a->pQueueFamilyIndices && b->pQueueFamilyIndices)
    {
        if (!((a->queueFamilyIndexCount) == (b->queueFamilyIndexCount))) { onFail("a->pQueueFamilyIndices (Error: Lengths not equal)"); };
        if (!((memcmp(a->pQueueFamilyIndices, b->pQueueFamilyIndices, a->queueFamilyIndexCount * sizeof(const uint32_t)) == 0))) { onFail("a->pQueueFamilyIndices (Error: Unequal dyn array)"); };
    }
    if (!((a->preTransform) == (b->preTransform))) { onFail("a->preTransform (Error: Value not equal)"); };
    if (!((a->compositeAlpha) == (b->compositeAlpha))) { onFail("a->compositeAlpha (Error: Value not equal)"); };
    if (!((a->presentMode) == (b->presentMode))) { onFail("a->presentMode (Error: Value not equal)"); };
    if (!((a->clipped) == (b->clipped))) { onFail("a->clipped (Error: Value not equal)"); };
    if (!((a->oldSwapchain) == (b->oldSwapchain))) { onFail("a->oldSwapchain (Error: Value not equal)"); };
}

void checkEqual_VkPresentInfoKHR(
    const VkPresentInfoKHR* a,
    const VkPresentInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->waitSemaphoreCount (Error: Value not equal)"); };
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->pWaitSemaphores (Error: Lengths not equal)"); };
    if (!((memcmp(a->pWaitSemaphores, b->pWaitSemaphores, a->waitSemaphoreCount * sizeof(const VkSemaphore)) == 0))) { onFail("a->pWaitSemaphores (Error: Unequal dyn array)"); };
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->swapchainCount (Error: Value not equal)"); };
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->pSwapchains (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSwapchains, b->pSwapchains, a->swapchainCount * sizeof(const VkSwapchainKHR)) == 0))) { onFail("a->pSwapchains (Error: Unequal dyn array)"); };
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->pImageIndices (Error: Lengths not equal)"); };
    if (!((memcmp(a->pImageIndices, b->pImageIndices, a->swapchainCount * sizeof(const uint32_t)) == 0))) { onFail("a->pImageIndices (Error: Unequal dyn array)"); };
    if (!((!(a->pResults) && !(b->pResults)) || ((a->pResults) && (b->pResults)))) { onFail("a->pResults (Error: Mismatch in optional field)"); };
    if (a->pResults && b->pResults)
    {
        if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->pResults (Error: Lengths not equal)"); };
        if (!((memcmp(a->pResults, b->pResults, a->swapchainCount * sizeof(VkResult)) == 0))) { onFail("a->pResults (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkImageSwapchainCreateInfoKHR(
    const VkImageSwapchainCreateInfoKHR* a,
    const VkImageSwapchainCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->swapchain) == (b->swapchain))) { onFail("a->swapchain (Error: Value not equal)"); };
}

void checkEqual_VkBindImageMemorySwapchainInfoKHR(
    const VkBindImageMemorySwapchainInfoKHR* a,
    const VkBindImageMemorySwapchainInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->swapchain) == (b->swapchain))) { onFail("a->swapchain (Error: Value not equal)"); };
    if (!((a->imageIndex) == (b->imageIndex))) { onFail("a->imageIndex (Error: Value not equal)"); };
}

void checkEqual_VkAcquireNextImageInfoKHR(
    const VkAcquireNextImageInfoKHR* a,
    const VkAcquireNextImageInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->swapchain) == (b->swapchain))) { onFail("a->swapchain (Error: Value not equal)"); };
    if (!((a->timeout) == (b->timeout))) { onFail("a->timeout (Error: Value not equal)"); };
    if (!((a->semaphore) == (b->semaphore))) { onFail("a->semaphore (Error: Value not equal)"); };
    if (!((a->fence) == (b->fence))) { onFail("a->fence (Error: Value not equal)"); };
    if (!((a->deviceMask) == (b->deviceMask))) { onFail("a->deviceMask (Error: Value not equal)"); };
}

void checkEqual_VkDeviceGroupPresentCapabilitiesKHR(
    const VkDeviceGroupPresentCapabilitiesKHR* a,
    const VkDeviceGroupPresentCapabilitiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->presentMask, b->presentMask, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t)) == 0))) { onFail("a->presentMask (Error: Unequal static array)"); };
    if (!((a->modes) == (b->modes))) { onFail("a->modes (Error: Value not equal)"); };
}

void checkEqual_VkDeviceGroupPresentInfoKHR(
    const VkDeviceGroupPresentInfoKHR* a,
    const VkDeviceGroupPresentInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->swapchainCount (Error: Value not equal)"); };
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->pDeviceMasks (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDeviceMasks, b->pDeviceMasks, a->swapchainCount * sizeof(const uint32_t)) == 0))) { onFail("a->pDeviceMasks (Error: Unequal dyn array)"); };
    if (!((a->mode) == (b->mode))) { onFail("a->mode (Error: Value not equal)"); };
}

void checkEqual_VkDeviceGroupSwapchainCreateInfoKHR(
    const VkDeviceGroupSwapchainCreateInfoKHR* a,
    const VkDeviceGroupSwapchainCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->modes) == (b->modes))) { onFail("a->modes (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_display
void checkEqual_VkDisplayPropertiesKHR(
    const VkDisplayPropertiesKHR* a,
    const VkDisplayPropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->display) == (b->display))) { onFail("a->display (Error: Value not equal)"); };
    if (!((!(a->displayName) && !(b->displayName)) || ((a->displayName) && (b->displayName)))) { onFail("a->displayName (Error: Mismatch in string pointer nullness)"); };
    if ((a->displayName) && (b->displayName))
    {
        if (!((strcmp(a->displayName, b->displayName) == 0))) { onFail("a->displayName (Error: Unequal strings)"); };
    }
    checkEqual_VkExtent2D(&a->physicalDimensions, &b->physicalDimensions, onFail);
    checkEqual_VkExtent2D(&a->physicalResolution, &b->physicalResolution, onFail);
    if (!((a->supportedTransforms) == (b->supportedTransforms))) { onFail("a->supportedTransforms (Error: Value not equal)"); };
    if (!((a->planeReorderPossible) == (b->planeReorderPossible))) { onFail("a->planeReorderPossible (Error: Value not equal)"); };
    if (!((a->persistentContent) == (b->persistentContent))) { onFail("a->persistentContent (Error: Value not equal)"); };
}

void checkEqual_VkDisplayModeParametersKHR(
    const VkDisplayModeParametersKHR* a,
    const VkDisplayModeParametersKHR* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkExtent2D(&a->visibleRegion, &b->visibleRegion, onFail);
    if (!((a->refreshRate) == (b->refreshRate))) { onFail("a->refreshRate (Error: Value not equal)"); };
}

void checkEqual_VkDisplayModePropertiesKHR(
    const VkDisplayModePropertiesKHR* a,
    const VkDisplayModePropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->displayMode) == (b->displayMode))) { onFail("a->displayMode (Error: Value not equal)"); };
    checkEqual_VkDisplayModeParametersKHR(&a->parameters, &b->parameters, onFail);
}

void checkEqual_VkDisplayModeCreateInfoKHR(
    const VkDisplayModeCreateInfoKHR* a,
    const VkDisplayModeCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    checkEqual_VkDisplayModeParametersKHR(&a->parameters, &b->parameters, onFail);
}

void checkEqual_VkDisplayPlaneCapabilitiesKHR(
    const VkDisplayPlaneCapabilitiesKHR* a,
    const VkDisplayPlaneCapabilitiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->supportedAlpha) == (b->supportedAlpha))) { onFail("a->supportedAlpha (Error: Value not equal)"); };
    checkEqual_VkOffset2D(&a->minSrcPosition, &b->minSrcPosition, onFail);
    checkEqual_VkOffset2D(&a->maxSrcPosition, &b->maxSrcPosition, onFail);
    checkEqual_VkExtent2D(&a->minSrcExtent, &b->minSrcExtent, onFail);
    checkEqual_VkExtent2D(&a->maxSrcExtent, &b->maxSrcExtent, onFail);
    checkEqual_VkOffset2D(&a->minDstPosition, &b->minDstPosition, onFail);
    checkEqual_VkOffset2D(&a->maxDstPosition, &b->maxDstPosition, onFail);
    checkEqual_VkExtent2D(&a->minDstExtent, &b->minDstExtent, onFail);
    checkEqual_VkExtent2D(&a->maxDstExtent, &b->maxDstExtent, onFail);
}

void checkEqual_VkDisplayPlanePropertiesKHR(
    const VkDisplayPlanePropertiesKHR* a,
    const VkDisplayPlanePropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->currentDisplay) == (b->currentDisplay))) { onFail("a->currentDisplay (Error: Value not equal)"); };
    if (!((a->currentStackIndex) == (b->currentStackIndex))) { onFail("a->currentStackIndex (Error: Value not equal)"); };
}

void checkEqual_VkDisplaySurfaceCreateInfoKHR(
    const VkDisplaySurfaceCreateInfoKHR* a,
    const VkDisplaySurfaceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->displayMode) == (b->displayMode))) { onFail("a->displayMode (Error: Value not equal)"); };
    if (!((a->planeIndex) == (b->planeIndex))) { onFail("a->planeIndex (Error: Value not equal)"); };
    if (!((a->planeStackIndex) == (b->planeStackIndex))) { onFail("a->planeStackIndex (Error: Value not equal)"); };
    if (!((a->transform) == (b->transform))) { onFail("a->transform (Error: Value not equal)"); };
    if (!((a->globalAlpha) == (b->globalAlpha))) { onFail("a->globalAlpha (Error: Value not equal)"); };
    if (!((a->alphaMode) == (b->alphaMode))) { onFail("a->alphaMode (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->imageExtent, &b->imageExtent, onFail);
}

#endif
#ifdef VK_KHR_display_swapchain
void checkEqual_VkDisplayPresentInfoKHR(
    const VkDisplayPresentInfoKHR* a,
    const VkDisplayPresentInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkRect2D(&a->srcRect, &b->srcRect, onFail);
    checkEqual_VkRect2D(&a->dstRect, &b->dstRect, onFail);
    if (!((a->persistent) == (b->persistent))) { onFail("a->persistent (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_xlib_surface
void checkEqual_VkXlibSurfaceCreateInfoKHR(
    const VkXlibSurfaceCreateInfoKHR* a,
    const VkXlibSurfaceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->dpy) && !(b->dpy)) || ((a->dpy) && (b->dpy)))) { onFail("a->dpy (Error: Mismatch in optional field)"); };
    if (a->dpy && b->dpy)
    {
        if (!((memcmp(a->dpy, b->dpy, sizeof(Display)) == 0))) { onFail("a->dpy (Error: Unequal dyn array)"); };
    }
    if (!((a->window) == (b->window))) { onFail("a->window (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_xcb_surface
void checkEqual_VkXcbSurfaceCreateInfoKHR(
    const VkXcbSurfaceCreateInfoKHR* a,
    const VkXcbSurfaceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->connection) && !(b->connection)) || ((a->connection) && (b->connection)))) { onFail("a->connection (Error: Mismatch in optional field)"); };
    if (a->connection && b->connection)
    {
        if (!((memcmp(a->connection, b->connection, sizeof(xcb_connection_t)) == 0))) { onFail("a->connection (Error: Unequal dyn array)"); };
    }
    if (!((a->window) == (b->window))) { onFail("a->window (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_wayland_surface
void checkEqual_VkWaylandSurfaceCreateInfoKHR(
    const VkWaylandSurfaceCreateInfoKHR* a,
    const VkWaylandSurfaceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->display) && !(b->display)) || ((a->display) && (b->display)))) { onFail("a->display (Error: Mismatch in optional field)"); };
    if (a->display && b->display)
    {
        if (!((memcmp(a->display, b->display, sizeof(wl_display)) == 0))) { onFail("a->display (Error: Unequal dyn array)"); };
    }
    if (!((!(a->surface) && !(b->surface)) || ((a->surface) && (b->surface)))) { onFail("a->surface (Error: Mismatch in optional field)"); };
    if (a->surface && b->surface)
    {
        if (!((memcmp(a->surface, b->surface, sizeof(wl_surface)) == 0))) { onFail("a->surface (Error: Unequal dyn array)"); };
    }
}

#endif
#ifdef VK_KHR_mir_surface
void checkEqual_VkMirSurfaceCreateInfoKHR(
    const VkMirSurfaceCreateInfoKHR* a,
    const VkMirSurfaceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->connection) && !(b->connection)) || ((a->connection) && (b->connection)))) { onFail("a->connection (Error: Mismatch in optional field)"); };
    if (a->connection && b->connection)
    {
        if (!((memcmp(a->connection, b->connection, sizeof(MirConnection)) == 0))) { onFail("a->connection (Error: Unequal dyn array)"); };
    }
    if (!((!(a->mirSurface) && !(b->mirSurface)) || ((a->mirSurface) && (b->mirSurface)))) { onFail("a->mirSurface (Error: Mismatch in optional field)"); };
    if (a->mirSurface && b->mirSurface)
    {
        if (!((memcmp(a->mirSurface, b->mirSurface, sizeof(MirSurface)) == 0))) { onFail("a->mirSurface (Error: Unequal dyn array)"); };
    }
}

#endif
#ifdef VK_KHR_android_surface
void checkEqual_VkAndroidSurfaceCreateInfoKHR(
    const VkAndroidSurfaceCreateInfoKHR* a,
    const VkAndroidSurfaceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->window) && !(b->window)) || ((a->window) && (b->window)))) { onFail("a->window (Error: Mismatch in optional field)"); };
    if (a->window && b->window)
    {
        if (!((memcmp(a->window, b->window, sizeof(ANativeWindow)) == 0))) { onFail("a->window (Error: Unequal dyn array)"); };
    }
}

#endif
#ifdef VK_KHR_win32_surface
void checkEqual_VkWin32SurfaceCreateInfoKHR(
    const VkWin32SurfaceCreateInfoKHR* a,
    const VkWin32SurfaceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->hinstance) == (b->hinstance))) { onFail("a->hinstance (Error: Value not equal)"); };
    if (!((a->hwnd) == (b->hwnd))) { onFail("a->hwnd (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_device_group
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_device_group_creation
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void checkEqual_VkImportMemoryWin32HandleInfoKHR(
    const VkImportMemoryWin32HandleInfoKHR* a,
    const VkImportMemoryWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->handle) == (b->handle))) { onFail("a->handle (Error: Value not equal)"); };
    if (!((a->name) == (b->name))) { onFail("a->name (Error: Value not equal)"); };
}

void checkEqual_VkExportMemoryWin32HandleInfoKHR(
    const VkExportMemoryWin32HandleInfoKHR* a,
    const VkExportMemoryWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pAttributes) && !(b->pAttributes)) || ((a->pAttributes) && (b->pAttributes)))) { onFail("a->pAttributes (Error: Mismatch in optional field)"); };
    if (a->pAttributes && b->pAttributes)
    {
        if (!((memcmp(a->pAttributes, b->pAttributes, sizeof(const SECURITY_ATTRIBUTES)) == 0))) { onFail("a->pAttributes (Error: Unequal dyn array)"); };
    }
    if (!((a->dwAccess) == (b->dwAccess))) { onFail("a->dwAccess (Error: Value not equal)"); };
    if (!((a->name) == (b->name))) { onFail("a->name (Error: Value not equal)"); };
}

void checkEqual_VkMemoryWin32HandlePropertiesKHR(
    const VkMemoryWin32HandlePropertiesKHR* a,
    const VkMemoryWin32HandlePropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memoryTypeBits) == (b->memoryTypeBits))) { onFail("a->memoryTypeBits (Error: Value not equal)"); };
}

void checkEqual_VkMemoryGetWin32HandleInfoKHR(
    const VkMemoryGetWin32HandleInfoKHR* a,
    const VkMemoryGetWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_external_memory_fd
void checkEqual_VkImportMemoryFdInfoKHR(
    const VkImportMemoryFdInfoKHR* a,
    const VkImportMemoryFdInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->fd) == (b->fd))) { onFail("a->fd (Error: Value not equal)"); };
}

void checkEqual_VkMemoryFdPropertiesKHR(
    const VkMemoryFdPropertiesKHR* a,
    const VkMemoryFdPropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memoryTypeBits) == (b->memoryTypeBits))) { onFail("a->memoryTypeBits (Error: Value not equal)"); };
}

void checkEqual_VkMemoryGetFdInfoKHR(
    const VkMemoryGetFdInfoKHR* a,
    const VkMemoryGetFdInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void checkEqual_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    const VkWin32KeyedMutexAcquireReleaseInfoKHR* a,
    const VkWin32KeyedMutexAcquireReleaseInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->acquireCount (Error: Value not equal)"); };
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->pAcquireSyncs (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAcquireSyncs, b->pAcquireSyncs, a->acquireCount * sizeof(const VkDeviceMemory)) == 0))) { onFail("a->pAcquireSyncs (Error: Unequal dyn array)"); };
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->pAcquireKeys (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAcquireKeys, b->pAcquireKeys, a->acquireCount * sizeof(const uint64_t)) == 0))) { onFail("a->pAcquireKeys (Error: Unequal dyn array)"); };
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->pAcquireTimeouts (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAcquireTimeouts, b->pAcquireTimeouts, a->acquireCount * sizeof(const uint32_t)) == 0))) { onFail("a->pAcquireTimeouts (Error: Unequal dyn array)"); };
    if (!((a->releaseCount) == (b->releaseCount))) { onFail("a->releaseCount (Error: Value not equal)"); };
    if (!((a->releaseCount) == (b->releaseCount))) { onFail("a->pReleaseSyncs (Error: Lengths not equal)"); };
    if (!((memcmp(a->pReleaseSyncs, b->pReleaseSyncs, a->releaseCount * sizeof(const VkDeviceMemory)) == 0))) { onFail("a->pReleaseSyncs (Error: Unequal dyn array)"); };
    if (!((a->releaseCount) == (b->releaseCount))) { onFail("a->pReleaseKeys (Error: Lengths not equal)"); };
    if (!((memcmp(a->pReleaseKeys, b->pReleaseKeys, a->releaseCount * sizeof(const uint64_t)) == 0))) { onFail("a->pReleaseKeys (Error: Unequal dyn array)"); };
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void checkEqual_VkImportSemaphoreWin32HandleInfoKHR(
    const VkImportSemaphoreWin32HandleInfoKHR* a,
    const VkImportSemaphoreWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->semaphore) == (b->semaphore))) { onFail("a->semaphore (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->handle) == (b->handle))) { onFail("a->handle (Error: Value not equal)"); };
    if (!((a->name) == (b->name))) { onFail("a->name (Error: Value not equal)"); };
}

void checkEqual_VkExportSemaphoreWin32HandleInfoKHR(
    const VkExportSemaphoreWin32HandleInfoKHR* a,
    const VkExportSemaphoreWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pAttributes) && !(b->pAttributes)) || ((a->pAttributes) && (b->pAttributes)))) { onFail("a->pAttributes (Error: Mismatch in optional field)"); };
    if (a->pAttributes && b->pAttributes)
    {
        if (!((memcmp(a->pAttributes, b->pAttributes, sizeof(const SECURITY_ATTRIBUTES)) == 0))) { onFail("a->pAttributes (Error: Unequal dyn array)"); };
    }
    if (!((a->dwAccess) == (b->dwAccess))) { onFail("a->dwAccess (Error: Value not equal)"); };
    if (!((a->name) == (b->name))) { onFail("a->name (Error: Value not equal)"); };
}

void checkEqual_VkD3D12FenceSubmitInfoKHR(
    const VkD3D12FenceSubmitInfoKHR* a,
    const VkD3D12FenceSubmitInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->waitSemaphoreValuesCount) == (b->waitSemaphoreValuesCount))) { onFail("a->waitSemaphoreValuesCount (Error: Value not equal)"); };
    if (!((!(a->pWaitSemaphoreValues) && !(b->pWaitSemaphoreValues)) || ((a->pWaitSemaphoreValues) && (b->pWaitSemaphoreValues)))) { onFail("a->pWaitSemaphoreValues (Error: Mismatch in optional field)"); };
    if (a->pWaitSemaphoreValues && b->pWaitSemaphoreValues)
    {
        if (!((a->waitSemaphoreValuesCount) == (b->waitSemaphoreValuesCount))) { onFail("a->pWaitSemaphoreValues (Error: Lengths not equal)"); };
        if (!((memcmp(a->pWaitSemaphoreValues, b->pWaitSemaphoreValues, a->waitSemaphoreValuesCount * sizeof(const uint64_t)) == 0))) { onFail("a->pWaitSemaphoreValues (Error: Unequal dyn array)"); };
    }
    if (!((a->signalSemaphoreValuesCount) == (b->signalSemaphoreValuesCount))) { onFail("a->signalSemaphoreValuesCount (Error: Value not equal)"); };
    if (!((!(a->pSignalSemaphoreValues) && !(b->pSignalSemaphoreValues)) || ((a->pSignalSemaphoreValues) && (b->pSignalSemaphoreValues)))) { onFail("a->pSignalSemaphoreValues (Error: Mismatch in optional field)"); };
    if (a->pSignalSemaphoreValues && b->pSignalSemaphoreValues)
    {
        if (!((a->signalSemaphoreValuesCount) == (b->signalSemaphoreValuesCount))) { onFail("a->pSignalSemaphoreValues (Error: Lengths not equal)"); };
        if (!((memcmp(a->pSignalSemaphoreValues, b->pSignalSemaphoreValues, a->signalSemaphoreValuesCount * sizeof(const uint64_t)) == 0))) { onFail("a->pSignalSemaphoreValues (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkSemaphoreGetWin32HandleInfoKHR(
    const VkSemaphoreGetWin32HandleInfoKHR* a,
    const VkSemaphoreGetWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->semaphore) == (b->semaphore))) { onFail("a->semaphore (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void checkEqual_VkImportSemaphoreFdInfoKHR(
    const VkImportSemaphoreFdInfoKHR* a,
    const VkImportSemaphoreFdInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->semaphore) == (b->semaphore))) { onFail("a->semaphore (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->fd) == (b->fd))) { onFail("a->fd (Error: Value not equal)"); };
}

void checkEqual_VkSemaphoreGetFdInfoKHR(
    const VkSemaphoreGetFdInfoKHR* a,
    const VkSemaphoreGetFdInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->semaphore) == (b->semaphore))) { onFail("a->semaphore (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_push_descriptor
void checkEqual_VkPhysicalDevicePushDescriptorPropertiesKHR(
    const VkPhysicalDevicePushDescriptorPropertiesKHR* a,
    const VkPhysicalDevicePushDescriptorPropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxPushDescriptors) == (b->maxPushDescriptors))) { onFail("a->maxPushDescriptors (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void checkEqual_VkRectLayerKHR(
    const VkRectLayerKHR* a,
    const VkRectLayerKHR* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkOffset2D(&a->offset, &b->offset, onFail);
    checkEqual_VkExtent2D(&a->extent, &b->extent, onFail);
    if (!((a->layer) == (b->layer))) { onFail("a->layer (Error: Value not equal)"); };
}

void checkEqual_VkPresentRegionKHR(
    const VkPresentRegionKHR* a,
    const VkPresentRegionKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->rectangleCount) == (b->rectangleCount))) { onFail("a->rectangleCount (Error: Value not equal)"); };
    if (!((!(a->pRectangles) && !(b->pRectangles)) || ((a->pRectangles) && (b->pRectangles)))) { onFail("a->pRectangles (Error: Mismatch in optional field)"); };
    if (a->pRectangles && b->pRectangles)
    {
        if ((a->pRectangles) && (b->pRectangles))
        {
            if (!((a->rectangleCount) == (b->rectangleCount))) { onFail("a->pRectangles (Error: Lengths not equal)"); };
            if ((a->rectangleCount) == (b->rectangleCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->rectangleCount; ++i)
                {
                    checkEqual_VkRectLayerKHR(a->pRectangles + i, b->pRectangles + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkPresentRegionsKHR(
    const VkPresentRegionsKHR* a,
    const VkPresentRegionsKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->swapchainCount (Error: Value not equal)"); };
    if (!((!(a->pRegions) && !(b->pRegions)) || ((a->pRegions) && (b->pRegions)))) { onFail("a->pRegions (Error: Mismatch in optional field)"); };
    if (a->pRegions && b->pRegions)
    {
        if ((a->pRegions) && (b->pRegions))
        {
            if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->pRegions (Error: Lengths not equal)"); };
            if ((a->swapchainCount) == (b->swapchainCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->swapchainCount; ++i)
                {
                    checkEqual_VkPresentRegionKHR(a->pRegions + i, b->pRegions + i, onFail);
                }
            }
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_create_renderpass2
void checkEqual_VkAttachmentDescription2KHR(
    const VkAttachmentDescription2KHR* a,
    const VkAttachmentDescription2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->samples) == (b->samples))) { onFail("a->samples (Error: Value not equal)"); };
    if (!((a->loadOp) == (b->loadOp))) { onFail("a->loadOp (Error: Value not equal)"); };
    if (!((a->storeOp) == (b->storeOp))) { onFail("a->storeOp (Error: Value not equal)"); };
    if (!((a->stencilLoadOp) == (b->stencilLoadOp))) { onFail("a->stencilLoadOp (Error: Value not equal)"); };
    if (!((a->stencilStoreOp) == (b->stencilStoreOp))) { onFail("a->stencilStoreOp (Error: Value not equal)"); };
    if (!((a->initialLayout) == (b->initialLayout))) { onFail("a->initialLayout (Error: Value not equal)"); };
    if (!((a->finalLayout) == (b->finalLayout))) { onFail("a->finalLayout (Error: Value not equal)"); };
}

void checkEqual_VkAttachmentReference2KHR(
    const VkAttachmentReference2KHR* a,
    const VkAttachmentReference2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->attachment) == (b->attachment))) { onFail("a->attachment (Error: Value not equal)"); };
    if (!((a->layout) == (b->layout))) { onFail("a->layout (Error: Value not equal)"); };
    if (!((a->aspectMask) == (b->aspectMask))) { onFail("a->aspectMask (Error: Value not equal)"); };
}

void checkEqual_VkSubpassDescription2KHR(
    const VkSubpassDescription2KHR* a,
    const VkSubpassDescription2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->pipelineBindPoint) == (b->pipelineBindPoint))) { onFail("a->pipelineBindPoint (Error: Value not equal)"); };
    if (!((a->viewMask) == (b->viewMask))) { onFail("a->viewMask (Error: Value not equal)"); };
    if (!((a->inputAttachmentCount) == (b->inputAttachmentCount))) { onFail("a->inputAttachmentCount (Error: Value not equal)"); };
    if ((a->pInputAttachments) && (b->pInputAttachments))
    {
        if (!((a->inputAttachmentCount) == (b->inputAttachmentCount))) { onFail("a->pInputAttachments (Error: Lengths not equal)"); };
        if ((a->inputAttachmentCount) == (b->inputAttachmentCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->inputAttachmentCount; ++i)
            {
                checkEqual_VkAttachmentReference2KHR(a->pInputAttachments + i, b->pInputAttachments + i, onFail);
            }
        }
    }
    if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->colorAttachmentCount (Error: Value not equal)"); };
    if ((a->pColorAttachments) && (b->pColorAttachments))
    {
        if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->pColorAttachments (Error: Lengths not equal)"); };
        if ((a->colorAttachmentCount) == (b->colorAttachmentCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->colorAttachmentCount; ++i)
            {
                checkEqual_VkAttachmentReference2KHR(a->pColorAttachments + i, b->pColorAttachments + i, onFail);
            }
        }
    }
    if (!((!(a->pResolveAttachments) && !(b->pResolveAttachments)) || ((a->pResolveAttachments) && (b->pResolveAttachments)))) { onFail("a->pResolveAttachments (Error: Mismatch in optional field)"); };
    if (a->pResolveAttachments && b->pResolveAttachments)
    {
        if ((a->pResolveAttachments) && (b->pResolveAttachments))
        {
            if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->pResolveAttachments (Error: Lengths not equal)"); };
            if ((a->colorAttachmentCount) == (b->colorAttachmentCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->colorAttachmentCount; ++i)
                {
                    checkEqual_VkAttachmentReference2KHR(a->pResolveAttachments + i, b->pResolveAttachments + i, onFail);
                }
            }
        }
    }
    if (!((!(a->pDepthStencilAttachment) && !(b->pDepthStencilAttachment)) || ((a->pDepthStencilAttachment) && (b->pDepthStencilAttachment)))) { onFail("a->pDepthStencilAttachment (Error: Mismatch in optional field)"); };
    if (a->pDepthStencilAttachment && b->pDepthStencilAttachment)
    {
        if ((a->pDepthStencilAttachment) && (b->pDepthStencilAttachment))
        {
            checkEqual_VkAttachmentReference2KHR(a->pDepthStencilAttachment, b->pDepthStencilAttachment, onFail);
        }
    }
    if (!((a->preserveAttachmentCount) == (b->preserveAttachmentCount))) { onFail("a->preserveAttachmentCount (Error: Value not equal)"); };
    if (!((a->preserveAttachmentCount) == (b->preserveAttachmentCount))) { onFail("a->pPreserveAttachments (Error: Lengths not equal)"); };
    if (!((memcmp(a->pPreserveAttachments, b->pPreserveAttachments, a->preserveAttachmentCount * sizeof(const uint32_t)) == 0))) { onFail("a->pPreserveAttachments (Error: Unequal dyn array)"); };
}

void checkEqual_VkSubpassDependency2KHR(
    const VkSubpassDependency2KHR* a,
    const VkSubpassDependency2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcSubpass) == (b->srcSubpass))) { onFail("a->srcSubpass (Error: Value not equal)"); };
    if (!((a->dstSubpass) == (b->dstSubpass))) { onFail("a->dstSubpass (Error: Value not equal)"); };
    if (!((a->srcStageMask) == (b->srcStageMask))) { onFail("a->srcStageMask (Error: Value not equal)"); };
    if (!((a->dstStageMask) == (b->dstStageMask))) { onFail("a->dstStageMask (Error: Value not equal)"); };
    if (!((a->srcAccessMask) == (b->srcAccessMask))) { onFail("a->srcAccessMask (Error: Value not equal)"); };
    if (!((a->dstAccessMask) == (b->dstAccessMask))) { onFail("a->dstAccessMask (Error: Value not equal)"); };
    if (!((a->dependencyFlags) == (b->dependencyFlags))) { onFail("a->dependencyFlags (Error: Value not equal)"); };
    if (!((a->viewOffset) == (b->viewOffset))) { onFail("a->viewOffset (Error: Value not equal)"); };
}

void checkEqual_VkRenderPassCreateInfo2KHR(
    const VkRenderPassCreateInfo2KHR* a,
    const VkRenderPassCreateInfo2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->attachmentCount (Error: Value not equal)"); };
    if ((a->pAttachments) && (b->pAttachments))
    {
        if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->pAttachments (Error: Lengths not equal)"); };
        if ((a->attachmentCount) == (b->attachmentCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->attachmentCount; ++i)
            {
                checkEqual_VkAttachmentDescription2KHR(a->pAttachments + i, b->pAttachments + i, onFail);
            }
        }
    }
    if (!((a->subpassCount) == (b->subpassCount))) { onFail("a->subpassCount (Error: Value not equal)"); };
    if ((a->pSubpasses) && (b->pSubpasses))
    {
        if (!((a->subpassCount) == (b->subpassCount))) { onFail("a->pSubpasses (Error: Lengths not equal)"); };
        if ((a->subpassCount) == (b->subpassCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->subpassCount; ++i)
            {
                checkEqual_VkSubpassDescription2KHR(a->pSubpasses + i, b->pSubpasses + i, onFail);
            }
        }
    }
    if (!((a->dependencyCount) == (b->dependencyCount))) { onFail("a->dependencyCount (Error: Value not equal)"); };
    if ((a->pDependencies) && (b->pDependencies))
    {
        if (!((a->dependencyCount) == (b->dependencyCount))) { onFail("a->pDependencies (Error: Lengths not equal)"); };
        if ((a->dependencyCount) == (b->dependencyCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->dependencyCount; ++i)
            {
                checkEqual_VkSubpassDependency2KHR(a->pDependencies + i, b->pDependencies + i, onFail);
            }
        }
    }
    if (!((a->correlatedViewMaskCount) == (b->correlatedViewMaskCount))) { onFail("a->correlatedViewMaskCount (Error: Value not equal)"); };
    if (!((a->correlatedViewMaskCount) == (b->correlatedViewMaskCount))) { onFail("a->pCorrelatedViewMasks (Error: Lengths not equal)"); };
    if (!((memcmp(a->pCorrelatedViewMasks, b->pCorrelatedViewMasks, a->correlatedViewMaskCount * sizeof(const uint32_t)) == 0))) { onFail("a->pCorrelatedViewMasks (Error: Unequal dyn array)"); };
}

void checkEqual_VkSubpassBeginInfoKHR(
    const VkSubpassBeginInfoKHR* a,
    const VkSubpassBeginInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->contents) == (b->contents))) { onFail("a->contents (Error: Value not equal)"); };
}

void checkEqual_VkSubpassEndInfoKHR(
    const VkSubpassEndInfoKHR* a,
    const VkSubpassEndInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
}

#endif
#ifdef VK_KHR_shared_presentable_image
void checkEqual_VkSharedPresentSurfaceCapabilitiesKHR(
    const VkSharedPresentSurfaceCapabilitiesKHR* a,
    const VkSharedPresentSurfaceCapabilitiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->sharedPresentSupportedUsageFlags) == (b->sharedPresentSupportedUsageFlags))) { onFail("a->sharedPresentSupportedUsageFlags (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void checkEqual_VkImportFenceWin32HandleInfoKHR(
    const VkImportFenceWin32HandleInfoKHR* a,
    const VkImportFenceWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fence) == (b->fence))) { onFail("a->fence (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->handle) == (b->handle))) { onFail("a->handle (Error: Value not equal)"); };
    if (!((a->name) == (b->name))) { onFail("a->name (Error: Value not equal)"); };
}

void checkEqual_VkExportFenceWin32HandleInfoKHR(
    const VkExportFenceWin32HandleInfoKHR* a,
    const VkExportFenceWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pAttributes) && !(b->pAttributes)) || ((a->pAttributes) && (b->pAttributes)))) { onFail("a->pAttributes (Error: Mismatch in optional field)"); };
    if (a->pAttributes && b->pAttributes)
    {
        if (!((memcmp(a->pAttributes, b->pAttributes, sizeof(const SECURITY_ATTRIBUTES)) == 0))) { onFail("a->pAttributes (Error: Unequal dyn array)"); };
    }
    if (!((a->dwAccess) == (b->dwAccess))) { onFail("a->dwAccess (Error: Value not equal)"); };
    if (!((a->name) == (b->name))) { onFail("a->name (Error: Value not equal)"); };
}

void checkEqual_VkFenceGetWin32HandleInfoKHR(
    const VkFenceGetWin32HandleInfoKHR* a,
    const VkFenceGetWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fence) == (b->fence))) { onFail("a->fence (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_external_fence_fd
void checkEqual_VkImportFenceFdInfoKHR(
    const VkImportFenceFdInfoKHR* a,
    const VkImportFenceFdInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fence) == (b->fence))) { onFail("a->fence (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->fd) == (b->fd))) { onFail("a->fd (Error: Value not equal)"); };
}

void checkEqual_VkFenceGetFdInfoKHR(
    const VkFenceGetFdInfoKHR* a,
    const VkFenceGetFdInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fence) == (b->fence))) { onFail("a->fence (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void checkEqual_VkPhysicalDeviceSurfaceInfo2KHR(
    const VkPhysicalDeviceSurfaceInfo2KHR* a,
    const VkPhysicalDeviceSurfaceInfo2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->surface) == (b->surface))) { onFail("a->surface (Error: Value not equal)"); };
}

void checkEqual_VkSurfaceCapabilities2KHR(
    const VkSurfaceCapabilities2KHR* a,
    const VkSurfaceCapabilities2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkSurfaceCapabilitiesKHR(&a->surfaceCapabilities, &b->surfaceCapabilities, onFail);
}

void checkEqual_VkSurfaceFormat2KHR(
    const VkSurfaceFormat2KHR* a,
    const VkSurfaceFormat2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkSurfaceFormatKHR(&a->surfaceFormat, &b->surfaceFormat, onFail);
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void checkEqual_VkDisplayProperties2KHR(
    const VkDisplayProperties2KHR* a,
    const VkDisplayProperties2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkDisplayPropertiesKHR(&a->displayProperties, &b->displayProperties, onFail);
}

void checkEqual_VkDisplayPlaneProperties2KHR(
    const VkDisplayPlaneProperties2KHR* a,
    const VkDisplayPlaneProperties2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkDisplayPlanePropertiesKHR(&a->displayPlaneProperties, &b->displayPlaneProperties, onFail);
}

void checkEqual_VkDisplayModeProperties2KHR(
    const VkDisplayModeProperties2KHR* a,
    const VkDisplayModeProperties2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkDisplayModePropertiesKHR(&a->displayModeProperties, &b->displayModeProperties, onFail);
}

void checkEqual_VkDisplayPlaneInfo2KHR(
    const VkDisplayPlaneInfo2KHR* a,
    const VkDisplayPlaneInfo2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->mode) == (b->mode))) { onFail("a->mode (Error: Value not equal)"); };
    if (!((a->planeIndex) == (b->planeIndex))) { onFail("a->planeIndex (Error: Value not equal)"); };
}

void checkEqual_VkDisplayPlaneCapabilities2KHR(
    const VkDisplayPlaneCapabilities2KHR* a,
    const VkDisplayPlaneCapabilities2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkDisplayPlaneCapabilitiesKHR(&a->capabilities, &b->capabilities, onFail);
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
void checkEqual_VkImageFormatListCreateInfoKHR(
    const VkImageFormatListCreateInfoKHR* a,
    const VkImageFormatListCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->viewFormatCount) == (b->viewFormatCount))) { onFail("a->viewFormatCount (Error: Value not equal)"); };
    if (!((a->viewFormatCount) == (b->viewFormatCount))) { onFail("a->pViewFormats (Error: Lengths not equal)"); };
    if (!((memcmp(a->pViewFormats, b->pViewFormats, a->viewFormatCount * sizeof(const VkFormat)) == 0))) { onFail("a->pViewFormats (Error: Unequal dyn array)"); };
}

#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_draw_indirect_count
#endif
#ifdef VK_KHR_8bit_storage
void checkEqual_VkPhysicalDevice8BitStorageFeaturesKHR(
    const VkPhysicalDevice8BitStorageFeaturesKHR* a,
    const VkPhysicalDevice8BitStorageFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->storageBuffer8BitAccess) == (b->storageBuffer8BitAccess))) { onFail("a->storageBuffer8BitAccess (Error: Value not equal)"); };
    if (!((a->uniformAndStorageBuffer8BitAccess) == (b->uniformAndStorageBuffer8BitAccess))) { onFail("a->uniformAndStorageBuffer8BitAccess (Error: Value not equal)"); };
    if (!((a->storagePushConstant8) == (b->storagePushConstant8))) { onFail("a->storagePushConstant8 (Error: Value not equal)"); };
}

#endif
#ifdef VK_ANDROID_native_buffer
void checkEqual_VkNativeBufferANDROID(
    const VkNativeBufferANDROID* a,
    const VkNativeBufferANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->handle) && !(b->handle)) || ((a->handle) && (b->handle)))) { onFail("a->handle (Error: Mismatch in optional field)"); };
    if (a->handle && b->handle)
    {
        if (!((memcmp(a->handle, b->handle, sizeof(const uint32_t)) == 0))) { onFail("a->handle (Error: Unequal dyn array)"); };
    }
    if (!((a->stride) == (b->stride))) { onFail("a->stride (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
    if (!((a->consumer) == (b->consumer))) { onFail("a->consumer (Error: Value not equal)"); };
    if (!((a->producer) == (b->producer))) { onFail("a->producer (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_debug_report
void checkEqual_VkDebugReportCallbackCreateInfoEXT(
    const VkDebugReportCallbackCreateInfoEXT* a,
    const VkDebugReportCallbackCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->pfnCallback) == (b->pfnCallback))) { onFail("a->pfnCallback (Error: Value not equal)"); };
    if (!((!(a->pUserData) && !(b->pUserData)) || ((a->pUserData) && (b->pUserData)))) { onFail("a->pUserData (Error: Mismatch in optional field)"); };
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void checkEqual_VkPipelineRasterizationStateRasterizationOrderAMD(
    const VkPipelineRasterizationStateRasterizationOrderAMD* a,
    const VkPipelineRasterizationStateRasterizationOrderAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->rasterizationOrder) == (b->rasterizationOrder))) { onFail("a->rasterizationOrder (Error: Value not equal)"); };
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void checkEqual_VkDebugMarkerObjectNameInfoEXT(
    const VkDebugMarkerObjectNameInfoEXT* a,
    const VkDebugMarkerObjectNameInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->objectType) == (b->objectType))) { onFail("a->objectType (Error: Value not equal)"); };
    if (!((a->object) == (b->object))) { onFail("a->object (Error: Value not equal)"); };
    if (!((!(a->pObjectName) && !(b->pObjectName)) || ((a->pObjectName) && (b->pObjectName)))) { onFail("a->pObjectName (Error: Mismatch in string pointer nullness)"); };
    if ((a->pObjectName) && (b->pObjectName))
    {
        if (!((strcmp(a->pObjectName, b->pObjectName) == 0))) { onFail("a->pObjectName (Error: Unequal strings)"); };
    }
}

void checkEqual_VkDebugMarkerObjectTagInfoEXT(
    const VkDebugMarkerObjectTagInfoEXT* a,
    const VkDebugMarkerObjectTagInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->objectType) == (b->objectType))) { onFail("a->objectType (Error: Value not equal)"); };
    if (!((a->object) == (b->object))) { onFail("a->object (Error: Value not equal)"); };
    if (!((a->tagName) == (b->tagName))) { onFail("a->tagName (Error: Value not equal)"); };
    if (!((a->tagSize) == (b->tagSize))) { onFail("a->tagSize (Error: Value not equal)"); };
}

void checkEqual_VkDebugMarkerMarkerInfoEXT(
    const VkDebugMarkerMarkerInfoEXT* a,
    const VkDebugMarkerMarkerInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pMarkerName) && !(b->pMarkerName)) || ((a->pMarkerName) && (b->pMarkerName)))) { onFail("a->pMarkerName (Error: Mismatch in string pointer nullness)"); };
    if ((a->pMarkerName) && (b->pMarkerName))
    {
        if (!((strcmp(a->pMarkerName, b->pMarkerName) == 0))) { onFail("a->pMarkerName (Error: Unequal strings)"); };
    }
    if (!((memcmp(a->color, b->color, 4 * sizeof(float)) == 0))) { onFail("a->color (Error: Unequal static array)"); };
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void checkEqual_VkDedicatedAllocationImageCreateInfoNV(
    const VkDedicatedAllocationImageCreateInfoNV* a,
    const VkDedicatedAllocationImageCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->dedicatedAllocation) == (b->dedicatedAllocation))) { onFail("a->dedicatedAllocation (Error: Value not equal)"); };
}

void checkEqual_VkDedicatedAllocationBufferCreateInfoNV(
    const VkDedicatedAllocationBufferCreateInfoNV* a,
    const VkDedicatedAllocationBufferCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->dedicatedAllocation) == (b->dedicatedAllocation))) { onFail("a->dedicatedAllocation (Error: Value not equal)"); };
}

void checkEqual_VkDedicatedAllocationMemoryAllocateInfoNV(
    const VkDedicatedAllocationMemoryAllocateInfoNV* a,
    const VkDedicatedAllocationMemoryAllocateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
}

#endif
#ifdef VK_AMD_draw_indirect_count
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
void checkEqual_VkTextureLODGatherFormatPropertiesAMD(
    const VkTextureLODGatherFormatPropertiesAMD* a,
    const VkTextureLODGatherFormatPropertiesAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->supportsTextureGatherLODBiasAMD) == (b->supportsTextureGatherLODBiasAMD))) { onFail("a->supportsTextureGatherLODBiasAMD (Error: Value not equal)"); };
}

#endif
#ifdef VK_AMD_shader_info
void checkEqual_VkShaderResourceUsageAMD(
    const VkShaderResourceUsageAMD* a,
    const VkShaderResourceUsageAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->numUsedVgprs) == (b->numUsedVgprs))) { onFail("a->numUsedVgprs (Error: Value not equal)"); };
    if (!((a->numUsedSgprs) == (b->numUsedSgprs))) { onFail("a->numUsedSgprs (Error: Value not equal)"); };
    if (!((a->ldsSizePerLocalWorkGroup) == (b->ldsSizePerLocalWorkGroup))) { onFail("a->ldsSizePerLocalWorkGroup (Error: Value not equal)"); };
    if (!((a->ldsUsageSizeInBytes) == (b->ldsUsageSizeInBytes))) { onFail("a->ldsUsageSizeInBytes (Error: Value not equal)"); };
    if (!((a->scratchMemUsageInBytes) == (b->scratchMemUsageInBytes))) { onFail("a->scratchMemUsageInBytes (Error: Value not equal)"); };
}

void checkEqual_VkShaderStatisticsInfoAMD(
    const VkShaderStatisticsInfoAMD* a,
    const VkShaderStatisticsInfoAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->shaderStageMask) == (b->shaderStageMask))) { onFail("a->shaderStageMask (Error: Value not equal)"); };
    checkEqual_VkShaderResourceUsageAMD(&a->resourceUsage, &b->resourceUsage, onFail);
    if (!((a->numPhysicalVgprs) == (b->numPhysicalVgprs))) { onFail("a->numPhysicalVgprs (Error: Value not equal)"); };
    if (!((a->numPhysicalSgprs) == (b->numPhysicalSgprs))) { onFail("a->numPhysicalSgprs (Error: Value not equal)"); };
    if (!((a->numAvailableVgprs) == (b->numAvailableVgprs))) { onFail("a->numAvailableVgprs (Error: Value not equal)"); };
    if (!((a->numAvailableSgprs) == (b->numAvailableSgprs))) { onFail("a->numAvailableSgprs (Error: Value not equal)"); };
    if (!((memcmp(a->computeWorkGroupSize, b->computeWorkGroupSize, 3 * sizeof(uint32_t)) == 0))) { onFail("a->computeWorkGroupSize (Error: Unequal static array)"); };
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void checkEqual_VkExternalImageFormatPropertiesNV(
    const VkExternalImageFormatPropertiesNV* a,
    const VkExternalImageFormatPropertiesNV* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkImageFormatProperties(&a->imageFormatProperties, &b->imageFormatProperties, onFail);
    if (!((a->externalMemoryFeatures) == (b->externalMemoryFeatures))) { onFail("a->externalMemoryFeatures (Error: Value not equal)"); };
    if (!((a->exportFromImportedHandleTypes) == (b->exportFromImportedHandleTypes))) { onFail("a->exportFromImportedHandleTypes (Error: Value not equal)"); };
    if (!((a->compatibleHandleTypes) == (b->compatibleHandleTypes))) { onFail("a->compatibleHandleTypes (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_external_memory
void checkEqual_VkExternalMemoryImageCreateInfoNV(
    const VkExternalMemoryImageCreateInfoNV* a,
    const VkExternalMemoryImageCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleTypes) == (b->handleTypes))) { onFail("a->handleTypes (Error: Value not equal)"); };
}

void checkEqual_VkExportMemoryAllocateInfoNV(
    const VkExportMemoryAllocateInfoNV* a,
    const VkExportMemoryAllocateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleTypes) == (b->handleTypes))) { onFail("a->handleTypes (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_external_memory_win32
void checkEqual_VkImportMemoryWin32HandleInfoNV(
    const VkImportMemoryWin32HandleInfoNV* a,
    const VkImportMemoryWin32HandleInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->handle) == (b->handle))) { onFail("a->handle (Error: Value not equal)"); };
}

void checkEqual_VkExportMemoryWin32HandleInfoNV(
    const VkExportMemoryWin32HandleInfoNV* a,
    const VkExportMemoryWin32HandleInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pAttributes) && !(b->pAttributes)) || ((a->pAttributes) && (b->pAttributes)))) { onFail("a->pAttributes (Error: Mismatch in optional field)"); };
    if (a->pAttributes && b->pAttributes)
    {
        if (!((memcmp(a->pAttributes, b->pAttributes, sizeof(const SECURITY_ATTRIBUTES)) == 0))) { onFail("a->pAttributes (Error: Unequal dyn array)"); };
    }
    if (!((a->dwAccess) == (b->dwAccess))) { onFail("a->dwAccess (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void checkEqual_VkWin32KeyedMutexAcquireReleaseInfoNV(
    const VkWin32KeyedMutexAcquireReleaseInfoNV* a,
    const VkWin32KeyedMutexAcquireReleaseInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->acquireCount (Error: Value not equal)"); };
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->pAcquireSyncs (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAcquireSyncs, b->pAcquireSyncs, a->acquireCount * sizeof(const VkDeviceMemory)) == 0))) { onFail("a->pAcquireSyncs (Error: Unequal dyn array)"); };
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->pAcquireKeys (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAcquireKeys, b->pAcquireKeys, a->acquireCount * sizeof(const uint64_t)) == 0))) { onFail("a->pAcquireKeys (Error: Unequal dyn array)"); };
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->pAcquireTimeoutMilliseconds (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAcquireTimeoutMilliseconds, b->pAcquireTimeoutMilliseconds, a->acquireCount * sizeof(const uint32_t)) == 0))) { onFail("a->pAcquireTimeoutMilliseconds (Error: Unequal dyn array)"); };
    if (!((a->releaseCount) == (b->releaseCount))) { onFail("a->releaseCount (Error: Value not equal)"); };
    if (!((a->releaseCount) == (b->releaseCount))) { onFail("a->pReleaseSyncs (Error: Lengths not equal)"); };
    if (!((memcmp(a->pReleaseSyncs, b->pReleaseSyncs, a->releaseCount * sizeof(const VkDeviceMemory)) == 0))) { onFail("a->pReleaseSyncs (Error: Unequal dyn array)"); };
    if (!((a->releaseCount) == (b->releaseCount))) { onFail("a->pReleaseKeys (Error: Lengths not equal)"); };
    if (!((memcmp(a->pReleaseKeys, b->pReleaseKeys, a->releaseCount * sizeof(const uint64_t)) == 0))) { onFail("a->pReleaseKeys (Error: Unequal dyn array)"); };
}

#endif
#ifdef VK_EXT_validation_flags
void checkEqual_VkValidationFlagsEXT(
    const VkValidationFlagsEXT* a,
    const VkValidationFlagsEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->disabledValidationCheckCount) == (b->disabledValidationCheckCount))) { onFail("a->disabledValidationCheckCount (Error: Value not equal)"); };
    if (!((a->disabledValidationCheckCount) == (b->disabledValidationCheckCount))) { onFail("a->pDisabledValidationChecks (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDisabledValidationChecks, b->pDisabledValidationChecks, a->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT)) == 0))) { onFail("a->pDisabledValidationChecks (Error: Unequal dyn array)"); };
}

#endif
#ifdef VK_NN_vi_surface
void checkEqual_VkViSurfaceCreateInfoNN(
    const VkViSurfaceCreateInfoNN* a,
    const VkViSurfaceCreateInfoNN* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->window) && !(b->window)) || ((a->window) && (b->window)))) { onFail("a->window (Error: Mismatch in optional field)"); };
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
void checkEqual_VkConditionalRenderingBeginInfoEXT(
    const VkConditionalRenderingBeginInfoEXT* a,
    const VkConditionalRenderingBeginInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT* a,
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->conditionalRendering) == (b->conditionalRendering))) { onFail("a->conditionalRendering (Error: Value not equal)"); };
    if (!((a->inheritedConditionalRendering) == (b->inheritedConditionalRendering))) { onFail("a->inheritedConditionalRendering (Error: Value not equal)"); };
}

void checkEqual_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* a,
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->conditionalRenderingEnable) == (b->conditionalRenderingEnable))) { onFail("a->conditionalRenderingEnable (Error: Value not equal)"); };
}

#endif
#ifdef VK_NVX_device_generated_commands
void checkEqual_VkDeviceGeneratedCommandsFeaturesNVX(
    const VkDeviceGeneratedCommandsFeaturesNVX* a,
    const VkDeviceGeneratedCommandsFeaturesNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->computeBindingPointSupport) == (b->computeBindingPointSupport))) { onFail("a->computeBindingPointSupport (Error: Value not equal)"); };
}

void checkEqual_VkDeviceGeneratedCommandsLimitsNVX(
    const VkDeviceGeneratedCommandsLimitsNVX* a,
    const VkDeviceGeneratedCommandsLimitsNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxIndirectCommandsLayoutTokenCount) == (b->maxIndirectCommandsLayoutTokenCount))) { onFail("a->maxIndirectCommandsLayoutTokenCount (Error: Value not equal)"); };
    if (!((a->maxObjectEntryCounts) == (b->maxObjectEntryCounts))) { onFail("a->maxObjectEntryCounts (Error: Value not equal)"); };
    if (!((a->minSequenceCountBufferOffsetAlignment) == (b->minSequenceCountBufferOffsetAlignment))) { onFail("a->minSequenceCountBufferOffsetAlignment (Error: Value not equal)"); };
    if (!((a->minSequenceIndexBufferOffsetAlignment) == (b->minSequenceIndexBufferOffsetAlignment))) { onFail("a->minSequenceIndexBufferOffsetAlignment (Error: Value not equal)"); };
    if (!((a->minCommandsTokenBufferOffsetAlignment) == (b->minCommandsTokenBufferOffsetAlignment))) { onFail("a->minCommandsTokenBufferOffsetAlignment (Error: Value not equal)"); };
}

void checkEqual_VkIndirectCommandsTokenNVX(
    const VkIndirectCommandsTokenNVX* a,
    const VkIndirectCommandsTokenNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->tokenType) == (b->tokenType))) { onFail("a->tokenType (Error: Value not equal)"); };
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
}

void checkEqual_VkIndirectCommandsLayoutTokenNVX(
    const VkIndirectCommandsLayoutTokenNVX* a,
    const VkIndirectCommandsLayoutTokenNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->tokenType) == (b->tokenType))) { onFail("a->tokenType (Error: Value not equal)"); };
    if (!((a->bindingUnit) == (b->bindingUnit))) { onFail("a->bindingUnit (Error: Value not equal)"); };
    if (!((a->dynamicCount) == (b->dynamicCount))) { onFail("a->dynamicCount (Error: Value not equal)"); };
    if (!((a->divisor) == (b->divisor))) { onFail("a->divisor (Error: Value not equal)"); };
}

void checkEqual_VkIndirectCommandsLayoutCreateInfoNVX(
    const VkIndirectCommandsLayoutCreateInfoNVX* a,
    const VkIndirectCommandsLayoutCreateInfoNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->pipelineBindPoint) == (b->pipelineBindPoint))) { onFail("a->pipelineBindPoint (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->tokenCount) == (b->tokenCount))) { onFail("a->tokenCount (Error: Value not equal)"); };
    if ((a->pTokens) && (b->pTokens))
    {
        if (!((a->tokenCount) == (b->tokenCount))) { onFail("a->pTokens (Error: Lengths not equal)"); };
        if ((a->tokenCount) == (b->tokenCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->tokenCount; ++i)
            {
                checkEqual_VkIndirectCommandsLayoutTokenNVX(a->pTokens + i, b->pTokens + i, onFail);
            }
        }
    }
}

void checkEqual_VkCmdProcessCommandsInfoNVX(
    const VkCmdProcessCommandsInfoNVX* a,
    const VkCmdProcessCommandsInfoNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->objectTable) == (b->objectTable))) { onFail("a->objectTable (Error: Value not equal)"); };
    if (!((a->indirectCommandsLayout) == (b->indirectCommandsLayout))) { onFail("a->indirectCommandsLayout (Error: Value not equal)"); };
    if (!((a->indirectCommandsTokenCount) == (b->indirectCommandsTokenCount))) { onFail("a->indirectCommandsTokenCount (Error: Value not equal)"); };
    if ((a->pIndirectCommandsTokens) && (b->pIndirectCommandsTokens))
    {
        if (!((a->indirectCommandsTokenCount) == (b->indirectCommandsTokenCount))) { onFail("a->pIndirectCommandsTokens (Error: Lengths not equal)"); };
        if ((a->indirectCommandsTokenCount) == (b->indirectCommandsTokenCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->indirectCommandsTokenCount; ++i)
            {
                checkEqual_VkIndirectCommandsTokenNVX(a->pIndirectCommandsTokens + i, b->pIndirectCommandsTokens + i, onFail);
            }
        }
    }
    if (!((a->maxSequencesCount) == (b->maxSequencesCount))) { onFail("a->maxSequencesCount (Error: Value not equal)"); };
    if (!((a->targetCommandBuffer) == (b->targetCommandBuffer))) { onFail("a->targetCommandBuffer (Error: Value not equal)"); };
    if (!((a->sequencesCountBuffer) == (b->sequencesCountBuffer))) { onFail("a->sequencesCountBuffer (Error: Value not equal)"); };
    if (!((a->sequencesCountOffset) == (b->sequencesCountOffset))) { onFail("a->sequencesCountOffset (Error: Value not equal)"); };
    if (!((a->sequencesIndexBuffer) == (b->sequencesIndexBuffer))) { onFail("a->sequencesIndexBuffer (Error: Value not equal)"); };
    if (!((a->sequencesIndexOffset) == (b->sequencesIndexOffset))) { onFail("a->sequencesIndexOffset (Error: Value not equal)"); };
}

void checkEqual_VkCmdReserveSpaceForCommandsInfoNVX(
    const VkCmdReserveSpaceForCommandsInfoNVX* a,
    const VkCmdReserveSpaceForCommandsInfoNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->objectTable) == (b->objectTable))) { onFail("a->objectTable (Error: Value not equal)"); };
    if (!((a->indirectCommandsLayout) == (b->indirectCommandsLayout))) { onFail("a->indirectCommandsLayout (Error: Value not equal)"); };
    if (!((a->maxSequencesCount) == (b->maxSequencesCount))) { onFail("a->maxSequencesCount (Error: Value not equal)"); };
}

void checkEqual_VkObjectTableCreateInfoNVX(
    const VkObjectTableCreateInfoNVX* a,
    const VkObjectTableCreateInfoNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->objectCount) == (b->objectCount))) { onFail("a->objectCount (Error: Value not equal)"); };
    if (!((a->objectCount) == (b->objectCount))) { onFail("a->pObjectEntryTypes (Error: Lengths not equal)"); };
    if (!((memcmp(a->pObjectEntryTypes, b->pObjectEntryTypes, a->objectCount * sizeof(const VkObjectEntryTypeNVX)) == 0))) { onFail("a->pObjectEntryTypes (Error: Unequal dyn array)"); };
    if (!((a->objectCount) == (b->objectCount))) { onFail("a->pObjectEntryCounts (Error: Lengths not equal)"); };
    if (!((memcmp(a->pObjectEntryCounts, b->pObjectEntryCounts, a->objectCount * sizeof(const uint32_t)) == 0))) { onFail("a->pObjectEntryCounts (Error: Unequal dyn array)"); };
    if (!((a->objectCount) == (b->objectCount))) { onFail("a->pObjectEntryUsageFlags (Error: Lengths not equal)"); };
    if (!((memcmp(a->pObjectEntryUsageFlags, b->pObjectEntryUsageFlags, a->objectCount * sizeof(const VkObjectEntryUsageFlagsNVX)) == 0))) { onFail("a->pObjectEntryUsageFlags (Error: Unequal dyn array)"); };
    if (!((a->maxUniformBuffersPerDescriptor) == (b->maxUniformBuffersPerDescriptor))) { onFail("a->maxUniformBuffersPerDescriptor (Error: Value not equal)"); };
    if (!((a->maxStorageBuffersPerDescriptor) == (b->maxStorageBuffersPerDescriptor))) { onFail("a->maxStorageBuffersPerDescriptor (Error: Value not equal)"); };
    if (!((a->maxStorageImagesPerDescriptor) == (b->maxStorageImagesPerDescriptor))) { onFail("a->maxStorageImagesPerDescriptor (Error: Value not equal)"); };
    if (!((a->maxSampledImagesPerDescriptor) == (b->maxSampledImagesPerDescriptor))) { onFail("a->maxSampledImagesPerDescriptor (Error: Value not equal)"); };
    if (!((a->maxPipelineLayouts) == (b->maxPipelineLayouts))) { onFail("a->maxPipelineLayouts (Error: Value not equal)"); };
}

void checkEqual_VkObjectTableEntryNVX(
    const VkObjectTableEntryNVX* a,
    const VkObjectTableEntryNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkObjectTablePipelineEntryNVX(
    const VkObjectTablePipelineEntryNVX* a,
    const VkObjectTablePipelineEntryNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->pipeline) == (b->pipeline))) { onFail("a->pipeline (Error: Value not equal)"); };
}

void checkEqual_VkObjectTableDescriptorSetEntryNVX(
    const VkObjectTableDescriptorSetEntryNVX* a,
    const VkObjectTableDescriptorSetEntryNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->pipelineLayout) == (b->pipelineLayout))) { onFail("a->pipelineLayout (Error: Value not equal)"); };
    if (!((a->descriptorSet) == (b->descriptorSet))) { onFail("a->descriptorSet (Error: Value not equal)"); };
}

void checkEqual_VkObjectTableVertexBufferEntryNVX(
    const VkObjectTableVertexBufferEntryNVX* a,
    const VkObjectTableVertexBufferEntryNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
}

void checkEqual_VkObjectTableIndexBufferEntryNVX(
    const VkObjectTableIndexBufferEntryNVX* a,
    const VkObjectTableIndexBufferEntryNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->indexType) == (b->indexType))) { onFail("a->indexType (Error: Value not equal)"); };
}

void checkEqual_VkObjectTablePushConstantEntryNVX(
    const VkObjectTablePushConstantEntryNVX* a,
    const VkObjectTablePushConstantEntryNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->pipelineLayout) == (b->pipelineLayout))) { onFail("a->pipelineLayout (Error: Value not equal)"); };
    if (!((a->stageFlags) == (b->stageFlags))) { onFail("a->stageFlags (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void checkEqual_VkViewportWScalingNV(
    const VkViewportWScalingNV* a,
    const VkViewportWScalingNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->xcoeff) == (b->xcoeff))) { onFail("a->xcoeff (Error: Value not equal)"); };
    if (!((a->ycoeff) == (b->ycoeff))) { onFail("a->ycoeff (Error: Value not equal)"); };
}

void checkEqual_VkPipelineViewportWScalingStateCreateInfoNV(
    const VkPipelineViewportWScalingStateCreateInfoNV* a,
    const VkPipelineViewportWScalingStateCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->viewportWScalingEnable) == (b->viewportWScalingEnable))) { onFail("a->viewportWScalingEnable (Error: Value not equal)"); };
    if (!((a->viewportCount) == (b->viewportCount))) { onFail("a->viewportCount (Error: Value not equal)"); };
    if (!((!(a->pViewportWScalings) && !(b->pViewportWScalings)) || ((a->pViewportWScalings) && (b->pViewportWScalings)))) { onFail("a->pViewportWScalings (Error: Mismatch in optional field)"); };
    if (a->pViewportWScalings && b->pViewportWScalings)
    {
        if ((a->pViewportWScalings) && (b->pViewportWScalings))
        {
            if (!((a->viewportCount) == (b->viewportCount))) { onFail("a->pViewportWScalings (Error: Lengths not equal)"); };
            if ((a->viewportCount) == (b->viewportCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->viewportCount; ++i)
                {
                    checkEqual_VkViewportWScalingNV(a->pViewportWScalings + i, b->pViewportWScalings + i, onFail);
                }
            }
        }
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
#endif
#ifdef VK_EXT_acquire_xlib_display
#endif
#ifdef VK_EXT_display_surface_counter
void checkEqual_VkSurfaceCapabilities2EXT(
    const VkSurfaceCapabilities2EXT* a,
    const VkSurfaceCapabilities2EXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->minImageCount) == (b->minImageCount))) { onFail("a->minImageCount (Error: Value not equal)"); };
    if (!((a->maxImageCount) == (b->maxImageCount))) { onFail("a->maxImageCount (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->currentExtent, &b->currentExtent, onFail);
    checkEqual_VkExtent2D(&a->minImageExtent, &b->minImageExtent, onFail);
    checkEqual_VkExtent2D(&a->maxImageExtent, &b->maxImageExtent, onFail);
    if (!((a->maxImageArrayLayers) == (b->maxImageArrayLayers))) { onFail("a->maxImageArrayLayers (Error: Value not equal)"); };
    if (!((a->supportedTransforms) == (b->supportedTransforms))) { onFail("a->supportedTransforms (Error: Value not equal)"); };
    if (!((a->currentTransform) == (b->currentTransform))) { onFail("a->currentTransform (Error: Value not equal)"); };
    if (!((a->supportedCompositeAlpha) == (b->supportedCompositeAlpha))) { onFail("a->supportedCompositeAlpha (Error: Value not equal)"); };
    if (!((a->supportedUsageFlags) == (b->supportedUsageFlags))) { onFail("a->supportedUsageFlags (Error: Value not equal)"); };
    if (!((a->supportedSurfaceCounters) == (b->supportedSurfaceCounters))) { onFail("a->supportedSurfaceCounters (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_display_control
void checkEqual_VkDisplayPowerInfoEXT(
    const VkDisplayPowerInfoEXT* a,
    const VkDisplayPowerInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->powerState) == (b->powerState))) { onFail("a->powerState (Error: Value not equal)"); };
}

void checkEqual_VkDeviceEventInfoEXT(
    const VkDeviceEventInfoEXT* a,
    const VkDeviceEventInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceEvent) == (b->deviceEvent))) { onFail("a->deviceEvent (Error: Value not equal)"); };
}

void checkEqual_VkDisplayEventInfoEXT(
    const VkDisplayEventInfoEXT* a,
    const VkDisplayEventInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->displayEvent) == (b->displayEvent))) { onFail("a->displayEvent (Error: Value not equal)"); };
}

void checkEqual_VkSwapchainCounterCreateInfoEXT(
    const VkSwapchainCounterCreateInfoEXT* a,
    const VkSwapchainCounterCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->surfaceCounters) == (b->surfaceCounters))) { onFail("a->surfaceCounters (Error: Value not equal)"); };
}

#endif
#ifdef VK_GOOGLE_display_timing
void checkEqual_VkRefreshCycleDurationGOOGLE(
    const VkRefreshCycleDurationGOOGLE* a,
    const VkRefreshCycleDurationGOOGLE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->refreshDuration) == (b->refreshDuration))) { onFail("a->refreshDuration (Error: Value not equal)"); };
}

void checkEqual_VkPastPresentationTimingGOOGLE(
    const VkPastPresentationTimingGOOGLE* a,
    const VkPastPresentationTimingGOOGLE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->presentID) == (b->presentID))) { onFail("a->presentID (Error: Value not equal)"); };
    if (!((a->desiredPresentTime) == (b->desiredPresentTime))) { onFail("a->desiredPresentTime (Error: Value not equal)"); };
    if (!((a->actualPresentTime) == (b->actualPresentTime))) { onFail("a->actualPresentTime (Error: Value not equal)"); };
    if (!((a->earliestPresentTime) == (b->earliestPresentTime))) { onFail("a->earliestPresentTime (Error: Value not equal)"); };
    if (!((a->presentMargin) == (b->presentMargin))) { onFail("a->presentMargin (Error: Value not equal)"); };
}

void checkEqual_VkPresentTimeGOOGLE(
    const VkPresentTimeGOOGLE* a,
    const VkPresentTimeGOOGLE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->presentID) == (b->presentID))) { onFail("a->presentID (Error: Value not equal)"); };
    if (!((a->desiredPresentTime) == (b->desiredPresentTime))) { onFail("a->desiredPresentTime (Error: Value not equal)"); };
}

void checkEqual_VkPresentTimesInfoGOOGLE(
    const VkPresentTimesInfoGOOGLE* a,
    const VkPresentTimesInfoGOOGLE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->swapchainCount (Error: Value not equal)"); };
    if (!((!(a->pTimes) && !(b->pTimes)) || ((a->pTimes) && (b->pTimes)))) { onFail("a->pTimes (Error: Mismatch in optional field)"); };
    if (a->pTimes && b->pTimes)
    {
        if ((a->pTimes) && (b->pTimes))
        {
            if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->pTimes (Error: Lengths not equal)"); };
            if ((a->swapchainCount) == (b->swapchainCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->swapchainCount; ++i)
                {
                    checkEqual_VkPresentTimeGOOGLE(a->pTimes + i, b->pTimes + i, onFail);
                }
            }
        }
    }
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void checkEqual_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* a,
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->perViewPositionAllComponents) == (b->perViewPositionAllComponents))) { onFail("a->perViewPositionAllComponents (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_viewport_swizzle
void checkEqual_VkViewportSwizzleNV(
    const VkViewportSwizzleNV* a,
    const VkViewportSwizzleNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->x) == (b->x))) { onFail("a->x (Error: Value not equal)"); };
    if (!((a->y) == (b->y))) { onFail("a->y (Error: Value not equal)"); };
    if (!((a->z) == (b->z))) { onFail("a->z (Error: Value not equal)"); };
    if (!((a->w) == (b->w))) { onFail("a->w (Error: Value not equal)"); };
}

void checkEqual_VkPipelineViewportSwizzleStateCreateInfoNV(
    const VkPipelineViewportSwizzleStateCreateInfoNV* a,
    const VkPipelineViewportSwizzleStateCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->viewportCount) == (b->viewportCount))) { onFail("a->viewportCount (Error: Value not equal)"); };
    if (!((!(a->pViewportSwizzles) && !(b->pViewportSwizzles)) || ((a->pViewportSwizzles) && (b->pViewportSwizzles)))) { onFail("a->pViewportSwizzles (Error: Mismatch in optional field)"); };
    if (a->pViewportSwizzles && b->pViewportSwizzles)
    {
        if ((a->pViewportSwizzles) && (b->pViewportSwizzles))
        {
            if (!((a->viewportCount) == (b->viewportCount))) { onFail("a->pViewportSwizzles (Error: Lengths not equal)"); };
            if ((a->viewportCount) == (b->viewportCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->viewportCount; ++i)
                {
                    checkEqual_VkViewportSwizzleNV(a->pViewportSwizzles + i, b->pViewportSwizzles + i, onFail);
                }
            }
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void checkEqual_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT* a,
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxDiscardRectangles) == (b->maxDiscardRectangles))) { onFail("a->maxDiscardRectangles (Error: Value not equal)"); };
}

void checkEqual_VkPipelineDiscardRectangleStateCreateInfoEXT(
    const VkPipelineDiscardRectangleStateCreateInfoEXT* a,
    const VkPipelineDiscardRectangleStateCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->discardRectangleMode) == (b->discardRectangleMode))) { onFail("a->discardRectangleMode (Error: Value not equal)"); };
    if (!((a->discardRectangleCount) == (b->discardRectangleCount))) { onFail("a->discardRectangleCount (Error: Value not equal)"); };
    if (!((!(a->pDiscardRectangles) && !(b->pDiscardRectangles)) || ((a->pDiscardRectangles) && (b->pDiscardRectangles)))) { onFail("a->pDiscardRectangles (Error: Mismatch in optional field)"); };
    if (a->pDiscardRectangles && b->pDiscardRectangles)
    {
        if ((a->pDiscardRectangles) && (b->pDiscardRectangles))
        {
            if (!((a->discardRectangleCount) == (b->discardRectangleCount))) { onFail("a->pDiscardRectangles (Error: Lengths not equal)"); };
            if ((a->discardRectangleCount) == (b->discardRectangleCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->discardRectangleCount; ++i)
                {
                    checkEqual_VkRect2D(a->pDiscardRectangles + i, b->pDiscardRectangles + i, onFail);
                }
            }
        }
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void checkEqual_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* a,
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->primitiveOverestimationSize) == (b->primitiveOverestimationSize))) { onFail("a->primitiveOverestimationSize (Error: Value not equal)"); };
    if (!((a->maxExtraPrimitiveOverestimationSize) == (b->maxExtraPrimitiveOverestimationSize))) { onFail("a->maxExtraPrimitiveOverestimationSize (Error: Value not equal)"); };
    if (!((a->extraPrimitiveOverestimationSizeGranularity) == (b->extraPrimitiveOverestimationSizeGranularity))) { onFail("a->extraPrimitiveOverestimationSizeGranularity (Error: Value not equal)"); };
    if (!((a->primitiveUnderestimation) == (b->primitiveUnderestimation))) { onFail("a->primitiveUnderestimation (Error: Value not equal)"); };
    if (!((a->conservativePointAndLineRasterization) == (b->conservativePointAndLineRasterization))) { onFail("a->conservativePointAndLineRasterization (Error: Value not equal)"); };
    if (!((a->degenerateTrianglesRasterized) == (b->degenerateTrianglesRasterized))) { onFail("a->degenerateTrianglesRasterized (Error: Value not equal)"); };
    if (!((a->degenerateLinesRasterized) == (b->degenerateLinesRasterized))) { onFail("a->degenerateLinesRasterized (Error: Value not equal)"); };
    if (!((a->fullyCoveredFragmentShaderInputVariable) == (b->fullyCoveredFragmentShaderInputVariable))) { onFail("a->fullyCoveredFragmentShaderInputVariable (Error: Value not equal)"); };
    if (!((a->conservativeRasterizationPostDepthCoverage) == (b->conservativeRasterizationPostDepthCoverage))) { onFail("a->conservativeRasterizationPostDepthCoverage (Error: Value not equal)"); };
}

void checkEqual_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* a,
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->conservativeRasterizationMode) == (b->conservativeRasterizationMode))) { onFail("a->conservativeRasterizationMode (Error: Value not equal)"); };
    if (!((a->extraPrimitiveOverestimationSize) == (b->extraPrimitiveOverestimationSize))) { onFail("a->extraPrimitiveOverestimationSize (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void checkEqual_VkXYColorEXT(
    const VkXYColorEXT* a,
    const VkXYColorEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->x) == (b->x))) { onFail("a->x (Error: Value not equal)"); };
    if (!((a->y) == (b->y))) { onFail("a->y (Error: Value not equal)"); };
}

void checkEqual_VkHdrMetadataEXT(
    const VkHdrMetadataEXT* a,
    const VkHdrMetadataEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkXYColorEXT(&a->displayPrimaryRed, &b->displayPrimaryRed, onFail);
    checkEqual_VkXYColorEXT(&a->displayPrimaryGreen, &b->displayPrimaryGreen, onFail);
    checkEqual_VkXYColorEXT(&a->displayPrimaryBlue, &b->displayPrimaryBlue, onFail);
    checkEqual_VkXYColorEXT(&a->whitePoint, &b->whitePoint, onFail);
    if (!((a->maxLuminance) == (b->maxLuminance))) { onFail("a->maxLuminance (Error: Value not equal)"); };
    if (!((a->minLuminance) == (b->minLuminance))) { onFail("a->minLuminance (Error: Value not equal)"); };
    if (!((a->maxContentLightLevel) == (b->maxContentLightLevel))) { onFail("a->maxContentLightLevel (Error: Value not equal)"); };
    if (!((a->maxFrameAverageLightLevel) == (b->maxFrameAverageLightLevel))) { onFail("a->maxFrameAverageLightLevel (Error: Value not equal)"); };
}

#endif
#ifdef VK_MVK_ios_surface
void checkEqual_VkIOSSurfaceCreateInfoMVK(
    const VkIOSSurfaceCreateInfoMVK* a,
    const VkIOSSurfaceCreateInfoMVK* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->pView) && !(b->pView)) || ((a->pView) && (b->pView)))) { onFail("a->pView (Error: Mismatch in optional field)"); };
}

#endif
#ifdef VK_MVK_macos_surface
void checkEqual_VkMacOSSurfaceCreateInfoMVK(
    const VkMacOSSurfaceCreateInfoMVK* a,
    const VkMacOSSurfaceCreateInfoMVK* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->pView) && !(b->pView)) || ((a->pView) && (b->pView)))) { onFail("a->pView (Error: Mismatch in optional field)"); };
}

#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void checkEqual_VkDebugUtilsObjectNameInfoEXT(
    const VkDebugUtilsObjectNameInfoEXT* a,
    const VkDebugUtilsObjectNameInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->objectType) == (b->objectType))) { onFail("a->objectType (Error: Value not equal)"); };
    if (!((a->objectHandle) == (b->objectHandle))) { onFail("a->objectHandle (Error: Value not equal)"); };
    if (!((!(a->pObjectName) && !(b->pObjectName)) || ((a->pObjectName) && (b->pObjectName)))) { onFail("a->pObjectName (Error: Mismatch in string pointer nullness)"); };
    if ((a->pObjectName) && (b->pObjectName))
    {
        if (!((strcmp(a->pObjectName, b->pObjectName) == 0))) { onFail("a->pObjectName (Error: Unequal strings)"); };
    }
}

void checkEqual_VkDebugUtilsObjectTagInfoEXT(
    const VkDebugUtilsObjectTagInfoEXT* a,
    const VkDebugUtilsObjectTagInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->objectType) == (b->objectType))) { onFail("a->objectType (Error: Value not equal)"); };
    if (!((a->objectHandle) == (b->objectHandle))) { onFail("a->objectHandle (Error: Value not equal)"); };
    if (!((a->tagName) == (b->tagName))) { onFail("a->tagName (Error: Value not equal)"); };
    if (!((a->tagSize) == (b->tagSize))) { onFail("a->tagSize (Error: Value not equal)"); };
}

void checkEqual_VkDebugUtilsLabelEXT(
    const VkDebugUtilsLabelEXT* a,
    const VkDebugUtilsLabelEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pLabelName) && !(b->pLabelName)) || ((a->pLabelName) && (b->pLabelName)))) { onFail("a->pLabelName (Error: Mismatch in string pointer nullness)"); };
    if ((a->pLabelName) && (b->pLabelName))
    {
        if (!((strcmp(a->pLabelName, b->pLabelName) == 0))) { onFail("a->pLabelName (Error: Unequal strings)"); };
    }
    if (!((memcmp(a->color, b->color, 4 * sizeof(float)) == 0))) { onFail("a->color (Error: Unequal static array)"); };
}

void checkEqual_VkDebugUtilsMessengerCallbackDataEXT(
    const VkDebugUtilsMessengerCallbackDataEXT* a,
    const VkDebugUtilsMessengerCallbackDataEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->pMessageIdName) && !(b->pMessageIdName)) || ((a->pMessageIdName) && (b->pMessageIdName)))) { onFail("a->pMessageIdName (Error: Mismatch in string pointer nullness)"); };
    if ((a->pMessageIdName) && (b->pMessageIdName))
    {
        if (!((strcmp(a->pMessageIdName, b->pMessageIdName) == 0))) { onFail("a->pMessageIdName (Error: Unequal strings)"); };
    }
    if (!((a->messageIdNumber) == (b->messageIdNumber))) { onFail("a->messageIdNumber (Error: Value not equal)"); };
    if (!((!(a->pMessage) && !(b->pMessage)) || ((a->pMessage) && (b->pMessage)))) { onFail("a->pMessage (Error: Mismatch in string pointer nullness)"); };
    if ((a->pMessage) && (b->pMessage))
    {
        if (!((strcmp(a->pMessage, b->pMessage) == 0))) { onFail("a->pMessage (Error: Unequal strings)"); };
    }
    if (!((a->queueLabelCount) == (b->queueLabelCount))) { onFail("a->queueLabelCount (Error: Value not equal)"); };
    if (!((!(a->pQueueLabels) && !(b->pQueueLabels)) || ((a->pQueueLabels) && (b->pQueueLabels)))) { onFail("a->pQueueLabels (Error: Mismatch in optional field)"); };
    if (a->pQueueLabels && b->pQueueLabels)
    {
        if ((a->pQueueLabels) && (b->pQueueLabels))
        {
            if (!((a->queueLabelCount) == (b->queueLabelCount))) { onFail("a->pQueueLabels (Error: Lengths not equal)"); };
            if ((a->queueLabelCount) == (b->queueLabelCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->queueLabelCount; ++i)
                {
                    checkEqual_VkDebugUtilsLabelEXT(a->pQueueLabels + i, b->pQueueLabels + i, onFail);
                }
            }
        }
    }
    if (!((a->cmdBufLabelCount) == (b->cmdBufLabelCount))) { onFail("a->cmdBufLabelCount (Error: Value not equal)"); };
    if (!((!(a->pCmdBufLabels) && !(b->pCmdBufLabels)) || ((a->pCmdBufLabels) && (b->pCmdBufLabels)))) { onFail("a->pCmdBufLabels (Error: Mismatch in optional field)"); };
    if (a->pCmdBufLabels && b->pCmdBufLabels)
    {
        if ((a->pCmdBufLabels) && (b->pCmdBufLabels))
        {
            if (!((a->cmdBufLabelCount) == (b->cmdBufLabelCount))) { onFail("a->pCmdBufLabels (Error: Lengths not equal)"); };
            if ((a->cmdBufLabelCount) == (b->cmdBufLabelCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->cmdBufLabelCount; ++i)
                {
                    checkEqual_VkDebugUtilsLabelEXT(a->pCmdBufLabels + i, b->pCmdBufLabels + i, onFail);
                }
            }
        }
    }
    if (!((a->objectCount) == (b->objectCount))) { onFail("a->objectCount (Error: Value not equal)"); };
    if (!((!(a->pObjects) && !(b->pObjects)) || ((a->pObjects) && (b->pObjects)))) { onFail("a->pObjects (Error: Mismatch in optional field)"); };
    if (a->pObjects && b->pObjects)
    {
        if ((a->pObjects) && (b->pObjects))
        {
            if (!((a->objectCount) == (b->objectCount))) { onFail("a->pObjects (Error: Lengths not equal)"); };
            if ((a->objectCount) == (b->objectCount))
            {
                for (uint32_t i = 0; i < (uint32_t)a->objectCount; ++i)
                {
                    checkEqual_VkDebugUtilsObjectNameInfoEXT(a->pObjects + i, b->pObjects + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkDebugUtilsMessengerCreateInfoEXT(
    const VkDebugUtilsMessengerCreateInfoEXT* a,
    const VkDebugUtilsMessengerCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->messageSeverity) == (b->messageSeverity))) { onFail("a->messageSeverity (Error: Value not equal)"); };
    if (!((a->messageType) == (b->messageType))) { onFail("a->messageType (Error: Value not equal)"); };
    if (!((a->pfnUserCallback) == (b->pfnUserCallback))) { onFail("a->pfnUserCallback (Error: Value not equal)"); };
    if (!((!(a->pUserData) && !(b->pUserData)) || ((a->pUserData) && (b->pUserData)))) { onFail("a->pUserData (Error: Mismatch in optional field)"); };
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void checkEqual_VkAndroidHardwareBufferUsageANDROID(
    const VkAndroidHardwareBufferUsageANDROID* a,
    const VkAndroidHardwareBufferUsageANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->androidHardwareBufferUsage) == (b->androidHardwareBufferUsage))) { onFail("a->androidHardwareBufferUsage (Error: Value not equal)"); };
}

void checkEqual_VkAndroidHardwareBufferPropertiesANDROID(
    const VkAndroidHardwareBufferPropertiesANDROID* a,
    const VkAndroidHardwareBufferPropertiesANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->allocationSize) == (b->allocationSize))) { onFail("a->allocationSize (Error: Value not equal)"); };
    if (!((a->memoryTypeBits) == (b->memoryTypeBits))) { onFail("a->memoryTypeBits (Error: Value not equal)"); };
}

void checkEqual_VkAndroidHardwareBufferFormatPropertiesANDROID(
    const VkAndroidHardwareBufferFormatPropertiesANDROID* a,
    const VkAndroidHardwareBufferFormatPropertiesANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->externalFormat) == (b->externalFormat))) { onFail("a->externalFormat (Error: Value not equal)"); };
    if (!((a->formatFeatures) == (b->formatFeatures))) { onFail("a->formatFeatures (Error: Value not equal)"); };
    checkEqual_VkComponentMapping(&a->samplerYcbcrConversionComponents, &b->samplerYcbcrConversionComponents, onFail);
    if (!((a->suggestedYcbcrModel) == (b->suggestedYcbcrModel))) { onFail("a->suggestedYcbcrModel (Error: Value not equal)"); };
    if (!((a->suggestedYcbcrRange) == (b->suggestedYcbcrRange))) { onFail("a->suggestedYcbcrRange (Error: Value not equal)"); };
    if (!((a->suggestedXChromaOffset) == (b->suggestedXChromaOffset))) { onFail("a->suggestedXChromaOffset (Error: Value not equal)"); };
    if (!((a->suggestedYChromaOffset) == (b->suggestedYChromaOffset))) { onFail("a->suggestedYChromaOffset (Error: Value not equal)"); };
}

void checkEqual_VkImportAndroidHardwareBufferInfoANDROID(
    const VkImportAndroidHardwareBufferInfoANDROID* a,
    const VkImportAndroidHardwareBufferInfoANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->buffer, b->buffer, sizeof(AHardwareBuffer)) == 0))) { onFail("a->buffer (Error: Unequal dyn array)"); };
}

void checkEqual_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* a,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
}

void checkEqual_VkExternalFormatANDROID(
    const VkExternalFormatANDROID* a,
    const VkExternalFormatANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->externalFormat) == (b->externalFormat))) { onFail("a->externalFormat (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
void checkEqual_VkSamplerReductionModeCreateInfoEXT(
    const VkSamplerReductionModeCreateInfoEXT* a,
    const VkSamplerReductionModeCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->reductionMode) == (b->reductionMode))) { onFail("a->reductionMode (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
    const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* a,
    const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->filterMinmaxSingleComponentFormats) == (b->filterMinmaxSingleComponentFormats))) { onFail("a->filterMinmaxSingleComponentFormats (Error: Value not equal)"); };
    if (!((a->filterMinmaxImageComponentMapping) == (b->filterMinmaxImageComponentMapping))) { onFail("a->filterMinmaxImageComponentMapping (Error: Value not equal)"); };
}

#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void checkEqual_VkSampleLocationEXT(
    const VkSampleLocationEXT* a,
    const VkSampleLocationEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->x) == (b->x))) { onFail("a->x (Error: Value not equal)"); };
    if (!((a->y) == (b->y))) { onFail("a->y (Error: Value not equal)"); };
}

void checkEqual_VkSampleLocationsInfoEXT(
    const VkSampleLocationsInfoEXT* a,
    const VkSampleLocationsInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->sampleLocationsPerPixel) == (b->sampleLocationsPerPixel))) { onFail("a->sampleLocationsPerPixel (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->sampleLocationGridSize, &b->sampleLocationGridSize, onFail);
    if (!((a->sampleLocationsCount) == (b->sampleLocationsCount))) { onFail("a->sampleLocationsCount (Error: Value not equal)"); };
    if ((a->pSampleLocations) && (b->pSampleLocations))
    {
        if (!((a->sampleLocationsCount) == (b->sampleLocationsCount))) { onFail("a->pSampleLocations (Error: Lengths not equal)"); };
        if ((a->sampleLocationsCount) == (b->sampleLocationsCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->sampleLocationsCount; ++i)
            {
                checkEqual_VkSampleLocationEXT(a->pSampleLocations + i, b->pSampleLocations + i, onFail);
            }
        }
    }
}

void checkEqual_VkAttachmentSampleLocationsEXT(
    const VkAttachmentSampleLocationsEXT* a,
    const VkAttachmentSampleLocationsEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->attachmentIndex) == (b->attachmentIndex))) { onFail("a->attachmentIndex (Error: Value not equal)"); };
    checkEqual_VkSampleLocationsInfoEXT(&a->sampleLocationsInfo, &b->sampleLocationsInfo, onFail);
}

void checkEqual_VkSubpassSampleLocationsEXT(
    const VkSubpassSampleLocationsEXT* a,
    const VkSubpassSampleLocationsEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->subpassIndex) == (b->subpassIndex))) { onFail("a->subpassIndex (Error: Value not equal)"); };
    checkEqual_VkSampleLocationsInfoEXT(&a->sampleLocationsInfo, &b->sampleLocationsInfo, onFail);
}

void checkEqual_VkRenderPassSampleLocationsBeginInfoEXT(
    const VkRenderPassSampleLocationsBeginInfoEXT* a,
    const VkRenderPassSampleLocationsBeginInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->attachmentInitialSampleLocationsCount) == (b->attachmentInitialSampleLocationsCount))) { onFail("a->attachmentInitialSampleLocationsCount (Error: Value not equal)"); };
    if ((a->pAttachmentInitialSampleLocations) && (b->pAttachmentInitialSampleLocations))
    {
        if (!((a->attachmentInitialSampleLocationsCount) == (b->attachmentInitialSampleLocationsCount))) { onFail("a->pAttachmentInitialSampleLocations (Error: Lengths not equal)"); };
        if ((a->attachmentInitialSampleLocationsCount) == (b->attachmentInitialSampleLocationsCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->attachmentInitialSampleLocationsCount; ++i)
            {
                checkEqual_VkAttachmentSampleLocationsEXT(a->pAttachmentInitialSampleLocations + i, b->pAttachmentInitialSampleLocations + i, onFail);
            }
        }
    }
    if (!((a->postSubpassSampleLocationsCount) == (b->postSubpassSampleLocationsCount))) { onFail("a->postSubpassSampleLocationsCount (Error: Value not equal)"); };
    if ((a->pPostSubpassSampleLocations) && (b->pPostSubpassSampleLocations))
    {
        if (!((a->postSubpassSampleLocationsCount) == (b->postSubpassSampleLocationsCount))) { onFail("a->pPostSubpassSampleLocations (Error: Lengths not equal)"); };
        if ((a->postSubpassSampleLocationsCount) == (b->postSubpassSampleLocationsCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->postSubpassSampleLocationsCount; ++i)
            {
                checkEqual_VkSubpassSampleLocationsEXT(a->pPostSubpassSampleLocations + i, b->pPostSubpassSampleLocations + i, onFail);
            }
        }
    }
}

void checkEqual_VkPipelineSampleLocationsStateCreateInfoEXT(
    const VkPipelineSampleLocationsStateCreateInfoEXT* a,
    const VkPipelineSampleLocationsStateCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->sampleLocationsEnable) == (b->sampleLocationsEnable))) { onFail("a->sampleLocationsEnable (Error: Value not equal)"); };
    checkEqual_VkSampleLocationsInfoEXT(&a->sampleLocationsInfo, &b->sampleLocationsInfo, onFail);
}

void checkEqual_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    const VkPhysicalDeviceSampleLocationsPropertiesEXT* a,
    const VkPhysicalDeviceSampleLocationsPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->sampleLocationSampleCounts) == (b->sampleLocationSampleCounts))) { onFail("a->sampleLocationSampleCounts (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->maxSampleLocationGridSize, &b->maxSampleLocationGridSize, onFail);
    if (!((memcmp(a->sampleLocationCoordinateRange, b->sampleLocationCoordinateRange, 2 * sizeof(float)) == 0))) { onFail("a->sampleLocationCoordinateRange (Error: Unequal static array)"); };
    if (!((a->sampleLocationSubPixelBits) == (b->sampleLocationSubPixelBits))) { onFail("a->sampleLocationSubPixelBits (Error: Value not equal)"); };
    if (!((a->variableSampleLocations) == (b->variableSampleLocations))) { onFail("a->variableSampleLocations (Error: Value not equal)"); };
}

void checkEqual_VkMultisamplePropertiesEXT(
    const VkMultisamplePropertiesEXT* a,
    const VkMultisamplePropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkExtent2D(&a->maxSampleLocationGridSize, &b->maxSampleLocationGridSize, onFail);
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void checkEqual_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* a,
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->advancedBlendCoherentOperations) == (b->advancedBlendCoherentOperations))) { onFail("a->advancedBlendCoherentOperations (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* a,
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->advancedBlendMaxColorAttachments) == (b->advancedBlendMaxColorAttachments))) { onFail("a->advancedBlendMaxColorAttachments (Error: Value not equal)"); };
    if (!((a->advancedBlendIndependentBlend) == (b->advancedBlendIndependentBlend))) { onFail("a->advancedBlendIndependentBlend (Error: Value not equal)"); };
    if (!((a->advancedBlendNonPremultipliedSrcColor) == (b->advancedBlendNonPremultipliedSrcColor))) { onFail("a->advancedBlendNonPremultipliedSrcColor (Error: Value not equal)"); };
    if (!((a->advancedBlendNonPremultipliedDstColor) == (b->advancedBlendNonPremultipliedDstColor))) { onFail("a->advancedBlendNonPremultipliedDstColor (Error: Value not equal)"); };
    if (!((a->advancedBlendCorrelatedOverlap) == (b->advancedBlendCorrelatedOverlap))) { onFail("a->advancedBlendCorrelatedOverlap (Error: Value not equal)"); };
    if (!((a->advancedBlendAllOperations) == (b->advancedBlendAllOperations))) { onFail("a->advancedBlendAllOperations (Error: Value not equal)"); };
}

void checkEqual_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT* a,
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcPremultiplied) == (b->srcPremultiplied))) { onFail("a->srcPremultiplied (Error: Value not equal)"); };
    if (!((a->dstPremultiplied) == (b->dstPremultiplied))) { onFail("a->dstPremultiplied (Error: Value not equal)"); };
    if (!((a->blendOverlap) == (b->blendOverlap))) { onFail("a->blendOverlap (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void checkEqual_VkPipelineCoverageToColorStateCreateInfoNV(
    const VkPipelineCoverageToColorStateCreateInfoNV* a,
    const VkPipelineCoverageToColorStateCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->coverageToColorEnable) == (b->coverageToColorEnable))) { onFail("a->coverageToColorEnable (Error: Value not equal)"); };
    if (!((a->coverageToColorLocation) == (b->coverageToColorLocation))) { onFail("a->coverageToColorLocation (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void checkEqual_VkPipelineCoverageModulationStateCreateInfoNV(
    const VkPipelineCoverageModulationStateCreateInfoNV* a,
    const VkPipelineCoverageModulationStateCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->coverageModulationMode) == (b->coverageModulationMode))) { onFail("a->coverageModulationMode (Error: Value not equal)"); };
    if (!((a->coverageModulationTableEnable) == (b->coverageModulationTableEnable))) { onFail("a->coverageModulationTableEnable (Error: Value not equal)"); };
    if (!((a->coverageModulationTableCount) == (b->coverageModulationTableCount))) { onFail("a->coverageModulationTableCount (Error: Value not equal)"); };
    if (!((!(a->pCoverageModulationTable) && !(b->pCoverageModulationTable)) || ((a->pCoverageModulationTable) && (b->pCoverageModulationTable)))) { onFail("a->pCoverageModulationTable (Error: Mismatch in optional field)"); };
    if (a->pCoverageModulationTable && b->pCoverageModulationTable)
    {
        if (!((a->coverageModulationTableCount) == (b->coverageModulationTableCount))) { onFail("a->pCoverageModulationTable (Error: Lengths not equal)"); };
        if (!((memcmp(a->pCoverageModulationTable, b->pCoverageModulationTable, a->coverageModulationTableCount * sizeof(const float)) == 0))) { onFail("a->pCoverageModulationTable (Error: Unequal dyn array)"); };
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
void checkEqual_VkValidationCacheCreateInfoEXT(
    const VkValidationCacheCreateInfoEXT* a,
    const VkValidationCacheCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->initialDataSize) == (b->initialDataSize))) { onFail("a->initialDataSize (Error: Value not equal)"); };
}

void checkEqual_VkShaderModuleValidationCacheCreateInfoEXT(
    const VkShaderModuleValidationCacheCreateInfoEXT* a,
    const VkShaderModuleValidationCacheCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->validationCache) == (b->validationCache))) { onFail("a->validationCache (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_descriptor_indexing
void checkEqual_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(
    const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* a,
    const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->bindingCount) == (b->bindingCount))) { onFail("a->bindingCount (Error: Value not equal)"); };
    if (!((a->bindingCount) == (b->bindingCount))) { onFail("a->pBindingFlags (Error: Lengths not equal)"); };
    if (!((memcmp(a->pBindingFlags, b->pBindingFlags, a->bindingCount * sizeof(const VkDescriptorBindingFlagsEXT)) == 0))) { onFail("a->pBindingFlags (Error: Unequal dyn array)"); };
}

void checkEqual_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(
    const VkPhysicalDeviceDescriptorIndexingFeaturesEXT* a,
    const VkPhysicalDeviceDescriptorIndexingFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderInputAttachmentArrayDynamicIndexing) == (b->shaderInputAttachmentArrayDynamicIndexing))) { onFail("a->shaderInputAttachmentArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderUniformTexelBufferArrayDynamicIndexing) == (b->shaderUniformTexelBufferArrayDynamicIndexing))) { onFail("a->shaderUniformTexelBufferArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageTexelBufferArrayDynamicIndexing) == (b->shaderStorageTexelBufferArrayDynamicIndexing))) { onFail("a->shaderStorageTexelBufferArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderUniformBufferArrayNonUniformIndexing) == (b->shaderUniformBufferArrayNonUniformIndexing))) { onFail("a->shaderUniformBufferArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderSampledImageArrayNonUniformIndexing) == (b->shaderSampledImageArrayNonUniformIndexing))) { onFail("a->shaderSampledImageArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageBufferArrayNonUniformIndexing) == (b->shaderStorageBufferArrayNonUniformIndexing))) { onFail("a->shaderStorageBufferArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageImageArrayNonUniformIndexing) == (b->shaderStorageImageArrayNonUniformIndexing))) { onFail("a->shaderStorageImageArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderInputAttachmentArrayNonUniformIndexing) == (b->shaderInputAttachmentArrayNonUniformIndexing))) { onFail("a->shaderInputAttachmentArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderUniformTexelBufferArrayNonUniformIndexing) == (b->shaderUniformTexelBufferArrayNonUniformIndexing))) { onFail("a->shaderUniformTexelBufferArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageTexelBufferArrayNonUniformIndexing) == (b->shaderStorageTexelBufferArrayNonUniformIndexing))) { onFail("a->shaderStorageTexelBufferArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->descriptorBindingUniformBufferUpdateAfterBind) == (b->descriptorBindingUniformBufferUpdateAfterBind))) { onFail("a->descriptorBindingUniformBufferUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingSampledImageUpdateAfterBind) == (b->descriptorBindingSampledImageUpdateAfterBind))) { onFail("a->descriptorBindingSampledImageUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingStorageImageUpdateAfterBind) == (b->descriptorBindingStorageImageUpdateAfterBind))) { onFail("a->descriptorBindingStorageImageUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingStorageBufferUpdateAfterBind) == (b->descriptorBindingStorageBufferUpdateAfterBind))) { onFail("a->descriptorBindingStorageBufferUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingUniformTexelBufferUpdateAfterBind) == (b->descriptorBindingUniformTexelBufferUpdateAfterBind))) { onFail("a->descriptorBindingUniformTexelBufferUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingStorageTexelBufferUpdateAfterBind) == (b->descriptorBindingStorageTexelBufferUpdateAfterBind))) { onFail("a->descriptorBindingStorageTexelBufferUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingUpdateUnusedWhilePending) == (b->descriptorBindingUpdateUnusedWhilePending))) { onFail("a->descriptorBindingUpdateUnusedWhilePending (Error: Value not equal)"); };
    if (!((a->descriptorBindingPartiallyBound) == (b->descriptorBindingPartiallyBound))) { onFail("a->descriptorBindingPartiallyBound (Error: Value not equal)"); };
    if (!((a->descriptorBindingVariableDescriptorCount) == (b->descriptorBindingVariableDescriptorCount))) { onFail("a->descriptorBindingVariableDescriptorCount (Error: Value not equal)"); };
    if (!((a->runtimeDescriptorArray) == (b->runtimeDescriptorArray))) { onFail("a->runtimeDescriptorArray (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(
    const VkPhysicalDeviceDescriptorIndexingPropertiesEXT* a,
    const VkPhysicalDeviceDescriptorIndexingPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxUpdateAfterBindDescriptorsInAllPools) == (b->maxUpdateAfterBindDescriptorsInAllPools))) { onFail("a->maxUpdateAfterBindDescriptorsInAllPools (Error: Value not equal)"); };
    if (!((a->shaderUniformBufferArrayNonUniformIndexingNative) == (b->shaderUniformBufferArrayNonUniformIndexingNative))) { onFail("a->shaderUniformBufferArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->shaderSampledImageArrayNonUniformIndexingNative) == (b->shaderSampledImageArrayNonUniformIndexingNative))) { onFail("a->shaderSampledImageArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->shaderStorageBufferArrayNonUniformIndexingNative) == (b->shaderStorageBufferArrayNonUniformIndexingNative))) { onFail("a->shaderStorageBufferArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->shaderStorageImageArrayNonUniformIndexingNative) == (b->shaderStorageImageArrayNonUniformIndexingNative))) { onFail("a->shaderStorageImageArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->shaderInputAttachmentArrayNonUniformIndexingNative) == (b->shaderInputAttachmentArrayNonUniformIndexingNative))) { onFail("a->shaderInputAttachmentArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->robustBufferAccessUpdateAfterBind) == (b->robustBufferAccessUpdateAfterBind))) { onFail("a->robustBufferAccessUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->quadDivergentImplicitLod) == (b->quadDivergentImplicitLod))) { onFail("a->quadDivergentImplicitLod (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindSamplers) == (b->maxPerStageDescriptorUpdateAfterBindSamplers))) { onFail("a->maxPerStageDescriptorUpdateAfterBindSamplers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindUniformBuffers) == (b->maxPerStageDescriptorUpdateAfterBindUniformBuffers))) { onFail("a->maxPerStageDescriptorUpdateAfterBindUniformBuffers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindStorageBuffers) == (b->maxPerStageDescriptorUpdateAfterBindStorageBuffers))) { onFail("a->maxPerStageDescriptorUpdateAfterBindStorageBuffers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindSampledImages) == (b->maxPerStageDescriptorUpdateAfterBindSampledImages))) { onFail("a->maxPerStageDescriptorUpdateAfterBindSampledImages (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindStorageImages) == (b->maxPerStageDescriptorUpdateAfterBindStorageImages))) { onFail("a->maxPerStageDescriptorUpdateAfterBindStorageImages (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindInputAttachments) == (b->maxPerStageDescriptorUpdateAfterBindInputAttachments))) { onFail("a->maxPerStageDescriptorUpdateAfterBindInputAttachments (Error: Value not equal)"); };
    if (!((a->maxPerStageUpdateAfterBindResources) == (b->maxPerStageUpdateAfterBindResources))) { onFail("a->maxPerStageUpdateAfterBindResources (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindSamplers) == (b->maxDescriptorSetUpdateAfterBindSamplers))) { onFail("a->maxDescriptorSetUpdateAfterBindSamplers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindUniformBuffers) == (b->maxDescriptorSetUpdateAfterBindUniformBuffers))) { onFail("a->maxDescriptorSetUpdateAfterBindUniformBuffers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic) == (b->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic))) { onFail("a->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindStorageBuffers) == (b->maxDescriptorSetUpdateAfterBindStorageBuffers))) { onFail("a->maxDescriptorSetUpdateAfterBindStorageBuffers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic) == (b->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic))) { onFail("a->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindSampledImages) == (b->maxDescriptorSetUpdateAfterBindSampledImages))) { onFail("a->maxDescriptorSetUpdateAfterBindSampledImages (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindStorageImages) == (b->maxDescriptorSetUpdateAfterBindStorageImages))) { onFail("a->maxDescriptorSetUpdateAfterBindStorageImages (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindInputAttachments) == (b->maxDescriptorSetUpdateAfterBindInputAttachments))) { onFail("a->maxDescriptorSetUpdateAfterBindInputAttachments (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(
    const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* a,
    const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->descriptorSetCount) == (b->descriptorSetCount))) { onFail("a->descriptorSetCount (Error: Value not equal)"); };
    if (!((a->descriptorSetCount) == (b->descriptorSetCount))) { onFail("a->pDescriptorCounts (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDescriptorCounts, b->pDescriptorCounts, a->descriptorSetCount * sizeof(const uint32_t)) == 0))) { onFail("a->pDescriptorCounts (Error: Unequal dyn array)"); };
}

void checkEqual_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(
    const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* a,
    const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxVariableDescriptorCount) == (b->maxVariableDescriptorCount))) { onFail("a->maxVariableDescriptorCount (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
void checkEqual_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    const VkDeviceQueueGlobalPriorityCreateInfoEXT* a,
    const VkDeviceQueueGlobalPriorityCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->globalPriority) == (b->globalPriority))) { onFail("a->globalPriority (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_external_memory_host
void checkEqual_VkImportMemoryHostPointerInfoEXT(
    const VkImportMemoryHostPointerInfoEXT* a,
    const VkImportMemoryHostPointerInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((!(a->pHostPointer) && !(b->pHostPointer)) || ((a->pHostPointer) && (b->pHostPointer)))) { onFail("a->pHostPointer (Error: Mismatch in optional field)"); };
}

void checkEqual_VkMemoryHostPointerPropertiesEXT(
    const VkMemoryHostPointerPropertiesEXT* a,
    const VkMemoryHostPointerPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memoryTypeBits) == (b->memoryTypeBits))) { onFail("a->memoryTypeBits (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* a,
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->minImportedHostPointerAlignment) == (b->minImportedHostPointerAlignment))) { onFail("a->minImportedHostPointerAlignment (Error: Value not equal)"); };
}

#endif
#ifdef VK_AMD_buffer_marker
#endif
#ifdef VK_AMD_shader_core_properties
void checkEqual_VkPhysicalDeviceShaderCorePropertiesAMD(
    const VkPhysicalDeviceShaderCorePropertiesAMD* a,
    const VkPhysicalDeviceShaderCorePropertiesAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderEngineCount) == (b->shaderEngineCount))) { onFail("a->shaderEngineCount (Error: Value not equal)"); };
    if (!((a->shaderArraysPerEngineCount) == (b->shaderArraysPerEngineCount))) { onFail("a->shaderArraysPerEngineCount (Error: Value not equal)"); };
    if (!((a->computeUnitsPerShaderArray) == (b->computeUnitsPerShaderArray))) { onFail("a->computeUnitsPerShaderArray (Error: Value not equal)"); };
    if (!((a->simdPerComputeUnit) == (b->simdPerComputeUnit))) { onFail("a->simdPerComputeUnit (Error: Value not equal)"); };
    if (!((a->wavefrontsPerSimd) == (b->wavefrontsPerSimd))) { onFail("a->wavefrontsPerSimd (Error: Value not equal)"); };
    if (!((a->wavefrontSize) == (b->wavefrontSize))) { onFail("a->wavefrontSize (Error: Value not equal)"); };
    if (!((a->sgprsPerSimd) == (b->sgprsPerSimd))) { onFail("a->sgprsPerSimd (Error: Value not equal)"); };
    if (!((a->minSgprAllocation) == (b->minSgprAllocation))) { onFail("a->minSgprAllocation (Error: Value not equal)"); };
    if (!((a->maxSgprAllocation) == (b->maxSgprAllocation))) { onFail("a->maxSgprAllocation (Error: Value not equal)"); };
    if (!((a->sgprAllocationGranularity) == (b->sgprAllocationGranularity))) { onFail("a->sgprAllocationGranularity (Error: Value not equal)"); };
    if (!((a->vgprsPerSimd) == (b->vgprsPerSimd))) { onFail("a->vgprsPerSimd (Error: Value not equal)"); };
    if (!((a->minVgprAllocation) == (b->minVgprAllocation))) { onFail("a->minVgprAllocation (Error: Value not equal)"); };
    if (!((a->maxVgprAllocation) == (b->maxVgprAllocation))) { onFail("a->maxVgprAllocation (Error: Value not equal)"); };
    if (!((a->vgprAllocationGranularity) == (b->vgprAllocationGranularity))) { onFail("a->vgprAllocationGranularity (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void checkEqual_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* a,
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxVertexAttribDivisor) == (b->maxVertexAttribDivisor))) { onFail("a->maxVertexAttribDivisor (Error: Value not equal)"); };
}

void checkEqual_VkVertexInputBindingDivisorDescriptionEXT(
    const VkVertexInputBindingDivisorDescriptionEXT* a,
    const VkVertexInputBindingDivisorDescriptionEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->binding) == (b->binding))) { onFail("a->binding (Error: Value not equal)"); };
    if (!((a->divisor) == (b->divisor))) { onFail("a->divisor (Error: Value not equal)"); };
}

void checkEqual_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    const VkPipelineVertexInputDivisorStateCreateInfoEXT* a,
    const VkPipelineVertexInputDivisorStateCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->vertexBindingDivisorCount) == (b->vertexBindingDivisorCount))) { onFail("a->vertexBindingDivisorCount (Error: Value not equal)"); };
    if ((a->pVertexBindingDivisors) && (b->pVertexBindingDivisors))
    {
        if (!((a->vertexBindingDivisorCount) == (b->vertexBindingDivisorCount))) { onFail("a->pVertexBindingDivisors (Error: Lengths not equal)"); };
        if ((a->vertexBindingDivisorCount) == (b->vertexBindingDivisorCount))
        {
            for (uint32_t i = 0; i < (uint32_t)a->vertexBindingDivisorCount; ++i)
            {
                checkEqual_VkVertexInputBindingDivisorDescriptionEXT(a->pVertexBindingDivisors + i, b->pVertexBindingDivisors + i, onFail);
            }
        }
    }
}

#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void checkEqual_VkQueueFamilyCheckpointPropertiesNV(
    const VkQueueFamilyCheckpointPropertiesNV* a,
    const VkQueueFamilyCheckpointPropertiesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->checkpointExecutionStageMask) == (b->checkpointExecutionStageMask))) { onFail("a->checkpointExecutionStageMask (Error: Value not equal)"); };
}

void checkEqual_VkCheckpointDataNV(
    const VkCheckpointDataNV* a,
    const VkCheckpointDataNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->stage) == (b->stage))) { onFail("a->stage (Error: Value not equal)"); };
    if (!((!(a->pCheckpointMarker) && !(b->pCheckpointMarker)) || ((a->pCheckpointMarker) && (b->pCheckpointMarker)))) { onFail("a->pCheckpointMarker (Error: Mismatch in optional field)"); };
}

#endif
#ifdef VK_GOOGLE_address_space
#endif
#ifdef VK_GOOGLE_color_buffer
void checkEqual_VkImportColorBufferGOOGLE(
    const VkImportColorBufferGOOGLE* a,
    const VkImportColorBufferGOOGLE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->colorBuffer) == (b->colorBuffer))) { onFail("a->colorBuffer (Error: Value not equal)"); };
}

void checkEqual_VkImportPhysicalAddressGOOGLE(
    const VkImportPhysicalAddressGOOGLE* a,
    const VkImportPhysicalAddressGOOGLE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->physicalAddress) == (b->physicalAddress))) { onFail("a->physicalAddress (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->tiling) == (b->tiling))) { onFail("a->tiling (Error: Value not equal)"); };
    if (!((a->tilingParameter) == (b->tilingParameter))) { onFail("a->tilingParameter (Error: Value not equal)"); };
}

#endif
#ifdef VK_GOOGLE_sized_descriptor_update_template
#endif
#ifdef VK_GOOGLE_async_command_buffers
#endif
void checkEqual_extension_struct(
    const void* structExtension,
    const void* structExtension2,
    OnFailCompareFunc onFail)
{
    if (!structExtension)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceSubgroupProperties(reinterpret_cast<const VkPhysicalDeviceSubgroupProperties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceSubgroupProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            checkEqual_VkPhysicalDevice16BitStorageFeatures(reinterpret_cast<const VkPhysicalDevice16BitStorageFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDevice16BitStorageFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            checkEqual_VkMemoryDedicatedRequirements(reinterpret_cast<const VkMemoryDedicatedRequirements*>(structExtension), reinterpret_cast<const VkMemoryDedicatedRequirements*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            checkEqual_VkMemoryDedicatedAllocateInfo(reinterpret_cast<const VkMemoryDedicatedAllocateInfo*>(structExtension), reinterpret_cast<const VkMemoryDedicatedAllocateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            checkEqual_VkMemoryAllocateFlagsInfo(reinterpret_cast<const VkMemoryAllocateFlagsInfo*>(structExtension), reinterpret_cast<const VkMemoryAllocateFlagsInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            checkEqual_VkDeviceGroupRenderPassBeginInfo(reinterpret_cast<const VkDeviceGroupRenderPassBeginInfo*>(structExtension), reinterpret_cast<const VkDeviceGroupRenderPassBeginInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            checkEqual_VkDeviceGroupCommandBufferBeginInfo(reinterpret_cast<const VkDeviceGroupCommandBufferBeginInfo*>(structExtension), reinterpret_cast<const VkDeviceGroupCommandBufferBeginInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            checkEqual_VkDeviceGroupSubmitInfo(reinterpret_cast<const VkDeviceGroupSubmitInfo*>(structExtension), reinterpret_cast<const VkDeviceGroupSubmitInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            checkEqual_VkDeviceGroupBindSparseInfo(reinterpret_cast<const VkDeviceGroupBindSparseInfo*>(structExtension), reinterpret_cast<const VkDeviceGroupBindSparseInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            checkEqual_VkBindBufferMemoryDeviceGroupInfo(reinterpret_cast<const VkBindBufferMemoryDeviceGroupInfo*>(structExtension), reinterpret_cast<const VkBindBufferMemoryDeviceGroupInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            checkEqual_VkBindImageMemoryDeviceGroupInfo(reinterpret_cast<const VkBindImageMemoryDeviceGroupInfo*>(structExtension), reinterpret_cast<const VkBindImageMemoryDeviceGroupInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            checkEqual_VkDeviceGroupDeviceCreateInfo(reinterpret_cast<const VkDeviceGroupDeviceCreateInfo*>(structExtension), reinterpret_cast<const VkDeviceGroupDeviceCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            checkEqual_VkPhysicalDeviceFeatures2(reinterpret_cast<const VkPhysicalDeviceFeatures2*>(structExtension), reinterpret_cast<const VkPhysicalDeviceFeatures2*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            checkEqual_VkPhysicalDevicePointClippingProperties(reinterpret_cast<const VkPhysicalDevicePointClippingProperties*>(structExtension), reinterpret_cast<const VkPhysicalDevicePointClippingProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            checkEqual_VkRenderPassInputAttachmentAspectCreateInfo(reinterpret_cast<const VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension), reinterpret_cast<const VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            checkEqual_VkImageViewUsageCreateInfo(reinterpret_cast<const VkImageViewUsageCreateInfo*>(structExtension), reinterpret_cast<const VkImageViewUsageCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            checkEqual_VkPipelineTessellationDomainOriginStateCreateInfo(reinterpret_cast<const VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension), reinterpret_cast<const VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            checkEqual_VkRenderPassMultiviewCreateInfo(reinterpret_cast<const VkRenderPassMultiviewCreateInfo*>(structExtension), reinterpret_cast<const VkRenderPassMultiviewCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            checkEqual_VkPhysicalDeviceMultiviewFeatures(reinterpret_cast<const VkPhysicalDeviceMultiviewFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMultiviewFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceMultiviewProperties(reinterpret_cast<const VkPhysicalDeviceMultiviewProperties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMultiviewProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES:
        {
            checkEqual_VkPhysicalDeviceVariablePointerFeatures(reinterpret_cast<const VkPhysicalDeviceVariablePointerFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceVariablePointerFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            checkEqual_VkPhysicalDeviceProtectedMemoryFeatures(reinterpret_cast<const VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceProtectedMemoryProperties(reinterpret_cast<const VkPhysicalDeviceProtectedMemoryProperties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceProtectedMemoryProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            checkEqual_VkProtectedSubmitInfo(reinterpret_cast<const VkProtectedSubmitInfo*>(structExtension), reinterpret_cast<const VkProtectedSubmitInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            checkEqual_VkSamplerYcbcrConversionInfo(reinterpret_cast<const VkSamplerYcbcrConversionInfo*>(structExtension), reinterpret_cast<const VkSamplerYcbcrConversionInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            checkEqual_VkBindImagePlaneMemoryInfo(reinterpret_cast<const VkBindImagePlaneMemoryInfo*>(structExtension), reinterpret_cast<const VkBindImagePlaneMemoryInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            checkEqual_VkImagePlaneMemoryRequirementsInfo(reinterpret_cast<const VkImagePlaneMemoryRequirementsInfo*>(structExtension), reinterpret_cast<const VkImagePlaneMemoryRequirementsInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            checkEqual_VkPhysicalDeviceSamplerYcbcrConversionFeatures(reinterpret_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            checkEqual_VkSamplerYcbcrConversionImageFormatProperties(reinterpret_cast<const VkSamplerYcbcrConversionImageFormatProperties*>(structExtension), reinterpret_cast<const VkSamplerYcbcrConversionImageFormatProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            checkEqual_VkPhysicalDeviceExternalImageFormatInfo(reinterpret_cast<const VkPhysicalDeviceExternalImageFormatInfo*>(structExtension), reinterpret_cast<const VkPhysicalDeviceExternalImageFormatInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            checkEqual_VkExternalImageFormatProperties(reinterpret_cast<const VkExternalImageFormatProperties*>(structExtension), reinterpret_cast<const VkExternalImageFormatProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceIDProperties(reinterpret_cast<const VkPhysicalDeviceIDProperties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceIDProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            checkEqual_VkExternalMemoryImageCreateInfo(reinterpret_cast<const VkExternalMemoryImageCreateInfo*>(structExtension), reinterpret_cast<const VkExternalMemoryImageCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            checkEqual_VkExternalMemoryBufferCreateInfo(reinterpret_cast<const VkExternalMemoryBufferCreateInfo*>(structExtension), reinterpret_cast<const VkExternalMemoryBufferCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            checkEqual_VkExportMemoryAllocateInfo(reinterpret_cast<const VkExportMemoryAllocateInfo*>(structExtension), reinterpret_cast<const VkExportMemoryAllocateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            checkEqual_VkExportFenceCreateInfo(reinterpret_cast<const VkExportFenceCreateInfo*>(structExtension), reinterpret_cast<const VkExportFenceCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            checkEqual_VkExportSemaphoreCreateInfo(reinterpret_cast<const VkExportSemaphoreCreateInfo*>(structExtension), reinterpret_cast<const VkExportSemaphoreCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceMaintenance3Properties(reinterpret_cast<const VkPhysicalDeviceMaintenance3Properties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMaintenance3Properties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES:
        {
            checkEqual_VkPhysicalDeviceShaderDrawParameterFeatures(reinterpret_cast<const VkPhysicalDeviceShaderDrawParameterFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderDrawParameterFeatures*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            checkEqual_VkImageSwapchainCreateInfoKHR(reinterpret_cast<const VkImageSwapchainCreateInfoKHR*>(structExtension), reinterpret_cast<const VkImageSwapchainCreateInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            checkEqual_VkBindImageMemorySwapchainInfoKHR(reinterpret_cast<const VkBindImageMemorySwapchainInfoKHR*>(structExtension), reinterpret_cast<const VkBindImageMemorySwapchainInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            checkEqual_VkDeviceGroupPresentInfoKHR(reinterpret_cast<const VkDeviceGroupPresentInfoKHR*>(structExtension), reinterpret_cast<const VkDeviceGroupPresentInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            checkEqual_VkDeviceGroupSwapchainCreateInfoKHR(reinterpret_cast<const VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension), reinterpret_cast<const VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            checkEqual_VkDisplayPresentInfoKHR(reinterpret_cast<const VkDisplayPresentInfoKHR*>(structExtension), reinterpret_cast<const VkDisplayPresentInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            checkEqual_VkImportMemoryWin32HandleInfoKHR(reinterpret_cast<const VkImportMemoryWin32HandleInfoKHR*>(structExtension), reinterpret_cast<const VkImportMemoryWin32HandleInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            checkEqual_VkExportMemoryWin32HandleInfoKHR(reinterpret_cast<const VkExportMemoryWin32HandleInfoKHR*>(structExtension), reinterpret_cast<const VkExportMemoryWin32HandleInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            checkEqual_VkImportMemoryFdInfoKHR(reinterpret_cast<const VkImportMemoryFdInfoKHR*>(structExtension), reinterpret_cast<const VkImportMemoryFdInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            checkEqual_VkWin32KeyedMutexAcquireReleaseInfoKHR(reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension), reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            checkEqual_VkExportSemaphoreWin32HandleInfoKHR(reinterpret_cast<const VkExportSemaphoreWin32HandleInfoKHR*>(structExtension), reinterpret_cast<const VkExportSemaphoreWin32HandleInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            checkEqual_VkD3D12FenceSubmitInfoKHR(reinterpret_cast<const VkD3D12FenceSubmitInfoKHR*>(structExtension), reinterpret_cast<const VkD3D12FenceSubmitInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            checkEqual_VkPhysicalDevicePushDescriptorPropertiesKHR(reinterpret_cast<const VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            checkEqual_VkPresentRegionsKHR(reinterpret_cast<const VkPresentRegionsKHR*>(structExtension), reinterpret_cast<const VkPresentRegionsKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            checkEqual_VkSharedPresentSurfaceCapabilitiesKHR(reinterpret_cast<const VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension), reinterpret_cast<const VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            checkEqual_VkExportFenceWin32HandleInfoKHR(reinterpret_cast<const VkExportFenceWin32HandleInfoKHR*>(structExtension), reinterpret_cast<const VkExportFenceWin32HandleInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_image_format_list
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR:
        {
            checkEqual_VkImageFormatListCreateInfoKHR(reinterpret_cast<const VkImageFormatListCreateInfoKHR*>(structExtension), reinterpret_cast<const VkImageFormatListCreateInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_8bit_storage
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDevice8BitStorageFeaturesKHR(reinterpret_cast<const VkPhysicalDevice8BitStorageFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDevice8BitStorageFeaturesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            checkEqual_VkNativeBufferANDROID(reinterpret_cast<const VkNativeBufferANDROID*>(structExtension), reinterpret_cast<const VkNativeBufferANDROID*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            checkEqual_VkDebugReportCallbackCreateInfoEXT(reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT*>(structExtension), reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            checkEqual_VkPipelineRasterizationStateRasterizationOrderAMD(reinterpret_cast<const VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension), reinterpret_cast<const VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            checkEqual_VkDedicatedAllocationImageCreateInfoNV(reinterpret_cast<const VkDedicatedAllocationImageCreateInfoNV*>(structExtension), reinterpret_cast<const VkDedicatedAllocationImageCreateInfoNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            checkEqual_VkDedicatedAllocationBufferCreateInfoNV(reinterpret_cast<const VkDedicatedAllocationBufferCreateInfoNV*>(structExtension), reinterpret_cast<const VkDedicatedAllocationBufferCreateInfoNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            checkEqual_VkDedicatedAllocationMemoryAllocateInfoNV(reinterpret_cast<const VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension), reinterpret_cast<const VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            checkEqual_VkTextureLODGatherFormatPropertiesAMD(reinterpret_cast<const VkTextureLODGatherFormatPropertiesAMD*>(structExtension), reinterpret_cast<const VkTextureLODGatherFormatPropertiesAMD*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            checkEqual_VkExternalMemoryImageCreateInfoNV(reinterpret_cast<const VkExternalMemoryImageCreateInfoNV*>(structExtension), reinterpret_cast<const VkExternalMemoryImageCreateInfoNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            checkEqual_VkExportMemoryAllocateInfoNV(reinterpret_cast<const VkExportMemoryAllocateInfoNV*>(structExtension), reinterpret_cast<const VkExportMemoryAllocateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            checkEqual_VkImportMemoryWin32HandleInfoNV(reinterpret_cast<const VkImportMemoryWin32HandleInfoNV*>(structExtension), reinterpret_cast<const VkImportMemoryWin32HandleInfoNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            checkEqual_VkExportMemoryWin32HandleInfoNV(reinterpret_cast<const VkExportMemoryWin32HandleInfoNV*>(structExtension), reinterpret_cast<const VkExportMemoryWin32HandleInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            checkEqual_VkWin32KeyedMutexAcquireReleaseInfoNV(reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension), reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            checkEqual_VkValidationFlagsEXT(reinterpret_cast<const VkValidationFlagsEXT*>(structExtension), reinterpret_cast<const VkValidationFlagsEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceConditionalRenderingFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            checkEqual_VkCommandBufferInheritanceConditionalRenderingInfoEXT(reinterpret_cast<const VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension), reinterpret_cast<const VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            checkEqual_VkPipelineViewportWScalingStateCreateInfoNV(reinterpret_cast<const VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension), reinterpret_cast<const VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            checkEqual_VkSwapchainCounterCreateInfoEXT(reinterpret_cast<const VkSwapchainCounterCreateInfoEXT*>(structExtension), reinterpret_cast<const VkSwapchainCounterCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            checkEqual_VkPresentTimesInfoGOOGLE(reinterpret_cast<const VkPresentTimesInfoGOOGLE*>(structExtension), reinterpret_cast<const VkPresentTimesInfoGOOGLE*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            checkEqual_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(reinterpret_cast<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            checkEqual_VkPipelineViewportSwizzleStateCreateInfoNV(reinterpret_cast<const VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension), reinterpret_cast<const VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceDiscardRectanglePropertiesEXT(reinterpret_cast<const VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineDiscardRectangleStateCreateInfoEXT(reinterpret_cast<const VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineRasterizationConservativeStateCreateInfoEXT(reinterpret_cast<const VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            checkEqual_VkDebugUtilsMessengerCreateInfoEXT(reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT*>(structExtension), reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            checkEqual_VkAndroidHardwareBufferUsageANDROID(reinterpret_cast<const VkAndroidHardwareBufferUsageANDROID*>(structExtension), reinterpret_cast<const VkAndroidHardwareBufferUsageANDROID*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            checkEqual_VkAndroidHardwareBufferFormatPropertiesANDROID(reinterpret_cast<const VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension), reinterpret_cast<const VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            checkEqual_VkImportAndroidHardwareBufferInfoANDROID(reinterpret_cast<const VkImportAndroidHardwareBufferInfoANDROID*>(structExtension), reinterpret_cast<const VkImportAndroidHardwareBufferInfoANDROID*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            checkEqual_VkExternalFormatANDROID(reinterpret_cast<const VkExternalFormatANDROID*>(structExtension), reinterpret_cast<const VkExternalFormatANDROID*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_sampler_filter_minmax
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
        {
            checkEqual_VkSamplerReductionModeCreateInfoEXT(reinterpret_cast<const VkSamplerReductionModeCreateInfoEXT*>(structExtension), reinterpret_cast<const VkSamplerReductionModeCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            checkEqual_VkSampleLocationsInfoEXT(reinterpret_cast<const VkSampleLocationsInfoEXT*>(structExtension), reinterpret_cast<const VkSampleLocationsInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            checkEqual_VkRenderPassSampleLocationsBeginInfoEXT(reinterpret_cast<const VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension), reinterpret_cast<const VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineSampleLocationsStateCreateInfoEXT(reinterpret_cast<const VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceSampleLocationsPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineColorBlendAdvancedStateCreateInfoEXT(reinterpret_cast<const VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            checkEqual_VkPipelineCoverageToColorStateCreateInfoNV(reinterpret_cast<const VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension), reinterpret_cast<const VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            checkEqual_VkPipelineCoverageModulationStateCreateInfoNV(reinterpret_cast<const VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension), reinterpret_cast<const VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            checkEqual_VkShaderModuleValidationCacheCreateInfoEXT(reinterpret_cast<const VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension), reinterpret_cast<const VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_descriptor_indexing
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
        {
            checkEqual_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(reinterpret_cast<const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>(structExtension), reinterpret_cast<const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingPropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT:
        {
            checkEqual_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(reinterpret_cast<const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>(structExtension), reinterpret_cast<const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT:
        {
            checkEqual_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(reinterpret_cast<const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT*>(structExtension), reinterpret_cast<const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            checkEqual_VkDeviceQueueGlobalPriorityCreateInfoEXT(reinterpret_cast<const VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension), reinterpret_cast<const VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            checkEqual_VkImportMemoryHostPointerInfoEXT(reinterpret_cast<const VkImportMemoryHostPointerInfoEXT*>(structExtension), reinterpret_cast<const VkImportMemoryHostPointerInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            checkEqual_VkPhysicalDeviceShaderCorePropertiesAMD(reinterpret_cast<const VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineVertexInputDivisorStateCreateInfoEXT(reinterpret_cast<const VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            checkEqual_VkQueueFamilyCheckpointPropertiesNV(reinterpret_cast<const VkQueueFamilyCheckpointPropertiesNV*>(structExtension), reinterpret_cast<const VkQueueFamilyCheckpointPropertiesNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_GOOGLE_color_buffer
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE:
        {
            checkEqual_VkImportColorBufferGOOGLE(reinterpret_cast<const VkImportColorBufferGOOGLE*>(structExtension), reinterpret_cast<const VkImportColorBufferGOOGLE*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE:
        {
            checkEqual_VkImportPhysicalAddressGOOGLE(reinterpret_cast<const VkImportPhysicalAddressGOOGLE*>(structExtension), reinterpret_cast<const VkImportPhysicalAddressGOOGLE*>(structExtension2), onFail);
            break;
        }
#endif
        default:
        {
            return;
        }
    }
}


} // namespace goldfish_vk
