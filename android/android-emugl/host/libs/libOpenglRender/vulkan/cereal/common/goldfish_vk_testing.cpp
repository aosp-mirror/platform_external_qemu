// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_testing
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "goldfish_vk_testing.h"


#include "goldfish_vk_extension_structs.h"
#include "goldfish_vk_private_defs.h"


namespace goldfish_vk {

void checkEqual_extension_struct(
    const void* structExtension,
    const void* structExtension2,
    OnFailCompareFunc onFail);

#ifdef VK_VERSION_1_0
void checkEqual_VkExtent2D(
    const VkExtent2D* a,
    const VkExtent2D* b,
    OnFailCompareFunc onFail)
{
    if (!((a->width) == (b->width))) { onFail("a->width (Error: Value not equal)"); };
    if (!((a->height) == (b->height))) { onFail("a->height (Error: Value not equal)"); };
}

void checkEqual_VkExtent3D(
    const VkExtent3D* a,
    const VkExtent3D* b,
    OnFailCompareFunc onFail)
{
    if (!((a->width) == (b->width))) { onFail("a->width (Error: Value not equal)"); };
    if (!((a->height) == (b->height))) { onFail("a->height (Error: Value not equal)"); };
    if (!((a->depth) == (b->depth))) { onFail("a->depth (Error: Value not equal)"); };
}

void checkEqual_VkOffset2D(
    const VkOffset2D* a,
    const VkOffset2D* b,
    OnFailCompareFunc onFail)
{
    if (!((a->x) == (b->x))) { onFail("a->x (Error: Value not equal)"); };
    if (!((a->y) == (b->y))) { onFail("a->y (Error: Value not equal)"); };
}

void checkEqual_VkOffset3D(
    const VkOffset3D* a,
    const VkOffset3D* b,
    OnFailCompareFunc onFail)
{
    if (!((a->x) == (b->x))) { onFail("a->x (Error: Value not equal)"); };
    if (!((a->y) == (b->y))) { onFail("a->y (Error: Value not equal)"); };
    if (!((a->z) == (b->z))) { onFail("a->z (Error: Value not equal)"); };
}

void checkEqual_VkRect2D(
    const VkRect2D* a,
    const VkRect2D* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkOffset2D(&a->offset, &b->offset, onFail);
    checkEqual_VkExtent2D(&a->extent, &b->extent, onFail);
}

void checkEqual_VkBaseInStructure(
    const VkBaseInStructure* a,
    const VkBaseInStructure* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
}

void checkEqual_VkBaseOutStructure(
    const VkBaseOutStructure* a,
    const VkBaseOutStructure* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
}

void checkEqual_VkBufferMemoryBarrier(
    const VkBufferMemoryBarrier* a,
    const VkBufferMemoryBarrier* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcAccessMask) == (b->srcAccessMask))) { onFail("a->srcAccessMask (Error: Value not equal)"); };
    if (!((a->dstAccessMask) == (b->dstAccessMask))) { onFail("a->dstAccessMask (Error: Value not equal)"); };
    if (!((a->srcQueueFamilyIndex) == (b->srcQueueFamilyIndex))) { onFail("a->srcQueueFamilyIndex (Error: Value not equal)"); };
    if (!((a->dstQueueFamilyIndex) == (b->dstQueueFamilyIndex))) { onFail("a->dstQueueFamilyIndex (Error: Value not equal)"); };
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
}

void checkEqual_VkDispatchIndirectCommand(
    const VkDispatchIndirectCommand* a,
    const VkDispatchIndirectCommand* b,
    OnFailCompareFunc onFail)
{
    if (!((a->x) == (b->x))) { onFail("a->x (Error: Value not equal)"); };
    if (!((a->y) == (b->y))) { onFail("a->y (Error: Value not equal)"); };
    if (!((a->z) == (b->z))) { onFail("a->z (Error: Value not equal)"); };
}

void checkEqual_VkDrawIndexedIndirectCommand(
    const VkDrawIndexedIndirectCommand* a,
    const VkDrawIndexedIndirectCommand* b,
    OnFailCompareFunc onFail)
{
    if (!((a->indexCount) == (b->indexCount))) { onFail("a->indexCount (Error: Value not equal)"); };
    if (!((a->instanceCount) == (b->instanceCount))) { onFail("a->instanceCount (Error: Value not equal)"); };
    if (!((a->firstIndex) == (b->firstIndex))) { onFail("a->firstIndex (Error: Value not equal)"); };
    if (!((a->vertexOffset) == (b->vertexOffset))) { onFail("a->vertexOffset (Error: Value not equal)"); };
    if (!((a->firstInstance) == (b->firstInstance))) { onFail("a->firstInstance (Error: Value not equal)"); };
}

void checkEqual_VkDrawIndirectCommand(
    const VkDrawIndirectCommand* a,
    const VkDrawIndirectCommand* b,
    OnFailCompareFunc onFail)
{
    if (!((a->vertexCount) == (b->vertexCount))) { onFail("a->vertexCount (Error: Value not equal)"); };
    if (!((a->instanceCount) == (b->instanceCount))) { onFail("a->instanceCount (Error: Value not equal)"); };
    if (!((a->firstVertex) == (b->firstVertex))) { onFail("a->firstVertex (Error: Value not equal)"); };
    if (!((a->firstInstance) == (b->firstInstance))) { onFail("a->firstInstance (Error: Value not equal)"); };
}

void checkEqual_VkImageSubresourceRange(
    const VkImageSubresourceRange* a,
    const VkImageSubresourceRange* b,
    OnFailCompareFunc onFail)
{
    if (!((a->aspectMask) == (b->aspectMask))) { onFail("a->aspectMask (Error: Value not equal)"); };
    if (!((a->baseMipLevel) == (b->baseMipLevel))) { onFail("a->baseMipLevel (Error: Value not equal)"); };
    if (!((a->levelCount) == (b->levelCount))) { onFail("a->levelCount (Error: Value not equal)"); };
    if (!((a->baseArrayLayer) == (b->baseArrayLayer))) { onFail("a->baseArrayLayer (Error: Value not equal)"); };
    if (!((a->layerCount) == (b->layerCount))) { onFail("a->layerCount (Error: Value not equal)"); };
}

void checkEqual_VkImageMemoryBarrier(
    const VkImageMemoryBarrier* a,
    const VkImageMemoryBarrier* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcAccessMask) == (b->srcAccessMask))) { onFail("a->srcAccessMask (Error: Value not equal)"); };
    if (!((a->dstAccessMask) == (b->dstAccessMask))) { onFail("a->dstAccessMask (Error: Value not equal)"); };
    if (!((a->oldLayout) == (b->oldLayout))) { onFail("a->oldLayout (Error: Value not equal)"); };
    if (!((a->newLayout) == (b->newLayout))) { onFail("a->newLayout (Error: Value not equal)"); };
    if (!((a->srcQueueFamilyIndex) == (b->srcQueueFamilyIndex))) { onFail("a->srcQueueFamilyIndex (Error: Value not equal)"); };
    if (!((a->dstQueueFamilyIndex) == (b->dstQueueFamilyIndex))) { onFail("a->dstQueueFamilyIndex (Error: Value not equal)"); };
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    checkEqual_VkImageSubresourceRange(&a->subresourceRange, &b->subresourceRange, onFail);
}

void checkEqual_VkMemoryBarrier(
    const VkMemoryBarrier* a,
    const VkMemoryBarrier* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcAccessMask) == (b->srcAccessMask))) { onFail("a->srcAccessMask (Error: Value not equal)"); };
    if (!((a->dstAccessMask) == (b->dstAccessMask))) { onFail("a->dstAccessMask (Error: Value not equal)"); };
}

void checkEqual_VkPipelineCacheHeaderVersionOne(
    const VkPipelineCacheHeaderVersionOne* a,
    const VkPipelineCacheHeaderVersionOne* b,
    OnFailCompareFunc onFail)
{
    if (!((a->headerSize) == (b->headerSize))) { onFail("a->headerSize (Error: Value not equal)"); };
    if (!((a->headerVersion) == (b->headerVersion))) { onFail("a->headerVersion (Error: Value not equal)"); };
    if (!((a->vendorID) == (b->vendorID))) { onFail("a->vendorID (Error: Value not equal)"); };
    if (!((a->deviceID) == (b->deviceID))) { onFail("a->deviceID (Error: Value not equal)"); };
    if (!((memcmp(a->pipelineCacheUUID, b->pipelineCacheUUID, VK_UUID_SIZE * sizeof(uint8_t)) == 0))) { onFail("a->pipelineCacheUUID (Error: Unequal static array)"); };
}

void checkEqual_VkAllocationCallbacks(
    const VkAllocationCallbacks* a,
    const VkAllocationCallbacks* b,
    OnFailCompareFunc onFail)
{
    if (!((!(a->pUserData) && !(b->pUserData)) || ((a->pUserData) && (b->pUserData)))) { onFail("a->pUserData (Error: Mismatch in optional field)"); };
    if (!((a->pfnAllocation) == (b->pfnAllocation))) { onFail("a->pfnAllocation (Error: Value not equal)"); };
    if (!((a->pfnReallocation) == (b->pfnReallocation))) { onFail("a->pfnReallocation (Error: Value not equal)"); };
    if (!((a->pfnFree) == (b->pfnFree))) { onFail("a->pfnFree (Error: Value not equal)"); };
    if (!((a->pfnInternalAllocation) == (b->pfnInternalAllocation))) { onFail("a->pfnInternalAllocation (Error: Value not equal)"); };
    if (!((a->pfnInternalFree) == (b->pfnInternalFree))) { onFail("a->pfnInternalFree (Error: Value not equal)"); };
}

void checkEqual_VkApplicationInfo(
    const VkApplicationInfo* a,
    const VkApplicationInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pApplicationName) && !(b->pApplicationName)) || ((a->pApplicationName) && (b->pApplicationName)))) { onFail("a->pApplicationName (Error: Mismatch in optional field)"); };
    if (a->pApplicationName && b->pApplicationName)
    {
        if (!((!(a->pApplicationName) && !(b->pApplicationName)) || ((a->pApplicationName) && (b->pApplicationName)))) { onFail("a->pApplicationName (Error: Mismatch in string pointer nullness)"); };
        if ((a->pApplicationName) && (b->pApplicationName))
        {
            if (!((strcmp(a->pApplicationName, b->pApplicationName) == 0))) { onFail("a->pApplicationName (Error: Unequal strings)"); };
        }
    }
    if (!((a->applicationVersion) == (b->applicationVersion))) { onFail("a->applicationVersion (Error: Value not equal)"); };
    if (!((!(a->pEngineName) && !(b->pEngineName)) || ((a->pEngineName) && (b->pEngineName)))) { onFail("a->pEngineName (Error: Mismatch in optional field)"); };
    if (a->pEngineName && b->pEngineName)
    {
        if (!((!(a->pEngineName) && !(b->pEngineName)) || ((a->pEngineName) && (b->pEngineName)))) { onFail("a->pEngineName (Error: Mismatch in string pointer nullness)"); };
        if ((a->pEngineName) && (b->pEngineName))
        {
            if (!((strcmp(a->pEngineName, b->pEngineName) == 0))) { onFail("a->pEngineName (Error: Unequal strings)"); };
        }
    }
    if (!((a->engineVersion) == (b->engineVersion))) { onFail("a->engineVersion (Error: Value not equal)"); };
    if (!((a->apiVersion) == (b->apiVersion))) { onFail("a->apiVersion (Error: Value not equal)"); };
}

void checkEqual_VkFormatProperties(
    const VkFormatProperties* a,
    const VkFormatProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->linearTilingFeatures) == (b->linearTilingFeatures))) { onFail("a->linearTilingFeatures (Error: Value not equal)"); };
    if (!((a->optimalTilingFeatures) == (b->optimalTilingFeatures))) { onFail("a->optimalTilingFeatures (Error: Value not equal)"); };
    if (!((a->bufferFeatures) == (b->bufferFeatures))) { onFail("a->bufferFeatures (Error: Value not equal)"); };
}

void checkEqual_VkImageFormatProperties(
    const VkImageFormatProperties* a,
    const VkImageFormatProperties* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkExtent3D(&a->maxExtent, &b->maxExtent, onFail);
    if (!((a->maxMipLevels) == (b->maxMipLevels))) { onFail("a->maxMipLevels (Error: Value not equal)"); };
    if (!((a->maxArrayLayers) == (b->maxArrayLayers))) { onFail("a->maxArrayLayers (Error: Value not equal)"); };
    if (!((a->sampleCounts) == (b->sampleCounts))) { onFail("a->sampleCounts (Error: Value not equal)"); };
    if (!((a->maxResourceSize) == (b->maxResourceSize))) { onFail("a->maxResourceSize (Error: Value not equal)"); };
}

void checkEqual_VkInstanceCreateInfo(
    const VkInstanceCreateInfo* a,
    const VkInstanceCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->pApplicationInfo) && !(b->pApplicationInfo)) || ((a->pApplicationInfo) && (b->pApplicationInfo)))) { onFail("a->pApplicationInfo (Error: Mismatch in optional field)"); };
    if (a->pApplicationInfo && b->pApplicationInfo)
    {
        if ((a->pApplicationInfo) && (b->pApplicationInfo))
        {
            checkEqual_VkApplicationInfo(a->pApplicationInfo, b->pApplicationInfo, onFail);
        }
    }
    if (!((a->enabledLayerCount) == (b->enabledLayerCount))) { onFail("a->enabledLayerCount (Error: Value not equal)"); };
    if (!((!(a->ppEnabledLayerNames) && !(b->ppEnabledLayerNames)) || ((a->ppEnabledLayerNames) && (b->ppEnabledLayerNames)))) { onFail("a->ppEnabledLayerNames (Error: Mismatch in string array pointer nullness)"); };
    if (!((a->enabledLayerCount) == (b->enabledLayerCount))) { onFail("a->ppEnabledLayerNames (Error: Lengths not equal in string array)"); };
    if (!((a->enabledLayerCount) == (b->enabledLayerCount))) { onFail("a->ppEnabledLayerNames (Error: Lengths not equal in string array)"); };
    if ((a->enabledLayerCount) == (b->enabledLayerCount) && (a->ppEnabledLayerNames) && (b->ppEnabledLayerNames))
    {
        if (a)
        {
            for (uint32_t i = 0; i < (uint32_t)a->enabledLayerCount; ++i)
            {
                if (!((strcmp(*(a->ppEnabledLayerNames + i), *(b->ppEnabledLayerNames + i)) == 0))) { onFail("a->ppEnabledLayerNames (Error: Unequal string in string array)"); };
            }
        }
    }
    if (!((a->enabledExtensionCount) == (b->enabledExtensionCount))) { onFail("a->enabledExtensionCount (Error: Value not equal)"); };
    if (!((!(a->ppEnabledExtensionNames) && !(b->ppEnabledExtensionNames)) || ((a->ppEnabledExtensionNames) && (b->ppEnabledExtensionNames)))) { onFail("a->ppEnabledExtensionNames (Error: Mismatch in string array pointer nullness)"); };
    if (!((a->enabledExtensionCount) == (b->enabledExtensionCount))) { onFail("a->ppEnabledExtensionNames (Error: Lengths not equal in string array)"); };
    if (!((a->enabledExtensionCount) == (b->enabledExtensionCount))) { onFail("a->ppEnabledExtensionNames (Error: Lengths not equal in string array)"); };
    if ((a->enabledExtensionCount) == (b->enabledExtensionCount) && (a->ppEnabledExtensionNames) && (b->ppEnabledExtensionNames))
    {
        if (a)
        {
            for (uint32_t i = 0; i < (uint32_t)a->enabledExtensionCount; ++i)
            {
                if (!((strcmp(*(a->ppEnabledExtensionNames + i), *(b->ppEnabledExtensionNames + i)) == 0))) { onFail("a->ppEnabledExtensionNames (Error: Unequal string in string array)"); };
            }
        }
    }
}

void checkEqual_VkMemoryHeap(
    const VkMemoryHeap* a,
    const VkMemoryHeap* b,
    OnFailCompareFunc onFail)
{
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkMemoryType(
    const VkMemoryType* a,
    const VkMemoryType* b,
    OnFailCompareFunc onFail)
{
    if (!((a->propertyFlags) == (b->propertyFlags))) { onFail("a->propertyFlags (Error: Value not equal)"); };
    if (!((a->heapIndex) == (b->heapIndex))) { onFail("a->heapIndex (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceFeatures(
    const VkPhysicalDeviceFeatures* a,
    const VkPhysicalDeviceFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->robustBufferAccess) == (b->robustBufferAccess))) { onFail("a->robustBufferAccess (Error: Value not equal)"); };
    if (!((a->fullDrawIndexUint32) == (b->fullDrawIndexUint32))) { onFail("a->fullDrawIndexUint32 (Error: Value not equal)"); };
    if (!((a->imageCubeArray) == (b->imageCubeArray))) { onFail("a->imageCubeArray (Error: Value not equal)"); };
    if (!((a->independentBlend) == (b->independentBlend))) { onFail("a->independentBlend (Error: Value not equal)"); };
    if (!((a->geometryShader) == (b->geometryShader))) { onFail("a->geometryShader (Error: Value not equal)"); };
    if (!((a->tessellationShader) == (b->tessellationShader))) { onFail("a->tessellationShader (Error: Value not equal)"); };
    if (!((a->sampleRateShading) == (b->sampleRateShading))) { onFail("a->sampleRateShading (Error: Value not equal)"); };
    if (!((a->dualSrcBlend) == (b->dualSrcBlend))) { onFail("a->dualSrcBlend (Error: Value not equal)"); };
    if (!((a->logicOp) == (b->logicOp))) { onFail("a->logicOp (Error: Value not equal)"); };
    if (!((a->multiDrawIndirect) == (b->multiDrawIndirect))) { onFail("a->multiDrawIndirect (Error: Value not equal)"); };
    if (!((a->drawIndirectFirstInstance) == (b->drawIndirectFirstInstance))) { onFail("a->drawIndirectFirstInstance (Error: Value not equal)"); };
    if (!((a->depthClamp) == (b->depthClamp))) { onFail("a->depthClamp (Error: Value not equal)"); };
    if (!((a->depthBiasClamp) == (b->depthBiasClamp))) { onFail("a->depthBiasClamp (Error: Value not equal)"); };
    if (!((a->fillModeNonSolid) == (b->fillModeNonSolid))) { onFail("a->fillModeNonSolid (Error: Value not equal)"); };
    if (!((a->depthBounds) == (b->depthBounds))) { onFail("a->depthBounds (Error: Value not equal)"); };
    if (!((a->wideLines) == (b->wideLines))) { onFail("a->wideLines (Error: Value not equal)"); };
    if (!((a->largePoints) == (b->largePoints))) { onFail("a->largePoints (Error: Value not equal)"); };
    if (!((a->alphaToOne) == (b->alphaToOne))) { onFail("a->alphaToOne (Error: Value not equal)"); };
    if (!((a->multiViewport) == (b->multiViewport))) { onFail("a->multiViewport (Error: Value not equal)"); };
    if (!((a->samplerAnisotropy) == (b->samplerAnisotropy))) { onFail("a->samplerAnisotropy (Error: Value not equal)"); };
    if (!((a->textureCompressionETC2) == (b->textureCompressionETC2))) { onFail("a->textureCompressionETC2 (Error: Value not equal)"); };
    if (!((a->textureCompressionASTC_LDR) == (b->textureCompressionASTC_LDR))) { onFail("a->textureCompressionASTC_LDR (Error: Value not equal)"); };
    if (!((a->textureCompressionBC) == (b->textureCompressionBC))) { onFail("a->textureCompressionBC (Error: Value not equal)"); };
    if (!((a->occlusionQueryPrecise) == (b->occlusionQueryPrecise))) { onFail("a->occlusionQueryPrecise (Error: Value not equal)"); };
    if (!((a->pipelineStatisticsQuery) == (b->pipelineStatisticsQuery))) { onFail("a->pipelineStatisticsQuery (Error: Value not equal)"); };
    if (!((a->vertexPipelineStoresAndAtomics) == (b->vertexPipelineStoresAndAtomics))) { onFail("a->vertexPipelineStoresAndAtomics (Error: Value not equal)"); };
    if (!((a->fragmentStoresAndAtomics) == (b->fragmentStoresAndAtomics))) { onFail("a->fragmentStoresAndAtomics (Error: Value not equal)"); };
    if (!((a->shaderTessellationAndGeometryPointSize) == (b->shaderTessellationAndGeometryPointSize))) { onFail("a->shaderTessellationAndGeometryPointSize (Error: Value not equal)"); };
    if (!((a->shaderImageGatherExtended) == (b->shaderImageGatherExtended))) { onFail("a->shaderImageGatherExtended (Error: Value not equal)"); };
    if (!((a->shaderStorageImageExtendedFormats) == (b->shaderStorageImageExtendedFormats))) { onFail("a->shaderStorageImageExtendedFormats (Error: Value not equal)"); };
    if (!((a->shaderStorageImageMultisample) == (b->shaderStorageImageMultisample))) { onFail("a->shaderStorageImageMultisample (Error: Value not equal)"); };
    if (!((a->shaderStorageImageReadWithoutFormat) == (b->shaderStorageImageReadWithoutFormat))) { onFail("a->shaderStorageImageReadWithoutFormat (Error: Value not equal)"); };
    if (!((a->shaderStorageImageWriteWithoutFormat) == (b->shaderStorageImageWriteWithoutFormat))) { onFail("a->shaderStorageImageWriteWithoutFormat (Error: Value not equal)"); };
    if (!((a->shaderUniformBufferArrayDynamicIndexing) == (b->shaderUniformBufferArrayDynamicIndexing))) { onFail("a->shaderUniformBufferArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderSampledImageArrayDynamicIndexing) == (b->shaderSampledImageArrayDynamicIndexing))) { onFail("a->shaderSampledImageArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageBufferArrayDynamicIndexing) == (b->shaderStorageBufferArrayDynamicIndexing))) { onFail("a->shaderStorageBufferArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageImageArrayDynamicIndexing) == (b->shaderStorageImageArrayDynamicIndexing))) { onFail("a->shaderStorageImageArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderClipDistance) == (b->shaderClipDistance))) { onFail("a->shaderClipDistance (Error: Value not equal)"); };
    if (!((a->shaderCullDistance) == (b->shaderCullDistance))) { onFail("a->shaderCullDistance (Error: Value not equal)"); };
    if (!((a->shaderFloat64) == (b->shaderFloat64))) { onFail("a->shaderFloat64 (Error: Value not equal)"); };
    if (!((a->shaderInt64) == (b->shaderInt64))) { onFail("a->shaderInt64 (Error: Value not equal)"); };
    if (!((a->shaderInt16) == (b->shaderInt16))) { onFail("a->shaderInt16 (Error: Value not equal)"); };
    if (!((a->shaderResourceResidency) == (b->shaderResourceResidency))) { onFail("a->shaderResourceResidency (Error: Value not equal)"); };
    if (!((a->shaderResourceMinLod) == (b->shaderResourceMinLod))) { onFail("a->shaderResourceMinLod (Error: Value not equal)"); };
    if (!((a->sparseBinding) == (b->sparseBinding))) { onFail("a->sparseBinding (Error: Value not equal)"); };
    if (!((a->sparseResidencyBuffer) == (b->sparseResidencyBuffer))) { onFail("a->sparseResidencyBuffer (Error: Value not equal)"); };
    if (!((a->sparseResidencyImage2D) == (b->sparseResidencyImage2D))) { onFail("a->sparseResidencyImage2D (Error: Value not equal)"); };
    if (!((a->sparseResidencyImage3D) == (b->sparseResidencyImage3D))) { onFail("a->sparseResidencyImage3D (Error: Value not equal)"); };
    if (!((a->sparseResidency2Samples) == (b->sparseResidency2Samples))) { onFail("a->sparseResidency2Samples (Error: Value not equal)"); };
    if (!((a->sparseResidency4Samples) == (b->sparseResidency4Samples))) { onFail("a->sparseResidency4Samples (Error: Value not equal)"); };
    if (!((a->sparseResidency8Samples) == (b->sparseResidency8Samples))) { onFail("a->sparseResidency8Samples (Error: Value not equal)"); };
    if (!((a->sparseResidency16Samples) == (b->sparseResidency16Samples))) { onFail("a->sparseResidency16Samples (Error: Value not equal)"); };
    if (!((a->sparseResidencyAliased) == (b->sparseResidencyAliased))) { onFail("a->sparseResidencyAliased (Error: Value not equal)"); };
    if (!((a->variableMultisampleRate) == (b->variableMultisampleRate))) { onFail("a->variableMultisampleRate (Error: Value not equal)"); };
    if (!((a->inheritedQueries) == (b->inheritedQueries))) { onFail("a->inheritedQueries (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceLimits(
    const VkPhysicalDeviceLimits* a,
    const VkPhysicalDeviceLimits* b,
    OnFailCompareFunc onFail)
{
    if (!((a->maxImageDimension1D) == (b->maxImageDimension1D))) { onFail("a->maxImageDimension1D (Error: Value not equal)"); };
    if (!((a->maxImageDimension2D) == (b->maxImageDimension2D))) { onFail("a->maxImageDimension2D (Error: Value not equal)"); };
    if (!((a->maxImageDimension3D) == (b->maxImageDimension3D))) { onFail("a->maxImageDimension3D (Error: Value not equal)"); };
    if (!((a->maxImageDimensionCube) == (b->maxImageDimensionCube))) { onFail("a->maxImageDimensionCube (Error: Value not equal)"); };
    if (!((a->maxImageArrayLayers) == (b->maxImageArrayLayers))) { onFail("a->maxImageArrayLayers (Error: Value not equal)"); };
    if (!((a->maxTexelBufferElements) == (b->maxTexelBufferElements))) { onFail("a->maxTexelBufferElements (Error: Value not equal)"); };
    if (!((a->maxUniformBufferRange) == (b->maxUniformBufferRange))) { onFail("a->maxUniformBufferRange (Error: Value not equal)"); };
    if (!((a->maxStorageBufferRange) == (b->maxStorageBufferRange))) { onFail("a->maxStorageBufferRange (Error: Value not equal)"); };
    if (!((a->maxPushConstantsSize) == (b->maxPushConstantsSize))) { onFail("a->maxPushConstantsSize (Error: Value not equal)"); };
    if (!((a->maxMemoryAllocationCount) == (b->maxMemoryAllocationCount))) { onFail("a->maxMemoryAllocationCount (Error: Value not equal)"); };
    if (!((a->maxSamplerAllocationCount) == (b->maxSamplerAllocationCount))) { onFail("a->maxSamplerAllocationCount (Error: Value not equal)"); };
    if (!((a->bufferImageGranularity) == (b->bufferImageGranularity))) { onFail("a->bufferImageGranularity (Error: Value not equal)"); };
    if (!((a->sparseAddressSpaceSize) == (b->sparseAddressSpaceSize))) { onFail("a->sparseAddressSpaceSize (Error: Value not equal)"); };
    if (!((a->maxBoundDescriptorSets) == (b->maxBoundDescriptorSets))) { onFail("a->maxBoundDescriptorSets (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorSamplers) == (b->maxPerStageDescriptorSamplers))) { onFail("a->maxPerStageDescriptorSamplers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUniformBuffers) == (b->maxPerStageDescriptorUniformBuffers))) { onFail("a->maxPerStageDescriptorUniformBuffers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorStorageBuffers) == (b->maxPerStageDescriptorStorageBuffers))) { onFail("a->maxPerStageDescriptorStorageBuffers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorSampledImages) == (b->maxPerStageDescriptorSampledImages))) { onFail("a->maxPerStageDescriptorSampledImages (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorStorageImages) == (b->maxPerStageDescriptorStorageImages))) { onFail("a->maxPerStageDescriptorStorageImages (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorInputAttachments) == (b->maxPerStageDescriptorInputAttachments))) { onFail("a->maxPerStageDescriptorInputAttachments (Error: Value not equal)"); };
    if (!((a->maxPerStageResources) == (b->maxPerStageResources))) { onFail("a->maxPerStageResources (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetSamplers) == (b->maxDescriptorSetSamplers))) { onFail("a->maxDescriptorSetSamplers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUniformBuffers) == (b->maxDescriptorSetUniformBuffers))) { onFail("a->maxDescriptorSetUniformBuffers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUniformBuffersDynamic) == (b->maxDescriptorSetUniformBuffersDynamic))) { onFail("a->maxDescriptorSetUniformBuffersDynamic (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetStorageBuffers) == (b->maxDescriptorSetStorageBuffers))) { onFail("a->maxDescriptorSetStorageBuffers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetStorageBuffersDynamic) == (b->maxDescriptorSetStorageBuffersDynamic))) { onFail("a->maxDescriptorSetStorageBuffersDynamic (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetSampledImages) == (b->maxDescriptorSetSampledImages))) { onFail("a->maxDescriptorSetSampledImages (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetStorageImages) == (b->maxDescriptorSetStorageImages))) { onFail("a->maxDescriptorSetStorageImages (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetInputAttachments) == (b->maxDescriptorSetInputAttachments))) { onFail("a->maxDescriptorSetInputAttachments (Error: Value not equal)"); };
    if (!((a->maxVertexInputAttributes) == (b->maxVertexInputAttributes))) { onFail("a->maxVertexInputAttributes (Error: Value not equal)"); };
    if (!((a->maxVertexInputBindings) == (b->maxVertexInputBindings))) { onFail("a->maxVertexInputBindings (Error: Value not equal)"); };
    if (!((a->maxVertexInputAttributeOffset) == (b->maxVertexInputAttributeOffset))) { onFail("a->maxVertexInputAttributeOffset (Error: Value not equal)"); };
    if (!((a->maxVertexInputBindingStride) == (b->maxVertexInputBindingStride))) { onFail("a->maxVertexInputBindingStride (Error: Value not equal)"); };
    if (!((a->maxVertexOutputComponents) == (b->maxVertexOutputComponents))) { onFail("a->maxVertexOutputComponents (Error: Value not equal)"); };
    if (!((a->maxTessellationGenerationLevel) == (b->maxTessellationGenerationLevel))) { onFail("a->maxTessellationGenerationLevel (Error: Value not equal)"); };
    if (!((a->maxTessellationPatchSize) == (b->maxTessellationPatchSize))) { onFail("a->maxTessellationPatchSize (Error: Value not equal)"); };
    if (!((a->maxTessellationControlPerVertexInputComponents) == (b->maxTessellationControlPerVertexInputComponents))) { onFail("a->maxTessellationControlPerVertexInputComponents (Error: Value not equal)"); };
    if (!((a->maxTessellationControlPerVertexOutputComponents) == (b->maxTessellationControlPerVertexOutputComponents))) { onFail("a->maxTessellationControlPerVertexOutputComponents (Error: Value not equal)"); };
    if (!((a->maxTessellationControlPerPatchOutputComponents) == (b->maxTessellationControlPerPatchOutputComponents))) { onFail("a->maxTessellationControlPerPatchOutputComponents (Error: Value not equal)"); };
    if (!((a->maxTessellationControlTotalOutputComponents) == (b->maxTessellationControlTotalOutputComponents))) { onFail("a->maxTessellationControlTotalOutputComponents (Error: Value not equal)"); };
    if (!((a->maxTessellationEvaluationInputComponents) == (b->maxTessellationEvaluationInputComponents))) { onFail("a->maxTessellationEvaluationInputComponents (Error: Value not equal)"); };
    if (!((a->maxTessellationEvaluationOutputComponents) == (b->maxTessellationEvaluationOutputComponents))) { onFail("a->maxTessellationEvaluationOutputComponents (Error: Value not equal)"); };
    if (!((a->maxGeometryShaderInvocations) == (b->maxGeometryShaderInvocations))) { onFail("a->maxGeometryShaderInvocations (Error: Value not equal)"); };
    if (!((a->maxGeometryInputComponents) == (b->maxGeometryInputComponents))) { onFail("a->maxGeometryInputComponents (Error: Value not equal)"); };
    if (!((a->maxGeometryOutputComponents) == (b->maxGeometryOutputComponents))) { onFail("a->maxGeometryOutputComponents (Error: Value not equal)"); };
    if (!((a->maxGeometryOutputVertices) == (b->maxGeometryOutputVertices))) { onFail("a->maxGeometryOutputVertices (Error: Value not equal)"); };
    if (!((a->maxGeometryTotalOutputComponents) == (b->maxGeometryTotalOutputComponents))) { onFail("a->maxGeometryTotalOutputComponents (Error: Value not equal)"); };
    if (!((a->maxFragmentInputComponents) == (b->maxFragmentInputComponents))) { onFail("a->maxFragmentInputComponents (Error: Value not equal)"); };
    if (!((a->maxFragmentOutputAttachments) == (b->maxFragmentOutputAttachments))) { onFail("a->maxFragmentOutputAttachments (Error: Value not equal)"); };
    if (!((a->maxFragmentDualSrcAttachments) == (b->maxFragmentDualSrcAttachments))) { onFail("a->maxFragmentDualSrcAttachments (Error: Value not equal)"); };
    if (!((a->maxFragmentCombinedOutputResources) == (b->maxFragmentCombinedOutputResources))) { onFail("a->maxFragmentCombinedOutputResources (Error: Value not equal)"); };
    if (!((a->maxComputeSharedMemorySize) == (b->maxComputeSharedMemorySize))) { onFail("a->maxComputeSharedMemorySize (Error: Value not equal)"); };
    if (!((memcmp(a->maxComputeWorkGroupCount, b->maxComputeWorkGroupCount, 3 * sizeof(uint32_t)) == 0))) { onFail("a->maxComputeWorkGroupCount (Error: Unequal static array)"); };
    if (!((a->maxComputeWorkGroupInvocations) == (b->maxComputeWorkGroupInvocations))) { onFail("a->maxComputeWorkGroupInvocations (Error: Value not equal)"); };
    if (!((memcmp(a->maxComputeWorkGroupSize, b->maxComputeWorkGroupSize, 3 * sizeof(uint32_t)) == 0))) { onFail("a->maxComputeWorkGroupSize (Error: Unequal static array)"); };
    if (!((a->subPixelPrecisionBits) == (b->subPixelPrecisionBits))) { onFail("a->subPixelPrecisionBits (Error: Value not equal)"); };
    if (!((a->subTexelPrecisionBits) == (b->subTexelPrecisionBits))) { onFail("a->subTexelPrecisionBits (Error: Value not equal)"); };
    if (!((a->mipmapPrecisionBits) == (b->mipmapPrecisionBits))) { onFail("a->mipmapPrecisionBits (Error: Value not equal)"); };
    if (!((a->maxDrawIndexedIndexValue) == (b->maxDrawIndexedIndexValue))) { onFail("a->maxDrawIndexedIndexValue (Error: Value not equal)"); };
    if (!((a->maxDrawIndirectCount) == (b->maxDrawIndirectCount))) { onFail("a->maxDrawIndirectCount (Error: Value not equal)"); };
    if (!((a->maxSamplerLodBias) == (b->maxSamplerLodBias))) { onFail("a->maxSamplerLodBias (Error: Value not equal)"); };
    if (!((a->maxSamplerAnisotropy) == (b->maxSamplerAnisotropy))) { onFail("a->maxSamplerAnisotropy (Error: Value not equal)"); };
    if (!((a->maxViewports) == (b->maxViewports))) { onFail("a->maxViewports (Error: Value not equal)"); };
    if (!((memcmp(a->maxViewportDimensions, b->maxViewportDimensions, 2 * sizeof(uint32_t)) == 0))) { onFail("a->maxViewportDimensions (Error: Unequal static array)"); };
    if (!((memcmp(a->viewportBoundsRange, b->viewportBoundsRange, 2 * sizeof(float)) == 0))) { onFail("a->viewportBoundsRange (Error: Unequal static array)"); };
    if (!((a->viewportSubPixelBits) == (b->viewportSubPixelBits))) { onFail("a->viewportSubPixelBits (Error: Value not equal)"); };
    if (!((a->minMemoryMapAlignment) == (b->minMemoryMapAlignment))) { onFail("a->minMemoryMapAlignment (Error: Value not equal)"); };
    if (!((a->minTexelBufferOffsetAlignment) == (b->minTexelBufferOffsetAlignment))) { onFail("a->minTexelBufferOffsetAlignment (Error: Value not equal)"); };
    if (!((a->minUniformBufferOffsetAlignment) == (b->minUniformBufferOffsetAlignment))) { onFail("a->minUniformBufferOffsetAlignment (Error: Value not equal)"); };
    if (!((a->minStorageBufferOffsetAlignment) == (b->minStorageBufferOffsetAlignment))) { onFail("a->minStorageBufferOffsetAlignment (Error: Value not equal)"); };
    if (!((a->minTexelOffset) == (b->minTexelOffset))) { onFail("a->minTexelOffset (Error: Value not equal)"); };
    if (!((a->maxTexelOffset) == (b->maxTexelOffset))) { onFail("a->maxTexelOffset (Error: Value not equal)"); };
    if (!((a->minTexelGatherOffset) == (b->minTexelGatherOffset))) { onFail("a->minTexelGatherOffset (Error: Value not equal)"); };
    if (!((a->maxTexelGatherOffset) == (b->maxTexelGatherOffset))) { onFail("a->maxTexelGatherOffset (Error: Value not equal)"); };
    if (!((a->minInterpolationOffset) == (b->minInterpolationOffset))) { onFail("a->minInterpolationOffset (Error: Value not equal)"); };
    if (!((a->maxInterpolationOffset) == (b->maxInterpolationOffset))) { onFail("a->maxInterpolationOffset (Error: Value not equal)"); };
    if (!((a->subPixelInterpolationOffsetBits) == (b->subPixelInterpolationOffsetBits))) { onFail("a->subPixelInterpolationOffsetBits (Error: Value not equal)"); };
    if (!((a->maxFramebufferWidth) == (b->maxFramebufferWidth))) { onFail("a->maxFramebufferWidth (Error: Value not equal)"); };
    if (!((a->maxFramebufferHeight) == (b->maxFramebufferHeight))) { onFail("a->maxFramebufferHeight (Error: Value not equal)"); };
    if (!((a->maxFramebufferLayers) == (b->maxFramebufferLayers))) { onFail("a->maxFramebufferLayers (Error: Value not equal)"); };
    if (!((a->framebufferColorSampleCounts) == (b->framebufferColorSampleCounts))) { onFail("a->framebufferColorSampleCounts (Error: Value not equal)"); };
    if (!((a->framebufferDepthSampleCounts) == (b->framebufferDepthSampleCounts))) { onFail("a->framebufferDepthSampleCounts (Error: Value not equal)"); };
    if (!((a->framebufferStencilSampleCounts) == (b->framebufferStencilSampleCounts))) { onFail("a->framebufferStencilSampleCounts (Error: Value not equal)"); };
    if (!((a->framebufferNoAttachmentsSampleCounts) == (b->framebufferNoAttachmentsSampleCounts))) { onFail("a->framebufferNoAttachmentsSampleCounts (Error: Value not equal)"); };
    if (!((a->maxColorAttachments) == (b->maxColorAttachments))) { onFail("a->maxColorAttachments (Error: Value not equal)"); };
    if (!((a->sampledImageColorSampleCounts) == (b->sampledImageColorSampleCounts))) { onFail("a->sampledImageColorSampleCounts (Error: Value not equal)"); };
    if (!((a->sampledImageIntegerSampleCounts) == (b->sampledImageIntegerSampleCounts))) { onFail("a->sampledImageIntegerSampleCounts (Error: Value not equal)"); };
    if (!((a->sampledImageDepthSampleCounts) == (b->sampledImageDepthSampleCounts))) { onFail("a->sampledImageDepthSampleCounts (Error: Value not equal)"); };
    if (!((a->sampledImageStencilSampleCounts) == (b->sampledImageStencilSampleCounts))) { onFail("a->sampledImageStencilSampleCounts (Error: Value not equal)"); };
    if (!((a->storageImageSampleCounts) == (b->storageImageSampleCounts))) { onFail("a->storageImageSampleCounts (Error: Value not equal)"); };
    if (!((a->maxSampleMaskWords) == (b->maxSampleMaskWords))) { onFail("a->maxSampleMaskWords (Error: Value not equal)"); };
    if (!((a->timestampComputeAndGraphics) == (b->timestampComputeAndGraphics))) { onFail("a->timestampComputeAndGraphics (Error: Value not equal)"); };
    if (!((a->timestampPeriod) == (b->timestampPeriod))) { onFail("a->timestampPeriod (Error: Value not equal)"); };
    if (!((a->maxClipDistances) == (b->maxClipDistances))) { onFail("a->maxClipDistances (Error: Value not equal)"); };
    if (!((a->maxCullDistances) == (b->maxCullDistances))) { onFail("a->maxCullDistances (Error: Value not equal)"); };
    if (!((a->maxCombinedClipAndCullDistances) == (b->maxCombinedClipAndCullDistances))) { onFail("a->maxCombinedClipAndCullDistances (Error: Value not equal)"); };
    if (!((a->discreteQueuePriorities) == (b->discreteQueuePriorities))) { onFail("a->discreteQueuePriorities (Error: Value not equal)"); };
    if (!((memcmp(a->pointSizeRange, b->pointSizeRange, 2 * sizeof(float)) == 0))) { onFail("a->pointSizeRange (Error: Unequal static array)"); };
    if (!((memcmp(a->lineWidthRange, b->lineWidthRange, 2 * sizeof(float)) == 0))) { onFail("a->lineWidthRange (Error: Unequal static array)"); };
    if (!((a->pointSizeGranularity) == (b->pointSizeGranularity))) { onFail("a->pointSizeGranularity (Error: Value not equal)"); };
    if (!((a->lineWidthGranularity) == (b->lineWidthGranularity))) { onFail("a->lineWidthGranularity (Error: Value not equal)"); };
    if (!((a->strictLines) == (b->strictLines))) { onFail("a->strictLines (Error: Value not equal)"); };
    if (!((a->standardSampleLocations) == (b->standardSampleLocations))) { onFail("a->standardSampleLocations (Error: Value not equal)"); };
    if (!((a->optimalBufferCopyOffsetAlignment) == (b->optimalBufferCopyOffsetAlignment))) { onFail("a->optimalBufferCopyOffsetAlignment (Error: Value not equal)"); };
    if (!((a->optimalBufferCopyRowPitchAlignment) == (b->optimalBufferCopyRowPitchAlignment))) { onFail("a->optimalBufferCopyRowPitchAlignment (Error: Value not equal)"); };
    if (!((a->nonCoherentAtomSize) == (b->nonCoherentAtomSize))) { onFail("a->nonCoherentAtomSize (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceMemoryProperties(
    const VkPhysicalDeviceMemoryProperties* a,
    const VkPhysicalDeviceMemoryProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->memoryTypeCount) == (b->memoryTypeCount))) { onFail("a->memoryTypeCount (Error: Value not equal)"); };
    if (!((VK_MAX_MEMORY_TYPES) == (VK_MAX_MEMORY_TYPES))) { onFail("a->memoryTypes (Error: Lengths not equal)"); };
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        checkEqual_VkMemoryType(a->memoryTypes + i, b->memoryTypes + i, onFail);
    }
    if (!((a->memoryHeapCount) == (b->memoryHeapCount))) { onFail("a->memoryHeapCount (Error: Value not equal)"); };
    if (!((VK_MAX_MEMORY_HEAPS) == (VK_MAX_MEMORY_HEAPS))) { onFail("a->memoryHeaps (Error: Lengths not equal)"); };
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        checkEqual_VkMemoryHeap(a->memoryHeaps + i, b->memoryHeaps + i, onFail);
    }
}

void checkEqual_VkPhysicalDeviceSparseProperties(
    const VkPhysicalDeviceSparseProperties* a,
    const VkPhysicalDeviceSparseProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->residencyStandard2DBlockShape) == (b->residencyStandard2DBlockShape))) { onFail("a->residencyStandard2DBlockShape (Error: Value not equal)"); };
    if (!((a->residencyStandard2DMultisampleBlockShape) == (b->residencyStandard2DMultisampleBlockShape))) { onFail("a->residencyStandard2DMultisampleBlockShape (Error: Value not equal)"); };
    if (!((a->residencyStandard3DBlockShape) == (b->residencyStandard3DBlockShape))) { onFail("a->residencyStandard3DBlockShape (Error: Value not equal)"); };
    if (!((a->residencyAlignedMipSize) == (b->residencyAlignedMipSize))) { onFail("a->residencyAlignedMipSize (Error: Value not equal)"); };
    if (!((a->residencyNonResidentStrict) == (b->residencyNonResidentStrict))) { onFail("a->residencyNonResidentStrict (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceProperties(
    const VkPhysicalDeviceProperties* a,
    const VkPhysicalDeviceProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->apiVersion) == (b->apiVersion))) { onFail("a->apiVersion (Error: Value not equal)"); };
    if (!((a->driverVersion) == (b->driverVersion))) { onFail("a->driverVersion (Error: Value not equal)"); };
    if (!((a->vendorID) == (b->vendorID))) { onFail("a->vendorID (Error: Value not equal)"); };
    if (!((a->deviceID) == (b->deviceID))) { onFail("a->deviceID (Error: Value not equal)"); };
    if (!((a->deviceType) == (b->deviceType))) { onFail("a->deviceType (Error: Value not equal)"); };
    if (!((memcmp(a->deviceName, b->deviceName, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char)) == 0))) { onFail("a->deviceName (Error: Unequal static array)"); };
    if (!((memcmp(a->pipelineCacheUUID, b->pipelineCacheUUID, VK_UUID_SIZE * sizeof(uint8_t)) == 0))) { onFail("a->pipelineCacheUUID (Error: Unequal static array)"); };
    checkEqual_VkPhysicalDeviceLimits(&a->limits, &b->limits, onFail);
    checkEqual_VkPhysicalDeviceSparseProperties(&a->sparseProperties, &b->sparseProperties, onFail);
}

void checkEqual_VkQueueFamilyProperties(
    const VkQueueFamilyProperties* a,
    const VkQueueFamilyProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->queueFlags) == (b->queueFlags))) { onFail("a->queueFlags (Error: Value not equal)"); };
    if (!((a->queueCount) == (b->queueCount))) { onFail("a->queueCount (Error: Value not equal)"); };
    if (!((a->timestampValidBits) == (b->timestampValidBits))) { onFail("a->timestampValidBits (Error: Value not equal)"); };
    checkEqual_VkExtent3D(&a->minImageTransferGranularity, &b->minImageTransferGranularity, onFail);
}

void checkEqual_VkDeviceQueueCreateInfo(
    const VkDeviceQueueCreateInfo* a,
    const VkDeviceQueueCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->queueFamilyIndex) == (b->queueFamilyIndex))) { onFail("a->queueFamilyIndex (Error: Value not equal)"); };
    if (!((a->queueCount) == (b->queueCount))) { onFail("a->queueCount (Error: Value not equal)"); };
    if (!((a->queueCount) == (b->queueCount))) { onFail("a->pQueuePriorities (Error: Lengths not equal)"); };
    if (!((memcmp(a->pQueuePriorities, b->pQueuePriorities, a->queueCount * sizeof(const float)) == 0))) { onFail("a->pQueuePriorities (Error: Unequal dyn array)"); };
}

void checkEqual_VkDeviceCreateInfo(
    const VkDeviceCreateInfo* a,
    const VkDeviceCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->queueCreateInfoCount) == (b->queueCreateInfoCount))) { onFail("a->queueCreateInfoCount (Error: Value not equal)"); };
    if ((a->pQueueCreateInfos) && (b->pQueueCreateInfos))
    {
        if (!((a->queueCreateInfoCount) == (b->queueCreateInfoCount))) { onFail("a->pQueueCreateInfos (Error: Lengths not equal)"); };
        if ((a->queueCreateInfoCount) == (b->queueCreateInfoCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->queueCreateInfoCount; ++i)
                {
                    checkEqual_VkDeviceQueueCreateInfo(a->pQueueCreateInfos + i, b->pQueueCreateInfos + i, onFail);
                }
            }
        }
    }
    if (!((a->enabledLayerCount) == (b->enabledLayerCount))) { onFail("a->enabledLayerCount (Error: Value not equal)"); };
    if (!((!(a->ppEnabledLayerNames) && !(b->ppEnabledLayerNames)) || ((a->ppEnabledLayerNames) && (b->ppEnabledLayerNames)))) { onFail("a->ppEnabledLayerNames (Error: Mismatch in string array pointer nullness)"); };
    if (!((a->enabledLayerCount) == (b->enabledLayerCount))) { onFail("a->ppEnabledLayerNames (Error: Lengths not equal in string array)"); };
    if (!((a->enabledLayerCount) == (b->enabledLayerCount))) { onFail("a->ppEnabledLayerNames (Error: Lengths not equal in string array)"); };
    if ((a->enabledLayerCount) == (b->enabledLayerCount) && (a->ppEnabledLayerNames) && (b->ppEnabledLayerNames))
    {
        if (a)
        {
            for (uint32_t i = 0; i < (uint32_t)a->enabledLayerCount; ++i)
            {
                if (!((strcmp(*(a->ppEnabledLayerNames + i), *(b->ppEnabledLayerNames + i)) == 0))) { onFail("a->ppEnabledLayerNames (Error: Unequal string in string array)"); };
            }
        }
    }
    if (!((a->enabledExtensionCount) == (b->enabledExtensionCount))) { onFail("a->enabledExtensionCount (Error: Value not equal)"); };
    if (!((!(a->ppEnabledExtensionNames) && !(b->ppEnabledExtensionNames)) || ((a->ppEnabledExtensionNames) && (b->ppEnabledExtensionNames)))) { onFail("a->ppEnabledExtensionNames (Error: Mismatch in string array pointer nullness)"); };
    if (!((a->enabledExtensionCount) == (b->enabledExtensionCount))) { onFail("a->ppEnabledExtensionNames (Error: Lengths not equal in string array)"); };
    if (!((a->enabledExtensionCount) == (b->enabledExtensionCount))) { onFail("a->ppEnabledExtensionNames (Error: Lengths not equal in string array)"); };
    if ((a->enabledExtensionCount) == (b->enabledExtensionCount) && (a->ppEnabledExtensionNames) && (b->ppEnabledExtensionNames))
    {
        if (a)
        {
            for (uint32_t i = 0; i < (uint32_t)a->enabledExtensionCount; ++i)
            {
                if (!((strcmp(*(a->ppEnabledExtensionNames + i), *(b->ppEnabledExtensionNames + i)) == 0))) { onFail("a->ppEnabledExtensionNames (Error: Unequal string in string array)"); };
            }
        }
    }
    if (!((!(a->pEnabledFeatures) && !(b->pEnabledFeatures)) || ((a->pEnabledFeatures) && (b->pEnabledFeatures)))) { onFail("a->pEnabledFeatures (Error: Mismatch in optional field)"); };
    if (a->pEnabledFeatures && b->pEnabledFeatures)
    {
        if ((a->pEnabledFeatures) && (b->pEnabledFeatures))
        {
            checkEqual_VkPhysicalDeviceFeatures(a->pEnabledFeatures, b->pEnabledFeatures, onFail);
        }
    }
}

void checkEqual_VkExtensionProperties(
    const VkExtensionProperties* a,
    const VkExtensionProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((memcmp(a->extensionName, b->extensionName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char)) == 0))) { onFail("a->extensionName (Error: Unequal static array)"); };
    if (!((a->specVersion) == (b->specVersion))) { onFail("a->specVersion (Error: Value not equal)"); };
}

void checkEqual_VkLayerProperties(
    const VkLayerProperties* a,
    const VkLayerProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((memcmp(a->layerName, b->layerName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char)) == 0))) { onFail("a->layerName (Error: Unequal static array)"); };
    if (!((a->specVersion) == (b->specVersion))) { onFail("a->specVersion (Error: Value not equal)"); };
    if (!((a->implementationVersion) == (b->implementationVersion))) { onFail("a->implementationVersion (Error: Value not equal)"); };
    if (!((memcmp(a->description, b->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char)) == 0))) { onFail("a->description (Error: Unequal static array)"); };
}

void checkEqual_VkSubmitInfo(
    const VkSubmitInfo* a,
    const VkSubmitInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->waitSemaphoreCount (Error: Value not equal)"); };
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->pWaitSemaphores (Error: Lengths not equal)"); };
    if (!((memcmp(a->pWaitSemaphores, b->pWaitSemaphores, a->waitSemaphoreCount * sizeof(const VkSemaphore)) == 0))) { onFail("a->pWaitSemaphores (Error: Unequal dyn array)"); };
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->pWaitDstStageMask (Error: Lengths not equal)"); };
    if (!((memcmp(a->pWaitDstStageMask, b->pWaitDstStageMask, a->waitSemaphoreCount * sizeof(const VkPipelineStageFlags)) == 0))) { onFail("a->pWaitDstStageMask (Error: Unequal dyn array)"); };
    if (!((a->commandBufferCount) == (b->commandBufferCount))) { onFail("a->commandBufferCount (Error: Value not equal)"); };
    if (!((a->commandBufferCount) == (b->commandBufferCount))) { onFail("a->pCommandBuffers (Error: Lengths not equal)"); };
    if (!((memcmp(a->pCommandBuffers, b->pCommandBuffers, a->commandBufferCount * sizeof(const VkCommandBuffer)) == 0))) { onFail("a->pCommandBuffers (Error: Unequal dyn array)"); };
    if (!((a->signalSemaphoreCount) == (b->signalSemaphoreCount))) { onFail("a->signalSemaphoreCount (Error: Value not equal)"); };
    if (!((a->signalSemaphoreCount) == (b->signalSemaphoreCount))) { onFail("a->pSignalSemaphores (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSignalSemaphores, b->pSignalSemaphores, a->signalSemaphoreCount * sizeof(const VkSemaphore)) == 0))) { onFail("a->pSignalSemaphores (Error: Unequal dyn array)"); };
}

void checkEqual_VkMappedMemoryRange(
    const VkMappedMemoryRange* a,
    const VkMappedMemoryRange* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
}

void checkEqual_VkMemoryAllocateInfo(
    const VkMemoryAllocateInfo* a,
    const VkMemoryAllocateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->allocationSize) == (b->allocationSize))) { onFail("a->allocationSize (Error: Value not equal)"); };
    if (!((a->memoryTypeIndex) == (b->memoryTypeIndex))) { onFail("a->memoryTypeIndex (Error: Value not equal)"); };
}

void checkEqual_VkMemoryRequirements(
    const VkMemoryRequirements* a,
    const VkMemoryRequirements* b,
    OnFailCompareFunc onFail)
{
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->alignment) == (b->alignment))) { onFail("a->alignment (Error: Value not equal)"); };
    if (!((a->memoryTypeBits) == (b->memoryTypeBits))) { onFail("a->memoryTypeBits (Error: Value not equal)"); };
}

void checkEqual_VkSparseMemoryBind(
    const VkSparseMemoryBind* a,
    const VkSparseMemoryBind* b,
    OnFailCompareFunc onFail)
{
    if (!((a->resourceOffset) == (b->resourceOffset))) { onFail("a->resourceOffset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->memoryOffset) == (b->memoryOffset))) { onFail("a->memoryOffset (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkSparseBufferMemoryBindInfo(
    const VkSparseBufferMemoryBindInfo* a,
    const VkSparseBufferMemoryBindInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->bindCount) == (b->bindCount))) { onFail("a->bindCount (Error: Value not equal)"); };
    if ((a->pBinds) && (b->pBinds))
    {
        if (!((a->bindCount) == (b->bindCount))) { onFail("a->pBinds (Error: Lengths not equal)"); };
        if ((a->bindCount) == (b->bindCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->bindCount; ++i)
                {
                    checkEqual_VkSparseMemoryBind(a->pBinds + i, b->pBinds + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkSparseImageOpaqueMemoryBindInfo(
    const VkSparseImageOpaqueMemoryBindInfo* a,
    const VkSparseImageOpaqueMemoryBindInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    if (!((a->bindCount) == (b->bindCount))) { onFail("a->bindCount (Error: Value not equal)"); };
    if ((a->pBinds) && (b->pBinds))
    {
        if (!((a->bindCount) == (b->bindCount))) { onFail("a->pBinds (Error: Lengths not equal)"); };
        if ((a->bindCount) == (b->bindCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->bindCount; ++i)
                {
                    checkEqual_VkSparseMemoryBind(a->pBinds + i, b->pBinds + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkImageSubresource(
    const VkImageSubresource* a,
    const VkImageSubresource* b,
    OnFailCompareFunc onFail)
{
    if (!((a->aspectMask) == (b->aspectMask))) { onFail("a->aspectMask (Error: Value not equal)"); };
    if (!((a->mipLevel) == (b->mipLevel))) { onFail("a->mipLevel (Error: Value not equal)"); };
    if (!((a->arrayLayer) == (b->arrayLayer))) { onFail("a->arrayLayer (Error: Value not equal)"); };
}

void checkEqual_VkSparseImageMemoryBind(
    const VkSparseImageMemoryBind* a,
    const VkSparseImageMemoryBind* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkImageSubresource(&a->subresource, &b->subresource, onFail);
    checkEqual_VkOffset3D(&a->offset, &b->offset, onFail);
    checkEqual_VkExtent3D(&a->extent, &b->extent, onFail);
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->memoryOffset) == (b->memoryOffset))) { onFail("a->memoryOffset (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkSparseImageMemoryBindInfo(
    const VkSparseImageMemoryBindInfo* a,
    const VkSparseImageMemoryBindInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    if (!((a->bindCount) == (b->bindCount))) { onFail("a->bindCount (Error: Value not equal)"); };
    if ((a->pBinds) && (b->pBinds))
    {
        if (!((a->bindCount) == (b->bindCount))) { onFail("a->pBinds (Error: Lengths not equal)"); };
        if ((a->bindCount) == (b->bindCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->bindCount; ++i)
                {
                    checkEqual_VkSparseImageMemoryBind(a->pBinds + i, b->pBinds + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkBindSparseInfo(
    const VkBindSparseInfo* a,
    const VkBindSparseInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->waitSemaphoreCount (Error: Value not equal)"); };
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->pWaitSemaphores (Error: Lengths not equal)"); };
    if (!((memcmp(a->pWaitSemaphores, b->pWaitSemaphores, a->waitSemaphoreCount * sizeof(const VkSemaphore)) == 0))) { onFail("a->pWaitSemaphores (Error: Unequal dyn array)"); };
    if (!((a->bufferBindCount) == (b->bufferBindCount))) { onFail("a->bufferBindCount (Error: Value not equal)"); };
    if ((a->pBufferBinds) && (b->pBufferBinds))
    {
        if (!((a->bufferBindCount) == (b->bufferBindCount))) { onFail("a->pBufferBinds (Error: Lengths not equal)"); };
        if ((a->bufferBindCount) == (b->bufferBindCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->bufferBindCount; ++i)
                {
                    checkEqual_VkSparseBufferMemoryBindInfo(a->pBufferBinds + i, b->pBufferBinds + i, onFail);
                }
            }
        }
    }
    if (!((a->imageOpaqueBindCount) == (b->imageOpaqueBindCount))) { onFail("a->imageOpaqueBindCount (Error: Value not equal)"); };
    if ((a->pImageOpaqueBinds) && (b->pImageOpaqueBinds))
    {
        if (!((a->imageOpaqueBindCount) == (b->imageOpaqueBindCount))) { onFail("a->pImageOpaqueBinds (Error: Lengths not equal)"); };
        if ((a->imageOpaqueBindCount) == (b->imageOpaqueBindCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->imageOpaqueBindCount; ++i)
                {
                    checkEqual_VkSparseImageOpaqueMemoryBindInfo(a->pImageOpaqueBinds + i, b->pImageOpaqueBinds + i, onFail);
                }
            }
        }
    }
    if (!((a->imageBindCount) == (b->imageBindCount))) { onFail("a->imageBindCount (Error: Value not equal)"); };
    if ((a->pImageBinds) && (b->pImageBinds))
    {
        if (!((a->imageBindCount) == (b->imageBindCount))) { onFail("a->pImageBinds (Error: Lengths not equal)"); };
        if ((a->imageBindCount) == (b->imageBindCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->imageBindCount; ++i)
                {
                    checkEqual_VkSparseImageMemoryBindInfo(a->pImageBinds + i, b->pImageBinds + i, onFail);
                }
            }
        }
    }
    if (!((a->signalSemaphoreCount) == (b->signalSemaphoreCount))) { onFail("a->signalSemaphoreCount (Error: Value not equal)"); };
    if (!((a->signalSemaphoreCount) == (b->signalSemaphoreCount))) { onFail("a->pSignalSemaphores (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSignalSemaphores, b->pSignalSemaphores, a->signalSemaphoreCount * sizeof(const VkSemaphore)) == 0))) { onFail("a->pSignalSemaphores (Error: Unequal dyn array)"); };
}

void checkEqual_VkSparseImageFormatProperties(
    const VkSparseImageFormatProperties* a,
    const VkSparseImageFormatProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->aspectMask) == (b->aspectMask))) { onFail("a->aspectMask (Error: Value not equal)"); };
    checkEqual_VkExtent3D(&a->imageGranularity, &b->imageGranularity, onFail);
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkSparseImageMemoryRequirements(
    const VkSparseImageMemoryRequirements* a,
    const VkSparseImageMemoryRequirements* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkSparseImageFormatProperties(&a->formatProperties, &b->formatProperties, onFail);
    if (!((a->imageMipTailFirstLod) == (b->imageMipTailFirstLod))) { onFail("a->imageMipTailFirstLod (Error: Value not equal)"); };
    if (!((a->imageMipTailSize) == (b->imageMipTailSize))) { onFail("a->imageMipTailSize (Error: Value not equal)"); };
    if (!((a->imageMipTailOffset) == (b->imageMipTailOffset))) { onFail("a->imageMipTailOffset (Error: Value not equal)"); };
    if (!((a->imageMipTailStride) == (b->imageMipTailStride))) { onFail("a->imageMipTailStride (Error: Value not equal)"); };
}

void checkEqual_VkFenceCreateInfo(
    const VkFenceCreateInfo* a,
    const VkFenceCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkSemaphoreCreateInfo(
    const VkSemaphoreCreateInfo* a,
    const VkSemaphoreCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkEventCreateInfo(
    const VkEventCreateInfo* a,
    const VkEventCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkQueryPoolCreateInfo(
    const VkQueryPoolCreateInfo* a,
    const VkQueryPoolCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->queryType) == (b->queryType))) { onFail("a->queryType (Error: Value not equal)"); };
    if (!((a->queryCount) == (b->queryCount))) { onFail("a->queryCount (Error: Value not equal)"); };
    if (!((a->pipelineStatistics) == (b->pipelineStatistics))) { onFail("a->pipelineStatistics (Error: Value not equal)"); };
}

void checkEqual_VkBufferCreateInfo(
    const VkBufferCreateInfo* a,
    const VkBufferCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
    if (!((a->sharingMode) == (b->sharingMode))) { onFail("a->sharingMode (Error: Value not equal)"); };
    if (!((a->queueFamilyIndexCount) == (b->queueFamilyIndexCount))) { onFail("a->queueFamilyIndexCount (Error: Value not equal)"); };
    if (!((!(a->pQueueFamilyIndices) && !(b->pQueueFamilyIndices)) || ((a->pQueueFamilyIndices) && (b->pQueueFamilyIndices)))) { onFail("a->pQueueFamilyIndices (Error: Mismatch in optional field)"); };
    if (a->pQueueFamilyIndices && b->pQueueFamilyIndices)
    {
        if (!((a->queueFamilyIndexCount) == (b->queueFamilyIndexCount))) { onFail("a->pQueueFamilyIndices (Error: Lengths not equal)"); };
        if (!((memcmp(a->pQueueFamilyIndices, b->pQueueFamilyIndices, a->queueFamilyIndexCount * sizeof(const uint32_t)) == 0))) { onFail("a->pQueueFamilyIndices (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkBufferViewCreateInfo(
    const VkBufferViewCreateInfo* a,
    const VkBufferViewCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->range) == (b->range))) { onFail("a->range (Error: Value not equal)"); };
}

void checkEqual_VkImageCreateInfo(
    const VkImageCreateInfo* a,
    const VkImageCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->imageType) == (b->imageType))) { onFail("a->imageType (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    checkEqual_VkExtent3D(&a->extent, &b->extent, onFail);
    if (!((a->mipLevels) == (b->mipLevels))) { onFail("a->mipLevels (Error: Value not equal)"); };
    if (!((a->arrayLayers) == (b->arrayLayers))) { onFail("a->arrayLayers (Error: Value not equal)"); };
    if (!((a->samples) == (b->samples))) { onFail("a->samples (Error: Value not equal)"); };
    if (!((a->tiling) == (b->tiling))) { onFail("a->tiling (Error: Value not equal)"); };
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
    if (!((a->sharingMode) == (b->sharingMode))) { onFail("a->sharingMode (Error: Value not equal)"); };
    if (!((a->queueFamilyIndexCount) == (b->queueFamilyIndexCount))) { onFail("a->queueFamilyIndexCount (Error: Value not equal)"); };
    if (!((!(a->pQueueFamilyIndices) && !(b->pQueueFamilyIndices)) || ((a->pQueueFamilyIndices) && (b->pQueueFamilyIndices)))) { onFail("a->pQueueFamilyIndices (Error: Mismatch in optional field)"); };
    if (a->pQueueFamilyIndices && b->pQueueFamilyIndices)
    {
        if (!((a->queueFamilyIndexCount) == (b->queueFamilyIndexCount))) { onFail("a->pQueueFamilyIndices (Error: Lengths not equal)"); };
        if (!((memcmp(a->pQueueFamilyIndices, b->pQueueFamilyIndices, a->queueFamilyIndexCount * sizeof(const uint32_t)) == 0))) { onFail("a->pQueueFamilyIndices (Error: Unequal dyn array)"); };
    }
    if (!((a->initialLayout) == (b->initialLayout))) { onFail("a->initialLayout (Error: Value not equal)"); };
}

void checkEqual_VkSubresourceLayout(
    const VkSubresourceLayout* a,
    const VkSubresourceLayout* b,
    OnFailCompareFunc onFail)
{
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->rowPitch) == (b->rowPitch))) { onFail("a->rowPitch (Error: Value not equal)"); };
    if (!((a->arrayPitch) == (b->arrayPitch))) { onFail("a->arrayPitch (Error: Value not equal)"); };
    if (!((a->depthPitch) == (b->depthPitch))) { onFail("a->depthPitch (Error: Value not equal)"); };
}

void checkEqual_VkComponentMapping(
    const VkComponentMapping* a,
    const VkComponentMapping* b,
    OnFailCompareFunc onFail)
{
    if (!((a->r) == (b->r))) { onFail("a->r (Error: Value not equal)"); };
    if (!((a->g) == (b->g))) { onFail("a->g (Error: Value not equal)"); };
    if (!((a->b) == (b->b))) { onFail("a->b (Error: Value not equal)"); };
    if (!((a->a) == (b->a))) { onFail("a->a (Error: Value not equal)"); };
}

void checkEqual_VkImageViewCreateInfo(
    const VkImageViewCreateInfo* a,
    const VkImageViewCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    if (!((a->viewType) == (b->viewType))) { onFail("a->viewType (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    checkEqual_VkComponentMapping(&a->components, &b->components, onFail);
    checkEqual_VkImageSubresourceRange(&a->subresourceRange, &b->subresourceRange, onFail);
}

void checkEqual_VkShaderModuleCreateInfo(
    const VkShaderModuleCreateInfo* a,
    const VkShaderModuleCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->codeSize) == (b->codeSize))) { onFail("a->codeSize (Error: Value not equal)"); };
    if (!(((a->codeSize / 4)) == ((b->codeSize / 4)))) { onFail("a->pCode (Error: Lengths not equal)"); };
    if (!((memcmp(a->pCode, b->pCode, (a->codeSize / 4) * sizeof(const uint32_t)) == 0))) { onFail("a->pCode (Error: Unequal dyn array)"); };
}

void checkEqual_VkPipelineCacheCreateInfo(
    const VkPipelineCacheCreateInfo* a,
    const VkPipelineCacheCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->initialDataSize) == (b->initialDataSize))) { onFail("a->initialDataSize (Error: Value not equal)"); };
}

void checkEqual_VkSpecializationMapEntry(
    const VkSpecializationMapEntry* a,
    const VkSpecializationMapEntry* b,
    OnFailCompareFunc onFail)
{
    if (!((a->constantID) == (b->constantID))) { onFail("a->constantID (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
}

void checkEqual_VkSpecializationInfo(
    const VkSpecializationInfo* a,
    const VkSpecializationInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->mapEntryCount) == (b->mapEntryCount))) { onFail("a->mapEntryCount (Error: Value not equal)"); };
    if ((a->pMapEntries) && (b->pMapEntries))
    {
        if (!((a->mapEntryCount) == (b->mapEntryCount))) { onFail("a->pMapEntries (Error: Lengths not equal)"); };
        if ((a->mapEntryCount) == (b->mapEntryCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->mapEntryCount; ++i)
                {
                    checkEqual_VkSpecializationMapEntry(a->pMapEntries + i, b->pMapEntries + i, onFail);
                }
            }
        }
    }
    if (!((a->dataSize) == (b->dataSize))) { onFail("a->dataSize (Error: Value not equal)"); };
}

void checkEqual_VkPipelineShaderStageCreateInfo(
    const VkPipelineShaderStageCreateInfo* a,
    const VkPipelineShaderStageCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->stage) == (b->stage))) { onFail("a->stage (Error: Value not equal)"); };
    if (!((a->module) == (b->module))) { onFail("a->module (Error: Value not equal)"); };
    if (!((!(a->pName) && !(b->pName)) || ((a->pName) && (b->pName)))) { onFail("a->pName (Error: Mismatch in string pointer nullness)"); };
    if ((a->pName) && (b->pName))
    {
        if (!((strcmp(a->pName, b->pName) == 0))) { onFail("a->pName (Error: Unequal strings)"); };
    }
    if (!((!(a->pSpecializationInfo) && !(b->pSpecializationInfo)) || ((a->pSpecializationInfo) && (b->pSpecializationInfo)))) { onFail("a->pSpecializationInfo (Error: Mismatch in optional field)"); };
    if (a->pSpecializationInfo && b->pSpecializationInfo)
    {
        if ((a->pSpecializationInfo) && (b->pSpecializationInfo))
        {
            checkEqual_VkSpecializationInfo(a->pSpecializationInfo, b->pSpecializationInfo, onFail);
        }
    }
}

void checkEqual_VkComputePipelineCreateInfo(
    const VkComputePipelineCreateInfo* a,
    const VkComputePipelineCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    checkEqual_VkPipelineShaderStageCreateInfo(&a->stage, &b->stage, onFail);
    if (!((a->layout) == (b->layout))) { onFail("a->layout (Error: Value not equal)"); };
    if (!((a->basePipelineHandle) == (b->basePipelineHandle))) { onFail("a->basePipelineHandle (Error: Value not equal)"); };
    if (!((a->basePipelineIndex) == (b->basePipelineIndex))) { onFail("a->basePipelineIndex (Error: Value not equal)"); };
}

void checkEqual_VkVertexInputBindingDescription(
    const VkVertexInputBindingDescription* a,
    const VkVertexInputBindingDescription* b,
    OnFailCompareFunc onFail)
{
    if (!((a->binding) == (b->binding))) { onFail("a->binding (Error: Value not equal)"); };
    if (!((a->stride) == (b->stride))) { onFail("a->stride (Error: Value not equal)"); };
    if (!((a->inputRate) == (b->inputRate))) { onFail("a->inputRate (Error: Value not equal)"); };
}

void checkEqual_VkVertexInputAttributeDescription(
    const VkVertexInputAttributeDescription* a,
    const VkVertexInputAttributeDescription* b,
    OnFailCompareFunc onFail)
{
    if (!((a->location) == (b->location))) { onFail("a->location (Error: Value not equal)"); };
    if (!((a->binding) == (b->binding))) { onFail("a->binding (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
}

void checkEqual_VkPipelineVertexInputStateCreateInfo(
    const VkPipelineVertexInputStateCreateInfo* a,
    const VkPipelineVertexInputStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->vertexBindingDescriptionCount) == (b->vertexBindingDescriptionCount))) { onFail("a->vertexBindingDescriptionCount (Error: Value not equal)"); };
    if ((a->pVertexBindingDescriptions) && (b->pVertexBindingDescriptions))
    {
        if (!((a->vertexBindingDescriptionCount) == (b->vertexBindingDescriptionCount))) { onFail("a->pVertexBindingDescriptions (Error: Lengths not equal)"); };
        if ((a->vertexBindingDescriptionCount) == (b->vertexBindingDescriptionCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->vertexBindingDescriptionCount; ++i)
                {
                    checkEqual_VkVertexInputBindingDescription(a->pVertexBindingDescriptions + i, b->pVertexBindingDescriptions + i, onFail);
                }
            }
        }
    }
    if (!((a->vertexAttributeDescriptionCount) == (b->vertexAttributeDescriptionCount))) { onFail("a->vertexAttributeDescriptionCount (Error: Value not equal)"); };
    if ((a->pVertexAttributeDescriptions) && (b->pVertexAttributeDescriptions))
    {
        if (!((a->vertexAttributeDescriptionCount) == (b->vertexAttributeDescriptionCount))) { onFail("a->pVertexAttributeDescriptions (Error: Lengths not equal)"); };
        if ((a->vertexAttributeDescriptionCount) == (b->vertexAttributeDescriptionCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->vertexAttributeDescriptionCount; ++i)
                {
                    checkEqual_VkVertexInputAttributeDescription(a->pVertexAttributeDescriptions + i, b->pVertexAttributeDescriptions + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkPipelineInputAssemblyStateCreateInfo(
    const VkPipelineInputAssemblyStateCreateInfo* a,
    const VkPipelineInputAssemblyStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->topology) == (b->topology))) { onFail("a->topology (Error: Value not equal)"); };
    if (!((a->primitiveRestartEnable) == (b->primitiveRestartEnable))) { onFail("a->primitiveRestartEnable (Error: Value not equal)"); };
}

void checkEqual_VkPipelineTessellationStateCreateInfo(
    const VkPipelineTessellationStateCreateInfo* a,
    const VkPipelineTessellationStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->patchControlPoints) == (b->patchControlPoints))) { onFail("a->patchControlPoints (Error: Value not equal)"); };
}

void checkEqual_VkViewport(
    const VkViewport* a,
    const VkViewport* b,
    OnFailCompareFunc onFail)
{
    if (!((a->x) == (b->x))) { onFail("a->x (Error: Value not equal)"); };
    if (!((a->y) == (b->y))) { onFail("a->y (Error: Value not equal)"); };
    if (!((a->width) == (b->width))) { onFail("a->width (Error: Value not equal)"); };
    if (!((a->height) == (b->height))) { onFail("a->height (Error: Value not equal)"); };
    if (!((a->minDepth) == (b->minDepth))) { onFail("a->minDepth (Error: Value not equal)"); };
    if (!((a->maxDepth) == (b->maxDepth))) { onFail("a->maxDepth (Error: Value not equal)"); };
}

void checkEqual_VkPipelineViewportStateCreateInfo(
    const VkPipelineViewportStateCreateInfo* a,
    const VkPipelineViewportStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->viewportCount) == (b->viewportCount))) { onFail("a->viewportCount (Error: Value not equal)"); };
    if (!((!(a->pViewports) && !(b->pViewports)) || ((a->pViewports) && (b->pViewports)))) { onFail("a->pViewports (Error: Mismatch in optional field)"); };
    if (a->pViewports && b->pViewports)
    {
        if ((a->pViewports) && (b->pViewports))
        {
            if (!((a->viewportCount) == (b->viewportCount))) { onFail("a->pViewports (Error: Lengths not equal)"); };
            if ((a->viewportCount) == (b->viewportCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->viewportCount; ++i)
                    {
                        checkEqual_VkViewport(a->pViewports + i, b->pViewports + i, onFail);
                    }
                }
            }
        }
    }
    if (!((a->scissorCount) == (b->scissorCount))) { onFail("a->scissorCount (Error: Value not equal)"); };
    if (!((!(a->pScissors) && !(b->pScissors)) || ((a->pScissors) && (b->pScissors)))) { onFail("a->pScissors (Error: Mismatch in optional field)"); };
    if (a->pScissors && b->pScissors)
    {
        if ((a->pScissors) && (b->pScissors))
        {
            if (!((a->scissorCount) == (b->scissorCount))) { onFail("a->pScissors (Error: Lengths not equal)"); };
            if ((a->scissorCount) == (b->scissorCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->scissorCount; ++i)
                    {
                        checkEqual_VkRect2D(a->pScissors + i, b->pScissors + i, onFail);
                    }
                }
            }
        }
    }
}

void checkEqual_VkPipelineRasterizationStateCreateInfo(
    const VkPipelineRasterizationStateCreateInfo* a,
    const VkPipelineRasterizationStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->depthClampEnable) == (b->depthClampEnable))) { onFail("a->depthClampEnable (Error: Value not equal)"); };
    if (!((a->rasterizerDiscardEnable) == (b->rasterizerDiscardEnable))) { onFail("a->rasterizerDiscardEnable (Error: Value not equal)"); };
    if (!((a->polygonMode) == (b->polygonMode))) { onFail("a->polygonMode (Error: Value not equal)"); };
    if (!((a->cullMode) == (b->cullMode))) { onFail("a->cullMode (Error: Value not equal)"); };
    if (!((a->frontFace) == (b->frontFace))) { onFail("a->frontFace (Error: Value not equal)"); };
    if (!((a->depthBiasEnable) == (b->depthBiasEnable))) { onFail("a->depthBiasEnable (Error: Value not equal)"); };
    if (!((a->depthBiasConstantFactor) == (b->depthBiasConstantFactor))) { onFail("a->depthBiasConstantFactor (Error: Value not equal)"); };
    if (!((a->depthBiasClamp) == (b->depthBiasClamp))) { onFail("a->depthBiasClamp (Error: Value not equal)"); };
    if (!((a->depthBiasSlopeFactor) == (b->depthBiasSlopeFactor))) { onFail("a->depthBiasSlopeFactor (Error: Value not equal)"); };
    if (!((a->lineWidth) == (b->lineWidth))) { onFail("a->lineWidth (Error: Value not equal)"); };
}

void checkEqual_VkPipelineMultisampleStateCreateInfo(
    const VkPipelineMultisampleStateCreateInfo* a,
    const VkPipelineMultisampleStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->rasterizationSamples) == (b->rasterizationSamples))) { onFail("a->rasterizationSamples (Error: Value not equal)"); };
    if (!((a->sampleShadingEnable) == (b->sampleShadingEnable))) { onFail("a->sampleShadingEnable (Error: Value not equal)"); };
    if (!((a->minSampleShading) == (b->minSampleShading))) { onFail("a->minSampleShading (Error: Value not equal)"); };
    if (!((!(a->pSampleMask) && !(b->pSampleMask)) || ((a->pSampleMask) && (b->pSampleMask)))) { onFail("a->pSampleMask (Error: Mismatch in optional field)"); };
    if (a->pSampleMask && b->pSampleMask)
    {
        if (!(((((a->rasterizationSamples) + 31) / 32)) == ((((b->rasterizationSamples) + 31) / 32)))) { onFail("a->pSampleMask (Error: Lengths not equal)"); };
        if (!((memcmp(a->pSampleMask, b->pSampleMask, (((a->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask)) == 0))) { onFail("a->pSampleMask (Error: Unequal dyn array)"); };
    }
    if (!((a->alphaToCoverageEnable) == (b->alphaToCoverageEnable))) { onFail("a->alphaToCoverageEnable (Error: Value not equal)"); };
    if (!((a->alphaToOneEnable) == (b->alphaToOneEnable))) { onFail("a->alphaToOneEnable (Error: Value not equal)"); };
}

void checkEqual_VkStencilOpState(
    const VkStencilOpState* a,
    const VkStencilOpState* b,
    OnFailCompareFunc onFail)
{
    if (!((a->failOp) == (b->failOp))) { onFail("a->failOp (Error: Value not equal)"); };
    if (!((a->passOp) == (b->passOp))) { onFail("a->passOp (Error: Value not equal)"); };
    if (!((a->depthFailOp) == (b->depthFailOp))) { onFail("a->depthFailOp (Error: Value not equal)"); };
    if (!((a->compareOp) == (b->compareOp))) { onFail("a->compareOp (Error: Value not equal)"); };
    if (!((a->compareMask) == (b->compareMask))) { onFail("a->compareMask (Error: Value not equal)"); };
    if (!((a->writeMask) == (b->writeMask))) { onFail("a->writeMask (Error: Value not equal)"); };
    if (!((a->reference) == (b->reference))) { onFail("a->reference (Error: Value not equal)"); };
}

void checkEqual_VkPipelineDepthStencilStateCreateInfo(
    const VkPipelineDepthStencilStateCreateInfo* a,
    const VkPipelineDepthStencilStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->depthTestEnable) == (b->depthTestEnable))) { onFail("a->depthTestEnable (Error: Value not equal)"); };
    if (!((a->depthWriteEnable) == (b->depthWriteEnable))) { onFail("a->depthWriteEnable (Error: Value not equal)"); };
    if (!((a->depthCompareOp) == (b->depthCompareOp))) { onFail("a->depthCompareOp (Error: Value not equal)"); };
    if (!((a->depthBoundsTestEnable) == (b->depthBoundsTestEnable))) { onFail("a->depthBoundsTestEnable (Error: Value not equal)"); };
    if (!((a->stencilTestEnable) == (b->stencilTestEnable))) { onFail("a->stencilTestEnable (Error: Value not equal)"); };
    checkEqual_VkStencilOpState(&a->front, &b->front, onFail);
    checkEqual_VkStencilOpState(&a->back, &b->back, onFail);
    if (!((a->minDepthBounds) == (b->minDepthBounds))) { onFail("a->minDepthBounds (Error: Value not equal)"); };
    if (!((a->maxDepthBounds) == (b->maxDepthBounds))) { onFail("a->maxDepthBounds (Error: Value not equal)"); };
}

void checkEqual_VkPipelineColorBlendAttachmentState(
    const VkPipelineColorBlendAttachmentState* a,
    const VkPipelineColorBlendAttachmentState* b,
    OnFailCompareFunc onFail)
{
    if (!((a->blendEnable) == (b->blendEnable))) { onFail("a->blendEnable (Error: Value not equal)"); };
    if (!((a->srcColorBlendFactor) == (b->srcColorBlendFactor))) { onFail("a->srcColorBlendFactor (Error: Value not equal)"); };
    if (!((a->dstColorBlendFactor) == (b->dstColorBlendFactor))) { onFail("a->dstColorBlendFactor (Error: Value not equal)"); };
    if (!((a->colorBlendOp) == (b->colorBlendOp))) { onFail("a->colorBlendOp (Error: Value not equal)"); };
    if (!((a->srcAlphaBlendFactor) == (b->srcAlphaBlendFactor))) { onFail("a->srcAlphaBlendFactor (Error: Value not equal)"); };
    if (!((a->dstAlphaBlendFactor) == (b->dstAlphaBlendFactor))) { onFail("a->dstAlphaBlendFactor (Error: Value not equal)"); };
    if (!((a->alphaBlendOp) == (b->alphaBlendOp))) { onFail("a->alphaBlendOp (Error: Value not equal)"); };
    if (!((a->colorWriteMask) == (b->colorWriteMask))) { onFail("a->colorWriteMask (Error: Value not equal)"); };
}

void checkEqual_VkPipelineColorBlendStateCreateInfo(
    const VkPipelineColorBlendStateCreateInfo* a,
    const VkPipelineColorBlendStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->logicOpEnable) == (b->logicOpEnable))) { onFail("a->logicOpEnable (Error: Value not equal)"); };
    if (!((a->logicOp) == (b->logicOp))) { onFail("a->logicOp (Error: Value not equal)"); };
    if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->attachmentCount (Error: Value not equal)"); };
    if ((a->pAttachments) && (b->pAttachments))
    {
        if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->pAttachments (Error: Lengths not equal)"); };
        if ((a->attachmentCount) == (b->attachmentCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->attachmentCount; ++i)
                {
                    checkEqual_VkPipelineColorBlendAttachmentState(a->pAttachments + i, b->pAttachments + i, onFail);
                }
            }
        }
    }
    if (!((memcmp(a->blendConstants, b->blendConstants, 4 * sizeof(float)) == 0))) { onFail("a->blendConstants (Error: Unequal static array)"); };
}

void checkEqual_VkPipelineDynamicStateCreateInfo(
    const VkPipelineDynamicStateCreateInfo* a,
    const VkPipelineDynamicStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->dynamicStateCount) == (b->dynamicStateCount))) { onFail("a->dynamicStateCount (Error: Value not equal)"); };
    if (!((a->dynamicStateCount) == (b->dynamicStateCount))) { onFail("a->pDynamicStates (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDynamicStates, b->pDynamicStates, a->dynamicStateCount * sizeof(const VkDynamicState)) == 0))) { onFail("a->pDynamicStates (Error: Unequal dyn array)"); };
}

void checkEqual_VkGraphicsPipelineCreateInfo(
    const VkGraphicsPipelineCreateInfo* a,
    const VkGraphicsPipelineCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->stageCount) == (b->stageCount))) { onFail("a->stageCount (Error: Value not equal)"); };
    if ((a->pStages) && (b->pStages))
    {
        if (!((a->stageCount) == (b->stageCount))) { onFail("a->pStages (Error: Lengths not equal)"); };
        if ((a->stageCount) == (b->stageCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->stageCount; ++i)
                {
                    checkEqual_VkPipelineShaderStageCreateInfo(a->pStages + i, b->pStages + i, onFail);
                }
            }
        }
    }
    if (!((!(a->pVertexInputState) && !(b->pVertexInputState)) || ((a->pVertexInputState) && (b->pVertexInputState)))) { onFail("a->pVertexInputState (Error: Mismatch in optional field)"); };
    if (a->pVertexInputState && b->pVertexInputState)
    {
        if ((a->pVertexInputState) && (b->pVertexInputState))
        {
            checkEqual_VkPipelineVertexInputStateCreateInfo(a->pVertexInputState, b->pVertexInputState, onFail);
        }
    }
    if (!((!(a->pInputAssemblyState) && !(b->pInputAssemblyState)) || ((a->pInputAssemblyState) && (b->pInputAssemblyState)))) { onFail("a->pInputAssemblyState (Error: Mismatch in optional field)"); };
    if (a->pInputAssemblyState && b->pInputAssemblyState)
    {
        if ((a->pInputAssemblyState) && (b->pInputAssemblyState))
        {
            checkEqual_VkPipelineInputAssemblyStateCreateInfo(a->pInputAssemblyState, b->pInputAssemblyState, onFail);
        }
    }
    if (!((!(a->pTessellationState) && !(b->pTessellationState)) || ((a->pTessellationState) && (b->pTessellationState)))) { onFail("a->pTessellationState (Error: Mismatch in optional field)"); };
    if (a->pTessellationState && b->pTessellationState)
    {
        if ((a->pTessellationState) && (b->pTessellationState))
        {
            checkEqual_VkPipelineTessellationStateCreateInfo(a->pTessellationState, b->pTessellationState, onFail);
        }
    }
    if (!((!(a->pViewportState) && !(b->pViewportState)) || ((a->pViewportState) && (b->pViewportState)))) { onFail("a->pViewportState (Error: Mismatch in optional field)"); };
    if (a->pViewportState && b->pViewportState)
    {
        if ((a->pViewportState) && (b->pViewportState))
        {
            checkEqual_VkPipelineViewportStateCreateInfo(a->pViewportState, b->pViewportState, onFail);
        }
    }
    if (!((!(a->pRasterizationState) && !(b->pRasterizationState)) || ((a->pRasterizationState) && (b->pRasterizationState)))) { onFail("a->pRasterizationState (Error: Mismatch in optional field)"); };
    if (a->pRasterizationState && b->pRasterizationState)
    {
        if ((a->pRasterizationState) && (b->pRasterizationState))
        {
            checkEqual_VkPipelineRasterizationStateCreateInfo(a->pRasterizationState, b->pRasterizationState, onFail);
        }
    }
    if (!((!(a->pMultisampleState) && !(b->pMultisampleState)) || ((a->pMultisampleState) && (b->pMultisampleState)))) { onFail("a->pMultisampleState (Error: Mismatch in optional field)"); };
    if (a->pMultisampleState && b->pMultisampleState)
    {
        if ((a->pMultisampleState) && (b->pMultisampleState))
        {
            checkEqual_VkPipelineMultisampleStateCreateInfo(a->pMultisampleState, b->pMultisampleState, onFail);
        }
    }
    if (!((!(a->pDepthStencilState) && !(b->pDepthStencilState)) || ((a->pDepthStencilState) && (b->pDepthStencilState)))) { onFail("a->pDepthStencilState (Error: Mismatch in optional field)"); };
    if (a->pDepthStencilState && b->pDepthStencilState)
    {
        if ((a->pDepthStencilState) && (b->pDepthStencilState))
        {
            checkEqual_VkPipelineDepthStencilStateCreateInfo(a->pDepthStencilState, b->pDepthStencilState, onFail);
        }
    }
    if (!((!(a->pColorBlendState) && !(b->pColorBlendState)) || ((a->pColorBlendState) && (b->pColorBlendState)))) { onFail("a->pColorBlendState (Error: Mismatch in optional field)"); };
    if (a->pColorBlendState && b->pColorBlendState)
    {
        if ((a->pColorBlendState) && (b->pColorBlendState))
        {
            checkEqual_VkPipelineColorBlendStateCreateInfo(a->pColorBlendState, b->pColorBlendState, onFail);
        }
    }
    if (!((!(a->pDynamicState) && !(b->pDynamicState)) || ((a->pDynamicState) && (b->pDynamicState)))) { onFail("a->pDynamicState (Error: Mismatch in optional field)"); };
    if (a->pDynamicState && b->pDynamicState)
    {
        if ((a->pDynamicState) && (b->pDynamicState))
        {
            checkEqual_VkPipelineDynamicStateCreateInfo(a->pDynamicState, b->pDynamicState, onFail);
        }
    }
    if (!((a->layout) == (b->layout))) { onFail("a->layout (Error: Value not equal)"); };
    if (!((a->renderPass) == (b->renderPass))) { onFail("a->renderPass (Error: Value not equal)"); };
    if (!((a->subpass) == (b->subpass))) { onFail("a->subpass (Error: Value not equal)"); };
    if (!((a->basePipelineHandle) == (b->basePipelineHandle))) { onFail("a->basePipelineHandle (Error: Value not equal)"); };
    if (!((a->basePipelineIndex) == (b->basePipelineIndex))) { onFail("a->basePipelineIndex (Error: Value not equal)"); };
}

void checkEqual_VkPushConstantRange(
    const VkPushConstantRange* a,
    const VkPushConstantRange* b,
    OnFailCompareFunc onFail)
{
    if (!((a->stageFlags) == (b->stageFlags))) { onFail("a->stageFlags (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
}

void checkEqual_VkPipelineLayoutCreateInfo(
    const VkPipelineLayoutCreateInfo* a,
    const VkPipelineLayoutCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->setLayoutCount) == (b->setLayoutCount))) { onFail("a->setLayoutCount (Error: Value not equal)"); };
    if (!((a->setLayoutCount) == (b->setLayoutCount))) { onFail("a->pSetLayouts (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSetLayouts, b->pSetLayouts, a->setLayoutCount * sizeof(const VkDescriptorSetLayout)) == 0))) { onFail("a->pSetLayouts (Error: Unequal dyn array)"); };
    if (!((a->pushConstantRangeCount) == (b->pushConstantRangeCount))) { onFail("a->pushConstantRangeCount (Error: Value not equal)"); };
    if ((a->pPushConstantRanges) && (b->pPushConstantRanges))
    {
        if (!((a->pushConstantRangeCount) == (b->pushConstantRangeCount))) { onFail("a->pPushConstantRanges (Error: Lengths not equal)"); };
        if ((a->pushConstantRangeCount) == (b->pushConstantRangeCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->pushConstantRangeCount; ++i)
                {
                    checkEqual_VkPushConstantRange(a->pPushConstantRanges + i, b->pPushConstantRanges + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkSamplerCreateInfo(
    const VkSamplerCreateInfo* a,
    const VkSamplerCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->magFilter) == (b->magFilter))) { onFail("a->magFilter (Error: Value not equal)"); };
    if (!((a->minFilter) == (b->minFilter))) { onFail("a->minFilter (Error: Value not equal)"); };
    if (!((a->mipmapMode) == (b->mipmapMode))) { onFail("a->mipmapMode (Error: Value not equal)"); };
    if (!((a->addressModeU) == (b->addressModeU))) { onFail("a->addressModeU (Error: Value not equal)"); };
    if (!((a->addressModeV) == (b->addressModeV))) { onFail("a->addressModeV (Error: Value not equal)"); };
    if (!((a->addressModeW) == (b->addressModeW))) { onFail("a->addressModeW (Error: Value not equal)"); };
    if (!((a->mipLodBias) == (b->mipLodBias))) { onFail("a->mipLodBias (Error: Value not equal)"); };
    if (!((a->anisotropyEnable) == (b->anisotropyEnable))) { onFail("a->anisotropyEnable (Error: Value not equal)"); };
    if (!((a->maxAnisotropy) == (b->maxAnisotropy))) { onFail("a->maxAnisotropy (Error: Value not equal)"); };
    if (!((a->compareEnable) == (b->compareEnable))) { onFail("a->compareEnable (Error: Value not equal)"); };
    if (!((a->compareOp) == (b->compareOp))) { onFail("a->compareOp (Error: Value not equal)"); };
    if (!((a->minLod) == (b->minLod))) { onFail("a->minLod (Error: Value not equal)"); };
    if (!((a->maxLod) == (b->maxLod))) { onFail("a->maxLod (Error: Value not equal)"); };
    if (!((a->borderColor) == (b->borderColor))) { onFail("a->borderColor (Error: Value not equal)"); };
    if (!((a->unnormalizedCoordinates) == (b->unnormalizedCoordinates))) { onFail("a->unnormalizedCoordinates (Error: Value not equal)"); };
}

void checkEqual_VkCopyDescriptorSet(
    const VkCopyDescriptorSet* a,
    const VkCopyDescriptorSet* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcSet) == (b->srcSet))) { onFail("a->srcSet (Error: Value not equal)"); };
    if (!((a->srcBinding) == (b->srcBinding))) { onFail("a->srcBinding (Error: Value not equal)"); };
    if (!((a->srcArrayElement) == (b->srcArrayElement))) { onFail("a->srcArrayElement (Error: Value not equal)"); };
    if (!((a->dstSet) == (b->dstSet))) { onFail("a->dstSet (Error: Value not equal)"); };
    if (!((a->dstBinding) == (b->dstBinding))) { onFail("a->dstBinding (Error: Value not equal)"); };
    if (!((a->dstArrayElement) == (b->dstArrayElement))) { onFail("a->dstArrayElement (Error: Value not equal)"); };
    if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->descriptorCount (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorBufferInfo(
    const VkDescriptorBufferInfo* a,
    const VkDescriptorBufferInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->range) == (b->range))) { onFail("a->range (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorImageInfo(
    const VkDescriptorImageInfo* a,
    const VkDescriptorImageInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sampler) == (b->sampler))) { onFail("a->sampler (Error: Value not equal)"); };
    if (!((a->imageView) == (b->imageView))) { onFail("a->imageView (Error: Value not equal)"); };
    if (!((a->imageLayout) == (b->imageLayout))) { onFail("a->imageLayout (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorPoolSize(
    const VkDescriptorPoolSize* a,
    const VkDescriptorPoolSize* b,
    OnFailCompareFunc onFail)
{
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->descriptorCount (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorPoolCreateInfo(
    const VkDescriptorPoolCreateInfo* a,
    const VkDescriptorPoolCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->maxSets) == (b->maxSets))) { onFail("a->maxSets (Error: Value not equal)"); };
    if (!((a->poolSizeCount) == (b->poolSizeCount))) { onFail("a->poolSizeCount (Error: Value not equal)"); };
    if ((a->pPoolSizes) && (b->pPoolSizes))
    {
        if (!((a->poolSizeCount) == (b->poolSizeCount))) { onFail("a->pPoolSizes (Error: Lengths not equal)"); };
        if ((a->poolSizeCount) == (b->poolSizeCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->poolSizeCount; ++i)
                {
                    checkEqual_VkDescriptorPoolSize(a->pPoolSizes + i, b->pPoolSizes + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkDescriptorSetAllocateInfo(
    const VkDescriptorSetAllocateInfo* a,
    const VkDescriptorSetAllocateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->descriptorPool) == (b->descriptorPool))) { onFail("a->descriptorPool (Error: Value not equal)"); };
    if (!((a->descriptorSetCount) == (b->descriptorSetCount))) { onFail("a->descriptorSetCount (Error: Value not equal)"); };
    if (!((a->descriptorSetCount) == (b->descriptorSetCount))) { onFail("a->pSetLayouts (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSetLayouts, b->pSetLayouts, a->descriptorSetCount * sizeof(const VkDescriptorSetLayout)) == 0))) { onFail("a->pSetLayouts (Error: Unequal dyn array)"); };
}

void checkEqual_VkDescriptorSetLayoutBinding(
    const VkDescriptorSetLayoutBinding* a,
    const VkDescriptorSetLayoutBinding* b,
    OnFailCompareFunc onFail)
{
    if (!((a->binding) == (b->binding))) { onFail("a->binding (Error: Value not equal)"); };
    if (!((a->descriptorType) == (b->descriptorType))) { onFail("a->descriptorType (Error: Value not equal)"); };
    if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->descriptorCount (Error: Value not equal)"); };
    if (!((a->stageFlags) == (b->stageFlags))) { onFail("a->stageFlags (Error: Value not equal)"); };
    if (!((!(a->pImmutableSamplers) && !(b->pImmutableSamplers)) || ((a->pImmutableSamplers) && (b->pImmutableSamplers)))) { onFail("a->pImmutableSamplers (Error: Mismatch in optional field)"); };
    if (a->pImmutableSamplers && b->pImmutableSamplers)
    {
        if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->pImmutableSamplers (Error: Lengths not equal)"); };
        if (!((memcmp(a->pImmutableSamplers, b->pImmutableSamplers, a->descriptorCount * sizeof(const VkSampler)) == 0))) { onFail("a->pImmutableSamplers (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkDescriptorSetLayoutCreateInfo(
    const VkDescriptorSetLayoutCreateInfo* a,
    const VkDescriptorSetLayoutCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->bindingCount) == (b->bindingCount))) { onFail("a->bindingCount (Error: Value not equal)"); };
    if ((a->pBindings) && (b->pBindings))
    {
        if (!((a->bindingCount) == (b->bindingCount))) { onFail("a->pBindings (Error: Lengths not equal)"); };
        if ((a->bindingCount) == (b->bindingCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->bindingCount; ++i)
                {
                    checkEqual_VkDescriptorSetLayoutBinding(a->pBindings + i, b->pBindings + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkWriteDescriptorSet(
    const VkWriteDescriptorSet* a,
    const VkWriteDescriptorSet* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->dstSet) == (b->dstSet))) { onFail("a->dstSet (Error: Value not equal)"); };
    if (!((a->dstBinding) == (b->dstBinding))) { onFail("a->dstBinding (Error: Value not equal)"); };
    if (!((a->dstArrayElement) == (b->dstArrayElement))) { onFail("a->dstArrayElement (Error: Value not equal)"); };
    if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->descriptorCount (Error: Value not equal)"); };
    if (!((a->descriptorType) == (b->descriptorType))) { onFail("a->descriptorType (Error: Value not equal)"); };
    if (!((!(a->pImageInfo) && !(b->pImageInfo)) || ((a->pImageInfo) && (b->pImageInfo)))) { onFail("a->pImageInfo (Error: Mismatch in optional field)"); };
    if (a->pImageInfo && b->pImageInfo)
    {
        if ((a->pImageInfo) && (b->pImageInfo))
        {
            if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->pImageInfo (Error: Lengths not equal)"); };
            if ((a->descriptorCount) == (b->descriptorCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->descriptorCount; ++i)
                    {
                        checkEqual_VkDescriptorImageInfo(a->pImageInfo + i, b->pImageInfo + i, onFail);
                    }
                }
            }
        }
    }
    if (!((!(a->pBufferInfo) && !(b->pBufferInfo)) || ((a->pBufferInfo) && (b->pBufferInfo)))) { onFail("a->pBufferInfo (Error: Mismatch in optional field)"); };
    if (a->pBufferInfo && b->pBufferInfo)
    {
        if ((a->pBufferInfo) && (b->pBufferInfo))
        {
            if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->pBufferInfo (Error: Lengths not equal)"); };
            if ((a->descriptorCount) == (b->descriptorCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->descriptorCount; ++i)
                    {
                        checkEqual_VkDescriptorBufferInfo(a->pBufferInfo + i, b->pBufferInfo + i, onFail);
                    }
                }
            }
        }
    }
    if (!((!(a->pTexelBufferView) && !(b->pTexelBufferView)) || ((a->pTexelBufferView) && (b->pTexelBufferView)))) { onFail("a->pTexelBufferView (Error: Mismatch in optional field)"); };
    if (a->pTexelBufferView && b->pTexelBufferView)
    {
        if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->pTexelBufferView (Error: Lengths not equal)"); };
        if (!((memcmp(a->pTexelBufferView, b->pTexelBufferView, a->descriptorCount * sizeof(const VkBufferView)) == 0))) { onFail("a->pTexelBufferView (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkAttachmentDescription(
    const VkAttachmentDescription* a,
    const VkAttachmentDescription* b,
    OnFailCompareFunc onFail)
{
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->samples) == (b->samples))) { onFail("a->samples (Error: Value not equal)"); };
    if (!((a->loadOp) == (b->loadOp))) { onFail("a->loadOp (Error: Value not equal)"); };
    if (!((a->storeOp) == (b->storeOp))) { onFail("a->storeOp (Error: Value not equal)"); };
    if (!((a->stencilLoadOp) == (b->stencilLoadOp))) { onFail("a->stencilLoadOp (Error: Value not equal)"); };
    if (!((a->stencilStoreOp) == (b->stencilStoreOp))) { onFail("a->stencilStoreOp (Error: Value not equal)"); };
    if (!((a->initialLayout) == (b->initialLayout))) { onFail("a->initialLayout (Error: Value not equal)"); };
    if (!((a->finalLayout) == (b->finalLayout))) { onFail("a->finalLayout (Error: Value not equal)"); };
}

void checkEqual_VkAttachmentReference(
    const VkAttachmentReference* a,
    const VkAttachmentReference* b,
    OnFailCompareFunc onFail)
{
    if (!((a->attachment) == (b->attachment))) { onFail("a->attachment (Error: Value not equal)"); };
    if (!((a->layout) == (b->layout))) { onFail("a->layout (Error: Value not equal)"); };
}

void checkEqual_VkFramebufferCreateInfo(
    const VkFramebufferCreateInfo* a,
    const VkFramebufferCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->renderPass) == (b->renderPass))) { onFail("a->renderPass (Error: Value not equal)"); };
    if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->attachmentCount (Error: Value not equal)"); };
    if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->pAttachments (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAttachments, b->pAttachments, a->attachmentCount * sizeof(const VkImageView)) == 0))) { onFail("a->pAttachments (Error: Unequal dyn array)"); };
    if (!((a->width) == (b->width))) { onFail("a->width (Error: Value not equal)"); };
    if (!((a->height) == (b->height))) { onFail("a->height (Error: Value not equal)"); };
    if (!((a->layers) == (b->layers))) { onFail("a->layers (Error: Value not equal)"); };
}

void checkEqual_VkSubpassDescription(
    const VkSubpassDescription* a,
    const VkSubpassDescription* b,
    OnFailCompareFunc onFail)
{
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->pipelineBindPoint) == (b->pipelineBindPoint))) { onFail("a->pipelineBindPoint (Error: Value not equal)"); };
    if (!((a->inputAttachmentCount) == (b->inputAttachmentCount))) { onFail("a->inputAttachmentCount (Error: Value not equal)"); };
    if ((a->pInputAttachments) && (b->pInputAttachments))
    {
        if (!((a->inputAttachmentCount) == (b->inputAttachmentCount))) { onFail("a->pInputAttachments (Error: Lengths not equal)"); };
        if ((a->inputAttachmentCount) == (b->inputAttachmentCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->inputAttachmentCount; ++i)
                {
                    checkEqual_VkAttachmentReference(a->pInputAttachments + i, b->pInputAttachments + i, onFail);
                }
            }
        }
    }
    if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->colorAttachmentCount (Error: Value not equal)"); };
    if ((a->pColorAttachments) && (b->pColorAttachments))
    {
        if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->pColorAttachments (Error: Lengths not equal)"); };
        if ((a->colorAttachmentCount) == (b->colorAttachmentCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->colorAttachmentCount; ++i)
                {
                    checkEqual_VkAttachmentReference(a->pColorAttachments + i, b->pColorAttachments + i, onFail);
                }
            }
        }
    }
    if (!((!(a->pResolveAttachments) && !(b->pResolveAttachments)) || ((a->pResolveAttachments) && (b->pResolveAttachments)))) { onFail("a->pResolveAttachments (Error: Mismatch in optional field)"); };
    if (a->pResolveAttachments && b->pResolveAttachments)
    {
        if ((a->pResolveAttachments) && (b->pResolveAttachments))
        {
            if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->pResolveAttachments (Error: Lengths not equal)"); };
            if ((a->colorAttachmentCount) == (b->colorAttachmentCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->colorAttachmentCount; ++i)
                    {
                        checkEqual_VkAttachmentReference(a->pResolveAttachments + i, b->pResolveAttachments + i, onFail);
                    }
                }
            }
        }
    }
    if (!((!(a->pDepthStencilAttachment) && !(b->pDepthStencilAttachment)) || ((a->pDepthStencilAttachment) && (b->pDepthStencilAttachment)))) { onFail("a->pDepthStencilAttachment (Error: Mismatch in optional field)"); };
    if (a->pDepthStencilAttachment && b->pDepthStencilAttachment)
    {
        if ((a->pDepthStencilAttachment) && (b->pDepthStencilAttachment))
        {
            checkEqual_VkAttachmentReference(a->pDepthStencilAttachment, b->pDepthStencilAttachment, onFail);
        }
    }
    if (!((a->preserveAttachmentCount) == (b->preserveAttachmentCount))) { onFail("a->preserveAttachmentCount (Error: Value not equal)"); };
    if (!((a->preserveAttachmentCount) == (b->preserveAttachmentCount))) { onFail("a->pPreserveAttachments (Error: Lengths not equal)"); };
    if (!((memcmp(a->pPreserveAttachments, b->pPreserveAttachments, a->preserveAttachmentCount * sizeof(const uint32_t)) == 0))) { onFail("a->pPreserveAttachments (Error: Unequal dyn array)"); };
}

void checkEqual_VkSubpassDependency(
    const VkSubpassDependency* a,
    const VkSubpassDependency* b,
    OnFailCompareFunc onFail)
{
    if (!((a->srcSubpass) == (b->srcSubpass))) { onFail("a->srcSubpass (Error: Value not equal)"); };
    if (!((a->dstSubpass) == (b->dstSubpass))) { onFail("a->dstSubpass (Error: Value not equal)"); };
    if (!((a->srcStageMask) == (b->srcStageMask))) { onFail("a->srcStageMask (Error: Value not equal)"); };
    if (!((a->dstStageMask) == (b->dstStageMask))) { onFail("a->dstStageMask (Error: Value not equal)"); };
    if (!((a->srcAccessMask) == (b->srcAccessMask))) { onFail("a->srcAccessMask (Error: Value not equal)"); };
    if (!((a->dstAccessMask) == (b->dstAccessMask))) { onFail("a->dstAccessMask (Error: Value not equal)"); };
    if (!((a->dependencyFlags) == (b->dependencyFlags))) { onFail("a->dependencyFlags (Error: Value not equal)"); };
}

void checkEqual_VkRenderPassCreateInfo(
    const VkRenderPassCreateInfo* a,
    const VkRenderPassCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->attachmentCount (Error: Value not equal)"); };
    if ((a->pAttachments) && (b->pAttachments))
    {
        if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->pAttachments (Error: Lengths not equal)"); };
        if ((a->attachmentCount) == (b->attachmentCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->attachmentCount; ++i)
                {
                    checkEqual_VkAttachmentDescription(a->pAttachments + i, b->pAttachments + i, onFail);
                }
            }
        }
    }
    if (!((a->subpassCount) == (b->subpassCount))) { onFail("a->subpassCount (Error: Value not equal)"); };
    if ((a->pSubpasses) && (b->pSubpasses))
    {
        if (!((a->subpassCount) == (b->subpassCount))) { onFail("a->pSubpasses (Error: Lengths not equal)"); };
        if ((a->subpassCount) == (b->subpassCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->subpassCount; ++i)
                {
                    checkEqual_VkSubpassDescription(a->pSubpasses + i, b->pSubpasses + i, onFail);
                }
            }
        }
    }
    if (!((a->dependencyCount) == (b->dependencyCount))) { onFail("a->dependencyCount (Error: Value not equal)"); };
    if ((a->pDependencies) && (b->pDependencies))
    {
        if (!((a->dependencyCount) == (b->dependencyCount))) { onFail("a->pDependencies (Error: Lengths not equal)"); };
        if ((a->dependencyCount) == (b->dependencyCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->dependencyCount; ++i)
                {
                    checkEqual_VkSubpassDependency(a->pDependencies + i, b->pDependencies + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkCommandPoolCreateInfo(
    const VkCommandPoolCreateInfo* a,
    const VkCommandPoolCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->queueFamilyIndex) == (b->queueFamilyIndex))) { onFail("a->queueFamilyIndex (Error: Value not equal)"); };
}

void checkEqual_VkCommandBufferAllocateInfo(
    const VkCommandBufferAllocateInfo* a,
    const VkCommandBufferAllocateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->commandPool) == (b->commandPool))) { onFail("a->commandPool (Error: Value not equal)"); };
    if (!((a->level) == (b->level))) { onFail("a->level (Error: Value not equal)"); };
    if (!((a->commandBufferCount) == (b->commandBufferCount))) { onFail("a->commandBufferCount (Error: Value not equal)"); };
}

void checkEqual_VkCommandBufferInheritanceInfo(
    const VkCommandBufferInheritanceInfo* a,
    const VkCommandBufferInheritanceInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->renderPass) == (b->renderPass))) { onFail("a->renderPass (Error: Value not equal)"); };
    if (!((a->subpass) == (b->subpass))) { onFail("a->subpass (Error: Value not equal)"); };
    if (!((a->framebuffer) == (b->framebuffer))) { onFail("a->framebuffer (Error: Value not equal)"); };
    if (!((a->occlusionQueryEnable) == (b->occlusionQueryEnable))) { onFail("a->occlusionQueryEnable (Error: Value not equal)"); };
    if (!((a->queryFlags) == (b->queryFlags))) { onFail("a->queryFlags (Error: Value not equal)"); };
    if (!((a->pipelineStatistics) == (b->pipelineStatistics))) { onFail("a->pipelineStatistics (Error: Value not equal)"); };
}

void checkEqual_VkCommandBufferBeginInfo(
    const VkCommandBufferBeginInfo* a,
    const VkCommandBufferBeginInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->pInheritanceInfo) && !(b->pInheritanceInfo)) || ((a->pInheritanceInfo) && (b->pInheritanceInfo)))) { onFail("a->pInheritanceInfo (Error: Mismatch in optional field)"); };
    if (a->pInheritanceInfo && b->pInheritanceInfo)
    {
        if ((a->pInheritanceInfo) && (b->pInheritanceInfo))
        {
            checkEqual_VkCommandBufferInheritanceInfo(a->pInheritanceInfo, b->pInheritanceInfo, onFail);
        }
    }
}

void checkEqual_VkBufferCopy(
    const VkBufferCopy* a,
    const VkBufferCopy* b,
    OnFailCompareFunc onFail)
{
    if (!((a->srcOffset) == (b->srcOffset))) { onFail("a->srcOffset (Error: Value not equal)"); };
    if (!((a->dstOffset) == (b->dstOffset))) { onFail("a->dstOffset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
}

void checkEqual_VkImageSubresourceLayers(
    const VkImageSubresourceLayers* a,
    const VkImageSubresourceLayers* b,
    OnFailCompareFunc onFail)
{
    if (!((a->aspectMask) == (b->aspectMask))) { onFail("a->aspectMask (Error: Value not equal)"); };
    if (!((a->mipLevel) == (b->mipLevel))) { onFail("a->mipLevel (Error: Value not equal)"); };
    if (!((a->baseArrayLayer) == (b->baseArrayLayer))) { onFail("a->baseArrayLayer (Error: Value not equal)"); };
    if (!((a->layerCount) == (b->layerCount))) { onFail("a->layerCount (Error: Value not equal)"); };
}

void checkEqual_VkBufferImageCopy(
    const VkBufferImageCopy* a,
    const VkBufferImageCopy* b,
    OnFailCompareFunc onFail)
{
    if (!((a->bufferOffset) == (b->bufferOffset))) { onFail("a->bufferOffset (Error: Value not equal)"); };
    if (!((a->bufferRowLength) == (b->bufferRowLength))) { onFail("a->bufferRowLength (Error: Value not equal)"); };
    if (!((a->bufferImageHeight) == (b->bufferImageHeight))) { onFail("a->bufferImageHeight (Error: Value not equal)"); };
    checkEqual_VkImageSubresourceLayers(&a->imageSubresource, &b->imageSubresource, onFail);
    checkEqual_VkOffset3D(&a->imageOffset, &b->imageOffset, onFail);
    checkEqual_VkExtent3D(&a->imageExtent, &b->imageExtent, onFail);
}

void checkEqual_VkClearColorValue(
    const VkClearColorValue* a,
    const VkClearColorValue* b,
    OnFailCompareFunc onFail)
{
    if (!((memcmp(a->float32, b->float32, 4 * sizeof(float)) == 0))) { onFail("a->float32 (Error: Unequal static array)"); };
    if (!((memcmp(a->int32, b->int32, 4 * sizeof(int32_t)) == 0))) { onFail("a->int32 (Error: Unequal static array)"); };
    if (!((memcmp(a->uint32, b->uint32, 4 * sizeof(uint32_t)) == 0))) { onFail("a->uint32 (Error: Unequal static array)"); };
}

void checkEqual_VkClearDepthStencilValue(
    const VkClearDepthStencilValue* a,
    const VkClearDepthStencilValue* b,
    OnFailCompareFunc onFail)
{
    if (!((a->depth) == (b->depth))) { onFail("a->depth (Error: Value not equal)"); };
    if (!((a->stencil) == (b->stencil))) { onFail("a->stencil (Error: Value not equal)"); };
}

void checkEqual_VkClearValue(
    const VkClearValue* a,
    const VkClearValue* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkClearColorValue(&a->color, &b->color, onFail);
    checkEqual_VkClearDepthStencilValue(&a->depthStencil, &b->depthStencil, onFail);
}

void checkEqual_VkClearAttachment(
    const VkClearAttachment* a,
    const VkClearAttachment* b,
    OnFailCompareFunc onFail)
{
    if (!((a->aspectMask) == (b->aspectMask))) { onFail("a->aspectMask (Error: Value not equal)"); };
    if (!((a->colorAttachment) == (b->colorAttachment))) { onFail("a->colorAttachment (Error: Value not equal)"); };
    checkEqual_VkClearValue(&a->clearValue, &b->clearValue, onFail);
}

void checkEqual_VkClearRect(
    const VkClearRect* a,
    const VkClearRect* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkRect2D(&a->rect, &b->rect, onFail);
    if (!((a->baseArrayLayer) == (b->baseArrayLayer))) { onFail("a->baseArrayLayer (Error: Value not equal)"); };
    if (!((a->layerCount) == (b->layerCount))) { onFail("a->layerCount (Error: Value not equal)"); };
}

void checkEqual_VkImageBlit(
    const VkImageBlit* a,
    const VkImageBlit* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkImageSubresourceLayers(&a->srcSubresource, &b->srcSubresource, onFail);
    if (!((2) == (2))) { onFail("a->srcOffsets (Error: Lengths not equal)"); };
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        checkEqual_VkOffset3D(a->srcOffsets + i, b->srcOffsets + i, onFail);
    }
    checkEqual_VkImageSubresourceLayers(&a->dstSubresource, &b->dstSubresource, onFail);
    if (!((2) == (2))) { onFail("a->dstOffsets (Error: Lengths not equal)"); };
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        checkEqual_VkOffset3D(a->dstOffsets + i, b->dstOffsets + i, onFail);
    }
}

void checkEqual_VkImageCopy(
    const VkImageCopy* a,
    const VkImageCopy* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkImageSubresourceLayers(&a->srcSubresource, &b->srcSubresource, onFail);
    checkEqual_VkOffset3D(&a->srcOffset, &b->srcOffset, onFail);
    checkEqual_VkImageSubresourceLayers(&a->dstSubresource, &b->dstSubresource, onFail);
    checkEqual_VkOffset3D(&a->dstOffset, &b->dstOffset, onFail);
    checkEqual_VkExtent3D(&a->extent, &b->extent, onFail);
}

void checkEqual_VkImageResolve(
    const VkImageResolve* a,
    const VkImageResolve* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkImageSubresourceLayers(&a->srcSubresource, &b->srcSubresource, onFail);
    checkEqual_VkOffset3D(&a->srcOffset, &b->srcOffset, onFail);
    checkEqual_VkImageSubresourceLayers(&a->dstSubresource, &b->dstSubresource, onFail);
    checkEqual_VkOffset3D(&a->dstOffset, &b->dstOffset, onFail);
    checkEqual_VkExtent3D(&a->extent, &b->extent, onFail);
}

void checkEqual_VkRenderPassBeginInfo(
    const VkRenderPassBeginInfo* a,
    const VkRenderPassBeginInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->renderPass) == (b->renderPass))) { onFail("a->renderPass (Error: Value not equal)"); };
    if (!((a->framebuffer) == (b->framebuffer))) { onFail("a->framebuffer (Error: Value not equal)"); };
    checkEqual_VkRect2D(&a->renderArea, &b->renderArea, onFail);
    if (!((a->clearValueCount) == (b->clearValueCount))) { onFail("a->clearValueCount (Error: Value not equal)"); };
    if (!((!(a->pClearValues) && !(b->pClearValues)) || ((a->pClearValues) && (b->pClearValues)))) { onFail("a->pClearValues (Error: Mismatch in optional field)"); };
    if (a->pClearValues && b->pClearValues)
    {
        if ((a->pClearValues) && (b->pClearValues))
        {
            if (!((a->clearValueCount) == (b->clearValueCount))) { onFail("a->pClearValues (Error: Lengths not equal)"); };
            if ((a->clearValueCount) == (b->clearValueCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->clearValueCount; ++i)
                    {
                        checkEqual_VkClearValue(a->pClearValues + i, b->pClearValues + i, onFail);
                    }
                }
            }
        }
    }
}

#endif
#ifdef VK_VERSION_1_1
void checkEqual_VkPhysicalDeviceSubgroupProperties(
    const VkPhysicalDeviceSubgroupProperties* a,
    const VkPhysicalDeviceSubgroupProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->subgroupSize) == (b->subgroupSize))) { onFail("a->subgroupSize (Error: Value not equal)"); };
    if (!((a->supportedStages) == (b->supportedStages))) { onFail("a->supportedStages (Error: Value not equal)"); };
    if (!((a->supportedOperations) == (b->supportedOperations))) { onFail("a->supportedOperations (Error: Value not equal)"); };
    if (!((a->quadOperationsInAllStages) == (b->quadOperationsInAllStages))) { onFail("a->quadOperationsInAllStages (Error: Value not equal)"); };
}

void checkEqual_VkBindBufferMemoryInfo(
    const VkBindBufferMemoryInfo* a,
    const VkBindBufferMemoryInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->memoryOffset) == (b->memoryOffset))) { onFail("a->memoryOffset (Error: Value not equal)"); };
}

void checkEqual_VkBindImageMemoryInfo(
    const VkBindImageMemoryInfo* a,
    const VkBindImageMemoryInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->memoryOffset) == (b->memoryOffset))) { onFail("a->memoryOffset (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDevice16BitStorageFeatures(
    const VkPhysicalDevice16BitStorageFeatures* a,
    const VkPhysicalDevice16BitStorageFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->storageBuffer16BitAccess) == (b->storageBuffer16BitAccess))) { onFail("a->storageBuffer16BitAccess (Error: Value not equal)"); };
    if (!((a->uniformAndStorageBuffer16BitAccess) == (b->uniformAndStorageBuffer16BitAccess))) { onFail("a->uniformAndStorageBuffer16BitAccess (Error: Value not equal)"); };
    if (!((a->storagePushConstant16) == (b->storagePushConstant16))) { onFail("a->storagePushConstant16 (Error: Value not equal)"); };
    if (!((a->storageInputOutput16) == (b->storageInputOutput16))) { onFail("a->storageInputOutput16 (Error: Value not equal)"); };
}

void checkEqual_VkMemoryDedicatedRequirements(
    const VkMemoryDedicatedRequirements* a,
    const VkMemoryDedicatedRequirements* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->prefersDedicatedAllocation) == (b->prefersDedicatedAllocation))) { onFail("a->prefersDedicatedAllocation (Error: Value not equal)"); };
    if (!((a->requiresDedicatedAllocation) == (b->requiresDedicatedAllocation))) { onFail("a->requiresDedicatedAllocation (Error: Value not equal)"); };
}

void checkEqual_VkMemoryDedicatedAllocateInfo(
    const VkMemoryDedicatedAllocateInfo* a,
    const VkMemoryDedicatedAllocateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
}

void checkEqual_VkMemoryAllocateFlagsInfo(
    const VkMemoryAllocateFlagsInfo* a,
    const VkMemoryAllocateFlagsInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->deviceMask) == (b->deviceMask))) { onFail("a->deviceMask (Error: Value not equal)"); };
}

void checkEqual_VkDeviceGroupRenderPassBeginInfo(
    const VkDeviceGroupRenderPassBeginInfo* a,
    const VkDeviceGroupRenderPassBeginInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceMask) == (b->deviceMask))) { onFail("a->deviceMask (Error: Value not equal)"); };
    if (!((a->deviceRenderAreaCount) == (b->deviceRenderAreaCount))) { onFail("a->deviceRenderAreaCount (Error: Value not equal)"); };
    if ((a->pDeviceRenderAreas) && (b->pDeviceRenderAreas))
    {
        if (!((a->deviceRenderAreaCount) == (b->deviceRenderAreaCount))) { onFail("a->pDeviceRenderAreas (Error: Lengths not equal)"); };
        if ((a->deviceRenderAreaCount) == (b->deviceRenderAreaCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->deviceRenderAreaCount; ++i)
                {
                    checkEqual_VkRect2D(a->pDeviceRenderAreas + i, b->pDeviceRenderAreas + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkDeviceGroupCommandBufferBeginInfo(
    const VkDeviceGroupCommandBufferBeginInfo* a,
    const VkDeviceGroupCommandBufferBeginInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceMask) == (b->deviceMask))) { onFail("a->deviceMask (Error: Value not equal)"); };
}

void checkEqual_VkDeviceGroupSubmitInfo(
    const VkDeviceGroupSubmitInfo* a,
    const VkDeviceGroupSubmitInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->waitSemaphoreCount (Error: Value not equal)"); };
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->pWaitSemaphoreDeviceIndices (Error: Lengths not equal)"); };
    if (!((memcmp(a->pWaitSemaphoreDeviceIndices, b->pWaitSemaphoreDeviceIndices, a->waitSemaphoreCount * sizeof(const uint32_t)) == 0))) { onFail("a->pWaitSemaphoreDeviceIndices (Error: Unequal dyn array)"); };
    if (!((a->commandBufferCount) == (b->commandBufferCount))) { onFail("a->commandBufferCount (Error: Value not equal)"); };
    if (!((a->commandBufferCount) == (b->commandBufferCount))) { onFail("a->pCommandBufferDeviceMasks (Error: Lengths not equal)"); };
    if (!((memcmp(a->pCommandBufferDeviceMasks, b->pCommandBufferDeviceMasks, a->commandBufferCount * sizeof(const uint32_t)) == 0))) { onFail("a->pCommandBufferDeviceMasks (Error: Unequal dyn array)"); };
    if (!((a->signalSemaphoreCount) == (b->signalSemaphoreCount))) { onFail("a->signalSemaphoreCount (Error: Value not equal)"); };
    if (!((a->signalSemaphoreCount) == (b->signalSemaphoreCount))) { onFail("a->pSignalSemaphoreDeviceIndices (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSignalSemaphoreDeviceIndices, b->pSignalSemaphoreDeviceIndices, a->signalSemaphoreCount * sizeof(const uint32_t)) == 0))) { onFail("a->pSignalSemaphoreDeviceIndices (Error: Unequal dyn array)"); };
}

void checkEqual_VkDeviceGroupBindSparseInfo(
    const VkDeviceGroupBindSparseInfo* a,
    const VkDeviceGroupBindSparseInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->resourceDeviceIndex) == (b->resourceDeviceIndex))) { onFail("a->resourceDeviceIndex (Error: Value not equal)"); };
    if (!((a->memoryDeviceIndex) == (b->memoryDeviceIndex))) { onFail("a->memoryDeviceIndex (Error: Value not equal)"); };
}

void checkEqual_VkBindBufferMemoryDeviceGroupInfo(
    const VkBindBufferMemoryDeviceGroupInfo* a,
    const VkBindBufferMemoryDeviceGroupInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceIndexCount) == (b->deviceIndexCount))) { onFail("a->deviceIndexCount (Error: Value not equal)"); };
    if (!((a->deviceIndexCount) == (b->deviceIndexCount))) { onFail("a->pDeviceIndices (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDeviceIndices, b->pDeviceIndices, a->deviceIndexCount * sizeof(const uint32_t)) == 0))) { onFail("a->pDeviceIndices (Error: Unequal dyn array)"); };
}

void checkEqual_VkBindImageMemoryDeviceGroupInfo(
    const VkBindImageMemoryDeviceGroupInfo* a,
    const VkBindImageMemoryDeviceGroupInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceIndexCount) == (b->deviceIndexCount))) { onFail("a->deviceIndexCount (Error: Value not equal)"); };
    if (!((a->deviceIndexCount) == (b->deviceIndexCount))) { onFail("a->pDeviceIndices (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDeviceIndices, b->pDeviceIndices, a->deviceIndexCount * sizeof(const uint32_t)) == 0))) { onFail("a->pDeviceIndices (Error: Unequal dyn array)"); };
    if (!((a->splitInstanceBindRegionCount) == (b->splitInstanceBindRegionCount))) { onFail("a->splitInstanceBindRegionCount (Error: Value not equal)"); };
    if ((a->pSplitInstanceBindRegions) && (b->pSplitInstanceBindRegions))
    {
        if (!((a->splitInstanceBindRegionCount) == (b->splitInstanceBindRegionCount))) { onFail("a->pSplitInstanceBindRegions (Error: Lengths not equal)"); };
        if ((a->splitInstanceBindRegionCount) == (b->splitInstanceBindRegionCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->splitInstanceBindRegionCount; ++i)
                {
                    checkEqual_VkRect2D(a->pSplitInstanceBindRegions + i, b->pSplitInstanceBindRegions + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkPhysicalDeviceGroupProperties(
    const VkPhysicalDeviceGroupProperties* a,
    const VkPhysicalDeviceGroupProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->physicalDeviceCount) == (b->physicalDeviceCount))) { onFail("a->physicalDeviceCount (Error: Value not equal)"); };
    if (!((memcmp(a->physicalDevices, b->physicalDevices, VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice)) == 0))) { onFail("a->physicalDevices (Error: Unequal static array)"); };
    if (!((a->subsetAllocation) == (b->subsetAllocation))) { onFail("a->subsetAllocation (Error: Value not equal)"); };
}

void checkEqual_VkDeviceGroupDeviceCreateInfo(
    const VkDeviceGroupDeviceCreateInfo* a,
    const VkDeviceGroupDeviceCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->physicalDeviceCount) == (b->physicalDeviceCount))) { onFail("a->physicalDeviceCount (Error: Value not equal)"); };
    if (!((a->physicalDeviceCount) == (b->physicalDeviceCount))) { onFail("a->pPhysicalDevices (Error: Lengths not equal)"); };
    if (!((memcmp(a->pPhysicalDevices, b->pPhysicalDevices, a->physicalDeviceCount * sizeof(const VkPhysicalDevice)) == 0))) { onFail("a->pPhysicalDevices (Error: Unequal dyn array)"); };
}

void checkEqual_VkBufferMemoryRequirementsInfo2(
    const VkBufferMemoryRequirementsInfo2* a,
    const VkBufferMemoryRequirementsInfo2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
}

void checkEqual_VkImageMemoryRequirementsInfo2(
    const VkImageMemoryRequirementsInfo2* a,
    const VkImageMemoryRequirementsInfo2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
}

void checkEqual_VkImageSparseMemoryRequirementsInfo2(
    const VkImageSparseMemoryRequirementsInfo2* a,
    const VkImageSparseMemoryRequirementsInfo2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
}

void checkEqual_VkMemoryRequirements2(
    const VkMemoryRequirements2* a,
    const VkMemoryRequirements2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkMemoryRequirements(&a->memoryRequirements, &b->memoryRequirements, onFail);
}

void checkEqual_VkSparseImageMemoryRequirements2(
    const VkSparseImageMemoryRequirements2* a,
    const VkSparseImageMemoryRequirements2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkSparseImageMemoryRequirements(&a->memoryRequirements, &b->memoryRequirements, onFail);
}

void checkEqual_VkPhysicalDeviceFeatures2(
    const VkPhysicalDeviceFeatures2* a,
    const VkPhysicalDeviceFeatures2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkPhysicalDeviceFeatures(&a->features, &b->features, onFail);
}

void checkEqual_VkPhysicalDeviceProperties2(
    const VkPhysicalDeviceProperties2* a,
    const VkPhysicalDeviceProperties2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkPhysicalDeviceProperties(&a->properties, &b->properties, onFail);
}

void checkEqual_VkFormatProperties2(
    const VkFormatProperties2* a,
    const VkFormatProperties2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkFormatProperties(&a->formatProperties, &b->formatProperties, onFail);
}

void checkEqual_VkImageFormatProperties2(
    const VkImageFormatProperties2* a,
    const VkImageFormatProperties2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkImageFormatProperties(&a->imageFormatProperties, &b->imageFormatProperties, onFail);
}

void checkEqual_VkPhysicalDeviceImageFormatInfo2(
    const VkPhysicalDeviceImageFormatInfo2* a,
    const VkPhysicalDeviceImageFormatInfo2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->tiling) == (b->tiling))) { onFail("a->tiling (Error: Value not equal)"); };
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkQueueFamilyProperties2(
    const VkQueueFamilyProperties2* a,
    const VkQueueFamilyProperties2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkQueueFamilyProperties(&a->queueFamilyProperties, &b->queueFamilyProperties, onFail);
}

void checkEqual_VkPhysicalDeviceMemoryProperties2(
    const VkPhysicalDeviceMemoryProperties2* a,
    const VkPhysicalDeviceMemoryProperties2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkPhysicalDeviceMemoryProperties(&a->memoryProperties, &b->memoryProperties, onFail);
}

void checkEqual_VkSparseImageFormatProperties2(
    const VkSparseImageFormatProperties2* a,
    const VkSparseImageFormatProperties2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkSparseImageFormatProperties(&a->properties, &b->properties, onFail);
}

void checkEqual_VkPhysicalDeviceSparseImageFormatInfo2(
    const VkPhysicalDeviceSparseImageFormatInfo2* a,
    const VkPhysicalDeviceSparseImageFormatInfo2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->samples) == (b->samples))) { onFail("a->samples (Error: Value not equal)"); };
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
    if (!((a->tiling) == (b->tiling))) { onFail("a->tiling (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDevicePointClippingProperties(
    const VkPhysicalDevicePointClippingProperties* a,
    const VkPhysicalDevicePointClippingProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->pointClippingBehavior) == (b->pointClippingBehavior))) { onFail("a->pointClippingBehavior (Error: Value not equal)"); };
}

void checkEqual_VkInputAttachmentAspectReference(
    const VkInputAttachmentAspectReference* a,
    const VkInputAttachmentAspectReference* b,
    OnFailCompareFunc onFail)
{
    if (!((a->subpass) == (b->subpass))) { onFail("a->subpass (Error: Value not equal)"); };
    if (!((a->inputAttachmentIndex) == (b->inputAttachmentIndex))) { onFail("a->inputAttachmentIndex (Error: Value not equal)"); };
    if (!((a->aspectMask) == (b->aspectMask))) { onFail("a->aspectMask (Error: Value not equal)"); };
}

void checkEqual_VkRenderPassInputAttachmentAspectCreateInfo(
    const VkRenderPassInputAttachmentAspectCreateInfo* a,
    const VkRenderPassInputAttachmentAspectCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->aspectReferenceCount) == (b->aspectReferenceCount))) { onFail("a->aspectReferenceCount (Error: Value not equal)"); };
    if ((a->pAspectReferences) && (b->pAspectReferences))
    {
        if (!((a->aspectReferenceCount) == (b->aspectReferenceCount))) { onFail("a->pAspectReferences (Error: Lengths not equal)"); };
        if ((a->aspectReferenceCount) == (b->aspectReferenceCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->aspectReferenceCount; ++i)
                {
                    checkEqual_VkInputAttachmentAspectReference(a->pAspectReferences + i, b->pAspectReferences + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkImageViewUsageCreateInfo(
    const VkImageViewUsageCreateInfo* a,
    const VkImageViewUsageCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
}

void checkEqual_VkPipelineTessellationDomainOriginStateCreateInfo(
    const VkPipelineTessellationDomainOriginStateCreateInfo* a,
    const VkPipelineTessellationDomainOriginStateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->domainOrigin) == (b->domainOrigin))) { onFail("a->domainOrigin (Error: Value not equal)"); };
}

void checkEqual_VkRenderPassMultiviewCreateInfo(
    const VkRenderPassMultiviewCreateInfo* a,
    const VkRenderPassMultiviewCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->subpassCount) == (b->subpassCount))) { onFail("a->subpassCount (Error: Value not equal)"); };
    if (!((a->subpassCount) == (b->subpassCount))) { onFail("a->pViewMasks (Error: Lengths not equal)"); };
    if (!((memcmp(a->pViewMasks, b->pViewMasks, a->subpassCount * sizeof(const uint32_t)) == 0))) { onFail("a->pViewMasks (Error: Unequal dyn array)"); };
    if (!((a->dependencyCount) == (b->dependencyCount))) { onFail("a->dependencyCount (Error: Value not equal)"); };
    if (!((a->dependencyCount) == (b->dependencyCount))) { onFail("a->pViewOffsets (Error: Lengths not equal)"); };
    if (!((memcmp(a->pViewOffsets, b->pViewOffsets, a->dependencyCount * sizeof(const int32_t)) == 0))) { onFail("a->pViewOffsets (Error: Unequal dyn array)"); };
    if (!((a->correlationMaskCount) == (b->correlationMaskCount))) { onFail("a->correlationMaskCount (Error: Value not equal)"); };
    if (!((a->correlationMaskCount) == (b->correlationMaskCount))) { onFail("a->pCorrelationMasks (Error: Lengths not equal)"); };
    if (!((memcmp(a->pCorrelationMasks, b->pCorrelationMasks, a->correlationMaskCount * sizeof(const uint32_t)) == 0))) { onFail("a->pCorrelationMasks (Error: Unequal dyn array)"); };
}

void checkEqual_VkPhysicalDeviceMultiviewFeatures(
    const VkPhysicalDeviceMultiviewFeatures* a,
    const VkPhysicalDeviceMultiviewFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->multiview) == (b->multiview))) { onFail("a->multiview (Error: Value not equal)"); };
    if (!((a->multiviewGeometryShader) == (b->multiviewGeometryShader))) { onFail("a->multiviewGeometryShader (Error: Value not equal)"); };
    if (!((a->multiviewTessellationShader) == (b->multiviewTessellationShader))) { onFail("a->multiviewTessellationShader (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceMultiviewProperties(
    const VkPhysicalDeviceMultiviewProperties* a,
    const VkPhysicalDeviceMultiviewProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxMultiviewViewCount) == (b->maxMultiviewViewCount))) { onFail("a->maxMultiviewViewCount (Error: Value not equal)"); };
    if (!((a->maxMultiviewInstanceIndex) == (b->maxMultiviewInstanceIndex))) { onFail("a->maxMultiviewInstanceIndex (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceVariablePointersFeatures(
    const VkPhysicalDeviceVariablePointersFeatures* a,
    const VkPhysicalDeviceVariablePointersFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->variablePointersStorageBuffer) == (b->variablePointersStorageBuffer))) { onFail("a->variablePointersStorageBuffer (Error: Value not equal)"); };
    if (!((a->variablePointers) == (b->variablePointers))) { onFail("a->variablePointers (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceProtectedMemoryFeatures(
    const VkPhysicalDeviceProtectedMemoryFeatures* a,
    const VkPhysicalDeviceProtectedMemoryFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->protectedMemory) == (b->protectedMemory))) { onFail("a->protectedMemory (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceProtectedMemoryProperties(
    const VkPhysicalDeviceProtectedMemoryProperties* a,
    const VkPhysicalDeviceProtectedMemoryProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->protectedNoFault) == (b->protectedNoFault))) { onFail("a->protectedNoFault (Error: Value not equal)"); };
}

void checkEqual_VkDeviceQueueInfo2(
    const VkDeviceQueueInfo2* a,
    const VkDeviceQueueInfo2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->queueFamilyIndex) == (b->queueFamilyIndex))) { onFail("a->queueFamilyIndex (Error: Value not equal)"); };
    if (!((a->queueIndex) == (b->queueIndex))) { onFail("a->queueIndex (Error: Value not equal)"); };
}

void checkEqual_VkProtectedSubmitInfo(
    const VkProtectedSubmitInfo* a,
    const VkProtectedSubmitInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->protectedSubmit) == (b->protectedSubmit))) { onFail("a->protectedSubmit (Error: Value not equal)"); };
}

void checkEqual_VkSamplerYcbcrConversionCreateInfo(
    const VkSamplerYcbcrConversionCreateInfo* a,
    const VkSamplerYcbcrConversionCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->ycbcrModel) == (b->ycbcrModel))) { onFail("a->ycbcrModel (Error: Value not equal)"); };
    if (!((a->ycbcrRange) == (b->ycbcrRange))) { onFail("a->ycbcrRange (Error: Value not equal)"); };
    checkEqual_VkComponentMapping(&a->components, &b->components, onFail);
    if (!((a->xChromaOffset) == (b->xChromaOffset))) { onFail("a->xChromaOffset (Error: Value not equal)"); };
    if (!((a->yChromaOffset) == (b->yChromaOffset))) { onFail("a->yChromaOffset (Error: Value not equal)"); };
    if (!((a->chromaFilter) == (b->chromaFilter))) { onFail("a->chromaFilter (Error: Value not equal)"); };
    if (!((a->forceExplicitReconstruction) == (b->forceExplicitReconstruction))) { onFail("a->forceExplicitReconstruction (Error: Value not equal)"); };
}

void checkEqual_VkSamplerYcbcrConversionInfo(
    const VkSamplerYcbcrConversionInfo* a,
    const VkSamplerYcbcrConversionInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->conversion) == (b->conversion))) { onFail("a->conversion (Error: Value not equal)"); };
}

void checkEqual_VkBindImagePlaneMemoryInfo(
    const VkBindImagePlaneMemoryInfo* a,
    const VkBindImagePlaneMemoryInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->planeAspect) == (b->planeAspect))) { onFail("a->planeAspect (Error: Value not equal)"); };
}

void checkEqual_VkImagePlaneMemoryRequirementsInfo(
    const VkImagePlaneMemoryRequirementsInfo* a,
    const VkImagePlaneMemoryRequirementsInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->planeAspect) == (b->planeAspect))) { onFail("a->planeAspect (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures* a,
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->samplerYcbcrConversion) == (b->samplerYcbcrConversion))) { onFail("a->samplerYcbcrConversion (Error: Value not equal)"); };
}

void checkEqual_VkSamplerYcbcrConversionImageFormatProperties(
    const VkSamplerYcbcrConversionImageFormatProperties* a,
    const VkSamplerYcbcrConversionImageFormatProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->combinedImageSamplerDescriptorCount) == (b->combinedImageSamplerDescriptorCount))) { onFail("a->combinedImageSamplerDescriptorCount (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorUpdateTemplateEntry(
    const VkDescriptorUpdateTemplateEntry* a,
    const VkDescriptorUpdateTemplateEntry* b,
    OnFailCompareFunc onFail)
{
    if (!((a->dstBinding) == (b->dstBinding))) { onFail("a->dstBinding (Error: Value not equal)"); };
    if (!((a->dstArrayElement) == (b->dstArrayElement))) { onFail("a->dstArrayElement (Error: Value not equal)"); };
    if (!((a->descriptorCount) == (b->descriptorCount))) { onFail("a->descriptorCount (Error: Value not equal)"); };
    if (!((a->descriptorType) == (b->descriptorType))) { onFail("a->descriptorType (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->stride) == (b->stride))) { onFail("a->stride (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorUpdateTemplateCreateInfo(
    const VkDescriptorUpdateTemplateCreateInfo* a,
    const VkDescriptorUpdateTemplateCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->descriptorUpdateEntryCount) == (b->descriptorUpdateEntryCount))) { onFail("a->descriptorUpdateEntryCount (Error: Value not equal)"); };
    if ((a->pDescriptorUpdateEntries) && (b->pDescriptorUpdateEntries))
    {
        if (!((a->descriptorUpdateEntryCount) == (b->descriptorUpdateEntryCount))) { onFail("a->pDescriptorUpdateEntries (Error: Lengths not equal)"); };
        if ((a->descriptorUpdateEntryCount) == (b->descriptorUpdateEntryCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->descriptorUpdateEntryCount; ++i)
                {
                    checkEqual_VkDescriptorUpdateTemplateEntry(a->pDescriptorUpdateEntries + i, b->pDescriptorUpdateEntries + i, onFail);
                }
            }
        }
    }
    if (!((a->templateType) == (b->templateType))) { onFail("a->templateType (Error: Value not equal)"); };
    if (!((a->descriptorSetLayout) == (b->descriptorSetLayout))) { onFail("a->descriptorSetLayout (Error: Value not equal)"); };
    if (!((a->pipelineBindPoint) == (b->pipelineBindPoint))) { onFail("a->pipelineBindPoint (Error: Value not equal)"); };
    if (!((a->pipelineLayout) == (b->pipelineLayout))) { onFail("a->pipelineLayout (Error: Value not equal)"); };
    if (!((a->set) == (b->set))) { onFail("a->set (Error: Value not equal)"); };
}

void checkEqual_VkExternalMemoryProperties(
    const VkExternalMemoryProperties* a,
    const VkExternalMemoryProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->externalMemoryFeatures) == (b->externalMemoryFeatures))) { onFail("a->externalMemoryFeatures (Error: Value not equal)"); };
    if (!((a->exportFromImportedHandleTypes) == (b->exportFromImportedHandleTypes))) { onFail("a->exportFromImportedHandleTypes (Error: Value not equal)"); };
    if (!((a->compatibleHandleTypes) == (b->compatibleHandleTypes))) { onFail("a->compatibleHandleTypes (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceExternalImageFormatInfo(
    const VkPhysicalDeviceExternalImageFormatInfo* a,
    const VkPhysicalDeviceExternalImageFormatInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

void checkEqual_VkExternalImageFormatProperties(
    const VkExternalImageFormatProperties* a,
    const VkExternalImageFormatProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkExternalMemoryProperties(&a->externalMemoryProperties, &b->externalMemoryProperties, onFail);
}

void checkEqual_VkPhysicalDeviceExternalBufferInfo(
    const VkPhysicalDeviceExternalBufferInfo* a,
    const VkPhysicalDeviceExternalBufferInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

void checkEqual_VkExternalBufferProperties(
    const VkExternalBufferProperties* a,
    const VkExternalBufferProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkExternalMemoryProperties(&a->externalMemoryProperties, &b->externalMemoryProperties, onFail);
}

void checkEqual_VkPhysicalDeviceIDProperties(
    const VkPhysicalDeviceIDProperties* a,
    const VkPhysicalDeviceIDProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->deviceUUID, b->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t)) == 0))) { onFail("a->deviceUUID (Error: Unequal static array)"); };
    if (!((memcmp(a->driverUUID, b->driverUUID, VK_UUID_SIZE * sizeof(uint8_t)) == 0))) { onFail("a->driverUUID (Error: Unequal static array)"); };
    if (!((memcmp(a->deviceLUID, b->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t)) == 0))) { onFail("a->deviceLUID (Error: Unequal static array)"); };
    if (!((a->deviceNodeMask) == (b->deviceNodeMask))) { onFail("a->deviceNodeMask (Error: Value not equal)"); };
    if (!((a->deviceLUIDValid) == (b->deviceLUIDValid))) { onFail("a->deviceLUIDValid (Error: Value not equal)"); };
}

void checkEqual_VkExternalMemoryImageCreateInfo(
    const VkExternalMemoryImageCreateInfo* a,
    const VkExternalMemoryImageCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleTypes) == (b->handleTypes))) { onFail("a->handleTypes (Error: Value not equal)"); };
}

void checkEqual_VkExternalMemoryBufferCreateInfo(
    const VkExternalMemoryBufferCreateInfo* a,
    const VkExternalMemoryBufferCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleTypes) == (b->handleTypes))) { onFail("a->handleTypes (Error: Value not equal)"); };
}

void checkEqual_VkExportMemoryAllocateInfo(
    const VkExportMemoryAllocateInfo* a,
    const VkExportMemoryAllocateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleTypes) == (b->handleTypes))) { onFail("a->handleTypes (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceExternalFenceInfo(
    const VkPhysicalDeviceExternalFenceInfo* a,
    const VkPhysicalDeviceExternalFenceInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

void checkEqual_VkExternalFenceProperties(
    const VkExternalFenceProperties* a,
    const VkExternalFenceProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->exportFromImportedHandleTypes) == (b->exportFromImportedHandleTypes))) { onFail("a->exportFromImportedHandleTypes (Error: Value not equal)"); };
    if (!((a->compatibleHandleTypes) == (b->compatibleHandleTypes))) { onFail("a->compatibleHandleTypes (Error: Value not equal)"); };
    if (!((a->externalFenceFeatures) == (b->externalFenceFeatures))) { onFail("a->externalFenceFeatures (Error: Value not equal)"); };
}

void checkEqual_VkExportFenceCreateInfo(
    const VkExportFenceCreateInfo* a,
    const VkExportFenceCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleTypes) == (b->handleTypes))) { onFail("a->handleTypes (Error: Value not equal)"); };
}

void checkEqual_VkExportSemaphoreCreateInfo(
    const VkExportSemaphoreCreateInfo* a,
    const VkExportSemaphoreCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleTypes) == (b->handleTypes))) { onFail("a->handleTypes (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceExternalSemaphoreInfo(
    const VkPhysicalDeviceExternalSemaphoreInfo* a,
    const VkPhysicalDeviceExternalSemaphoreInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

void checkEqual_VkExternalSemaphoreProperties(
    const VkExternalSemaphoreProperties* a,
    const VkExternalSemaphoreProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->exportFromImportedHandleTypes) == (b->exportFromImportedHandleTypes))) { onFail("a->exportFromImportedHandleTypes (Error: Value not equal)"); };
    if (!((a->compatibleHandleTypes) == (b->compatibleHandleTypes))) { onFail("a->compatibleHandleTypes (Error: Value not equal)"); };
    if (!((a->externalSemaphoreFeatures) == (b->externalSemaphoreFeatures))) { onFail("a->externalSemaphoreFeatures (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceMaintenance3Properties(
    const VkPhysicalDeviceMaintenance3Properties* a,
    const VkPhysicalDeviceMaintenance3Properties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxPerSetDescriptors) == (b->maxPerSetDescriptors))) { onFail("a->maxPerSetDescriptors (Error: Value not equal)"); };
    if (!((a->maxMemoryAllocationSize) == (b->maxMemoryAllocationSize))) { onFail("a->maxMemoryAllocationSize (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorSetLayoutSupport(
    const VkDescriptorSetLayoutSupport* a,
    const VkDescriptorSetLayoutSupport* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->supported) == (b->supported))) { onFail("a->supported (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceShaderDrawParametersFeatures(
    const VkPhysicalDeviceShaderDrawParametersFeatures* a,
    const VkPhysicalDeviceShaderDrawParametersFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderDrawParameters) == (b->shaderDrawParameters))) { onFail("a->shaderDrawParameters (Error: Value not equal)"); };
}

#endif
#ifdef VK_VERSION_1_2
void checkEqual_VkPhysicalDeviceVulkan11Features(
    const VkPhysicalDeviceVulkan11Features* a,
    const VkPhysicalDeviceVulkan11Features* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->storageBuffer16BitAccess) == (b->storageBuffer16BitAccess))) { onFail("a->storageBuffer16BitAccess (Error: Value not equal)"); };
    if (!((a->uniformAndStorageBuffer16BitAccess) == (b->uniformAndStorageBuffer16BitAccess))) { onFail("a->uniformAndStorageBuffer16BitAccess (Error: Value not equal)"); };
    if (!((a->storagePushConstant16) == (b->storagePushConstant16))) { onFail("a->storagePushConstant16 (Error: Value not equal)"); };
    if (!((a->storageInputOutput16) == (b->storageInputOutput16))) { onFail("a->storageInputOutput16 (Error: Value not equal)"); };
    if (!((a->multiview) == (b->multiview))) { onFail("a->multiview (Error: Value not equal)"); };
    if (!((a->multiviewGeometryShader) == (b->multiviewGeometryShader))) { onFail("a->multiviewGeometryShader (Error: Value not equal)"); };
    if (!((a->multiviewTessellationShader) == (b->multiviewTessellationShader))) { onFail("a->multiviewTessellationShader (Error: Value not equal)"); };
    if (!((a->variablePointersStorageBuffer) == (b->variablePointersStorageBuffer))) { onFail("a->variablePointersStorageBuffer (Error: Value not equal)"); };
    if (!((a->variablePointers) == (b->variablePointers))) { onFail("a->variablePointers (Error: Value not equal)"); };
    if (!((a->protectedMemory) == (b->protectedMemory))) { onFail("a->protectedMemory (Error: Value not equal)"); };
    if (!((a->samplerYcbcrConversion) == (b->samplerYcbcrConversion))) { onFail("a->samplerYcbcrConversion (Error: Value not equal)"); };
    if (!((a->shaderDrawParameters) == (b->shaderDrawParameters))) { onFail("a->shaderDrawParameters (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceVulkan11Properties(
    const VkPhysicalDeviceVulkan11Properties* a,
    const VkPhysicalDeviceVulkan11Properties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->deviceUUID, b->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t)) == 0))) { onFail("a->deviceUUID (Error: Unequal static array)"); };
    if (!((memcmp(a->driverUUID, b->driverUUID, VK_UUID_SIZE * sizeof(uint8_t)) == 0))) { onFail("a->driverUUID (Error: Unequal static array)"); };
    if (!((memcmp(a->deviceLUID, b->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t)) == 0))) { onFail("a->deviceLUID (Error: Unequal static array)"); };
    if (!((a->deviceNodeMask) == (b->deviceNodeMask))) { onFail("a->deviceNodeMask (Error: Value not equal)"); };
    if (!((a->deviceLUIDValid) == (b->deviceLUIDValid))) { onFail("a->deviceLUIDValid (Error: Value not equal)"); };
    if (!((a->subgroupSize) == (b->subgroupSize))) { onFail("a->subgroupSize (Error: Value not equal)"); };
    if (!((a->subgroupSupportedStages) == (b->subgroupSupportedStages))) { onFail("a->subgroupSupportedStages (Error: Value not equal)"); };
    if (!((a->subgroupSupportedOperations) == (b->subgroupSupportedOperations))) { onFail("a->subgroupSupportedOperations (Error: Value not equal)"); };
    if (!((a->subgroupQuadOperationsInAllStages) == (b->subgroupQuadOperationsInAllStages))) { onFail("a->subgroupQuadOperationsInAllStages (Error: Value not equal)"); };
    if (!((a->pointClippingBehavior) == (b->pointClippingBehavior))) { onFail("a->pointClippingBehavior (Error: Value not equal)"); };
    if (!((a->maxMultiviewViewCount) == (b->maxMultiviewViewCount))) { onFail("a->maxMultiviewViewCount (Error: Value not equal)"); };
    if (!((a->maxMultiviewInstanceIndex) == (b->maxMultiviewInstanceIndex))) { onFail("a->maxMultiviewInstanceIndex (Error: Value not equal)"); };
    if (!((a->protectedNoFault) == (b->protectedNoFault))) { onFail("a->protectedNoFault (Error: Value not equal)"); };
    if (!((a->maxPerSetDescriptors) == (b->maxPerSetDescriptors))) { onFail("a->maxPerSetDescriptors (Error: Value not equal)"); };
    if (!((a->maxMemoryAllocationSize) == (b->maxMemoryAllocationSize))) { onFail("a->maxMemoryAllocationSize (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceVulkan12Features(
    const VkPhysicalDeviceVulkan12Features* a,
    const VkPhysicalDeviceVulkan12Features* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->samplerMirrorClampToEdge) == (b->samplerMirrorClampToEdge))) { onFail("a->samplerMirrorClampToEdge (Error: Value not equal)"); };
    if (!((a->drawIndirectCount) == (b->drawIndirectCount))) { onFail("a->drawIndirectCount (Error: Value not equal)"); };
    if (!((a->storageBuffer8BitAccess) == (b->storageBuffer8BitAccess))) { onFail("a->storageBuffer8BitAccess (Error: Value not equal)"); };
    if (!((a->uniformAndStorageBuffer8BitAccess) == (b->uniformAndStorageBuffer8BitAccess))) { onFail("a->uniformAndStorageBuffer8BitAccess (Error: Value not equal)"); };
    if (!((a->storagePushConstant8) == (b->storagePushConstant8))) { onFail("a->storagePushConstant8 (Error: Value not equal)"); };
    if (!((a->shaderBufferInt64Atomics) == (b->shaderBufferInt64Atomics))) { onFail("a->shaderBufferInt64Atomics (Error: Value not equal)"); };
    if (!((a->shaderSharedInt64Atomics) == (b->shaderSharedInt64Atomics))) { onFail("a->shaderSharedInt64Atomics (Error: Value not equal)"); };
    if (!((a->shaderFloat16) == (b->shaderFloat16))) { onFail("a->shaderFloat16 (Error: Value not equal)"); };
    if (!((a->shaderInt8) == (b->shaderInt8))) { onFail("a->shaderInt8 (Error: Value not equal)"); };
    if (!((a->descriptorIndexing) == (b->descriptorIndexing))) { onFail("a->descriptorIndexing (Error: Value not equal)"); };
    if (!((a->shaderInputAttachmentArrayDynamicIndexing) == (b->shaderInputAttachmentArrayDynamicIndexing))) { onFail("a->shaderInputAttachmentArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderUniformTexelBufferArrayDynamicIndexing) == (b->shaderUniformTexelBufferArrayDynamicIndexing))) { onFail("a->shaderUniformTexelBufferArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageTexelBufferArrayDynamicIndexing) == (b->shaderStorageTexelBufferArrayDynamicIndexing))) { onFail("a->shaderStorageTexelBufferArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderUniformBufferArrayNonUniformIndexing) == (b->shaderUniformBufferArrayNonUniformIndexing))) { onFail("a->shaderUniformBufferArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderSampledImageArrayNonUniformIndexing) == (b->shaderSampledImageArrayNonUniformIndexing))) { onFail("a->shaderSampledImageArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageBufferArrayNonUniformIndexing) == (b->shaderStorageBufferArrayNonUniformIndexing))) { onFail("a->shaderStorageBufferArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageImageArrayNonUniformIndexing) == (b->shaderStorageImageArrayNonUniformIndexing))) { onFail("a->shaderStorageImageArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderInputAttachmentArrayNonUniformIndexing) == (b->shaderInputAttachmentArrayNonUniformIndexing))) { onFail("a->shaderInputAttachmentArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderUniformTexelBufferArrayNonUniformIndexing) == (b->shaderUniformTexelBufferArrayNonUniformIndexing))) { onFail("a->shaderUniformTexelBufferArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageTexelBufferArrayNonUniformIndexing) == (b->shaderStorageTexelBufferArrayNonUniformIndexing))) { onFail("a->shaderStorageTexelBufferArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->descriptorBindingUniformBufferUpdateAfterBind) == (b->descriptorBindingUniformBufferUpdateAfterBind))) { onFail("a->descriptorBindingUniformBufferUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingSampledImageUpdateAfterBind) == (b->descriptorBindingSampledImageUpdateAfterBind))) { onFail("a->descriptorBindingSampledImageUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingStorageImageUpdateAfterBind) == (b->descriptorBindingStorageImageUpdateAfterBind))) { onFail("a->descriptorBindingStorageImageUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingStorageBufferUpdateAfterBind) == (b->descriptorBindingStorageBufferUpdateAfterBind))) { onFail("a->descriptorBindingStorageBufferUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingUniformTexelBufferUpdateAfterBind) == (b->descriptorBindingUniformTexelBufferUpdateAfterBind))) { onFail("a->descriptorBindingUniformTexelBufferUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingStorageTexelBufferUpdateAfterBind) == (b->descriptorBindingStorageTexelBufferUpdateAfterBind))) { onFail("a->descriptorBindingStorageTexelBufferUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingUpdateUnusedWhilePending) == (b->descriptorBindingUpdateUnusedWhilePending))) { onFail("a->descriptorBindingUpdateUnusedWhilePending (Error: Value not equal)"); };
    if (!((a->descriptorBindingPartiallyBound) == (b->descriptorBindingPartiallyBound))) { onFail("a->descriptorBindingPartiallyBound (Error: Value not equal)"); };
    if (!((a->descriptorBindingVariableDescriptorCount) == (b->descriptorBindingVariableDescriptorCount))) { onFail("a->descriptorBindingVariableDescriptorCount (Error: Value not equal)"); };
    if (!((a->runtimeDescriptorArray) == (b->runtimeDescriptorArray))) { onFail("a->runtimeDescriptorArray (Error: Value not equal)"); };
    if (!((a->samplerFilterMinmax) == (b->samplerFilterMinmax))) { onFail("a->samplerFilterMinmax (Error: Value not equal)"); };
    if (!((a->scalarBlockLayout) == (b->scalarBlockLayout))) { onFail("a->scalarBlockLayout (Error: Value not equal)"); };
    if (!((a->imagelessFramebuffer) == (b->imagelessFramebuffer))) { onFail("a->imagelessFramebuffer (Error: Value not equal)"); };
    if (!((a->uniformBufferStandardLayout) == (b->uniformBufferStandardLayout))) { onFail("a->uniformBufferStandardLayout (Error: Value not equal)"); };
    if (!((a->shaderSubgroupExtendedTypes) == (b->shaderSubgroupExtendedTypes))) { onFail("a->shaderSubgroupExtendedTypes (Error: Value not equal)"); };
    if (!((a->separateDepthStencilLayouts) == (b->separateDepthStencilLayouts))) { onFail("a->separateDepthStencilLayouts (Error: Value not equal)"); };
    if (!((a->hostQueryReset) == (b->hostQueryReset))) { onFail("a->hostQueryReset (Error: Value not equal)"); };
    if (!((a->timelineSemaphore) == (b->timelineSemaphore))) { onFail("a->timelineSemaphore (Error: Value not equal)"); };
    if (!((a->bufferDeviceAddress) == (b->bufferDeviceAddress))) { onFail("a->bufferDeviceAddress (Error: Value not equal)"); };
    if (!((a->bufferDeviceAddressCaptureReplay) == (b->bufferDeviceAddressCaptureReplay))) { onFail("a->bufferDeviceAddressCaptureReplay (Error: Value not equal)"); };
    if (!((a->bufferDeviceAddressMultiDevice) == (b->bufferDeviceAddressMultiDevice))) { onFail("a->bufferDeviceAddressMultiDevice (Error: Value not equal)"); };
    if (!((a->vulkanMemoryModel) == (b->vulkanMemoryModel))) { onFail("a->vulkanMemoryModel (Error: Value not equal)"); };
    if (!((a->vulkanMemoryModelDeviceScope) == (b->vulkanMemoryModelDeviceScope))) { onFail("a->vulkanMemoryModelDeviceScope (Error: Value not equal)"); };
    if (!((a->vulkanMemoryModelAvailabilityVisibilityChains) == (b->vulkanMemoryModelAvailabilityVisibilityChains))) { onFail("a->vulkanMemoryModelAvailabilityVisibilityChains (Error: Value not equal)"); };
    if (!((a->shaderOutputViewportIndex) == (b->shaderOutputViewportIndex))) { onFail("a->shaderOutputViewportIndex (Error: Value not equal)"); };
    if (!((a->shaderOutputLayer) == (b->shaderOutputLayer))) { onFail("a->shaderOutputLayer (Error: Value not equal)"); };
    if (!((a->subgroupBroadcastDynamicId) == (b->subgroupBroadcastDynamicId))) { onFail("a->subgroupBroadcastDynamicId (Error: Value not equal)"); };
}

void checkEqual_VkConformanceVersion(
    const VkConformanceVersion* a,
    const VkConformanceVersion* b,
    OnFailCompareFunc onFail)
{
    if (!((a->major) == (b->major))) { onFail("a->major (Error: Value not equal)"); };
    if (!((a->minor) == (b->minor))) { onFail("a->minor (Error: Value not equal)"); };
    if (!((a->subminor) == (b->subminor))) { onFail("a->subminor (Error: Value not equal)"); };
    if (!((a->patch) == (b->patch))) { onFail("a->patch (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceVulkan12Properties(
    const VkPhysicalDeviceVulkan12Properties* a,
    const VkPhysicalDeviceVulkan12Properties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->driverID) == (b->driverID))) { onFail("a->driverID (Error: Value not equal)"); };
    if (!((memcmp(a->driverName, b->driverName, VK_MAX_DRIVER_NAME_SIZE * sizeof(char)) == 0))) { onFail("a->driverName (Error: Unequal static array)"); };
    if (!((memcmp(a->driverInfo, b->driverInfo, VK_MAX_DRIVER_INFO_SIZE * sizeof(char)) == 0))) { onFail("a->driverInfo (Error: Unequal static array)"); };
    checkEqual_VkConformanceVersion(&a->conformanceVersion, &b->conformanceVersion, onFail);
    if (!((a->denormBehaviorIndependence) == (b->denormBehaviorIndependence))) { onFail("a->denormBehaviorIndependence (Error: Value not equal)"); };
    if (!((a->roundingModeIndependence) == (b->roundingModeIndependence))) { onFail("a->roundingModeIndependence (Error: Value not equal)"); };
    if (!((a->shaderSignedZeroInfNanPreserveFloat16) == (b->shaderSignedZeroInfNanPreserveFloat16))) { onFail("a->shaderSignedZeroInfNanPreserveFloat16 (Error: Value not equal)"); };
    if (!((a->shaderSignedZeroInfNanPreserveFloat32) == (b->shaderSignedZeroInfNanPreserveFloat32))) { onFail("a->shaderSignedZeroInfNanPreserveFloat32 (Error: Value not equal)"); };
    if (!((a->shaderSignedZeroInfNanPreserveFloat64) == (b->shaderSignedZeroInfNanPreserveFloat64))) { onFail("a->shaderSignedZeroInfNanPreserveFloat64 (Error: Value not equal)"); };
    if (!((a->shaderDenormPreserveFloat16) == (b->shaderDenormPreserveFloat16))) { onFail("a->shaderDenormPreserveFloat16 (Error: Value not equal)"); };
    if (!((a->shaderDenormPreserveFloat32) == (b->shaderDenormPreserveFloat32))) { onFail("a->shaderDenormPreserveFloat32 (Error: Value not equal)"); };
    if (!((a->shaderDenormPreserveFloat64) == (b->shaderDenormPreserveFloat64))) { onFail("a->shaderDenormPreserveFloat64 (Error: Value not equal)"); };
    if (!((a->shaderDenormFlushToZeroFloat16) == (b->shaderDenormFlushToZeroFloat16))) { onFail("a->shaderDenormFlushToZeroFloat16 (Error: Value not equal)"); };
    if (!((a->shaderDenormFlushToZeroFloat32) == (b->shaderDenormFlushToZeroFloat32))) { onFail("a->shaderDenormFlushToZeroFloat32 (Error: Value not equal)"); };
    if (!((a->shaderDenormFlushToZeroFloat64) == (b->shaderDenormFlushToZeroFloat64))) { onFail("a->shaderDenormFlushToZeroFloat64 (Error: Value not equal)"); };
    if (!((a->shaderRoundingModeRTEFloat16) == (b->shaderRoundingModeRTEFloat16))) { onFail("a->shaderRoundingModeRTEFloat16 (Error: Value not equal)"); };
    if (!((a->shaderRoundingModeRTEFloat32) == (b->shaderRoundingModeRTEFloat32))) { onFail("a->shaderRoundingModeRTEFloat32 (Error: Value not equal)"); };
    if (!((a->shaderRoundingModeRTEFloat64) == (b->shaderRoundingModeRTEFloat64))) { onFail("a->shaderRoundingModeRTEFloat64 (Error: Value not equal)"); };
    if (!((a->shaderRoundingModeRTZFloat16) == (b->shaderRoundingModeRTZFloat16))) { onFail("a->shaderRoundingModeRTZFloat16 (Error: Value not equal)"); };
    if (!((a->shaderRoundingModeRTZFloat32) == (b->shaderRoundingModeRTZFloat32))) { onFail("a->shaderRoundingModeRTZFloat32 (Error: Value not equal)"); };
    if (!((a->shaderRoundingModeRTZFloat64) == (b->shaderRoundingModeRTZFloat64))) { onFail("a->shaderRoundingModeRTZFloat64 (Error: Value not equal)"); };
    if (!((a->maxUpdateAfterBindDescriptorsInAllPools) == (b->maxUpdateAfterBindDescriptorsInAllPools))) { onFail("a->maxUpdateAfterBindDescriptorsInAllPools (Error: Value not equal)"); };
    if (!((a->shaderUniformBufferArrayNonUniformIndexingNative) == (b->shaderUniformBufferArrayNonUniformIndexingNative))) { onFail("a->shaderUniformBufferArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->shaderSampledImageArrayNonUniformIndexingNative) == (b->shaderSampledImageArrayNonUniformIndexingNative))) { onFail("a->shaderSampledImageArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->shaderStorageBufferArrayNonUniformIndexingNative) == (b->shaderStorageBufferArrayNonUniformIndexingNative))) { onFail("a->shaderStorageBufferArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->shaderStorageImageArrayNonUniformIndexingNative) == (b->shaderStorageImageArrayNonUniformIndexingNative))) { onFail("a->shaderStorageImageArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->shaderInputAttachmentArrayNonUniformIndexingNative) == (b->shaderInputAttachmentArrayNonUniformIndexingNative))) { onFail("a->shaderInputAttachmentArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->robustBufferAccessUpdateAfterBind) == (b->robustBufferAccessUpdateAfterBind))) { onFail("a->robustBufferAccessUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->quadDivergentImplicitLod) == (b->quadDivergentImplicitLod))) { onFail("a->quadDivergentImplicitLod (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindSamplers) == (b->maxPerStageDescriptorUpdateAfterBindSamplers))) { onFail("a->maxPerStageDescriptorUpdateAfterBindSamplers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindUniformBuffers) == (b->maxPerStageDescriptorUpdateAfterBindUniformBuffers))) { onFail("a->maxPerStageDescriptorUpdateAfterBindUniformBuffers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindStorageBuffers) == (b->maxPerStageDescriptorUpdateAfterBindStorageBuffers))) { onFail("a->maxPerStageDescriptorUpdateAfterBindStorageBuffers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindSampledImages) == (b->maxPerStageDescriptorUpdateAfterBindSampledImages))) { onFail("a->maxPerStageDescriptorUpdateAfterBindSampledImages (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindStorageImages) == (b->maxPerStageDescriptorUpdateAfterBindStorageImages))) { onFail("a->maxPerStageDescriptorUpdateAfterBindStorageImages (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindInputAttachments) == (b->maxPerStageDescriptorUpdateAfterBindInputAttachments))) { onFail("a->maxPerStageDescriptorUpdateAfterBindInputAttachments (Error: Value not equal)"); };
    if (!((a->maxPerStageUpdateAfterBindResources) == (b->maxPerStageUpdateAfterBindResources))) { onFail("a->maxPerStageUpdateAfterBindResources (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindSamplers) == (b->maxDescriptorSetUpdateAfterBindSamplers))) { onFail("a->maxDescriptorSetUpdateAfterBindSamplers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindUniformBuffers) == (b->maxDescriptorSetUpdateAfterBindUniformBuffers))) { onFail("a->maxDescriptorSetUpdateAfterBindUniformBuffers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic) == (b->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic))) { onFail("a->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindStorageBuffers) == (b->maxDescriptorSetUpdateAfterBindStorageBuffers))) { onFail("a->maxDescriptorSetUpdateAfterBindStorageBuffers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic) == (b->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic))) { onFail("a->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindSampledImages) == (b->maxDescriptorSetUpdateAfterBindSampledImages))) { onFail("a->maxDescriptorSetUpdateAfterBindSampledImages (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindStorageImages) == (b->maxDescriptorSetUpdateAfterBindStorageImages))) { onFail("a->maxDescriptorSetUpdateAfterBindStorageImages (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindInputAttachments) == (b->maxDescriptorSetUpdateAfterBindInputAttachments))) { onFail("a->maxDescriptorSetUpdateAfterBindInputAttachments (Error: Value not equal)"); };
    if (!((a->supportedDepthResolveModes) == (b->supportedDepthResolveModes))) { onFail("a->supportedDepthResolveModes (Error: Value not equal)"); };
    if (!((a->supportedStencilResolveModes) == (b->supportedStencilResolveModes))) { onFail("a->supportedStencilResolveModes (Error: Value not equal)"); };
    if (!((a->independentResolveNone) == (b->independentResolveNone))) { onFail("a->independentResolveNone (Error: Value not equal)"); };
    if (!((a->independentResolve) == (b->independentResolve))) { onFail("a->independentResolve (Error: Value not equal)"); };
    if (!((a->filterMinmaxSingleComponentFormats) == (b->filterMinmaxSingleComponentFormats))) { onFail("a->filterMinmaxSingleComponentFormats (Error: Value not equal)"); };
    if (!((a->filterMinmaxImageComponentMapping) == (b->filterMinmaxImageComponentMapping))) { onFail("a->filterMinmaxImageComponentMapping (Error: Value not equal)"); };
    if (!((a->maxTimelineSemaphoreValueDifference) == (b->maxTimelineSemaphoreValueDifference))) { onFail("a->maxTimelineSemaphoreValueDifference (Error: Value not equal)"); };
    if (!((a->framebufferIntegerColorSampleCounts) == (b->framebufferIntegerColorSampleCounts))) { onFail("a->framebufferIntegerColorSampleCounts (Error: Value not equal)"); };
}

void checkEqual_VkImageFormatListCreateInfo(
    const VkImageFormatListCreateInfo* a,
    const VkImageFormatListCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->viewFormatCount) == (b->viewFormatCount))) { onFail("a->viewFormatCount (Error: Value not equal)"); };
    if (!((a->viewFormatCount) == (b->viewFormatCount))) { onFail("a->pViewFormats (Error: Lengths not equal)"); };
    if (!((memcmp(a->pViewFormats, b->pViewFormats, a->viewFormatCount * sizeof(const VkFormat)) == 0))) { onFail("a->pViewFormats (Error: Unequal dyn array)"); };
}

void checkEqual_VkAttachmentDescription2(
    const VkAttachmentDescription2* a,
    const VkAttachmentDescription2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->samples) == (b->samples))) { onFail("a->samples (Error: Value not equal)"); };
    if (!((a->loadOp) == (b->loadOp))) { onFail("a->loadOp (Error: Value not equal)"); };
    if (!((a->storeOp) == (b->storeOp))) { onFail("a->storeOp (Error: Value not equal)"); };
    if (!((a->stencilLoadOp) == (b->stencilLoadOp))) { onFail("a->stencilLoadOp (Error: Value not equal)"); };
    if (!((a->stencilStoreOp) == (b->stencilStoreOp))) { onFail("a->stencilStoreOp (Error: Value not equal)"); };
    if (!((a->initialLayout) == (b->initialLayout))) { onFail("a->initialLayout (Error: Value not equal)"); };
    if (!((a->finalLayout) == (b->finalLayout))) { onFail("a->finalLayout (Error: Value not equal)"); };
}

void checkEqual_VkAttachmentReference2(
    const VkAttachmentReference2* a,
    const VkAttachmentReference2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->attachment) == (b->attachment))) { onFail("a->attachment (Error: Value not equal)"); };
    if (!((a->layout) == (b->layout))) { onFail("a->layout (Error: Value not equal)"); };
    if (!((a->aspectMask) == (b->aspectMask))) { onFail("a->aspectMask (Error: Value not equal)"); };
}

void checkEqual_VkSubpassDescription2(
    const VkSubpassDescription2* a,
    const VkSubpassDescription2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->pipelineBindPoint) == (b->pipelineBindPoint))) { onFail("a->pipelineBindPoint (Error: Value not equal)"); };
    if (!((a->viewMask) == (b->viewMask))) { onFail("a->viewMask (Error: Value not equal)"); };
    if (!((a->inputAttachmentCount) == (b->inputAttachmentCount))) { onFail("a->inputAttachmentCount (Error: Value not equal)"); };
    if ((a->pInputAttachments) && (b->pInputAttachments))
    {
        if (!((a->inputAttachmentCount) == (b->inputAttachmentCount))) { onFail("a->pInputAttachments (Error: Lengths not equal)"); };
        if ((a->inputAttachmentCount) == (b->inputAttachmentCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->inputAttachmentCount; ++i)
                {
                    checkEqual_VkAttachmentReference2(a->pInputAttachments + i, b->pInputAttachments + i, onFail);
                }
            }
        }
    }
    if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->colorAttachmentCount (Error: Value not equal)"); };
    if ((a->pColorAttachments) && (b->pColorAttachments))
    {
        if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->pColorAttachments (Error: Lengths not equal)"); };
        if ((a->colorAttachmentCount) == (b->colorAttachmentCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->colorAttachmentCount; ++i)
                {
                    checkEqual_VkAttachmentReference2(a->pColorAttachments + i, b->pColorAttachments + i, onFail);
                }
            }
        }
    }
    if (!((!(a->pResolveAttachments) && !(b->pResolveAttachments)) || ((a->pResolveAttachments) && (b->pResolveAttachments)))) { onFail("a->pResolveAttachments (Error: Mismatch in optional field)"); };
    if (a->pResolveAttachments && b->pResolveAttachments)
    {
        if ((a->pResolveAttachments) && (b->pResolveAttachments))
        {
            if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->pResolveAttachments (Error: Lengths not equal)"); };
            if ((a->colorAttachmentCount) == (b->colorAttachmentCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->colorAttachmentCount; ++i)
                    {
                        checkEqual_VkAttachmentReference2(a->pResolveAttachments + i, b->pResolveAttachments + i, onFail);
                    }
                }
            }
        }
    }
    if (!((!(a->pDepthStencilAttachment) && !(b->pDepthStencilAttachment)) || ((a->pDepthStencilAttachment) && (b->pDepthStencilAttachment)))) { onFail("a->pDepthStencilAttachment (Error: Mismatch in optional field)"); };
    if (a->pDepthStencilAttachment && b->pDepthStencilAttachment)
    {
        if ((a->pDepthStencilAttachment) && (b->pDepthStencilAttachment))
        {
            checkEqual_VkAttachmentReference2(a->pDepthStencilAttachment, b->pDepthStencilAttachment, onFail);
        }
    }
    if (!((a->preserveAttachmentCount) == (b->preserveAttachmentCount))) { onFail("a->preserveAttachmentCount (Error: Value not equal)"); };
    if (!((a->preserveAttachmentCount) == (b->preserveAttachmentCount))) { onFail("a->pPreserveAttachments (Error: Lengths not equal)"); };
    if (!((memcmp(a->pPreserveAttachments, b->pPreserveAttachments, a->preserveAttachmentCount * sizeof(const uint32_t)) == 0))) { onFail("a->pPreserveAttachments (Error: Unequal dyn array)"); };
}

void checkEqual_VkSubpassDependency2(
    const VkSubpassDependency2* a,
    const VkSubpassDependency2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcSubpass) == (b->srcSubpass))) { onFail("a->srcSubpass (Error: Value not equal)"); };
    if (!((a->dstSubpass) == (b->dstSubpass))) { onFail("a->dstSubpass (Error: Value not equal)"); };
    if (!((a->srcStageMask) == (b->srcStageMask))) { onFail("a->srcStageMask (Error: Value not equal)"); };
    if (!((a->dstStageMask) == (b->dstStageMask))) { onFail("a->dstStageMask (Error: Value not equal)"); };
    if (!((a->srcAccessMask) == (b->srcAccessMask))) { onFail("a->srcAccessMask (Error: Value not equal)"); };
    if (!((a->dstAccessMask) == (b->dstAccessMask))) { onFail("a->dstAccessMask (Error: Value not equal)"); };
    if (!((a->dependencyFlags) == (b->dependencyFlags))) { onFail("a->dependencyFlags (Error: Value not equal)"); };
    if (!((a->viewOffset) == (b->viewOffset))) { onFail("a->viewOffset (Error: Value not equal)"); };
}

void checkEqual_VkRenderPassCreateInfo2(
    const VkRenderPassCreateInfo2* a,
    const VkRenderPassCreateInfo2* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->attachmentCount (Error: Value not equal)"); };
    if ((a->pAttachments) && (b->pAttachments))
    {
        if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->pAttachments (Error: Lengths not equal)"); };
        if ((a->attachmentCount) == (b->attachmentCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->attachmentCount; ++i)
                {
                    checkEqual_VkAttachmentDescription2(a->pAttachments + i, b->pAttachments + i, onFail);
                }
            }
        }
    }
    if (!((a->subpassCount) == (b->subpassCount))) { onFail("a->subpassCount (Error: Value not equal)"); };
    if ((a->pSubpasses) && (b->pSubpasses))
    {
        if (!((a->subpassCount) == (b->subpassCount))) { onFail("a->pSubpasses (Error: Lengths not equal)"); };
        if ((a->subpassCount) == (b->subpassCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->subpassCount; ++i)
                {
                    checkEqual_VkSubpassDescription2(a->pSubpasses + i, b->pSubpasses + i, onFail);
                }
            }
        }
    }
    if (!((a->dependencyCount) == (b->dependencyCount))) { onFail("a->dependencyCount (Error: Value not equal)"); };
    if ((a->pDependencies) && (b->pDependencies))
    {
        if (!((a->dependencyCount) == (b->dependencyCount))) { onFail("a->pDependencies (Error: Lengths not equal)"); };
        if ((a->dependencyCount) == (b->dependencyCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->dependencyCount; ++i)
                {
                    checkEqual_VkSubpassDependency2(a->pDependencies + i, b->pDependencies + i, onFail);
                }
            }
        }
    }
    if (!((a->correlatedViewMaskCount) == (b->correlatedViewMaskCount))) { onFail("a->correlatedViewMaskCount (Error: Value not equal)"); };
    if (!((a->correlatedViewMaskCount) == (b->correlatedViewMaskCount))) { onFail("a->pCorrelatedViewMasks (Error: Lengths not equal)"); };
    if (!((memcmp(a->pCorrelatedViewMasks, b->pCorrelatedViewMasks, a->correlatedViewMaskCount * sizeof(const uint32_t)) == 0))) { onFail("a->pCorrelatedViewMasks (Error: Unequal dyn array)"); };
}

void checkEqual_VkSubpassBeginInfo(
    const VkSubpassBeginInfo* a,
    const VkSubpassBeginInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->contents) == (b->contents))) { onFail("a->contents (Error: Value not equal)"); };
}

void checkEqual_VkSubpassEndInfo(
    const VkSubpassEndInfo* a,
    const VkSubpassEndInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
}

void checkEqual_VkPhysicalDevice8BitStorageFeatures(
    const VkPhysicalDevice8BitStorageFeatures* a,
    const VkPhysicalDevice8BitStorageFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->storageBuffer8BitAccess) == (b->storageBuffer8BitAccess))) { onFail("a->storageBuffer8BitAccess (Error: Value not equal)"); };
    if (!((a->uniformAndStorageBuffer8BitAccess) == (b->uniformAndStorageBuffer8BitAccess))) { onFail("a->uniformAndStorageBuffer8BitAccess (Error: Value not equal)"); };
    if (!((a->storagePushConstant8) == (b->storagePushConstant8))) { onFail("a->storagePushConstant8 (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceDriverProperties(
    const VkPhysicalDeviceDriverProperties* a,
    const VkPhysicalDeviceDriverProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->driverID) == (b->driverID))) { onFail("a->driverID (Error: Value not equal)"); };
    if (!((memcmp(a->driverName, b->driverName, VK_MAX_DRIVER_NAME_SIZE * sizeof(char)) == 0))) { onFail("a->driverName (Error: Unequal static array)"); };
    if (!((memcmp(a->driverInfo, b->driverInfo, VK_MAX_DRIVER_INFO_SIZE * sizeof(char)) == 0))) { onFail("a->driverInfo (Error: Unequal static array)"); };
    checkEqual_VkConformanceVersion(&a->conformanceVersion, &b->conformanceVersion, onFail);
}

void checkEqual_VkPhysicalDeviceShaderAtomicInt64Features(
    const VkPhysicalDeviceShaderAtomicInt64Features* a,
    const VkPhysicalDeviceShaderAtomicInt64Features* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderBufferInt64Atomics) == (b->shaderBufferInt64Atomics))) { onFail("a->shaderBufferInt64Atomics (Error: Value not equal)"); };
    if (!((a->shaderSharedInt64Atomics) == (b->shaderSharedInt64Atomics))) { onFail("a->shaderSharedInt64Atomics (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceShaderFloat16Int8Features(
    const VkPhysicalDeviceShaderFloat16Int8Features* a,
    const VkPhysicalDeviceShaderFloat16Int8Features* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderFloat16) == (b->shaderFloat16))) { onFail("a->shaderFloat16 (Error: Value not equal)"); };
    if (!((a->shaderInt8) == (b->shaderInt8))) { onFail("a->shaderInt8 (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceFloatControlsProperties(
    const VkPhysicalDeviceFloatControlsProperties* a,
    const VkPhysicalDeviceFloatControlsProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->denormBehaviorIndependence) == (b->denormBehaviorIndependence))) { onFail("a->denormBehaviorIndependence (Error: Value not equal)"); };
    if (!((a->roundingModeIndependence) == (b->roundingModeIndependence))) { onFail("a->roundingModeIndependence (Error: Value not equal)"); };
    if (!((a->shaderSignedZeroInfNanPreserveFloat16) == (b->shaderSignedZeroInfNanPreserveFloat16))) { onFail("a->shaderSignedZeroInfNanPreserveFloat16 (Error: Value not equal)"); };
    if (!((a->shaderSignedZeroInfNanPreserveFloat32) == (b->shaderSignedZeroInfNanPreserveFloat32))) { onFail("a->shaderSignedZeroInfNanPreserveFloat32 (Error: Value not equal)"); };
    if (!((a->shaderSignedZeroInfNanPreserveFloat64) == (b->shaderSignedZeroInfNanPreserveFloat64))) { onFail("a->shaderSignedZeroInfNanPreserveFloat64 (Error: Value not equal)"); };
    if (!((a->shaderDenormPreserveFloat16) == (b->shaderDenormPreserveFloat16))) { onFail("a->shaderDenormPreserveFloat16 (Error: Value not equal)"); };
    if (!((a->shaderDenormPreserveFloat32) == (b->shaderDenormPreserveFloat32))) { onFail("a->shaderDenormPreserveFloat32 (Error: Value not equal)"); };
    if (!((a->shaderDenormPreserveFloat64) == (b->shaderDenormPreserveFloat64))) { onFail("a->shaderDenormPreserveFloat64 (Error: Value not equal)"); };
    if (!((a->shaderDenormFlushToZeroFloat16) == (b->shaderDenormFlushToZeroFloat16))) { onFail("a->shaderDenormFlushToZeroFloat16 (Error: Value not equal)"); };
    if (!((a->shaderDenormFlushToZeroFloat32) == (b->shaderDenormFlushToZeroFloat32))) { onFail("a->shaderDenormFlushToZeroFloat32 (Error: Value not equal)"); };
    if (!((a->shaderDenormFlushToZeroFloat64) == (b->shaderDenormFlushToZeroFloat64))) { onFail("a->shaderDenormFlushToZeroFloat64 (Error: Value not equal)"); };
    if (!((a->shaderRoundingModeRTEFloat16) == (b->shaderRoundingModeRTEFloat16))) { onFail("a->shaderRoundingModeRTEFloat16 (Error: Value not equal)"); };
    if (!((a->shaderRoundingModeRTEFloat32) == (b->shaderRoundingModeRTEFloat32))) { onFail("a->shaderRoundingModeRTEFloat32 (Error: Value not equal)"); };
    if (!((a->shaderRoundingModeRTEFloat64) == (b->shaderRoundingModeRTEFloat64))) { onFail("a->shaderRoundingModeRTEFloat64 (Error: Value not equal)"); };
    if (!((a->shaderRoundingModeRTZFloat16) == (b->shaderRoundingModeRTZFloat16))) { onFail("a->shaderRoundingModeRTZFloat16 (Error: Value not equal)"); };
    if (!((a->shaderRoundingModeRTZFloat32) == (b->shaderRoundingModeRTZFloat32))) { onFail("a->shaderRoundingModeRTZFloat32 (Error: Value not equal)"); };
    if (!((a->shaderRoundingModeRTZFloat64) == (b->shaderRoundingModeRTZFloat64))) { onFail("a->shaderRoundingModeRTZFloat64 (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorSetLayoutBindingFlagsCreateInfo(
    const VkDescriptorSetLayoutBindingFlagsCreateInfo* a,
    const VkDescriptorSetLayoutBindingFlagsCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->bindingCount) == (b->bindingCount))) { onFail("a->bindingCount (Error: Value not equal)"); };
    if (!((!(a->pBindingFlags) && !(b->pBindingFlags)) || ((a->pBindingFlags) && (b->pBindingFlags)))) { onFail("a->pBindingFlags (Error: Mismatch in optional field)"); };
    if (a->pBindingFlags && b->pBindingFlags)
    {
        if (!((a->bindingCount) == (b->bindingCount))) { onFail("a->pBindingFlags (Error: Lengths not equal)"); };
        if (!((memcmp(a->pBindingFlags, b->pBindingFlags, a->bindingCount * sizeof(const VkDescriptorBindingFlags)) == 0))) { onFail("a->pBindingFlags (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkPhysicalDeviceDescriptorIndexingFeatures(
    const VkPhysicalDeviceDescriptorIndexingFeatures* a,
    const VkPhysicalDeviceDescriptorIndexingFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderInputAttachmentArrayDynamicIndexing) == (b->shaderInputAttachmentArrayDynamicIndexing))) { onFail("a->shaderInputAttachmentArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderUniformTexelBufferArrayDynamicIndexing) == (b->shaderUniformTexelBufferArrayDynamicIndexing))) { onFail("a->shaderUniformTexelBufferArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageTexelBufferArrayDynamicIndexing) == (b->shaderStorageTexelBufferArrayDynamicIndexing))) { onFail("a->shaderStorageTexelBufferArrayDynamicIndexing (Error: Value not equal)"); };
    if (!((a->shaderUniformBufferArrayNonUniformIndexing) == (b->shaderUniformBufferArrayNonUniformIndexing))) { onFail("a->shaderUniformBufferArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderSampledImageArrayNonUniformIndexing) == (b->shaderSampledImageArrayNonUniformIndexing))) { onFail("a->shaderSampledImageArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageBufferArrayNonUniformIndexing) == (b->shaderStorageBufferArrayNonUniformIndexing))) { onFail("a->shaderStorageBufferArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageImageArrayNonUniformIndexing) == (b->shaderStorageImageArrayNonUniformIndexing))) { onFail("a->shaderStorageImageArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderInputAttachmentArrayNonUniformIndexing) == (b->shaderInputAttachmentArrayNonUniformIndexing))) { onFail("a->shaderInputAttachmentArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderUniformTexelBufferArrayNonUniformIndexing) == (b->shaderUniformTexelBufferArrayNonUniformIndexing))) { onFail("a->shaderUniformTexelBufferArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->shaderStorageTexelBufferArrayNonUniformIndexing) == (b->shaderStorageTexelBufferArrayNonUniformIndexing))) { onFail("a->shaderStorageTexelBufferArrayNonUniformIndexing (Error: Value not equal)"); };
    if (!((a->descriptorBindingUniformBufferUpdateAfterBind) == (b->descriptorBindingUniformBufferUpdateAfterBind))) { onFail("a->descriptorBindingUniformBufferUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingSampledImageUpdateAfterBind) == (b->descriptorBindingSampledImageUpdateAfterBind))) { onFail("a->descriptorBindingSampledImageUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingStorageImageUpdateAfterBind) == (b->descriptorBindingStorageImageUpdateAfterBind))) { onFail("a->descriptorBindingStorageImageUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingStorageBufferUpdateAfterBind) == (b->descriptorBindingStorageBufferUpdateAfterBind))) { onFail("a->descriptorBindingStorageBufferUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingUniformTexelBufferUpdateAfterBind) == (b->descriptorBindingUniformTexelBufferUpdateAfterBind))) { onFail("a->descriptorBindingUniformTexelBufferUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingStorageTexelBufferUpdateAfterBind) == (b->descriptorBindingStorageTexelBufferUpdateAfterBind))) { onFail("a->descriptorBindingStorageTexelBufferUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->descriptorBindingUpdateUnusedWhilePending) == (b->descriptorBindingUpdateUnusedWhilePending))) { onFail("a->descriptorBindingUpdateUnusedWhilePending (Error: Value not equal)"); };
    if (!((a->descriptorBindingPartiallyBound) == (b->descriptorBindingPartiallyBound))) { onFail("a->descriptorBindingPartiallyBound (Error: Value not equal)"); };
    if (!((a->descriptorBindingVariableDescriptorCount) == (b->descriptorBindingVariableDescriptorCount))) { onFail("a->descriptorBindingVariableDescriptorCount (Error: Value not equal)"); };
    if (!((a->runtimeDescriptorArray) == (b->runtimeDescriptorArray))) { onFail("a->runtimeDescriptorArray (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceDescriptorIndexingProperties(
    const VkPhysicalDeviceDescriptorIndexingProperties* a,
    const VkPhysicalDeviceDescriptorIndexingProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxUpdateAfterBindDescriptorsInAllPools) == (b->maxUpdateAfterBindDescriptorsInAllPools))) { onFail("a->maxUpdateAfterBindDescriptorsInAllPools (Error: Value not equal)"); };
    if (!((a->shaderUniformBufferArrayNonUniformIndexingNative) == (b->shaderUniformBufferArrayNonUniformIndexingNative))) { onFail("a->shaderUniformBufferArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->shaderSampledImageArrayNonUniformIndexingNative) == (b->shaderSampledImageArrayNonUniformIndexingNative))) { onFail("a->shaderSampledImageArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->shaderStorageBufferArrayNonUniformIndexingNative) == (b->shaderStorageBufferArrayNonUniformIndexingNative))) { onFail("a->shaderStorageBufferArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->shaderStorageImageArrayNonUniformIndexingNative) == (b->shaderStorageImageArrayNonUniformIndexingNative))) { onFail("a->shaderStorageImageArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->shaderInputAttachmentArrayNonUniformIndexingNative) == (b->shaderInputAttachmentArrayNonUniformIndexingNative))) { onFail("a->shaderInputAttachmentArrayNonUniformIndexingNative (Error: Value not equal)"); };
    if (!((a->robustBufferAccessUpdateAfterBind) == (b->robustBufferAccessUpdateAfterBind))) { onFail("a->robustBufferAccessUpdateAfterBind (Error: Value not equal)"); };
    if (!((a->quadDivergentImplicitLod) == (b->quadDivergentImplicitLod))) { onFail("a->quadDivergentImplicitLod (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindSamplers) == (b->maxPerStageDescriptorUpdateAfterBindSamplers))) { onFail("a->maxPerStageDescriptorUpdateAfterBindSamplers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindUniformBuffers) == (b->maxPerStageDescriptorUpdateAfterBindUniformBuffers))) { onFail("a->maxPerStageDescriptorUpdateAfterBindUniformBuffers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindStorageBuffers) == (b->maxPerStageDescriptorUpdateAfterBindStorageBuffers))) { onFail("a->maxPerStageDescriptorUpdateAfterBindStorageBuffers (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindSampledImages) == (b->maxPerStageDescriptorUpdateAfterBindSampledImages))) { onFail("a->maxPerStageDescriptorUpdateAfterBindSampledImages (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindStorageImages) == (b->maxPerStageDescriptorUpdateAfterBindStorageImages))) { onFail("a->maxPerStageDescriptorUpdateAfterBindStorageImages (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindInputAttachments) == (b->maxPerStageDescriptorUpdateAfterBindInputAttachments))) { onFail("a->maxPerStageDescriptorUpdateAfterBindInputAttachments (Error: Value not equal)"); };
    if (!((a->maxPerStageUpdateAfterBindResources) == (b->maxPerStageUpdateAfterBindResources))) { onFail("a->maxPerStageUpdateAfterBindResources (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindSamplers) == (b->maxDescriptorSetUpdateAfterBindSamplers))) { onFail("a->maxDescriptorSetUpdateAfterBindSamplers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindUniformBuffers) == (b->maxDescriptorSetUpdateAfterBindUniformBuffers))) { onFail("a->maxDescriptorSetUpdateAfterBindUniformBuffers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic) == (b->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic))) { onFail("a->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindStorageBuffers) == (b->maxDescriptorSetUpdateAfterBindStorageBuffers))) { onFail("a->maxDescriptorSetUpdateAfterBindStorageBuffers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic) == (b->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic))) { onFail("a->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindSampledImages) == (b->maxDescriptorSetUpdateAfterBindSampledImages))) { onFail("a->maxDescriptorSetUpdateAfterBindSampledImages (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindStorageImages) == (b->maxDescriptorSetUpdateAfterBindStorageImages))) { onFail("a->maxDescriptorSetUpdateAfterBindStorageImages (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindInputAttachments) == (b->maxDescriptorSetUpdateAfterBindInputAttachments))) { onFail("a->maxDescriptorSetUpdateAfterBindInputAttachments (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorSetVariableDescriptorCountAllocateInfo(
    const VkDescriptorSetVariableDescriptorCountAllocateInfo* a,
    const VkDescriptorSetVariableDescriptorCountAllocateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->descriptorSetCount) == (b->descriptorSetCount))) { onFail("a->descriptorSetCount (Error: Value not equal)"); };
    if (!((a->descriptorSetCount) == (b->descriptorSetCount))) { onFail("a->pDescriptorCounts (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDescriptorCounts, b->pDescriptorCounts, a->descriptorSetCount * sizeof(const uint32_t)) == 0))) { onFail("a->pDescriptorCounts (Error: Unequal dyn array)"); };
}

void checkEqual_VkDescriptorSetVariableDescriptorCountLayoutSupport(
    const VkDescriptorSetVariableDescriptorCountLayoutSupport* a,
    const VkDescriptorSetVariableDescriptorCountLayoutSupport* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxVariableDescriptorCount) == (b->maxVariableDescriptorCount))) { onFail("a->maxVariableDescriptorCount (Error: Value not equal)"); };
}

void checkEqual_VkSubpassDescriptionDepthStencilResolve(
    const VkSubpassDescriptionDepthStencilResolve* a,
    const VkSubpassDescriptionDepthStencilResolve* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->depthResolveMode) == (b->depthResolveMode))) { onFail("a->depthResolveMode (Error: Value not equal)"); };
    if (!((a->stencilResolveMode) == (b->stencilResolveMode))) { onFail("a->stencilResolveMode (Error: Value not equal)"); };
    if (!((!(a->pDepthStencilResolveAttachment) && !(b->pDepthStencilResolveAttachment)) || ((a->pDepthStencilResolveAttachment) && (b->pDepthStencilResolveAttachment)))) { onFail("a->pDepthStencilResolveAttachment (Error: Mismatch in optional field)"); };
    if (a->pDepthStencilResolveAttachment && b->pDepthStencilResolveAttachment)
    {
        if ((a->pDepthStencilResolveAttachment) && (b->pDepthStencilResolveAttachment))
        {
            checkEqual_VkAttachmentReference2(a->pDepthStencilResolveAttachment, b->pDepthStencilResolveAttachment, onFail);
        }
    }
}

void checkEqual_VkPhysicalDeviceDepthStencilResolveProperties(
    const VkPhysicalDeviceDepthStencilResolveProperties* a,
    const VkPhysicalDeviceDepthStencilResolveProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->supportedDepthResolveModes) == (b->supportedDepthResolveModes))) { onFail("a->supportedDepthResolveModes (Error: Value not equal)"); };
    if (!((a->supportedStencilResolveModes) == (b->supportedStencilResolveModes))) { onFail("a->supportedStencilResolveModes (Error: Value not equal)"); };
    if (!((a->independentResolveNone) == (b->independentResolveNone))) { onFail("a->independentResolveNone (Error: Value not equal)"); };
    if (!((a->independentResolve) == (b->independentResolve))) { onFail("a->independentResolve (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceScalarBlockLayoutFeatures(
    const VkPhysicalDeviceScalarBlockLayoutFeatures* a,
    const VkPhysicalDeviceScalarBlockLayoutFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->scalarBlockLayout) == (b->scalarBlockLayout))) { onFail("a->scalarBlockLayout (Error: Value not equal)"); };
}

void checkEqual_VkImageStencilUsageCreateInfo(
    const VkImageStencilUsageCreateInfo* a,
    const VkImageStencilUsageCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->stencilUsage) == (b->stencilUsage))) { onFail("a->stencilUsage (Error: Value not equal)"); };
}

void checkEqual_VkSamplerReductionModeCreateInfo(
    const VkSamplerReductionModeCreateInfo* a,
    const VkSamplerReductionModeCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->reductionMode) == (b->reductionMode))) { onFail("a->reductionMode (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceSamplerFilterMinmaxProperties(
    const VkPhysicalDeviceSamplerFilterMinmaxProperties* a,
    const VkPhysicalDeviceSamplerFilterMinmaxProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->filterMinmaxSingleComponentFormats) == (b->filterMinmaxSingleComponentFormats))) { onFail("a->filterMinmaxSingleComponentFormats (Error: Value not equal)"); };
    if (!((a->filterMinmaxImageComponentMapping) == (b->filterMinmaxImageComponentMapping))) { onFail("a->filterMinmaxImageComponentMapping (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceVulkanMemoryModelFeatures(
    const VkPhysicalDeviceVulkanMemoryModelFeatures* a,
    const VkPhysicalDeviceVulkanMemoryModelFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->vulkanMemoryModel) == (b->vulkanMemoryModel))) { onFail("a->vulkanMemoryModel (Error: Value not equal)"); };
    if (!((a->vulkanMemoryModelDeviceScope) == (b->vulkanMemoryModelDeviceScope))) { onFail("a->vulkanMemoryModelDeviceScope (Error: Value not equal)"); };
    if (!((a->vulkanMemoryModelAvailabilityVisibilityChains) == (b->vulkanMemoryModelAvailabilityVisibilityChains))) { onFail("a->vulkanMemoryModelAvailabilityVisibilityChains (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceImagelessFramebufferFeatures(
    const VkPhysicalDeviceImagelessFramebufferFeatures* a,
    const VkPhysicalDeviceImagelessFramebufferFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->imagelessFramebuffer) == (b->imagelessFramebuffer))) { onFail("a->imagelessFramebuffer (Error: Value not equal)"); };
}

void checkEqual_VkFramebufferAttachmentImageInfo(
    const VkFramebufferAttachmentImageInfo* a,
    const VkFramebufferAttachmentImageInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
    if (!((a->width) == (b->width))) { onFail("a->width (Error: Value not equal)"); };
    if (!((a->height) == (b->height))) { onFail("a->height (Error: Value not equal)"); };
    if (!((a->layerCount) == (b->layerCount))) { onFail("a->layerCount (Error: Value not equal)"); };
    if (!((a->viewFormatCount) == (b->viewFormatCount))) { onFail("a->viewFormatCount (Error: Value not equal)"); };
    if (!((a->viewFormatCount) == (b->viewFormatCount))) { onFail("a->pViewFormats (Error: Lengths not equal)"); };
    if (!((memcmp(a->pViewFormats, b->pViewFormats, a->viewFormatCount * sizeof(const VkFormat)) == 0))) { onFail("a->pViewFormats (Error: Unequal dyn array)"); };
}

void checkEqual_VkFramebufferAttachmentsCreateInfo(
    const VkFramebufferAttachmentsCreateInfo* a,
    const VkFramebufferAttachmentsCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->attachmentImageInfoCount) == (b->attachmentImageInfoCount))) { onFail("a->attachmentImageInfoCount (Error: Value not equal)"); };
    if ((a->pAttachmentImageInfos) && (b->pAttachmentImageInfos))
    {
        if (!((a->attachmentImageInfoCount) == (b->attachmentImageInfoCount))) { onFail("a->pAttachmentImageInfos (Error: Lengths not equal)"); };
        if ((a->attachmentImageInfoCount) == (b->attachmentImageInfoCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->attachmentImageInfoCount; ++i)
                {
                    checkEqual_VkFramebufferAttachmentImageInfo(a->pAttachmentImageInfos + i, b->pAttachmentImageInfos + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkRenderPassAttachmentBeginInfo(
    const VkRenderPassAttachmentBeginInfo* a,
    const VkRenderPassAttachmentBeginInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->attachmentCount (Error: Value not equal)"); };
    if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->pAttachments (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAttachments, b->pAttachments, a->attachmentCount * sizeof(const VkImageView)) == 0))) { onFail("a->pAttachments (Error: Unequal dyn array)"); };
}

void checkEqual_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
    const VkPhysicalDeviceUniformBufferStandardLayoutFeatures* a,
    const VkPhysicalDeviceUniformBufferStandardLayoutFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->uniformBufferStandardLayout) == (b->uniformBufferStandardLayout))) { onFail("a->uniformBufferStandardLayout (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
    const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* a,
    const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderSubgroupExtendedTypes) == (b->shaderSubgroupExtendedTypes))) { onFail("a->shaderSubgroupExtendedTypes (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
    const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* a,
    const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->separateDepthStencilLayouts) == (b->separateDepthStencilLayouts))) { onFail("a->separateDepthStencilLayouts (Error: Value not equal)"); };
}

void checkEqual_VkAttachmentReferenceStencilLayout(
    const VkAttachmentReferenceStencilLayout* a,
    const VkAttachmentReferenceStencilLayout* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->stencilLayout) == (b->stencilLayout))) { onFail("a->stencilLayout (Error: Value not equal)"); };
}

void checkEqual_VkAttachmentDescriptionStencilLayout(
    const VkAttachmentDescriptionStencilLayout* a,
    const VkAttachmentDescriptionStencilLayout* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->stencilInitialLayout) == (b->stencilInitialLayout))) { onFail("a->stencilInitialLayout (Error: Value not equal)"); };
    if (!((a->stencilFinalLayout) == (b->stencilFinalLayout))) { onFail("a->stencilFinalLayout (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceHostQueryResetFeatures(
    const VkPhysicalDeviceHostQueryResetFeatures* a,
    const VkPhysicalDeviceHostQueryResetFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->hostQueryReset) == (b->hostQueryReset))) { onFail("a->hostQueryReset (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceTimelineSemaphoreFeatures(
    const VkPhysicalDeviceTimelineSemaphoreFeatures* a,
    const VkPhysicalDeviceTimelineSemaphoreFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->timelineSemaphore) == (b->timelineSemaphore))) { onFail("a->timelineSemaphore (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceTimelineSemaphoreProperties(
    const VkPhysicalDeviceTimelineSemaphoreProperties* a,
    const VkPhysicalDeviceTimelineSemaphoreProperties* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxTimelineSemaphoreValueDifference) == (b->maxTimelineSemaphoreValueDifference))) { onFail("a->maxTimelineSemaphoreValueDifference (Error: Value not equal)"); };
}

void checkEqual_VkSemaphoreTypeCreateInfo(
    const VkSemaphoreTypeCreateInfo* a,
    const VkSemaphoreTypeCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->semaphoreType) == (b->semaphoreType))) { onFail("a->semaphoreType (Error: Value not equal)"); };
    if (!((a->initialValue) == (b->initialValue))) { onFail("a->initialValue (Error: Value not equal)"); };
}

void checkEqual_VkTimelineSemaphoreSubmitInfo(
    const VkTimelineSemaphoreSubmitInfo* a,
    const VkTimelineSemaphoreSubmitInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->waitSemaphoreValueCount) == (b->waitSemaphoreValueCount))) { onFail("a->waitSemaphoreValueCount (Error: Value not equal)"); };
    if (!((!(a->pWaitSemaphoreValues) && !(b->pWaitSemaphoreValues)) || ((a->pWaitSemaphoreValues) && (b->pWaitSemaphoreValues)))) { onFail("a->pWaitSemaphoreValues (Error: Mismatch in optional field)"); };
    if (a->pWaitSemaphoreValues && b->pWaitSemaphoreValues)
    {
        if (!((a->waitSemaphoreValueCount) == (b->waitSemaphoreValueCount))) { onFail("a->pWaitSemaphoreValues (Error: Lengths not equal)"); };
        if (!((memcmp(a->pWaitSemaphoreValues, b->pWaitSemaphoreValues, a->waitSemaphoreValueCount * sizeof(const uint64_t)) == 0))) { onFail("a->pWaitSemaphoreValues (Error: Unequal dyn array)"); };
    }
    if (!((a->signalSemaphoreValueCount) == (b->signalSemaphoreValueCount))) { onFail("a->signalSemaphoreValueCount (Error: Value not equal)"); };
    if (!((!(a->pSignalSemaphoreValues) && !(b->pSignalSemaphoreValues)) || ((a->pSignalSemaphoreValues) && (b->pSignalSemaphoreValues)))) { onFail("a->pSignalSemaphoreValues (Error: Mismatch in optional field)"); };
    if (a->pSignalSemaphoreValues && b->pSignalSemaphoreValues)
    {
        if (!((a->signalSemaphoreValueCount) == (b->signalSemaphoreValueCount))) { onFail("a->pSignalSemaphoreValues (Error: Lengths not equal)"); };
        if (!((memcmp(a->pSignalSemaphoreValues, b->pSignalSemaphoreValues, a->signalSemaphoreValueCount * sizeof(const uint64_t)) == 0))) { onFail("a->pSignalSemaphoreValues (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkSemaphoreWaitInfo(
    const VkSemaphoreWaitInfo* a,
    const VkSemaphoreWaitInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->semaphoreCount) == (b->semaphoreCount))) { onFail("a->semaphoreCount (Error: Value not equal)"); };
    if (!((a->semaphoreCount) == (b->semaphoreCount))) { onFail("a->pSemaphores (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSemaphores, b->pSemaphores, a->semaphoreCount * sizeof(const VkSemaphore)) == 0))) { onFail("a->pSemaphores (Error: Unequal dyn array)"); };
    if (!((a->semaphoreCount) == (b->semaphoreCount))) { onFail("a->pValues (Error: Lengths not equal)"); };
    if (!((memcmp(a->pValues, b->pValues, a->semaphoreCount * sizeof(const uint64_t)) == 0))) { onFail("a->pValues (Error: Unequal dyn array)"); };
}

void checkEqual_VkSemaphoreSignalInfo(
    const VkSemaphoreSignalInfo* a,
    const VkSemaphoreSignalInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->semaphore) == (b->semaphore))) { onFail("a->semaphore (Error: Value not equal)"); };
    if (!((a->value) == (b->value))) { onFail("a->value (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceBufferDeviceAddressFeatures(
    const VkPhysicalDeviceBufferDeviceAddressFeatures* a,
    const VkPhysicalDeviceBufferDeviceAddressFeatures* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->bufferDeviceAddress) == (b->bufferDeviceAddress))) { onFail("a->bufferDeviceAddress (Error: Value not equal)"); };
    if (!((a->bufferDeviceAddressCaptureReplay) == (b->bufferDeviceAddressCaptureReplay))) { onFail("a->bufferDeviceAddressCaptureReplay (Error: Value not equal)"); };
    if (!((a->bufferDeviceAddressMultiDevice) == (b->bufferDeviceAddressMultiDevice))) { onFail("a->bufferDeviceAddressMultiDevice (Error: Value not equal)"); };
}

void checkEqual_VkBufferDeviceAddressInfo(
    const VkBufferDeviceAddressInfo* a,
    const VkBufferDeviceAddressInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
}

void checkEqual_VkBufferOpaqueCaptureAddressCreateInfo(
    const VkBufferOpaqueCaptureAddressCreateInfo* a,
    const VkBufferOpaqueCaptureAddressCreateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->opaqueCaptureAddress) == (b->opaqueCaptureAddress))) { onFail("a->opaqueCaptureAddress (Error: Value not equal)"); };
}

void checkEqual_VkMemoryOpaqueCaptureAddressAllocateInfo(
    const VkMemoryOpaqueCaptureAddressAllocateInfo* a,
    const VkMemoryOpaqueCaptureAddressAllocateInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->opaqueCaptureAddress) == (b->opaqueCaptureAddress))) { onFail("a->opaqueCaptureAddress (Error: Value not equal)"); };
}

void checkEqual_VkDeviceMemoryOpaqueCaptureAddressInfo(
    const VkDeviceMemoryOpaqueCaptureAddressInfo* a,
    const VkDeviceMemoryOpaqueCaptureAddressInfo* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_surface
void checkEqual_VkSurfaceCapabilitiesKHR(
    const VkSurfaceCapabilitiesKHR* a,
    const VkSurfaceCapabilitiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->minImageCount) == (b->minImageCount))) { onFail("a->minImageCount (Error: Value not equal)"); };
    if (!((a->maxImageCount) == (b->maxImageCount))) { onFail("a->maxImageCount (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->currentExtent, &b->currentExtent, onFail);
    checkEqual_VkExtent2D(&a->minImageExtent, &b->minImageExtent, onFail);
    checkEqual_VkExtent2D(&a->maxImageExtent, &b->maxImageExtent, onFail);
    if (!((a->maxImageArrayLayers) == (b->maxImageArrayLayers))) { onFail("a->maxImageArrayLayers (Error: Value not equal)"); };
    if (!((a->supportedTransforms) == (b->supportedTransforms))) { onFail("a->supportedTransforms (Error: Value not equal)"); };
    if (!((a->currentTransform) == (b->currentTransform))) { onFail("a->currentTransform (Error: Value not equal)"); };
    if (!((a->supportedCompositeAlpha) == (b->supportedCompositeAlpha))) { onFail("a->supportedCompositeAlpha (Error: Value not equal)"); };
    if (!((a->supportedUsageFlags) == (b->supportedUsageFlags))) { onFail("a->supportedUsageFlags (Error: Value not equal)"); };
}

void checkEqual_VkSurfaceFormatKHR(
    const VkSurfaceFormatKHR* a,
    const VkSurfaceFormatKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->colorSpace) == (b->colorSpace))) { onFail("a->colorSpace (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_swapchain
void checkEqual_VkSwapchainCreateInfoKHR(
    const VkSwapchainCreateInfoKHR* a,
    const VkSwapchainCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->surface) == (b->surface))) { onFail("a->surface (Error: Value not equal)"); };
    if (!((a->minImageCount) == (b->minImageCount))) { onFail("a->minImageCount (Error: Value not equal)"); };
    if (!((a->imageFormat) == (b->imageFormat))) { onFail("a->imageFormat (Error: Value not equal)"); };
    if (!((a->imageColorSpace) == (b->imageColorSpace))) { onFail("a->imageColorSpace (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->imageExtent, &b->imageExtent, onFail);
    if (!((a->imageArrayLayers) == (b->imageArrayLayers))) { onFail("a->imageArrayLayers (Error: Value not equal)"); };
    if (!((a->imageUsage) == (b->imageUsage))) { onFail("a->imageUsage (Error: Value not equal)"); };
    if (!((a->imageSharingMode) == (b->imageSharingMode))) { onFail("a->imageSharingMode (Error: Value not equal)"); };
    if (!((a->queueFamilyIndexCount) == (b->queueFamilyIndexCount))) { onFail("a->queueFamilyIndexCount (Error: Value not equal)"); };
    if (!((!(a->pQueueFamilyIndices) && !(b->pQueueFamilyIndices)) || ((a->pQueueFamilyIndices) && (b->pQueueFamilyIndices)))) { onFail("a->pQueueFamilyIndices (Error: Mismatch in optional field)"); };
    if (a->pQueueFamilyIndices && b->pQueueFamilyIndices)
    {
        if (!((a->queueFamilyIndexCount) == (b->queueFamilyIndexCount))) { onFail("a->pQueueFamilyIndices (Error: Lengths not equal)"); };
        if (!((memcmp(a->pQueueFamilyIndices, b->pQueueFamilyIndices, a->queueFamilyIndexCount * sizeof(const uint32_t)) == 0))) { onFail("a->pQueueFamilyIndices (Error: Unequal dyn array)"); };
    }
    if (!((a->preTransform) == (b->preTransform))) { onFail("a->preTransform (Error: Value not equal)"); };
    if (!((a->compositeAlpha) == (b->compositeAlpha))) { onFail("a->compositeAlpha (Error: Value not equal)"); };
    if (!((a->presentMode) == (b->presentMode))) { onFail("a->presentMode (Error: Value not equal)"); };
    if (!((a->clipped) == (b->clipped))) { onFail("a->clipped (Error: Value not equal)"); };
    if (!((a->oldSwapchain) == (b->oldSwapchain))) { onFail("a->oldSwapchain (Error: Value not equal)"); };
}

void checkEqual_VkPresentInfoKHR(
    const VkPresentInfoKHR* a,
    const VkPresentInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->waitSemaphoreCount (Error: Value not equal)"); };
    if (!((a->waitSemaphoreCount) == (b->waitSemaphoreCount))) { onFail("a->pWaitSemaphores (Error: Lengths not equal)"); };
    if (!((memcmp(a->pWaitSemaphores, b->pWaitSemaphores, a->waitSemaphoreCount * sizeof(const VkSemaphore)) == 0))) { onFail("a->pWaitSemaphores (Error: Unequal dyn array)"); };
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->swapchainCount (Error: Value not equal)"); };
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->pSwapchains (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSwapchains, b->pSwapchains, a->swapchainCount * sizeof(const VkSwapchainKHR)) == 0))) { onFail("a->pSwapchains (Error: Unequal dyn array)"); };
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->pImageIndices (Error: Lengths not equal)"); };
    if (!((memcmp(a->pImageIndices, b->pImageIndices, a->swapchainCount * sizeof(const uint32_t)) == 0))) { onFail("a->pImageIndices (Error: Unequal dyn array)"); };
    if (!((!(a->pResults) && !(b->pResults)) || ((a->pResults) && (b->pResults)))) { onFail("a->pResults (Error: Mismatch in optional field)"); };
    if (a->pResults && b->pResults)
    {
        if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->pResults (Error: Lengths not equal)"); };
        if (!((memcmp(a->pResults, b->pResults, a->swapchainCount * sizeof(VkResult)) == 0))) { onFail("a->pResults (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkImageSwapchainCreateInfoKHR(
    const VkImageSwapchainCreateInfoKHR* a,
    const VkImageSwapchainCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->swapchain) == (b->swapchain))) { onFail("a->swapchain (Error: Value not equal)"); };
}

void checkEqual_VkBindImageMemorySwapchainInfoKHR(
    const VkBindImageMemorySwapchainInfoKHR* a,
    const VkBindImageMemorySwapchainInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->swapchain) == (b->swapchain))) { onFail("a->swapchain (Error: Value not equal)"); };
    if (!((a->imageIndex) == (b->imageIndex))) { onFail("a->imageIndex (Error: Value not equal)"); };
}

void checkEqual_VkAcquireNextImageInfoKHR(
    const VkAcquireNextImageInfoKHR* a,
    const VkAcquireNextImageInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->swapchain) == (b->swapchain))) { onFail("a->swapchain (Error: Value not equal)"); };
    if (!((a->timeout) == (b->timeout))) { onFail("a->timeout (Error: Value not equal)"); };
    if (!((a->semaphore) == (b->semaphore))) { onFail("a->semaphore (Error: Value not equal)"); };
    if (!((a->fence) == (b->fence))) { onFail("a->fence (Error: Value not equal)"); };
    if (!((a->deviceMask) == (b->deviceMask))) { onFail("a->deviceMask (Error: Value not equal)"); };
}

void checkEqual_VkDeviceGroupPresentCapabilitiesKHR(
    const VkDeviceGroupPresentCapabilitiesKHR* a,
    const VkDeviceGroupPresentCapabilitiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->presentMask, b->presentMask, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t)) == 0))) { onFail("a->presentMask (Error: Unequal static array)"); };
    if (!((a->modes) == (b->modes))) { onFail("a->modes (Error: Value not equal)"); };
}

void checkEqual_VkDeviceGroupPresentInfoKHR(
    const VkDeviceGroupPresentInfoKHR* a,
    const VkDeviceGroupPresentInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->swapchainCount (Error: Value not equal)"); };
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->pDeviceMasks (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDeviceMasks, b->pDeviceMasks, a->swapchainCount * sizeof(const uint32_t)) == 0))) { onFail("a->pDeviceMasks (Error: Unequal dyn array)"); };
    if (!((a->mode) == (b->mode))) { onFail("a->mode (Error: Value not equal)"); };
}

void checkEqual_VkDeviceGroupSwapchainCreateInfoKHR(
    const VkDeviceGroupSwapchainCreateInfoKHR* a,
    const VkDeviceGroupSwapchainCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->modes) == (b->modes))) { onFail("a->modes (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_display
void checkEqual_VkDisplayModeParametersKHR(
    const VkDisplayModeParametersKHR* a,
    const VkDisplayModeParametersKHR* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkExtent2D(&a->visibleRegion, &b->visibleRegion, onFail);
    if (!((a->refreshRate) == (b->refreshRate))) { onFail("a->refreshRate (Error: Value not equal)"); };
}

void checkEqual_VkDisplayModeCreateInfoKHR(
    const VkDisplayModeCreateInfoKHR* a,
    const VkDisplayModeCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    checkEqual_VkDisplayModeParametersKHR(&a->parameters, &b->parameters, onFail);
}

void checkEqual_VkDisplayModePropertiesKHR(
    const VkDisplayModePropertiesKHR* a,
    const VkDisplayModePropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->displayMode) == (b->displayMode))) { onFail("a->displayMode (Error: Value not equal)"); };
    checkEqual_VkDisplayModeParametersKHR(&a->parameters, &b->parameters, onFail);
}

void checkEqual_VkDisplayPlaneCapabilitiesKHR(
    const VkDisplayPlaneCapabilitiesKHR* a,
    const VkDisplayPlaneCapabilitiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->supportedAlpha) == (b->supportedAlpha))) { onFail("a->supportedAlpha (Error: Value not equal)"); };
    checkEqual_VkOffset2D(&a->minSrcPosition, &b->minSrcPosition, onFail);
    checkEqual_VkOffset2D(&a->maxSrcPosition, &b->maxSrcPosition, onFail);
    checkEqual_VkExtent2D(&a->minSrcExtent, &b->minSrcExtent, onFail);
    checkEqual_VkExtent2D(&a->maxSrcExtent, &b->maxSrcExtent, onFail);
    checkEqual_VkOffset2D(&a->minDstPosition, &b->minDstPosition, onFail);
    checkEqual_VkOffset2D(&a->maxDstPosition, &b->maxDstPosition, onFail);
    checkEqual_VkExtent2D(&a->minDstExtent, &b->minDstExtent, onFail);
    checkEqual_VkExtent2D(&a->maxDstExtent, &b->maxDstExtent, onFail);
}

void checkEqual_VkDisplayPlanePropertiesKHR(
    const VkDisplayPlanePropertiesKHR* a,
    const VkDisplayPlanePropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->currentDisplay) == (b->currentDisplay))) { onFail("a->currentDisplay (Error: Value not equal)"); };
    if (!((a->currentStackIndex) == (b->currentStackIndex))) { onFail("a->currentStackIndex (Error: Value not equal)"); };
}

void checkEqual_VkDisplayPropertiesKHR(
    const VkDisplayPropertiesKHR* a,
    const VkDisplayPropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->display) == (b->display))) { onFail("a->display (Error: Value not equal)"); };
    if (!((!(a->displayName) && !(b->displayName)) || ((a->displayName) && (b->displayName)))) { onFail("a->displayName (Error: Mismatch in string pointer nullness)"); };
    if ((a->displayName) && (b->displayName))
    {
        if (!((strcmp(a->displayName, b->displayName) == 0))) { onFail("a->displayName (Error: Unequal strings)"); };
    }
    checkEqual_VkExtent2D(&a->physicalDimensions, &b->physicalDimensions, onFail);
    checkEqual_VkExtent2D(&a->physicalResolution, &b->physicalResolution, onFail);
    if (!((a->supportedTransforms) == (b->supportedTransforms))) { onFail("a->supportedTransforms (Error: Value not equal)"); };
    if (!((a->planeReorderPossible) == (b->planeReorderPossible))) { onFail("a->planeReorderPossible (Error: Value not equal)"); };
    if (!((a->persistentContent) == (b->persistentContent))) { onFail("a->persistentContent (Error: Value not equal)"); };
}

void checkEqual_VkDisplaySurfaceCreateInfoKHR(
    const VkDisplaySurfaceCreateInfoKHR* a,
    const VkDisplaySurfaceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->displayMode) == (b->displayMode))) { onFail("a->displayMode (Error: Value not equal)"); };
    if (!((a->planeIndex) == (b->planeIndex))) { onFail("a->planeIndex (Error: Value not equal)"); };
    if (!((a->planeStackIndex) == (b->planeStackIndex))) { onFail("a->planeStackIndex (Error: Value not equal)"); };
    if (!((a->transform) == (b->transform))) { onFail("a->transform (Error: Value not equal)"); };
    if (!((a->globalAlpha) == (b->globalAlpha))) { onFail("a->globalAlpha (Error: Value not equal)"); };
    if (!((a->alphaMode) == (b->alphaMode))) { onFail("a->alphaMode (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->imageExtent, &b->imageExtent, onFail);
}

#endif
#ifdef VK_KHR_display_swapchain
void checkEqual_VkDisplayPresentInfoKHR(
    const VkDisplayPresentInfoKHR* a,
    const VkDisplayPresentInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkRect2D(&a->srcRect, &b->srcRect, onFail);
    checkEqual_VkRect2D(&a->dstRect, &b->dstRect, onFail);
    if (!((a->persistent) == (b->persistent))) { onFail("a->persistent (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_xlib_surface
void checkEqual_VkXlibSurfaceCreateInfoKHR(
    const VkXlibSurfaceCreateInfoKHR* a,
    const VkXlibSurfaceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->dpy) && !(b->dpy)) || ((a->dpy) && (b->dpy)))) { onFail("a->dpy (Error: Mismatch in optional field)"); };
    if (a->dpy && b->dpy)
    {
        if (!((memcmp(a->dpy, b->dpy, sizeof(Display)) == 0))) { onFail("a->dpy (Error: Unequal dyn array)"); };
    }
    if (!((a->window) == (b->window))) { onFail("a->window (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_xcb_surface
void checkEqual_VkXcbSurfaceCreateInfoKHR(
    const VkXcbSurfaceCreateInfoKHR* a,
    const VkXcbSurfaceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->connection) && !(b->connection)) || ((a->connection) && (b->connection)))) { onFail("a->connection (Error: Mismatch in optional field)"); };
    if (a->connection && b->connection)
    {
        if (!((memcmp(a->connection, b->connection, sizeof(xcb_connection_t)) == 0))) { onFail("a->connection (Error: Unequal dyn array)"); };
    }
    if (!((a->window) == (b->window))) { onFail("a->window (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_wayland_surface
void checkEqual_VkWaylandSurfaceCreateInfoKHR(
    const VkWaylandSurfaceCreateInfoKHR* a,
    const VkWaylandSurfaceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->display) && !(b->display)) || ((a->display) && (b->display)))) { onFail("a->display (Error: Mismatch in optional field)"); };
    if (a->display && b->display)
    {
        if (!((memcmp(a->display, b->display, sizeof(wl_display)) == 0))) { onFail("a->display (Error: Unequal dyn array)"); };
    }
    if (!((!(a->surface) && !(b->surface)) || ((a->surface) && (b->surface)))) { onFail("a->surface (Error: Mismatch in optional field)"); };
    if (a->surface && b->surface)
    {
        if (!((memcmp(a->surface, b->surface, sizeof(wl_surface)) == 0))) { onFail("a->surface (Error: Unequal dyn array)"); };
    }
}

#endif
#ifdef VK_KHR_android_surface
void checkEqual_VkAndroidSurfaceCreateInfoKHR(
    const VkAndroidSurfaceCreateInfoKHR* a,
    const VkAndroidSurfaceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->window) && !(b->window)) || ((a->window) && (b->window)))) { onFail("a->window (Error: Mismatch in optional field)"); };
    if (a->window && b->window)
    {
        if (!((memcmp(a->window, b->window, sizeof(ANativeWindow)) == 0))) { onFail("a->window (Error: Unequal dyn array)"); };
    }
}

#endif
#ifdef VK_KHR_win32_surface
void checkEqual_VkWin32SurfaceCreateInfoKHR(
    const VkWin32SurfaceCreateInfoKHR* a,
    const VkWin32SurfaceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->hinstance) == (b->hinstance))) { onFail("a->hinstance (Error: Value not equal)"); };
    if (!((a->hwnd) == (b->hwnd))) { onFail("a->hwnd (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_video_queue
void checkEqual_VkVideoQueueFamilyProperties2KHR(
    const VkVideoQueueFamilyProperties2KHR* a,
    const VkVideoQueueFamilyProperties2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->videoCodecOperations) == (b->videoCodecOperations))) { onFail("a->videoCodecOperations (Error: Value not equal)"); };
}

void checkEqual_VkVideoProfileKHR(
    const VkVideoProfileKHR* a,
    const VkVideoProfileKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->videoCodecOperation) == (b->videoCodecOperation))) { onFail("a->videoCodecOperation (Error: Value not equal)"); };
    if (!((a->chromaSubsampling) == (b->chromaSubsampling))) { onFail("a->chromaSubsampling (Error: Value not equal)"); };
    if (!((a->lumaBitDepth) == (b->lumaBitDepth))) { onFail("a->lumaBitDepth (Error: Value not equal)"); };
    if (!((a->chromaBitDepth) == (b->chromaBitDepth))) { onFail("a->chromaBitDepth (Error: Value not equal)"); };
}

void checkEqual_VkVideoProfilesKHR(
    const VkVideoProfilesKHR* a,
    const VkVideoProfilesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->profileCount) == (b->profileCount))) { onFail("a->profileCount (Error: Value not equal)"); };
    if ((a->pProfiles) && (b->pProfiles))
    {
        checkEqual_VkVideoProfileKHR(a->pProfiles, b->pProfiles, onFail);
    }
}

void checkEqual_VkVideoCapabilitiesKHR(
    const VkVideoCapabilitiesKHR* a,
    const VkVideoCapabilitiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->capabilityFlags) == (b->capabilityFlags))) { onFail("a->capabilityFlags (Error: Value not equal)"); };
    if (!((a->minBitstreamBufferOffsetAlignment) == (b->minBitstreamBufferOffsetAlignment))) { onFail("a->minBitstreamBufferOffsetAlignment (Error: Value not equal)"); };
    if (!((a->minBitstreamBufferSizeAlignment) == (b->minBitstreamBufferSizeAlignment))) { onFail("a->minBitstreamBufferSizeAlignment (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->videoPictureExtentGranularity, &b->videoPictureExtentGranularity, onFail);
    checkEqual_VkExtent2D(&a->minExtent, &b->minExtent, onFail);
    checkEqual_VkExtent2D(&a->maxExtent, &b->maxExtent, onFail);
    if (!((a->maxReferencePicturesSlotsCount) == (b->maxReferencePicturesSlotsCount))) { onFail("a->maxReferencePicturesSlotsCount (Error: Value not equal)"); };
    if (!((a->maxReferencePicturesActiveCount) == (b->maxReferencePicturesActiveCount))) { onFail("a->maxReferencePicturesActiveCount (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceVideoFormatInfoKHR(
    const VkPhysicalDeviceVideoFormatInfoKHR* a,
    const VkPhysicalDeviceVideoFormatInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->imageUsage) == (b->imageUsage))) { onFail("a->imageUsage (Error: Value not equal)"); };
    if ((a->pVideoProfiles) && (b->pVideoProfiles))
    {
        checkEqual_VkVideoProfilesKHR(a->pVideoProfiles, b->pVideoProfiles, onFail);
    }
}

void checkEqual_VkVideoFormatPropertiesKHR(
    const VkVideoFormatPropertiesKHR* a,
    const VkVideoFormatPropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
}

void checkEqual_VkVideoPictureResourceKHR(
    const VkVideoPictureResourceKHR* a,
    const VkVideoPictureResourceKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkOffset2D(&a->codedOffset, &b->codedOffset, onFail);
    checkEqual_VkExtent2D(&a->codedExtent, &b->codedExtent, onFail);
    if (!((a->baseArrayLayer) == (b->baseArrayLayer))) { onFail("a->baseArrayLayer (Error: Value not equal)"); };
    if (!((a->imageViewBinding) == (b->imageViewBinding))) { onFail("a->imageViewBinding (Error: Value not equal)"); };
}

void checkEqual_VkVideoReferenceSlotKHR(
    const VkVideoReferenceSlotKHR* a,
    const VkVideoReferenceSlotKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->slotIndex) == (b->slotIndex))) { onFail("a->slotIndex (Error: Value not equal)"); };
    if ((a->pPictureResource) && (b->pPictureResource))
    {
        checkEqual_VkVideoPictureResourceKHR(a->pPictureResource, b->pPictureResource, onFail);
    }
}

void checkEqual_VkVideoGetMemoryPropertiesKHR(
    const VkVideoGetMemoryPropertiesKHR* a,
    const VkVideoGetMemoryPropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memoryBindIndex) == (b->memoryBindIndex))) { onFail("a->memoryBindIndex (Error: Value not equal)"); };
    if ((a->pMemoryRequirements) && (b->pMemoryRequirements))
    {
        checkEqual_VkMemoryRequirements2(a->pMemoryRequirements, b->pMemoryRequirements, onFail);
    }
}

void checkEqual_VkVideoBindMemoryKHR(
    const VkVideoBindMemoryKHR* a,
    const VkVideoBindMemoryKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memoryBindIndex) == (b->memoryBindIndex))) { onFail("a->memoryBindIndex (Error: Value not equal)"); };
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->memoryOffset) == (b->memoryOffset))) { onFail("a->memoryOffset (Error: Value not equal)"); };
    if (!((a->memorySize) == (b->memorySize))) { onFail("a->memorySize (Error: Value not equal)"); };
}

void checkEqual_VkVideoSessionCreateInfoKHR(
    const VkVideoSessionCreateInfoKHR* a,
    const VkVideoSessionCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->queueFamilyIndex) == (b->queueFamilyIndex))) { onFail("a->queueFamilyIndex (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if ((a->pVideoProfile) && (b->pVideoProfile))
    {
        checkEqual_VkVideoProfileKHR(a->pVideoProfile, b->pVideoProfile, onFail);
    }
    if (!((a->pictureFormat) == (b->pictureFormat))) { onFail("a->pictureFormat (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->maxCodedExtent, &b->maxCodedExtent, onFail);
    if (!((a->referencePicturesFormat) == (b->referencePicturesFormat))) { onFail("a->referencePicturesFormat (Error: Value not equal)"); };
    if (!((a->maxReferencePicturesSlotsCount) == (b->maxReferencePicturesSlotsCount))) { onFail("a->maxReferencePicturesSlotsCount (Error: Value not equal)"); };
    if (!((a->maxReferencePicturesActiveCount) == (b->maxReferencePicturesActiveCount))) { onFail("a->maxReferencePicturesActiveCount (Error: Value not equal)"); };
}

void checkEqual_VkVideoSessionParametersCreateInfoKHR(
    const VkVideoSessionParametersCreateInfoKHR* a,
    const VkVideoSessionParametersCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->videoSessionParametersTemplate) == (b->videoSessionParametersTemplate))) { onFail("a->videoSessionParametersTemplate (Error: Value not equal)"); };
    if (!((a->videoSession) == (b->videoSession))) { onFail("a->videoSession (Error: Value not equal)"); };
}

void checkEqual_VkVideoSessionParametersUpdateInfoKHR(
    const VkVideoSessionParametersUpdateInfoKHR* a,
    const VkVideoSessionParametersUpdateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->updateSequenceCount) == (b->updateSequenceCount))) { onFail("a->updateSequenceCount (Error: Value not equal)"); };
}

void checkEqual_VkVideoBeginCodingInfoKHR(
    const VkVideoBeginCodingInfoKHR* a,
    const VkVideoBeginCodingInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->codecQualityPreset) == (b->codecQualityPreset))) { onFail("a->codecQualityPreset (Error: Value not equal)"); };
    if (!((a->videoSession) == (b->videoSession))) { onFail("a->videoSession (Error: Value not equal)"); };
    if (!((a->videoSessionParameters) == (b->videoSessionParameters))) { onFail("a->videoSessionParameters (Error: Value not equal)"); };
    if (!((a->referenceSlotCount) == (b->referenceSlotCount))) { onFail("a->referenceSlotCount (Error: Value not equal)"); };
    if ((a->pReferenceSlots) && (b->pReferenceSlots))
    {
        if (!((a->referenceSlotCount) == (b->referenceSlotCount))) { onFail("a->pReferenceSlots (Error: Lengths not equal)"); };
        if ((a->referenceSlotCount) == (b->referenceSlotCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->referenceSlotCount; ++i)
                {
                    checkEqual_VkVideoReferenceSlotKHR(a->pReferenceSlots + i, b->pReferenceSlots + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkVideoEndCodingInfoKHR(
    const VkVideoEndCodingInfoKHR* a,
    const VkVideoEndCodingInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkVideoCodingControlInfoKHR(
    const VkVideoCodingControlInfoKHR* a,
    const VkVideoCodingControlInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_video_decode_queue
void checkEqual_VkVideoDecodeInfoKHR(
    const VkVideoDecodeInfoKHR* a,
    const VkVideoDecodeInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    checkEqual_VkOffset2D(&a->codedOffset, &b->codedOffset, onFail);
    checkEqual_VkExtent2D(&a->codedExtent, &b->codedExtent, onFail);
    if (!((a->srcBuffer) == (b->srcBuffer))) { onFail("a->srcBuffer (Error: Value not equal)"); };
    if (!((a->srcBufferOffset) == (b->srcBufferOffset))) { onFail("a->srcBufferOffset (Error: Value not equal)"); };
    if (!((a->srcBufferRange) == (b->srcBufferRange))) { onFail("a->srcBufferRange (Error: Value not equal)"); };
    checkEqual_VkVideoPictureResourceKHR(&a->dstPictureResource, &b->dstPictureResource, onFail);
    if ((a->pSetupReferenceSlot) && (b->pSetupReferenceSlot))
    {
        checkEqual_VkVideoReferenceSlotKHR(a->pSetupReferenceSlot, b->pSetupReferenceSlot, onFail);
    }
    if (!((a->referenceSlotCount) == (b->referenceSlotCount))) { onFail("a->referenceSlotCount (Error: Value not equal)"); };
    if ((a->pReferenceSlots) && (b->pReferenceSlots))
    {
        if (!((a->referenceSlotCount) == (b->referenceSlotCount))) { onFail("a->pReferenceSlots (Error: Lengths not equal)"); };
        if ((a->referenceSlotCount) == (b->referenceSlotCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->referenceSlotCount; ++i)
                {
                    checkEqual_VkVideoReferenceSlotKHR(a->pReferenceSlots + i, b->pReferenceSlots + i, onFail);
                }
            }
        }
    }
}

#endif
#ifdef VK_KHR_dynamic_rendering
void checkEqual_VkRenderingAttachmentInfoKHR(
    const VkRenderingAttachmentInfoKHR* a,
    const VkRenderingAttachmentInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->imageView) == (b->imageView))) { onFail("a->imageView (Error: Value not equal)"); };
    if (!((a->imageLayout) == (b->imageLayout))) { onFail("a->imageLayout (Error: Value not equal)"); };
    if (!((a->resolveMode) == (b->resolveMode))) { onFail("a->resolveMode (Error: Value not equal)"); };
    if (!((a->resolveImageView) == (b->resolveImageView))) { onFail("a->resolveImageView (Error: Value not equal)"); };
    if (!((a->resolveImageLayout) == (b->resolveImageLayout))) { onFail("a->resolveImageLayout (Error: Value not equal)"); };
    if (!((a->loadOp) == (b->loadOp))) { onFail("a->loadOp (Error: Value not equal)"); };
    if (!((a->storeOp) == (b->storeOp))) { onFail("a->storeOp (Error: Value not equal)"); };
    checkEqual_VkClearValue(&a->clearValue, &b->clearValue, onFail);
}

void checkEqual_VkRenderingInfoKHR(
    const VkRenderingInfoKHR* a,
    const VkRenderingInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    checkEqual_VkRect2D(&a->renderArea, &b->renderArea, onFail);
    if (!((a->layerCount) == (b->layerCount))) { onFail("a->layerCount (Error: Value not equal)"); };
    if (!((a->viewMask) == (b->viewMask))) { onFail("a->viewMask (Error: Value not equal)"); };
    if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->colorAttachmentCount (Error: Value not equal)"); };
    if ((a->pColorAttachments) && (b->pColorAttachments))
    {
        if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->pColorAttachments (Error: Lengths not equal)"); };
        if ((a->colorAttachmentCount) == (b->colorAttachmentCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->colorAttachmentCount; ++i)
                {
                    checkEqual_VkRenderingAttachmentInfoKHR(a->pColorAttachments + i, b->pColorAttachments + i, onFail);
                }
            }
        }
    }
    if (!((!(a->pDepthAttachment) && !(b->pDepthAttachment)) || ((a->pDepthAttachment) && (b->pDepthAttachment)))) { onFail("a->pDepthAttachment (Error: Mismatch in optional field)"); };
    if (a->pDepthAttachment && b->pDepthAttachment)
    {
        if ((a->pDepthAttachment) && (b->pDepthAttachment))
        {
            checkEqual_VkRenderingAttachmentInfoKHR(a->pDepthAttachment, b->pDepthAttachment, onFail);
        }
    }
    if (!((!(a->pStencilAttachment) && !(b->pStencilAttachment)) || ((a->pStencilAttachment) && (b->pStencilAttachment)))) { onFail("a->pStencilAttachment (Error: Mismatch in optional field)"); };
    if (a->pStencilAttachment && b->pStencilAttachment)
    {
        if ((a->pStencilAttachment) && (b->pStencilAttachment))
        {
            checkEqual_VkRenderingAttachmentInfoKHR(a->pStencilAttachment, b->pStencilAttachment, onFail);
        }
    }
}

void checkEqual_VkPipelineRenderingCreateInfoKHR(
    const VkPipelineRenderingCreateInfoKHR* a,
    const VkPipelineRenderingCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->viewMask) == (b->viewMask))) { onFail("a->viewMask (Error: Value not equal)"); };
    if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->colorAttachmentCount (Error: Value not equal)"); };
    if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->pColorAttachmentFormats (Error: Lengths not equal)"); };
    if (!((memcmp(a->pColorAttachmentFormats, b->pColorAttachmentFormats, a->colorAttachmentCount * sizeof(const VkFormat)) == 0))) { onFail("a->pColorAttachmentFormats (Error: Unequal dyn array)"); };
    if (!((a->depthAttachmentFormat) == (b->depthAttachmentFormat))) { onFail("a->depthAttachmentFormat (Error: Value not equal)"); };
    if (!((a->stencilAttachmentFormat) == (b->stencilAttachmentFormat))) { onFail("a->stencilAttachmentFormat (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceDynamicRenderingFeaturesKHR(
    const VkPhysicalDeviceDynamicRenderingFeaturesKHR* a,
    const VkPhysicalDeviceDynamicRenderingFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->dynamicRendering) == (b->dynamicRendering))) { onFail("a->dynamicRendering (Error: Value not equal)"); };
}

void checkEqual_VkCommandBufferInheritanceRenderingInfoKHR(
    const VkCommandBufferInheritanceRenderingInfoKHR* a,
    const VkCommandBufferInheritanceRenderingInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->viewMask) == (b->viewMask))) { onFail("a->viewMask (Error: Value not equal)"); };
    if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->colorAttachmentCount (Error: Value not equal)"); };
    if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->pColorAttachmentFormats (Error: Lengths not equal)"); };
    if (!((memcmp(a->pColorAttachmentFormats, b->pColorAttachmentFormats, a->colorAttachmentCount * sizeof(const VkFormat)) == 0))) { onFail("a->pColorAttachmentFormats (Error: Unequal dyn array)"); };
    if (!((a->depthAttachmentFormat) == (b->depthAttachmentFormat))) { onFail("a->depthAttachmentFormat (Error: Value not equal)"); };
    if (!((a->stencilAttachmentFormat) == (b->stencilAttachmentFormat))) { onFail("a->stencilAttachmentFormat (Error: Value not equal)"); };
    if (!((a->rasterizationSamples) == (b->rasterizationSamples))) { onFail("a->rasterizationSamples (Error: Value not equal)"); };
}

void checkEqual_VkRenderingFragmentShadingRateAttachmentInfoKHR(
    const VkRenderingFragmentShadingRateAttachmentInfoKHR* a,
    const VkRenderingFragmentShadingRateAttachmentInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->imageView) == (b->imageView))) { onFail("a->imageView (Error: Value not equal)"); };
    if (!((a->imageLayout) == (b->imageLayout))) { onFail("a->imageLayout (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->shadingRateAttachmentTexelSize, &b->shadingRateAttachmentTexelSize, onFail);
}

void checkEqual_VkRenderingFragmentDensityMapAttachmentInfoEXT(
    const VkRenderingFragmentDensityMapAttachmentInfoEXT* a,
    const VkRenderingFragmentDensityMapAttachmentInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->imageView) == (b->imageView))) { onFail("a->imageView (Error: Value not equal)"); };
    if (!((a->imageLayout) == (b->imageLayout))) { onFail("a->imageLayout (Error: Value not equal)"); };
}

void checkEqual_VkAttachmentSampleCountInfoAMD(
    const VkAttachmentSampleCountInfoAMD* a,
    const VkAttachmentSampleCountInfoAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->colorAttachmentCount (Error: Value not equal)"); };
    if (!((!(a->pColorAttachmentSamples) && !(b->pColorAttachmentSamples)) || ((a->pColorAttachmentSamples) && (b->pColorAttachmentSamples)))) { onFail("a->pColorAttachmentSamples (Error: Mismatch in optional field)"); };
    if (a->pColorAttachmentSamples && b->pColorAttachmentSamples)
    {
        if (!((a->colorAttachmentCount) == (b->colorAttachmentCount))) { onFail("a->pColorAttachmentSamples (Error: Lengths not equal)"); };
        if (!((memcmp(a->pColorAttachmentSamples, b->pColorAttachmentSamples, a->colorAttachmentCount * sizeof(const VkSampleCountFlagBits)) == 0))) { onFail("a->pColorAttachmentSamples (Error: Unequal dyn array)"); };
    }
    if (!((a->depthStencilAttachmentSamples) == (b->depthStencilAttachmentSamples))) { onFail("a->depthStencilAttachmentSamples (Error: Value not equal)"); };
}

void checkEqual_VkMultiviewPerViewAttributesInfoNVX(
    const VkMultiviewPerViewAttributesInfoNVX* a,
    const VkMultiviewPerViewAttributesInfoNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->perViewAttributes) == (b->perViewAttributes))) { onFail("a->perViewAttributes (Error: Value not equal)"); };
    if (!((a->perViewAttributesPositionXOnly) == (b->perViewAttributesPositionXOnly))) { onFail("a->perViewAttributesPositionXOnly (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_device_group
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_device_group_creation
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void checkEqual_VkImportMemoryWin32HandleInfoKHR(
    const VkImportMemoryWin32HandleInfoKHR* a,
    const VkImportMemoryWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->handle) == (b->handle))) { onFail("a->handle (Error: Value not equal)"); };
    if (!((a->name) == (b->name))) { onFail("a->name (Error: Value not equal)"); };
}

void checkEqual_VkExportMemoryWin32HandleInfoKHR(
    const VkExportMemoryWin32HandleInfoKHR* a,
    const VkExportMemoryWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pAttributes) && !(b->pAttributes)) || ((a->pAttributes) && (b->pAttributes)))) { onFail("a->pAttributes (Error: Mismatch in optional field)"); };
    if (a->pAttributes && b->pAttributes)
    {
        if (!((memcmp(a->pAttributes, b->pAttributes, sizeof(const SECURITY_ATTRIBUTES)) == 0))) { onFail("a->pAttributes (Error: Unequal dyn array)"); };
    }
    if (!((a->dwAccess) == (b->dwAccess))) { onFail("a->dwAccess (Error: Value not equal)"); };
    if (!((a->name) == (b->name))) { onFail("a->name (Error: Value not equal)"); };
}

void checkEqual_VkMemoryWin32HandlePropertiesKHR(
    const VkMemoryWin32HandlePropertiesKHR* a,
    const VkMemoryWin32HandlePropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memoryTypeBits) == (b->memoryTypeBits))) { onFail("a->memoryTypeBits (Error: Value not equal)"); };
}

void checkEqual_VkMemoryGetWin32HandleInfoKHR(
    const VkMemoryGetWin32HandleInfoKHR* a,
    const VkMemoryGetWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_external_memory_fd
void checkEqual_VkImportMemoryFdInfoKHR(
    const VkImportMemoryFdInfoKHR* a,
    const VkImportMemoryFdInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->fd) == (b->fd))) { onFail("a->fd (Error: Value not equal)"); };
}

void checkEqual_VkMemoryFdPropertiesKHR(
    const VkMemoryFdPropertiesKHR* a,
    const VkMemoryFdPropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memoryTypeBits) == (b->memoryTypeBits))) { onFail("a->memoryTypeBits (Error: Value not equal)"); };
}

void checkEqual_VkMemoryGetFdInfoKHR(
    const VkMemoryGetFdInfoKHR* a,
    const VkMemoryGetFdInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void checkEqual_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    const VkWin32KeyedMutexAcquireReleaseInfoKHR* a,
    const VkWin32KeyedMutexAcquireReleaseInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->acquireCount (Error: Value not equal)"); };
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->pAcquireSyncs (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAcquireSyncs, b->pAcquireSyncs, a->acquireCount * sizeof(const VkDeviceMemory)) == 0))) { onFail("a->pAcquireSyncs (Error: Unequal dyn array)"); };
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->pAcquireKeys (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAcquireKeys, b->pAcquireKeys, a->acquireCount * sizeof(const uint64_t)) == 0))) { onFail("a->pAcquireKeys (Error: Unequal dyn array)"); };
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->pAcquireTimeouts (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAcquireTimeouts, b->pAcquireTimeouts, a->acquireCount * sizeof(const uint32_t)) == 0))) { onFail("a->pAcquireTimeouts (Error: Unequal dyn array)"); };
    if (!((a->releaseCount) == (b->releaseCount))) { onFail("a->releaseCount (Error: Value not equal)"); };
    if (!((a->releaseCount) == (b->releaseCount))) { onFail("a->pReleaseSyncs (Error: Lengths not equal)"); };
    if (!((memcmp(a->pReleaseSyncs, b->pReleaseSyncs, a->releaseCount * sizeof(const VkDeviceMemory)) == 0))) { onFail("a->pReleaseSyncs (Error: Unequal dyn array)"); };
    if (!((a->releaseCount) == (b->releaseCount))) { onFail("a->pReleaseKeys (Error: Lengths not equal)"); };
    if (!((memcmp(a->pReleaseKeys, b->pReleaseKeys, a->releaseCount * sizeof(const uint64_t)) == 0))) { onFail("a->pReleaseKeys (Error: Unequal dyn array)"); };
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void checkEqual_VkImportSemaphoreWin32HandleInfoKHR(
    const VkImportSemaphoreWin32HandleInfoKHR* a,
    const VkImportSemaphoreWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->semaphore) == (b->semaphore))) { onFail("a->semaphore (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->handle) == (b->handle))) { onFail("a->handle (Error: Value not equal)"); };
    if (!((a->name) == (b->name))) { onFail("a->name (Error: Value not equal)"); };
}

void checkEqual_VkExportSemaphoreWin32HandleInfoKHR(
    const VkExportSemaphoreWin32HandleInfoKHR* a,
    const VkExportSemaphoreWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pAttributes) && !(b->pAttributes)) || ((a->pAttributes) && (b->pAttributes)))) { onFail("a->pAttributes (Error: Mismatch in optional field)"); };
    if (a->pAttributes && b->pAttributes)
    {
        if (!((memcmp(a->pAttributes, b->pAttributes, sizeof(const SECURITY_ATTRIBUTES)) == 0))) { onFail("a->pAttributes (Error: Unequal dyn array)"); };
    }
    if (!((a->dwAccess) == (b->dwAccess))) { onFail("a->dwAccess (Error: Value not equal)"); };
    if (!((a->name) == (b->name))) { onFail("a->name (Error: Value not equal)"); };
}

void checkEqual_VkD3D12FenceSubmitInfoKHR(
    const VkD3D12FenceSubmitInfoKHR* a,
    const VkD3D12FenceSubmitInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->waitSemaphoreValuesCount) == (b->waitSemaphoreValuesCount))) { onFail("a->waitSemaphoreValuesCount (Error: Value not equal)"); };
    if (!((!(a->pWaitSemaphoreValues) && !(b->pWaitSemaphoreValues)) || ((a->pWaitSemaphoreValues) && (b->pWaitSemaphoreValues)))) { onFail("a->pWaitSemaphoreValues (Error: Mismatch in optional field)"); };
    if (a->pWaitSemaphoreValues && b->pWaitSemaphoreValues)
    {
        if (!((a->waitSemaphoreValuesCount) == (b->waitSemaphoreValuesCount))) { onFail("a->pWaitSemaphoreValues (Error: Lengths not equal)"); };
        if (!((memcmp(a->pWaitSemaphoreValues, b->pWaitSemaphoreValues, a->waitSemaphoreValuesCount * sizeof(const uint64_t)) == 0))) { onFail("a->pWaitSemaphoreValues (Error: Unequal dyn array)"); };
    }
    if (!((a->signalSemaphoreValuesCount) == (b->signalSemaphoreValuesCount))) { onFail("a->signalSemaphoreValuesCount (Error: Value not equal)"); };
    if (!((!(a->pSignalSemaphoreValues) && !(b->pSignalSemaphoreValues)) || ((a->pSignalSemaphoreValues) && (b->pSignalSemaphoreValues)))) { onFail("a->pSignalSemaphoreValues (Error: Mismatch in optional field)"); };
    if (a->pSignalSemaphoreValues && b->pSignalSemaphoreValues)
    {
        if (!((a->signalSemaphoreValuesCount) == (b->signalSemaphoreValuesCount))) { onFail("a->pSignalSemaphoreValues (Error: Lengths not equal)"); };
        if (!((memcmp(a->pSignalSemaphoreValues, b->pSignalSemaphoreValues, a->signalSemaphoreValuesCount * sizeof(const uint64_t)) == 0))) { onFail("a->pSignalSemaphoreValues (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkSemaphoreGetWin32HandleInfoKHR(
    const VkSemaphoreGetWin32HandleInfoKHR* a,
    const VkSemaphoreGetWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->semaphore) == (b->semaphore))) { onFail("a->semaphore (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void checkEqual_VkImportSemaphoreFdInfoKHR(
    const VkImportSemaphoreFdInfoKHR* a,
    const VkImportSemaphoreFdInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->semaphore) == (b->semaphore))) { onFail("a->semaphore (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->fd) == (b->fd))) { onFail("a->fd (Error: Value not equal)"); };
}

void checkEqual_VkSemaphoreGetFdInfoKHR(
    const VkSemaphoreGetFdInfoKHR* a,
    const VkSemaphoreGetFdInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->semaphore) == (b->semaphore))) { onFail("a->semaphore (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_push_descriptor
void checkEqual_VkPhysicalDevicePushDescriptorPropertiesKHR(
    const VkPhysicalDevicePushDescriptorPropertiesKHR* a,
    const VkPhysicalDevicePushDescriptorPropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxPushDescriptors) == (b->maxPushDescriptors))) { onFail("a->maxPushDescriptors (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void checkEqual_VkRectLayerKHR(
    const VkRectLayerKHR* a,
    const VkRectLayerKHR* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkOffset2D(&a->offset, &b->offset, onFail);
    checkEqual_VkExtent2D(&a->extent, &b->extent, onFail);
    if (!((a->layer) == (b->layer))) { onFail("a->layer (Error: Value not equal)"); };
}

void checkEqual_VkPresentRegionKHR(
    const VkPresentRegionKHR* a,
    const VkPresentRegionKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->rectangleCount) == (b->rectangleCount))) { onFail("a->rectangleCount (Error: Value not equal)"); };
    if (!((!(a->pRectangles) && !(b->pRectangles)) || ((a->pRectangles) && (b->pRectangles)))) { onFail("a->pRectangles (Error: Mismatch in optional field)"); };
    if (a->pRectangles && b->pRectangles)
    {
        if ((a->pRectangles) && (b->pRectangles))
        {
            if (!((a->rectangleCount) == (b->rectangleCount))) { onFail("a->pRectangles (Error: Lengths not equal)"); };
            if ((a->rectangleCount) == (b->rectangleCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->rectangleCount; ++i)
                    {
                        checkEqual_VkRectLayerKHR(a->pRectangles + i, b->pRectangles + i, onFail);
                    }
                }
            }
        }
    }
}

void checkEqual_VkPresentRegionsKHR(
    const VkPresentRegionsKHR* a,
    const VkPresentRegionsKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->swapchainCount (Error: Value not equal)"); };
    if (!((!(a->pRegions) && !(b->pRegions)) || ((a->pRegions) && (b->pRegions)))) { onFail("a->pRegions (Error: Mismatch in optional field)"); };
    if (a->pRegions && b->pRegions)
    {
        if ((a->pRegions) && (b->pRegions))
        {
            if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->pRegions (Error: Lengths not equal)"); };
            if ((a->swapchainCount) == (b->swapchainCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->swapchainCount; ++i)
                    {
                        checkEqual_VkPresentRegionKHR(a->pRegions + i, b->pRegions + i, onFail);
                    }
                }
            }
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_imageless_framebuffer
#endif
#ifdef VK_KHR_create_renderpass2
#endif
#ifdef VK_KHR_shared_presentable_image
void checkEqual_VkSharedPresentSurfaceCapabilitiesKHR(
    const VkSharedPresentSurfaceCapabilitiesKHR* a,
    const VkSharedPresentSurfaceCapabilitiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->sharedPresentSupportedUsageFlags) == (b->sharedPresentSupportedUsageFlags))) { onFail("a->sharedPresentSupportedUsageFlags (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void checkEqual_VkImportFenceWin32HandleInfoKHR(
    const VkImportFenceWin32HandleInfoKHR* a,
    const VkImportFenceWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fence) == (b->fence))) { onFail("a->fence (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->handle) == (b->handle))) { onFail("a->handle (Error: Value not equal)"); };
    if (!((a->name) == (b->name))) { onFail("a->name (Error: Value not equal)"); };
}

void checkEqual_VkExportFenceWin32HandleInfoKHR(
    const VkExportFenceWin32HandleInfoKHR* a,
    const VkExportFenceWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pAttributes) && !(b->pAttributes)) || ((a->pAttributes) && (b->pAttributes)))) { onFail("a->pAttributes (Error: Mismatch in optional field)"); };
    if (a->pAttributes && b->pAttributes)
    {
        if (!((memcmp(a->pAttributes, b->pAttributes, sizeof(const SECURITY_ATTRIBUTES)) == 0))) { onFail("a->pAttributes (Error: Unequal dyn array)"); };
    }
    if (!((a->dwAccess) == (b->dwAccess))) { onFail("a->dwAccess (Error: Value not equal)"); };
    if (!((a->name) == (b->name))) { onFail("a->name (Error: Value not equal)"); };
}

void checkEqual_VkFenceGetWin32HandleInfoKHR(
    const VkFenceGetWin32HandleInfoKHR* a,
    const VkFenceGetWin32HandleInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fence) == (b->fence))) { onFail("a->fence (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_external_fence_fd
void checkEqual_VkImportFenceFdInfoKHR(
    const VkImportFenceFdInfoKHR* a,
    const VkImportFenceFdInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fence) == (b->fence))) { onFail("a->fence (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->fd) == (b->fd))) { onFail("a->fd (Error: Value not equal)"); };
}

void checkEqual_VkFenceGetFdInfoKHR(
    const VkFenceGetFdInfoKHR* a,
    const VkFenceGetFdInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fence) == (b->fence))) { onFail("a->fence (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_performance_query
void checkEqual_VkPhysicalDevicePerformanceQueryFeaturesKHR(
    const VkPhysicalDevicePerformanceQueryFeaturesKHR* a,
    const VkPhysicalDevicePerformanceQueryFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->performanceCounterQueryPools) == (b->performanceCounterQueryPools))) { onFail("a->performanceCounterQueryPools (Error: Value not equal)"); };
    if (!((a->performanceCounterMultipleQueryPools) == (b->performanceCounterMultipleQueryPools))) { onFail("a->performanceCounterMultipleQueryPools (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDevicePerformanceQueryPropertiesKHR(
    const VkPhysicalDevicePerformanceQueryPropertiesKHR* a,
    const VkPhysicalDevicePerformanceQueryPropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->allowCommandBufferQueryCopies) == (b->allowCommandBufferQueryCopies))) { onFail("a->allowCommandBufferQueryCopies (Error: Value not equal)"); };
}

void checkEqual_VkPerformanceCounterKHR(
    const VkPerformanceCounterKHR* a,
    const VkPerformanceCounterKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->unit) == (b->unit))) { onFail("a->unit (Error: Value not equal)"); };
    if (!((a->scope) == (b->scope))) { onFail("a->scope (Error: Value not equal)"); };
    if (!((a->storage) == (b->storage))) { onFail("a->storage (Error: Value not equal)"); };
    if (!((memcmp(a->uuid, b->uuid, VK_UUID_SIZE * sizeof(uint8_t)) == 0))) { onFail("a->uuid (Error: Unequal static array)"); };
}

void checkEqual_VkPerformanceCounterDescriptionKHR(
    const VkPerformanceCounterDescriptionKHR* a,
    const VkPerformanceCounterDescriptionKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((memcmp(a->name, b->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char)) == 0))) { onFail("a->name (Error: Unequal static array)"); };
    if (!((memcmp(a->category, b->category, VK_MAX_DESCRIPTION_SIZE * sizeof(char)) == 0))) { onFail("a->category (Error: Unequal static array)"); };
    if (!((memcmp(a->description, b->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char)) == 0))) { onFail("a->description (Error: Unequal static array)"); };
}

void checkEqual_VkQueryPoolPerformanceCreateInfoKHR(
    const VkQueryPoolPerformanceCreateInfoKHR* a,
    const VkQueryPoolPerformanceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->queueFamilyIndex) == (b->queueFamilyIndex))) { onFail("a->queueFamilyIndex (Error: Value not equal)"); };
    if (!((a->counterIndexCount) == (b->counterIndexCount))) { onFail("a->counterIndexCount (Error: Value not equal)"); };
    if (!((a->counterIndexCount) == (b->counterIndexCount))) { onFail("a->pCounterIndices (Error: Lengths not equal)"); };
    if (!((memcmp(a->pCounterIndices, b->pCounterIndices, a->counterIndexCount * sizeof(const uint32_t)) == 0))) { onFail("a->pCounterIndices (Error: Unequal dyn array)"); };
}

void checkEqual_VkPerformanceCounterResultKHR(
    const VkPerformanceCounterResultKHR* a,
    const VkPerformanceCounterResultKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->int32) == (b->int32))) { onFail("a->int32 (Error: Value not equal)"); };
    if (!((a->int64) == (b->int64))) { onFail("a->int64 (Error: Value not equal)"); };
    if (!((a->uint32) == (b->uint32))) { onFail("a->uint32 (Error: Value not equal)"); };
    if (!((a->uint64) == (b->uint64))) { onFail("a->uint64 (Error: Value not equal)"); };
    if (!((a->float32) == (b->float32))) { onFail("a->float32 (Error: Value not equal)"); };
    if (!((a->float64) == (b->float64))) { onFail("a->float64 (Error: Value not equal)"); };
}

void checkEqual_VkAcquireProfilingLockInfoKHR(
    const VkAcquireProfilingLockInfoKHR* a,
    const VkAcquireProfilingLockInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->timeout) == (b->timeout))) { onFail("a->timeout (Error: Value not equal)"); };
}

void checkEqual_VkPerformanceQuerySubmitInfoKHR(
    const VkPerformanceQuerySubmitInfoKHR* a,
    const VkPerformanceQuerySubmitInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->counterPassIndex) == (b->counterPassIndex))) { onFail("a->counterPassIndex (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void checkEqual_VkPhysicalDeviceSurfaceInfo2KHR(
    const VkPhysicalDeviceSurfaceInfo2KHR* a,
    const VkPhysicalDeviceSurfaceInfo2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->surface) == (b->surface))) { onFail("a->surface (Error: Value not equal)"); };
}

void checkEqual_VkSurfaceCapabilities2KHR(
    const VkSurfaceCapabilities2KHR* a,
    const VkSurfaceCapabilities2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkSurfaceCapabilitiesKHR(&a->surfaceCapabilities, &b->surfaceCapabilities, onFail);
}

void checkEqual_VkSurfaceFormat2KHR(
    const VkSurfaceFormat2KHR* a,
    const VkSurfaceFormat2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkSurfaceFormatKHR(&a->surfaceFormat, &b->surfaceFormat, onFail);
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void checkEqual_VkDisplayProperties2KHR(
    const VkDisplayProperties2KHR* a,
    const VkDisplayProperties2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkDisplayPropertiesKHR(&a->displayProperties, &b->displayProperties, onFail);
}

void checkEqual_VkDisplayPlaneProperties2KHR(
    const VkDisplayPlaneProperties2KHR* a,
    const VkDisplayPlaneProperties2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkDisplayPlanePropertiesKHR(&a->displayPlaneProperties, &b->displayPlaneProperties, onFail);
}

void checkEqual_VkDisplayModeProperties2KHR(
    const VkDisplayModeProperties2KHR* a,
    const VkDisplayModeProperties2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkDisplayModePropertiesKHR(&a->displayModeProperties, &b->displayModeProperties, onFail);
}

void checkEqual_VkDisplayPlaneInfo2KHR(
    const VkDisplayPlaneInfo2KHR* a,
    const VkDisplayPlaneInfo2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->mode) == (b->mode))) { onFail("a->mode (Error: Value not equal)"); };
    if (!((a->planeIndex) == (b->planeIndex))) { onFail("a->planeIndex (Error: Value not equal)"); };
}

void checkEqual_VkDisplayPlaneCapabilities2KHR(
    const VkDisplayPlaneCapabilities2KHR* a,
    const VkDisplayPlaneCapabilities2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkDisplayPlaneCapabilitiesKHR(&a->capabilities, &b->capabilities, onFail);
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_portability_subset
void checkEqual_VkPhysicalDevicePortabilitySubsetFeaturesKHR(
    const VkPhysicalDevicePortabilitySubsetFeaturesKHR* a,
    const VkPhysicalDevicePortabilitySubsetFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->constantAlphaColorBlendFactors) == (b->constantAlphaColorBlendFactors))) { onFail("a->constantAlphaColorBlendFactors (Error: Value not equal)"); };
    if (!((a->events) == (b->events))) { onFail("a->events (Error: Value not equal)"); };
    if (!((a->imageViewFormatReinterpretation) == (b->imageViewFormatReinterpretation))) { onFail("a->imageViewFormatReinterpretation (Error: Value not equal)"); };
    if (!((a->imageViewFormatSwizzle) == (b->imageViewFormatSwizzle))) { onFail("a->imageViewFormatSwizzle (Error: Value not equal)"); };
    if (!((a->imageView2DOn3DImage) == (b->imageView2DOn3DImage))) { onFail("a->imageView2DOn3DImage (Error: Value not equal)"); };
    if (!((a->multisampleArrayImage) == (b->multisampleArrayImage))) { onFail("a->multisampleArrayImage (Error: Value not equal)"); };
    if (!((a->mutableComparisonSamplers) == (b->mutableComparisonSamplers))) { onFail("a->mutableComparisonSamplers (Error: Value not equal)"); };
    if (!((a->pointPolygons) == (b->pointPolygons))) { onFail("a->pointPolygons (Error: Value not equal)"); };
    if (!((a->samplerMipLodBias) == (b->samplerMipLodBias))) { onFail("a->samplerMipLodBias (Error: Value not equal)"); };
    if (!((a->separateStencilMaskRef) == (b->separateStencilMaskRef))) { onFail("a->separateStencilMaskRef (Error: Value not equal)"); };
    if (!((a->shaderSampleRateInterpolationFunctions) == (b->shaderSampleRateInterpolationFunctions))) { onFail("a->shaderSampleRateInterpolationFunctions (Error: Value not equal)"); };
    if (!((a->tessellationIsolines) == (b->tessellationIsolines))) { onFail("a->tessellationIsolines (Error: Value not equal)"); };
    if (!((a->tessellationPointMode) == (b->tessellationPointMode))) { onFail("a->tessellationPointMode (Error: Value not equal)"); };
    if (!((a->triangleFans) == (b->triangleFans))) { onFail("a->triangleFans (Error: Value not equal)"); };
    if (!((a->vertexAttributeAccessBeyondStride) == (b->vertexAttributeAccessBeyondStride))) { onFail("a->vertexAttributeAccessBeyondStride (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDevicePortabilitySubsetPropertiesKHR(
    const VkPhysicalDevicePortabilitySubsetPropertiesKHR* a,
    const VkPhysicalDevicePortabilitySubsetPropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->minVertexInputBindingStrideAlignment) == (b->minVertexInputBindingStrideAlignment))) { onFail("a->minVertexInputBindingStrideAlignment (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_draw_indirect_count
#endif
#ifdef VK_KHR_shader_subgroup_extended_types
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_KHR_shader_atomic_int64
#endif
#ifdef VK_KHR_shader_clock
void checkEqual_VkPhysicalDeviceShaderClockFeaturesKHR(
    const VkPhysicalDeviceShaderClockFeaturesKHR* a,
    const VkPhysicalDeviceShaderClockFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderSubgroupClock) == (b->shaderSubgroupClock))) { onFail("a->shaderSubgroupClock (Error: Value not equal)"); };
    if (!((a->shaderDeviceClock) == (b->shaderDeviceClock))) { onFail("a->shaderDeviceClock (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_driver_properties
#endif
#ifdef VK_KHR_shader_float_controls
#endif
#ifdef VK_KHR_depth_stencil_resolve
#endif
#ifdef VK_KHR_swapchain_mutable_format
#endif
#ifdef VK_KHR_timeline_semaphore
#endif
#ifdef VK_KHR_vulkan_memory_model
#endif
#ifdef VK_KHR_shader_terminate_invocation
void checkEqual_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(
    const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR* a,
    const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderTerminateInvocation) == (b->shaderTerminateInvocation))) { onFail("a->shaderTerminateInvocation (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_fragment_shading_rate
void checkEqual_VkFragmentShadingRateAttachmentInfoKHR(
    const VkFragmentShadingRateAttachmentInfoKHR* a,
    const VkFragmentShadingRateAttachmentInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pFragmentShadingRateAttachment) && !(b->pFragmentShadingRateAttachment)) || ((a->pFragmentShadingRateAttachment) && (b->pFragmentShadingRateAttachment)))) { onFail("a->pFragmentShadingRateAttachment (Error: Mismatch in optional field)"); };
    if (a->pFragmentShadingRateAttachment && b->pFragmentShadingRateAttachment)
    {
        if ((a->pFragmentShadingRateAttachment) && (b->pFragmentShadingRateAttachment))
        {
            checkEqual_VkAttachmentReference2(a->pFragmentShadingRateAttachment, b->pFragmentShadingRateAttachment, onFail);
        }
    }
    checkEqual_VkExtent2D(&a->shadingRateAttachmentTexelSize, &b->shadingRateAttachmentTexelSize, onFail);
}

void checkEqual_VkPipelineFragmentShadingRateStateCreateInfoKHR(
    const VkPipelineFragmentShadingRateStateCreateInfoKHR* a,
    const VkPipelineFragmentShadingRateStateCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkExtent2D(&a->fragmentSize, &b->fragmentSize, onFail);
    if (!((memcmp(a->combinerOps, b->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR)) == 0))) { onFail("a->combinerOps (Error: Unequal static array)"); };
}

void checkEqual_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(
    const VkPhysicalDeviceFragmentShadingRateFeaturesKHR* a,
    const VkPhysicalDeviceFragmentShadingRateFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->pipelineFragmentShadingRate) == (b->pipelineFragmentShadingRate))) { onFail("a->pipelineFragmentShadingRate (Error: Value not equal)"); };
    if (!((a->primitiveFragmentShadingRate) == (b->primitiveFragmentShadingRate))) { onFail("a->primitiveFragmentShadingRate (Error: Value not equal)"); };
    if (!((a->attachmentFragmentShadingRate) == (b->attachmentFragmentShadingRate))) { onFail("a->attachmentFragmentShadingRate (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(
    const VkPhysicalDeviceFragmentShadingRatePropertiesKHR* a,
    const VkPhysicalDeviceFragmentShadingRatePropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkExtent2D(&a->minFragmentShadingRateAttachmentTexelSize, &b->minFragmentShadingRateAttachmentTexelSize, onFail);
    checkEqual_VkExtent2D(&a->maxFragmentShadingRateAttachmentTexelSize, &b->maxFragmentShadingRateAttachmentTexelSize, onFail);
    if (!((a->maxFragmentShadingRateAttachmentTexelSizeAspectRatio) == (b->maxFragmentShadingRateAttachmentTexelSizeAspectRatio))) { onFail("a->maxFragmentShadingRateAttachmentTexelSizeAspectRatio (Error: Value not equal)"); };
    if (!((a->primitiveFragmentShadingRateWithMultipleViewports) == (b->primitiveFragmentShadingRateWithMultipleViewports))) { onFail("a->primitiveFragmentShadingRateWithMultipleViewports (Error: Value not equal)"); };
    if (!((a->layeredShadingRateAttachments) == (b->layeredShadingRateAttachments))) { onFail("a->layeredShadingRateAttachments (Error: Value not equal)"); };
    if (!((a->fragmentShadingRateNonTrivialCombinerOps) == (b->fragmentShadingRateNonTrivialCombinerOps))) { onFail("a->fragmentShadingRateNonTrivialCombinerOps (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->maxFragmentSize, &b->maxFragmentSize, onFail);
    if (!((a->maxFragmentSizeAspectRatio) == (b->maxFragmentSizeAspectRatio))) { onFail("a->maxFragmentSizeAspectRatio (Error: Value not equal)"); };
    if (!((a->maxFragmentShadingRateCoverageSamples) == (b->maxFragmentShadingRateCoverageSamples))) { onFail("a->maxFragmentShadingRateCoverageSamples (Error: Value not equal)"); };
    if (!((a->maxFragmentShadingRateRasterizationSamples) == (b->maxFragmentShadingRateRasterizationSamples))) { onFail("a->maxFragmentShadingRateRasterizationSamples (Error: Value not equal)"); };
    if (!((a->fragmentShadingRateWithShaderDepthStencilWrites) == (b->fragmentShadingRateWithShaderDepthStencilWrites))) { onFail("a->fragmentShadingRateWithShaderDepthStencilWrites (Error: Value not equal)"); };
    if (!((a->fragmentShadingRateWithSampleMask) == (b->fragmentShadingRateWithSampleMask))) { onFail("a->fragmentShadingRateWithSampleMask (Error: Value not equal)"); };
    if (!((a->fragmentShadingRateWithShaderSampleMask) == (b->fragmentShadingRateWithShaderSampleMask))) { onFail("a->fragmentShadingRateWithShaderSampleMask (Error: Value not equal)"); };
    if (!((a->fragmentShadingRateWithConservativeRasterization) == (b->fragmentShadingRateWithConservativeRasterization))) { onFail("a->fragmentShadingRateWithConservativeRasterization (Error: Value not equal)"); };
    if (!((a->fragmentShadingRateWithFragmentShaderInterlock) == (b->fragmentShadingRateWithFragmentShaderInterlock))) { onFail("a->fragmentShadingRateWithFragmentShaderInterlock (Error: Value not equal)"); };
    if (!((a->fragmentShadingRateWithCustomSampleLocations) == (b->fragmentShadingRateWithCustomSampleLocations))) { onFail("a->fragmentShadingRateWithCustomSampleLocations (Error: Value not equal)"); };
    if (!((a->fragmentShadingRateStrictMultiplyCombiner) == (b->fragmentShadingRateStrictMultiplyCombiner))) { onFail("a->fragmentShadingRateStrictMultiplyCombiner (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceFragmentShadingRateKHR(
    const VkPhysicalDeviceFragmentShadingRateKHR* a,
    const VkPhysicalDeviceFragmentShadingRateKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->sampleCounts) == (b->sampleCounts))) { onFail("a->sampleCounts (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->fragmentSize, &b->fragmentSize, onFail);
}

#endif
#ifdef VK_KHR_spirv_1_4
#endif
#ifdef VK_KHR_surface_protected_capabilities
void checkEqual_VkSurfaceProtectedCapabilitiesKHR(
    const VkSurfaceProtectedCapabilitiesKHR* a,
    const VkSurfaceProtectedCapabilitiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->supportsProtected) == (b->supportsProtected))) { onFail("a->supportsProtected (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_separate_depth_stencil_layouts
#endif
#ifdef VK_KHR_present_wait
void checkEqual_VkPhysicalDevicePresentWaitFeaturesKHR(
    const VkPhysicalDevicePresentWaitFeaturesKHR* a,
    const VkPhysicalDevicePresentWaitFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->presentWait) == (b->presentWait))) { onFail("a->presentWait (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_uniform_buffer_standard_layout
#endif
#ifdef VK_KHR_buffer_device_address
#endif
#ifdef VK_KHR_deferred_host_operations
#endif
#ifdef VK_KHR_pipeline_executable_properties
void checkEqual_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
    const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* a,
    const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->pipelineExecutableInfo) == (b->pipelineExecutableInfo))) { onFail("a->pipelineExecutableInfo (Error: Value not equal)"); };
}

void checkEqual_VkPipelineInfoKHR(
    const VkPipelineInfoKHR* a,
    const VkPipelineInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->pipeline) == (b->pipeline))) { onFail("a->pipeline (Error: Value not equal)"); };
}

void checkEqual_VkPipelineExecutablePropertiesKHR(
    const VkPipelineExecutablePropertiesKHR* a,
    const VkPipelineExecutablePropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->stages) == (b->stages))) { onFail("a->stages (Error: Value not equal)"); };
    if (!((memcmp(a->name, b->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char)) == 0))) { onFail("a->name (Error: Unequal static array)"); };
    if (!((memcmp(a->description, b->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char)) == 0))) { onFail("a->description (Error: Unequal static array)"); };
    if (!((a->subgroupSize) == (b->subgroupSize))) { onFail("a->subgroupSize (Error: Value not equal)"); };
}

void checkEqual_VkPipelineExecutableInfoKHR(
    const VkPipelineExecutableInfoKHR* a,
    const VkPipelineExecutableInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->pipeline) == (b->pipeline))) { onFail("a->pipeline (Error: Value not equal)"); };
    if (!((a->executableIndex) == (b->executableIndex))) { onFail("a->executableIndex (Error: Value not equal)"); };
}

void checkEqual_VkPipelineExecutableStatisticValueKHR(
    const VkPipelineExecutableStatisticValueKHR* a,
    const VkPipelineExecutableStatisticValueKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->b32) == (b->b32))) { onFail("a->b32 (Error: Value not equal)"); };
    if (!((a->i64) == (b->i64))) { onFail("a->i64 (Error: Value not equal)"); };
    if (!((a->u64) == (b->u64))) { onFail("a->u64 (Error: Value not equal)"); };
    if (!((a->f64) == (b->f64))) { onFail("a->f64 (Error: Value not equal)"); };
}

void checkEqual_VkPipelineExecutableStatisticKHR(
    const VkPipelineExecutableStatisticKHR* a,
    const VkPipelineExecutableStatisticKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->name, b->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char)) == 0))) { onFail("a->name (Error: Unequal static array)"); };
    if (!((memcmp(a->description, b->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char)) == 0))) { onFail("a->description (Error: Unequal static array)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    checkEqual_VkPipelineExecutableStatisticValueKHR(&a->value, &b->value, onFail);
}

void checkEqual_VkPipelineExecutableInternalRepresentationKHR(
    const VkPipelineExecutableInternalRepresentationKHR* a,
    const VkPipelineExecutableInternalRepresentationKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->name, b->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char)) == 0))) { onFail("a->name (Error: Unequal static array)"); };
    if (!((memcmp(a->description, b->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char)) == 0))) { onFail("a->description (Error: Unequal static array)"); };
    if (!((a->isText) == (b->isText))) { onFail("a->isText (Error: Value not equal)"); };
    if (!((a->dataSize) == (b->dataSize))) { onFail("a->dataSize (Error: Value not equal)"); };
    if (!((!(a->pData) && !(b->pData)) || ((a->pData) && (b->pData)))) { onFail("a->pData (Error: Mismatch in optional field)"); };
}

#endif
#ifdef VK_KHR_shader_integer_dot_product
void checkEqual_VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR(
    const VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR* a,
    const VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderIntegerDotProduct) == (b->shaderIntegerDotProduct))) { onFail("a->shaderIntegerDotProduct (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR(
    const VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR* a,
    const VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->integerDotProduct8BitUnsignedAccelerated) == (b->integerDotProduct8BitUnsignedAccelerated))) { onFail("a->integerDotProduct8BitUnsignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProduct8BitSignedAccelerated) == (b->integerDotProduct8BitSignedAccelerated))) { onFail("a->integerDotProduct8BitSignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProduct8BitMixedSignednessAccelerated) == (b->integerDotProduct8BitMixedSignednessAccelerated))) { onFail("a->integerDotProduct8BitMixedSignednessAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProduct4x8BitPackedUnsignedAccelerated) == (b->integerDotProduct4x8BitPackedUnsignedAccelerated))) { onFail("a->integerDotProduct4x8BitPackedUnsignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProduct4x8BitPackedSignedAccelerated) == (b->integerDotProduct4x8BitPackedSignedAccelerated))) { onFail("a->integerDotProduct4x8BitPackedSignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProduct4x8BitPackedMixedSignednessAccelerated) == (b->integerDotProduct4x8BitPackedMixedSignednessAccelerated))) { onFail("a->integerDotProduct4x8BitPackedMixedSignednessAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProduct16BitUnsignedAccelerated) == (b->integerDotProduct16BitUnsignedAccelerated))) { onFail("a->integerDotProduct16BitUnsignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProduct16BitSignedAccelerated) == (b->integerDotProduct16BitSignedAccelerated))) { onFail("a->integerDotProduct16BitSignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProduct16BitMixedSignednessAccelerated) == (b->integerDotProduct16BitMixedSignednessAccelerated))) { onFail("a->integerDotProduct16BitMixedSignednessAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProduct32BitUnsignedAccelerated) == (b->integerDotProduct32BitUnsignedAccelerated))) { onFail("a->integerDotProduct32BitUnsignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProduct32BitSignedAccelerated) == (b->integerDotProduct32BitSignedAccelerated))) { onFail("a->integerDotProduct32BitSignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProduct32BitMixedSignednessAccelerated) == (b->integerDotProduct32BitMixedSignednessAccelerated))) { onFail("a->integerDotProduct32BitMixedSignednessAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProduct64BitUnsignedAccelerated) == (b->integerDotProduct64BitUnsignedAccelerated))) { onFail("a->integerDotProduct64BitUnsignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProduct64BitSignedAccelerated) == (b->integerDotProduct64BitSignedAccelerated))) { onFail("a->integerDotProduct64BitSignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProduct64BitMixedSignednessAccelerated) == (b->integerDotProduct64BitMixedSignednessAccelerated))) { onFail("a->integerDotProduct64BitMixedSignednessAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated) == (b->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating8BitSignedAccelerated) == (b->integerDotProductAccumulatingSaturating8BitSignedAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating8BitSignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated) == (b->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated) == (b->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated) == (b->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated) == (b->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated) == (b->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating16BitSignedAccelerated) == (b->integerDotProductAccumulatingSaturating16BitSignedAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating16BitSignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated) == (b->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated) == (b->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating32BitSignedAccelerated) == (b->integerDotProductAccumulatingSaturating32BitSignedAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating32BitSignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated) == (b->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated) == (b->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating64BitSignedAccelerated) == (b->integerDotProductAccumulatingSaturating64BitSignedAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating64BitSignedAccelerated (Error: Value not equal)"); };
    if (!((a->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated) == (b->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated))) { onFail("a->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_pipeline_library
void checkEqual_VkPipelineLibraryCreateInfoKHR(
    const VkPipelineLibraryCreateInfoKHR* a,
    const VkPipelineLibraryCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->libraryCount) == (b->libraryCount))) { onFail("a->libraryCount (Error: Value not equal)"); };
    if (!((a->libraryCount) == (b->libraryCount))) { onFail("a->pLibraries (Error: Lengths not equal)"); };
    if (!((memcmp(a->pLibraries, b->pLibraries, a->libraryCount * sizeof(const VkPipeline)) == 0))) { onFail("a->pLibraries (Error: Unequal dyn array)"); };
}

#endif
#ifdef VK_KHR_shader_non_semantic_info
#endif
#ifdef VK_KHR_present_id
void checkEqual_VkPresentIdKHR(
    const VkPresentIdKHR* a,
    const VkPresentIdKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->swapchainCount (Error: Value not equal)"); };
    if (!((!(a->pPresentIds) && !(b->pPresentIds)) || ((a->pPresentIds) && (b->pPresentIds)))) { onFail("a->pPresentIds (Error: Mismatch in optional field)"); };
    if (a->pPresentIds && b->pPresentIds)
    {
        if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->pPresentIds (Error: Lengths not equal)"); };
        if (!((memcmp(a->pPresentIds, b->pPresentIds, a->swapchainCount * sizeof(const uint64_t)) == 0))) { onFail("a->pPresentIds (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkPhysicalDevicePresentIdFeaturesKHR(
    const VkPhysicalDevicePresentIdFeaturesKHR* a,
    const VkPhysicalDevicePresentIdFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->presentId) == (b->presentId))) { onFail("a->presentId (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_video_encode_queue
void checkEqual_VkVideoEncodeInfoKHR(
    const VkVideoEncodeInfoKHR* a,
    const VkVideoEncodeInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->qualityLevel) == (b->qualityLevel))) { onFail("a->qualityLevel (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->codedExtent, &b->codedExtent, onFail);
    if (!((a->dstBitstreamBuffer) == (b->dstBitstreamBuffer))) { onFail("a->dstBitstreamBuffer (Error: Value not equal)"); };
    if (!((a->dstBitstreamBufferOffset) == (b->dstBitstreamBufferOffset))) { onFail("a->dstBitstreamBufferOffset (Error: Value not equal)"); };
    if (!((a->dstBitstreamBufferMaxRange) == (b->dstBitstreamBufferMaxRange))) { onFail("a->dstBitstreamBufferMaxRange (Error: Value not equal)"); };
    checkEqual_VkVideoPictureResourceKHR(&a->srcPictureResource, &b->srcPictureResource, onFail);
    if ((a->pSetupReferenceSlot) && (b->pSetupReferenceSlot))
    {
        checkEqual_VkVideoReferenceSlotKHR(a->pSetupReferenceSlot, b->pSetupReferenceSlot, onFail);
    }
    if (!((a->referenceSlotCount) == (b->referenceSlotCount))) { onFail("a->referenceSlotCount (Error: Value not equal)"); };
    if ((a->pReferenceSlots) && (b->pReferenceSlots))
    {
        if (!((a->referenceSlotCount) == (b->referenceSlotCount))) { onFail("a->pReferenceSlots (Error: Lengths not equal)"); };
        if ((a->referenceSlotCount) == (b->referenceSlotCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->referenceSlotCount; ++i)
                {
                    checkEqual_VkVideoReferenceSlotKHR(a->pReferenceSlots + i, b->pReferenceSlots + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkVideoEncodeRateControlInfoKHR(
    const VkVideoEncodeRateControlInfoKHR* a,
    const VkVideoEncodeRateControlInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->rateControlMode) == (b->rateControlMode))) { onFail("a->rateControlMode (Error: Value not equal)"); };
    if (!((a->averageBitrate) == (b->averageBitrate))) { onFail("a->averageBitrate (Error: Value not equal)"); };
    if (!((a->peakToAverageBitrateRatio) == (b->peakToAverageBitrateRatio))) { onFail("a->peakToAverageBitrateRatio (Error: Value not equal)"); };
    if (!((a->frameRateNumerator) == (b->frameRateNumerator))) { onFail("a->frameRateNumerator (Error: Value not equal)"); };
    if (!((a->frameRateDenominator) == (b->frameRateDenominator))) { onFail("a->frameRateDenominator (Error: Value not equal)"); };
    if (!((a->virtualBufferSizeInMs) == (b->virtualBufferSizeInMs))) { onFail("a->virtualBufferSizeInMs (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_synchronization2
void checkEqual_VkMemoryBarrier2KHR(
    const VkMemoryBarrier2KHR* a,
    const VkMemoryBarrier2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcStageMask) == (b->srcStageMask))) { onFail("a->srcStageMask (Error: Value not equal)"); };
    if (!((a->srcAccessMask) == (b->srcAccessMask))) { onFail("a->srcAccessMask (Error: Value not equal)"); };
    if (!((a->dstStageMask) == (b->dstStageMask))) { onFail("a->dstStageMask (Error: Value not equal)"); };
    if (!((a->dstAccessMask) == (b->dstAccessMask))) { onFail("a->dstAccessMask (Error: Value not equal)"); };
}

void checkEqual_VkBufferMemoryBarrier2KHR(
    const VkBufferMemoryBarrier2KHR* a,
    const VkBufferMemoryBarrier2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcStageMask) == (b->srcStageMask))) { onFail("a->srcStageMask (Error: Value not equal)"); };
    if (!((a->srcAccessMask) == (b->srcAccessMask))) { onFail("a->srcAccessMask (Error: Value not equal)"); };
    if (!((a->dstStageMask) == (b->dstStageMask))) { onFail("a->dstStageMask (Error: Value not equal)"); };
    if (!((a->dstAccessMask) == (b->dstAccessMask))) { onFail("a->dstAccessMask (Error: Value not equal)"); };
    if (!((a->srcQueueFamilyIndex) == (b->srcQueueFamilyIndex))) { onFail("a->srcQueueFamilyIndex (Error: Value not equal)"); };
    if (!((a->dstQueueFamilyIndex) == (b->dstQueueFamilyIndex))) { onFail("a->dstQueueFamilyIndex (Error: Value not equal)"); };
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
}

void checkEqual_VkImageMemoryBarrier2KHR(
    const VkImageMemoryBarrier2KHR* a,
    const VkImageMemoryBarrier2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcStageMask) == (b->srcStageMask))) { onFail("a->srcStageMask (Error: Value not equal)"); };
    if (!((a->srcAccessMask) == (b->srcAccessMask))) { onFail("a->srcAccessMask (Error: Value not equal)"); };
    if (!((a->dstStageMask) == (b->dstStageMask))) { onFail("a->dstStageMask (Error: Value not equal)"); };
    if (!((a->dstAccessMask) == (b->dstAccessMask))) { onFail("a->dstAccessMask (Error: Value not equal)"); };
    if (!((a->oldLayout) == (b->oldLayout))) { onFail("a->oldLayout (Error: Value not equal)"); };
    if (!((a->newLayout) == (b->newLayout))) { onFail("a->newLayout (Error: Value not equal)"); };
    if (!((a->srcQueueFamilyIndex) == (b->srcQueueFamilyIndex))) { onFail("a->srcQueueFamilyIndex (Error: Value not equal)"); };
    if (!((a->dstQueueFamilyIndex) == (b->dstQueueFamilyIndex))) { onFail("a->dstQueueFamilyIndex (Error: Value not equal)"); };
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    checkEqual_VkImageSubresourceRange(&a->subresourceRange, &b->subresourceRange, onFail);
}

void checkEqual_VkDependencyInfoKHR(
    const VkDependencyInfoKHR* a,
    const VkDependencyInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->dependencyFlags) == (b->dependencyFlags))) { onFail("a->dependencyFlags (Error: Value not equal)"); };
    if (!((a->memoryBarrierCount) == (b->memoryBarrierCount))) { onFail("a->memoryBarrierCount (Error: Value not equal)"); };
    if ((a->pMemoryBarriers) && (b->pMemoryBarriers))
    {
        if (!((a->memoryBarrierCount) == (b->memoryBarrierCount))) { onFail("a->pMemoryBarriers (Error: Lengths not equal)"); };
        if ((a->memoryBarrierCount) == (b->memoryBarrierCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->memoryBarrierCount; ++i)
                {
                    checkEqual_VkMemoryBarrier2KHR(a->pMemoryBarriers + i, b->pMemoryBarriers + i, onFail);
                }
            }
        }
    }
    if (!((a->bufferMemoryBarrierCount) == (b->bufferMemoryBarrierCount))) { onFail("a->bufferMemoryBarrierCount (Error: Value not equal)"); };
    if ((a->pBufferMemoryBarriers) && (b->pBufferMemoryBarriers))
    {
        if (!((a->bufferMemoryBarrierCount) == (b->bufferMemoryBarrierCount))) { onFail("a->pBufferMemoryBarriers (Error: Lengths not equal)"); };
        if ((a->bufferMemoryBarrierCount) == (b->bufferMemoryBarrierCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->bufferMemoryBarrierCount; ++i)
                {
                    checkEqual_VkBufferMemoryBarrier2KHR(a->pBufferMemoryBarriers + i, b->pBufferMemoryBarriers + i, onFail);
                }
            }
        }
    }
    if (!((a->imageMemoryBarrierCount) == (b->imageMemoryBarrierCount))) { onFail("a->imageMemoryBarrierCount (Error: Value not equal)"); };
    if ((a->pImageMemoryBarriers) && (b->pImageMemoryBarriers))
    {
        if (!((a->imageMemoryBarrierCount) == (b->imageMemoryBarrierCount))) { onFail("a->pImageMemoryBarriers (Error: Lengths not equal)"); };
        if ((a->imageMemoryBarrierCount) == (b->imageMemoryBarrierCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->imageMemoryBarrierCount; ++i)
                {
                    checkEqual_VkImageMemoryBarrier2KHR(a->pImageMemoryBarriers + i, b->pImageMemoryBarriers + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkSemaphoreSubmitInfoKHR(
    const VkSemaphoreSubmitInfoKHR* a,
    const VkSemaphoreSubmitInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->semaphore) == (b->semaphore))) { onFail("a->semaphore (Error: Value not equal)"); };
    if (!((a->value) == (b->value))) { onFail("a->value (Error: Value not equal)"); };
    if (!((a->stageMask) == (b->stageMask))) { onFail("a->stageMask (Error: Value not equal)"); };
    if (!((a->deviceIndex) == (b->deviceIndex))) { onFail("a->deviceIndex (Error: Value not equal)"); };
}

void checkEqual_VkCommandBufferSubmitInfoKHR(
    const VkCommandBufferSubmitInfoKHR* a,
    const VkCommandBufferSubmitInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->commandBuffer) == (b->commandBuffer))) { onFail("a->commandBuffer (Error: Value not equal)"); };
    if (!((a->deviceMask) == (b->deviceMask))) { onFail("a->deviceMask (Error: Value not equal)"); };
}

void checkEqual_VkSubmitInfo2KHR(
    const VkSubmitInfo2KHR* a,
    const VkSubmitInfo2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->waitSemaphoreInfoCount) == (b->waitSemaphoreInfoCount))) { onFail("a->waitSemaphoreInfoCount (Error: Value not equal)"); };
    if ((a->pWaitSemaphoreInfos) && (b->pWaitSemaphoreInfos))
    {
        if (!((a->waitSemaphoreInfoCount) == (b->waitSemaphoreInfoCount))) { onFail("a->pWaitSemaphoreInfos (Error: Lengths not equal)"); };
        if ((a->waitSemaphoreInfoCount) == (b->waitSemaphoreInfoCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->waitSemaphoreInfoCount; ++i)
                {
                    checkEqual_VkSemaphoreSubmitInfoKHR(a->pWaitSemaphoreInfos + i, b->pWaitSemaphoreInfos + i, onFail);
                }
            }
        }
    }
    if (!((a->commandBufferInfoCount) == (b->commandBufferInfoCount))) { onFail("a->commandBufferInfoCount (Error: Value not equal)"); };
    if ((a->pCommandBufferInfos) && (b->pCommandBufferInfos))
    {
        if (!((a->commandBufferInfoCount) == (b->commandBufferInfoCount))) { onFail("a->pCommandBufferInfos (Error: Lengths not equal)"); };
        if ((a->commandBufferInfoCount) == (b->commandBufferInfoCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->commandBufferInfoCount; ++i)
                {
                    checkEqual_VkCommandBufferSubmitInfoKHR(a->pCommandBufferInfos + i, b->pCommandBufferInfos + i, onFail);
                }
            }
        }
    }
    if (!((a->signalSemaphoreInfoCount) == (b->signalSemaphoreInfoCount))) { onFail("a->signalSemaphoreInfoCount (Error: Value not equal)"); };
    if ((a->pSignalSemaphoreInfos) && (b->pSignalSemaphoreInfos))
    {
        if (!((a->signalSemaphoreInfoCount) == (b->signalSemaphoreInfoCount))) { onFail("a->pSignalSemaphoreInfos (Error: Lengths not equal)"); };
        if ((a->signalSemaphoreInfoCount) == (b->signalSemaphoreInfoCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->signalSemaphoreInfoCount; ++i)
                {
                    checkEqual_VkSemaphoreSubmitInfoKHR(a->pSignalSemaphoreInfos + i, b->pSignalSemaphoreInfos + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkPhysicalDeviceSynchronization2FeaturesKHR(
    const VkPhysicalDeviceSynchronization2FeaturesKHR* a,
    const VkPhysicalDeviceSynchronization2FeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->synchronization2) == (b->synchronization2))) { onFail("a->synchronization2 (Error: Value not equal)"); };
}

void checkEqual_VkQueueFamilyCheckpointProperties2NV(
    const VkQueueFamilyCheckpointProperties2NV* a,
    const VkQueueFamilyCheckpointProperties2NV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->checkpointExecutionStageMask) == (b->checkpointExecutionStageMask))) { onFail("a->checkpointExecutionStageMask (Error: Value not equal)"); };
}

void checkEqual_VkCheckpointData2NV(
    const VkCheckpointData2NV* a,
    const VkCheckpointData2NV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->stage) == (b->stage))) { onFail("a->stage (Error: Value not equal)"); };
    if (!((!(a->pCheckpointMarker) && !(b->pCheckpointMarker)) || ((a->pCheckpointMarker) && (b->pCheckpointMarker)))) { onFail("a->pCheckpointMarker (Error: Mismatch in optional field)"); };
}

#endif
#ifdef VK_KHR_shader_subgroup_uniform_control_flow
void checkEqual_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(
    const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* a,
    const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderSubgroupUniformControlFlow) == (b->shaderSubgroupUniformControlFlow))) { onFail("a->shaderSubgroupUniformControlFlow (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_zero_initialize_workgroup_memory
void checkEqual_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR(
    const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR* a,
    const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderZeroInitializeWorkgroupMemory) == (b->shaderZeroInitializeWorkgroupMemory))) { onFail("a->shaderZeroInitializeWorkgroupMemory (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_workgroup_memory_explicit_layout
void checkEqual_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(
    const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* a,
    const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->workgroupMemoryExplicitLayout) == (b->workgroupMemoryExplicitLayout))) { onFail("a->workgroupMemoryExplicitLayout (Error: Value not equal)"); };
    if (!((a->workgroupMemoryExplicitLayoutScalarBlockLayout) == (b->workgroupMemoryExplicitLayoutScalarBlockLayout))) { onFail("a->workgroupMemoryExplicitLayoutScalarBlockLayout (Error: Value not equal)"); };
    if (!((a->workgroupMemoryExplicitLayout8BitAccess) == (b->workgroupMemoryExplicitLayout8BitAccess))) { onFail("a->workgroupMemoryExplicitLayout8BitAccess (Error: Value not equal)"); };
    if (!((a->workgroupMemoryExplicitLayout16BitAccess) == (b->workgroupMemoryExplicitLayout16BitAccess))) { onFail("a->workgroupMemoryExplicitLayout16BitAccess (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_copy_commands2
void checkEqual_VkBufferCopy2KHR(
    const VkBufferCopy2KHR* a,
    const VkBufferCopy2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcOffset) == (b->srcOffset))) { onFail("a->srcOffset (Error: Value not equal)"); };
    if (!((a->dstOffset) == (b->dstOffset))) { onFail("a->dstOffset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
}

void checkEqual_VkCopyBufferInfo2KHR(
    const VkCopyBufferInfo2KHR* a,
    const VkCopyBufferInfo2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcBuffer) == (b->srcBuffer))) { onFail("a->srcBuffer (Error: Value not equal)"); };
    if (!((a->dstBuffer) == (b->dstBuffer))) { onFail("a->dstBuffer (Error: Value not equal)"); };
    if (!((a->regionCount) == (b->regionCount))) { onFail("a->regionCount (Error: Value not equal)"); };
    if ((a->pRegions) && (b->pRegions))
    {
        if (!((a->regionCount) == (b->regionCount))) { onFail("a->pRegions (Error: Lengths not equal)"); };
        if ((a->regionCount) == (b->regionCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->regionCount; ++i)
                {
                    checkEqual_VkBufferCopy2KHR(a->pRegions + i, b->pRegions + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkImageCopy2KHR(
    const VkImageCopy2KHR* a,
    const VkImageCopy2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkImageSubresourceLayers(&a->srcSubresource, &b->srcSubresource, onFail);
    checkEqual_VkOffset3D(&a->srcOffset, &b->srcOffset, onFail);
    checkEqual_VkImageSubresourceLayers(&a->dstSubresource, &b->dstSubresource, onFail);
    checkEqual_VkOffset3D(&a->dstOffset, &b->dstOffset, onFail);
    checkEqual_VkExtent3D(&a->extent, &b->extent, onFail);
}

void checkEqual_VkCopyImageInfo2KHR(
    const VkCopyImageInfo2KHR* a,
    const VkCopyImageInfo2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcImage) == (b->srcImage))) { onFail("a->srcImage (Error: Value not equal)"); };
    if (!((a->srcImageLayout) == (b->srcImageLayout))) { onFail("a->srcImageLayout (Error: Value not equal)"); };
    if (!((a->dstImage) == (b->dstImage))) { onFail("a->dstImage (Error: Value not equal)"); };
    if (!((a->dstImageLayout) == (b->dstImageLayout))) { onFail("a->dstImageLayout (Error: Value not equal)"); };
    if (!((a->regionCount) == (b->regionCount))) { onFail("a->regionCount (Error: Value not equal)"); };
    if ((a->pRegions) && (b->pRegions))
    {
        if (!((a->regionCount) == (b->regionCount))) { onFail("a->pRegions (Error: Lengths not equal)"); };
        if ((a->regionCount) == (b->regionCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->regionCount; ++i)
                {
                    checkEqual_VkImageCopy2KHR(a->pRegions + i, b->pRegions + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkBufferImageCopy2KHR(
    const VkBufferImageCopy2KHR* a,
    const VkBufferImageCopy2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->bufferOffset) == (b->bufferOffset))) { onFail("a->bufferOffset (Error: Value not equal)"); };
    if (!((a->bufferRowLength) == (b->bufferRowLength))) { onFail("a->bufferRowLength (Error: Value not equal)"); };
    if (!((a->bufferImageHeight) == (b->bufferImageHeight))) { onFail("a->bufferImageHeight (Error: Value not equal)"); };
    checkEqual_VkImageSubresourceLayers(&a->imageSubresource, &b->imageSubresource, onFail);
    checkEqual_VkOffset3D(&a->imageOffset, &b->imageOffset, onFail);
    checkEqual_VkExtent3D(&a->imageExtent, &b->imageExtent, onFail);
}

void checkEqual_VkCopyBufferToImageInfo2KHR(
    const VkCopyBufferToImageInfo2KHR* a,
    const VkCopyBufferToImageInfo2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcBuffer) == (b->srcBuffer))) { onFail("a->srcBuffer (Error: Value not equal)"); };
    if (!((a->dstImage) == (b->dstImage))) { onFail("a->dstImage (Error: Value not equal)"); };
    if (!((a->dstImageLayout) == (b->dstImageLayout))) { onFail("a->dstImageLayout (Error: Value not equal)"); };
    if (!((a->regionCount) == (b->regionCount))) { onFail("a->regionCount (Error: Value not equal)"); };
    if ((a->pRegions) && (b->pRegions))
    {
        if (!((a->regionCount) == (b->regionCount))) { onFail("a->pRegions (Error: Lengths not equal)"); };
        if ((a->regionCount) == (b->regionCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->regionCount; ++i)
                {
                    checkEqual_VkBufferImageCopy2KHR(a->pRegions + i, b->pRegions + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkCopyImageToBufferInfo2KHR(
    const VkCopyImageToBufferInfo2KHR* a,
    const VkCopyImageToBufferInfo2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcImage) == (b->srcImage))) { onFail("a->srcImage (Error: Value not equal)"); };
    if (!((a->srcImageLayout) == (b->srcImageLayout))) { onFail("a->srcImageLayout (Error: Value not equal)"); };
    if (!((a->dstBuffer) == (b->dstBuffer))) { onFail("a->dstBuffer (Error: Value not equal)"); };
    if (!((a->regionCount) == (b->regionCount))) { onFail("a->regionCount (Error: Value not equal)"); };
    if ((a->pRegions) && (b->pRegions))
    {
        if (!((a->regionCount) == (b->regionCount))) { onFail("a->pRegions (Error: Lengths not equal)"); };
        if ((a->regionCount) == (b->regionCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->regionCount; ++i)
                {
                    checkEqual_VkBufferImageCopy2KHR(a->pRegions + i, b->pRegions + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkImageBlit2KHR(
    const VkImageBlit2KHR* a,
    const VkImageBlit2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkImageSubresourceLayers(&a->srcSubresource, &b->srcSubresource, onFail);
    if (!((2) == (2))) { onFail("a->srcOffsets (Error: Lengths not equal)"); };
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        checkEqual_VkOffset3D(a->srcOffsets + i, b->srcOffsets + i, onFail);
    }
    checkEqual_VkImageSubresourceLayers(&a->dstSubresource, &b->dstSubresource, onFail);
    if (!((2) == (2))) { onFail("a->dstOffsets (Error: Lengths not equal)"); };
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        checkEqual_VkOffset3D(a->dstOffsets + i, b->dstOffsets + i, onFail);
    }
}

void checkEqual_VkBlitImageInfo2KHR(
    const VkBlitImageInfo2KHR* a,
    const VkBlitImageInfo2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcImage) == (b->srcImage))) { onFail("a->srcImage (Error: Value not equal)"); };
    if (!((a->srcImageLayout) == (b->srcImageLayout))) { onFail("a->srcImageLayout (Error: Value not equal)"); };
    if (!((a->dstImage) == (b->dstImage))) { onFail("a->dstImage (Error: Value not equal)"); };
    if (!((a->dstImageLayout) == (b->dstImageLayout))) { onFail("a->dstImageLayout (Error: Value not equal)"); };
    if (!((a->regionCount) == (b->regionCount))) { onFail("a->regionCount (Error: Value not equal)"); };
    if ((a->pRegions) && (b->pRegions))
    {
        if (!((a->regionCount) == (b->regionCount))) { onFail("a->pRegions (Error: Lengths not equal)"); };
        if ((a->regionCount) == (b->regionCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->regionCount; ++i)
                {
                    checkEqual_VkImageBlit2KHR(a->pRegions + i, b->pRegions + i, onFail);
                }
            }
        }
    }
    if (!((a->filter) == (b->filter))) { onFail("a->filter (Error: Value not equal)"); };
}

void checkEqual_VkImageResolve2KHR(
    const VkImageResolve2KHR* a,
    const VkImageResolve2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkImageSubresourceLayers(&a->srcSubresource, &b->srcSubresource, onFail);
    checkEqual_VkOffset3D(&a->srcOffset, &b->srcOffset, onFail);
    checkEqual_VkImageSubresourceLayers(&a->dstSubresource, &b->dstSubresource, onFail);
    checkEqual_VkOffset3D(&a->dstOffset, &b->dstOffset, onFail);
    checkEqual_VkExtent3D(&a->extent, &b->extent, onFail);
}

void checkEqual_VkResolveImageInfo2KHR(
    const VkResolveImageInfo2KHR* a,
    const VkResolveImageInfo2KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcImage) == (b->srcImage))) { onFail("a->srcImage (Error: Value not equal)"); };
    if (!((a->srcImageLayout) == (b->srcImageLayout))) { onFail("a->srcImageLayout (Error: Value not equal)"); };
    if (!((a->dstImage) == (b->dstImage))) { onFail("a->dstImage (Error: Value not equal)"); };
    if (!((a->dstImageLayout) == (b->dstImageLayout))) { onFail("a->dstImageLayout (Error: Value not equal)"); };
    if (!((a->regionCount) == (b->regionCount))) { onFail("a->regionCount (Error: Value not equal)"); };
    if ((a->pRegions) && (b->pRegions))
    {
        if (!((a->regionCount) == (b->regionCount))) { onFail("a->pRegions (Error: Lengths not equal)"); };
        if ((a->regionCount) == (b->regionCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->regionCount; ++i)
                {
                    checkEqual_VkImageResolve2KHR(a->pRegions + i, b->pRegions + i, onFail);
                }
            }
        }
    }
}

#endif
#ifdef VK_KHR_format_feature_flags2
void checkEqual_VkFormatProperties3KHR(
    const VkFormatProperties3KHR* a,
    const VkFormatProperties3KHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->linearTilingFeatures) == (b->linearTilingFeatures))) { onFail("a->linearTilingFeatures (Error: Value not equal)"); };
    if (!((a->optimalTilingFeatures) == (b->optimalTilingFeatures))) { onFail("a->optimalTilingFeatures (Error: Value not equal)"); };
    if (!((a->bufferFeatures) == (b->bufferFeatures))) { onFail("a->bufferFeatures (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_maintenance4
void checkEqual_VkPhysicalDeviceMaintenance4FeaturesKHR(
    const VkPhysicalDeviceMaintenance4FeaturesKHR* a,
    const VkPhysicalDeviceMaintenance4FeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maintenance4) == (b->maintenance4))) { onFail("a->maintenance4 (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceMaintenance4PropertiesKHR(
    const VkPhysicalDeviceMaintenance4PropertiesKHR* a,
    const VkPhysicalDeviceMaintenance4PropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxBufferSize) == (b->maxBufferSize))) { onFail("a->maxBufferSize (Error: Value not equal)"); };
}

void checkEqual_VkDeviceBufferMemoryRequirementsKHR(
    const VkDeviceBufferMemoryRequirementsKHR* a,
    const VkDeviceBufferMemoryRequirementsKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if ((a->pCreateInfo) && (b->pCreateInfo))
    {
        checkEqual_VkBufferCreateInfo(a->pCreateInfo, b->pCreateInfo, onFail);
    }
}

void checkEqual_VkDeviceImageMemoryRequirementsKHR(
    const VkDeviceImageMemoryRequirementsKHR* a,
    const VkDeviceImageMemoryRequirementsKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if ((a->pCreateInfo) && (b->pCreateInfo))
    {
        checkEqual_VkImageCreateInfo(a->pCreateInfo, b->pCreateInfo, onFail);
    }
    if (!((a->planeAspect) == (b->planeAspect))) { onFail("a->planeAspect (Error: Value not equal)"); };
}

#endif
#ifdef VK_ANDROID_native_buffer
void checkEqual_VkNativeBufferANDROID(
    const VkNativeBufferANDROID* a,
    const VkNativeBufferANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->handle) && !(b->handle)) || ((a->handle) && (b->handle)))) { onFail("a->handle (Error: Mismatch in optional field)"); };
    if (a->handle && b->handle)
    {
        if (!((memcmp(a->handle, b->handle, sizeof(const uint32_t)) == 0))) { onFail("a->handle (Error: Unequal dyn array)"); };
    }
    if (!((a->stride) == (b->stride))) { onFail("a->stride (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->usage) == (b->usage))) { onFail("a->usage (Error: Value not equal)"); };
    if (!((a->consumer) == (b->consumer))) { onFail("a->consumer (Error: Value not equal)"); };
    if (!((a->producer) == (b->producer))) { onFail("a->producer (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_debug_report
void checkEqual_VkDebugReportCallbackCreateInfoEXT(
    const VkDebugReportCallbackCreateInfoEXT* a,
    const VkDebugReportCallbackCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->pfnCallback) == (b->pfnCallback))) { onFail("a->pfnCallback (Error: Value not equal)"); };
    if (!((!(a->pUserData) && !(b->pUserData)) || ((a->pUserData) && (b->pUserData)))) { onFail("a->pUserData (Error: Mismatch in optional field)"); };
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void checkEqual_VkPipelineRasterizationStateRasterizationOrderAMD(
    const VkPipelineRasterizationStateRasterizationOrderAMD* a,
    const VkPipelineRasterizationStateRasterizationOrderAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->rasterizationOrder) == (b->rasterizationOrder))) { onFail("a->rasterizationOrder (Error: Value not equal)"); };
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void checkEqual_VkDebugMarkerObjectNameInfoEXT(
    const VkDebugMarkerObjectNameInfoEXT* a,
    const VkDebugMarkerObjectNameInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->objectType) == (b->objectType))) { onFail("a->objectType (Error: Value not equal)"); };
    if (!((a->object) == (b->object))) { onFail("a->object (Error: Value not equal)"); };
    if (!((!(a->pObjectName) && !(b->pObjectName)) || ((a->pObjectName) && (b->pObjectName)))) { onFail("a->pObjectName (Error: Mismatch in string pointer nullness)"); };
    if ((a->pObjectName) && (b->pObjectName))
    {
        if (!((strcmp(a->pObjectName, b->pObjectName) == 0))) { onFail("a->pObjectName (Error: Unequal strings)"); };
    }
}

void checkEqual_VkDebugMarkerObjectTagInfoEXT(
    const VkDebugMarkerObjectTagInfoEXT* a,
    const VkDebugMarkerObjectTagInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->objectType) == (b->objectType))) { onFail("a->objectType (Error: Value not equal)"); };
    if (!((a->object) == (b->object))) { onFail("a->object (Error: Value not equal)"); };
    if (!((a->tagName) == (b->tagName))) { onFail("a->tagName (Error: Value not equal)"); };
    if (!((a->tagSize) == (b->tagSize))) { onFail("a->tagSize (Error: Value not equal)"); };
}

void checkEqual_VkDebugMarkerMarkerInfoEXT(
    const VkDebugMarkerMarkerInfoEXT* a,
    const VkDebugMarkerMarkerInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pMarkerName) && !(b->pMarkerName)) || ((a->pMarkerName) && (b->pMarkerName)))) { onFail("a->pMarkerName (Error: Mismatch in string pointer nullness)"); };
    if ((a->pMarkerName) && (b->pMarkerName))
    {
        if (!((strcmp(a->pMarkerName, b->pMarkerName) == 0))) { onFail("a->pMarkerName (Error: Unequal strings)"); };
    }
    if (!((memcmp(a->color, b->color, 4 * sizeof(float)) == 0))) { onFail("a->color (Error: Unequal static array)"); };
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void checkEqual_VkDedicatedAllocationImageCreateInfoNV(
    const VkDedicatedAllocationImageCreateInfoNV* a,
    const VkDedicatedAllocationImageCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->dedicatedAllocation) == (b->dedicatedAllocation))) { onFail("a->dedicatedAllocation (Error: Value not equal)"); };
}

void checkEqual_VkDedicatedAllocationBufferCreateInfoNV(
    const VkDedicatedAllocationBufferCreateInfoNV* a,
    const VkDedicatedAllocationBufferCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->dedicatedAllocation) == (b->dedicatedAllocation))) { onFail("a->dedicatedAllocation (Error: Value not equal)"); };
}

void checkEqual_VkDedicatedAllocationMemoryAllocateInfoNV(
    const VkDedicatedAllocationMemoryAllocateInfoNV* a,
    const VkDedicatedAllocationMemoryAllocateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->image) == (b->image))) { onFail("a->image (Error: Value not equal)"); };
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_transform_feedback
void checkEqual_VkPhysicalDeviceTransformFeedbackFeaturesEXT(
    const VkPhysicalDeviceTransformFeedbackFeaturesEXT* a,
    const VkPhysicalDeviceTransformFeedbackFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->transformFeedback) == (b->transformFeedback))) { onFail("a->transformFeedback (Error: Value not equal)"); };
    if (!((a->geometryStreams) == (b->geometryStreams))) { onFail("a->geometryStreams (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceTransformFeedbackPropertiesEXT(
    const VkPhysicalDeviceTransformFeedbackPropertiesEXT* a,
    const VkPhysicalDeviceTransformFeedbackPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxTransformFeedbackStreams) == (b->maxTransformFeedbackStreams))) { onFail("a->maxTransformFeedbackStreams (Error: Value not equal)"); };
    if (!((a->maxTransformFeedbackBuffers) == (b->maxTransformFeedbackBuffers))) { onFail("a->maxTransformFeedbackBuffers (Error: Value not equal)"); };
    if (!((a->maxTransformFeedbackBufferSize) == (b->maxTransformFeedbackBufferSize))) { onFail("a->maxTransformFeedbackBufferSize (Error: Value not equal)"); };
    if (!((a->maxTransformFeedbackStreamDataSize) == (b->maxTransformFeedbackStreamDataSize))) { onFail("a->maxTransformFeedbackStreamDataSize (Error: Value not equal)"); };
    if (!((a->maxTransformFeedbackBufferDataSize) == (b->maxTransformFeedbackBufferDataSize))) { onFail("a->maxTransformFeedbackBufferDataSize (Error: Value not equal)"); };
    if (!((a->maxTransformFeedbackBufferDataStride) == (b->maxTransformFeedbackBufferDataStride))) { onFail("a->maxTransformFeedbackBufferDataStride (Error: Value not equal)"); };
    if (!((a->transformFeedbackQueries) == (b->transformFeedbackQueries))) { onFail("a->transformFeedbackQueries (Error: Value not equal)"); };
    if (!((a->transformFeedbackStreamsLinesTriangles) == (b->transformFeedbackStreamsLinesTriangles))) { onFail("a->transformFeedbackStreamsLinesTriangles (Error: Value not equal)"); };
    if (!((a->transformFeedbackRasterizationStreamSelect) == (b->transformFeedbackRasterizationStreamSelect))) { onFail("a->transformFeedbackRasterizationStreamSelect (Error: Value not equal)"); };
    if (!((a->transformFeedbackDraw) == (b->transformFeedbackDraw))) { onFail("a->transformFeedbackDraw (Error: Value not equal)"); };
}

void checkEqual_VkPipelineRasterizationStateStreamCreateInfoEXT(
    const VkPipelineRasterizationStateStreamCreateInfoEXT* a,
    const VkPipelineRasterizationStateStreamCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->rasterizationStream) == (b->rasterizationStream))) { onFail("a->rasterizationStream (Error: Value not equal)"); };
}

#endif
#ifdef VK_NVX_binary_import
void checkEqual_VkCuModuleCreateInfoNVX(
    const VkCuModuleCreateInfoNVX* a,
    const VkCuModuleCreateInfoNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->dataSize) == (b->dataSize))) { onFail("a->dataSize (Error: Value not equal)"); };
}

void checkEqual_VkCuFunctionCreateInfoNVX(
    const VkCuFunctionCreateInfoNVX* a,
    const VkCuFunctionCreateInfoNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->module) == (b->module))) { onFail("a->module (Error: Value not equal)"); };
    if (!((!(a->pName) && !(b->pName)) || ((a->pName) && (b->pName)))) { onFail("a->pName (Error: Mismatch in string pointer nullness)"); };
    if ((a->pName) && (b->pName))
    {
        if (!((strcmp(a->pName, b->pName) == 0))) { onFail("a->pName (Error: Unequal strings)"); };
    }
}

void checkEqual_VkCuLaunchInfoNVX(
    const VkCuLaunchInfoNVX* a,
    const VkCuLaunchInfoNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->function) == (b->function))) { onFail("a->function (Error: Value not equal)"); };
    if (!((a->gridDimX) == (b->gridDimX))) { onFail("a->gridDimX (Error: Value not equal)"); };
    if (!((a->gridDimY) == (b->gridDimY))) { onFail("a->gridDimY (Error: Value not equal)"); };
    if (!((a->gridDimZ) == (b->gridDimZ))) { onFail("a->gridDimZ (Error: Value not equal)"); };
    if (!((a->blockDimX) == (b->blockDimX))) { onFail("a->blockDimX (Error: Value not equal)"); };
    if (!((a->blockDimY) == (b->blockDimY))) { onFail("a->blockDimY (Error: Value not equal)"); };
    if (!((a->blockDimZ) == (b->blockDimZ))) { onFail("a->blockDimZ (Error: Value not equal)"); };
    if (!((a->sharedMemBytes) == (b->sharedMemBytes))) { onFail("a->sharedMemBytes (Error: Value not equal)"); };
    if (!((a->paramCount) == (b->paramCount))) { onFail("a->paramCount (Error: Value not equal)"); };
    if (!((a->extraCount) == (b->extraCount))) { onFail("a->extraCount (Error: Value not equal)"); };
}

#endif
#ifdef VK_NVX_image_view_handle
void checkEqual_VkImageViewHandleInfoNVX(
    const VkImageViewHandleInfoNVX* a,
    const VkImageViewHandleInfoNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->imageView) == (b->imageView))) { onFail("a->imageView (Error: Value not equal)"); };
    if (!((a->descriptorType) == (b->descriptorType))) { onFail("a->descriptorType (Error: Value not equal)"); };
    if (!((a->sampler) == (b->sampler))) { onFail("a->sampler (Error: Value not equal)"); };
}

void checkEqual_VkImageViewAddressPropertiesNVX(
    const VkImageViewAddressPropertiesNVX* a,
    const VkImageViewAddressPropertiesNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceAddress) == (b->deviceAddress))) { onFail("a->deviceAddress (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
}

#endif
#ifdef VK_AMD_draw_indirect_count
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_EXT_video_encode_h264
void checkEqual_VkVideoEncodeH264CapabilitiesEXT(
    const VkVideoEncodeH264CapabilitiesEXT* a,
    const VkVideoEncodeH264CapabilitiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->inputModeFlags) == (b->inputModeFlags))) { onFail("a->inputModeFlags (Error: Value not equal)"); };
    if (!((a->outputModeFlags) == (b->outputModeFlags))) { onFail("a->outputModeFlags (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->minPictureSizeInMbs, &b->minPictureSizeInMbs, onFail);
    checkEqual_VkExtent2D(&a->maxPictureSizeInMbs, &b->maxPictureSizeInMbs, onFail);
    checkEqual_VkExtent2D(&a->inputImageDataAlignment, &b->inputImageDataAlignment, onFail);
    if (!((a->maxNumL0ReferenceForP) == (b->maxNumL0ReferenceForP))) { onFail("a->maxNumL0ReferenceForP (Error: Value not equal)"); };
    if (!((a->maxNumL0ReferenceForB) == (b->maxNumL0ReferenceForB))) { onFail("a->maxNumL0ReferenceForB (Error: Value not equal)"); };
    if (!((a->maxNumL1Reference) == (b->maxNumL1Reference))) { onFail("a->maxNumL1Reference (Error: Value not equal)"); };
    if (!((a->qualityLevelCount) == (b->qualityLevelCount))) { onFail("a->qualityLevelCount (Error: Value not equal)"); };
    checkEqual_VkExtensionProperties(&a->stdExtensionVersion, &b->stdExtensionVersion, onFail);
}

void checkEqual_VkVideoEncodeH264SessionCreateInfoEXT(
    const VkVideoEncodeH264SessionCreateInfoEXT* a,
    const VkVideoEncodeH264SessionCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->maxPictureSizeInMbs, &b->maxPictureSizeInMbs, onFail);
    if ((a->pStdExtensionVersion) && (b->pStdExtensionVersion))
    {
        checkEqual_VkExtensionProperties(a->pStdExtensionVersion, b->pStdExtensionVersion, onFail);
    }
}

void checkEqual_VkVideoEncodeH264SessionParametersAddInfoEXT(
    const VkVideoEncodeH264SessionParametersAddInfoEXT* a,
    const VkVideoEncodeH264SessionParametersAddInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->spsStdCount) == (b->spsStdCount))) { onFail("a->spsStdCount (Error: Value not equal)"); };
    if (!((!(a->pSpsStd) && !(b->pSpsStd)) || ((a->pSpsStd) && (b->pSpsStd)))) { onFail("a->pSpsStd (Error: Mismatch in optional field)"); };
    if (a->pSpsStd && b->pSpsStd)
    {
        if (!((a->spsStdCount) == (b->spsStdCount))) { onFail("a->pSpsStd (Error: Lengths not equal)"); };
        if (!((memcmp(a->pSpsStd, b->pSpsStd, a->spsStdCount * sizeof(const StdVideoH264SequenceParameterSet)) == 0))) { onFail("a->pSpsStd (Error: Unequal dyn array)"); };
    }
    if (!((a->ppsStdCount) == (b->ppsStdCount))) { onFail("a->ppsStdCount (Error: Value not equal)"); };
    if (!((!(a->pPpsStd) && !(b->pPpsStd)) || ((a->pPpsStd) && (b->pPpsStd)))) { onFail("a->pPpsStd (Error: Mismatch in optional field)"); };
    if (a->pPpsStd && b->pPpsStd)
    {
        if (!((a->ppsStdCount) == (b->ppsStdCount))) { onFail("a->pPpsStd (Error: Lengths not equal)"); };
        if (!((memcmp(a->pPpsStd, b->pPpsStd, a->ppsStdCount * sizeof(const StdVideoH264PictureParameterSet)) == 0))) { onFail("a->pPpsStd (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkVideoEncodeH264SessionParametersCreateInfoEXT(
    const VkVideoEncodeH264SessionParametersCreateInfoEXT* a,
    const VkVideoEncodeH264SessionParametersCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxSpsStdCount) == (b->maxSpsStdCount))) { onFail("a->maxSpsStdCount (Error: Value not equal)"); };
    if (!((a->maxPpsStdCount) == (b->maxPpsStdCount))) { onFail("a->maxPpsStdCount (Error: Value not equal)"); };
    if (!((!(a->pParametersAddInfo) && !(b->pParametersAddInfo)) || ((a->pParametersAddInfo) && (b->pParametersAddInfo)))) { onFail("a->pParametersAddInfo (Error: Mismatch in optional field)"); };
    if (a->pParametersAddInfo && b->pParametersAddInfo)
    {
        if ((a->pParametersAddInfo) && (b->pParametersAddInfo))
        {
            checkEqual_VkVideoEncodeH264SessionParametersAddInfoEXT(a->pParametersAddInfo, b->pParametersAddInfo, onFail);
        }
    }
}

void checkEqual_VkVideoEncodeH264DpbSlotInfoEXT(
    const VkVideoEncodeH264DpbSlotInfoEXT* a,
    const VkVideoEncodeH264DpbSlotInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->slotIndex) == (b->slotIndex))) { onFail("a->slotIndex (Error: Value not equal)"); };
    if (!((memcmp(a->pStdPictureInfo, b->pStdPictureInfo, sizeof(const StdVideoEncodeH264PictureInfo)) == 0))) { onFail("a->pStdPictureInfo (Error: Unequal dyn array)"); };
}

void checkEqual_VkVideoEncodeH264NaluSliceEXT(
    const VkVideoEncodeH264NaluSliceEXT* a,
    const VkVideoEncodeH264NaluSliceEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->pSliceHeaderStd, b->pSliceHeaderStd, sizeof(const StdVideoEncodeH264SliceHeader)) == 0))) { onFail("a->pSliceHeaderStd (Error: Unequal dyn array)"); };
    if (!((a->mbCount) == (b->mbCount))) { onFail("a->mbCount (Error: Value not equal)"); };
    if (!((a->refFinalList0EntryCount) == (b->refFinalList0EntryCount))) { onFail("a->refFinalList0EntryCount (Error: Value not equal)"); };
    if ((a->pRefFinalList0Entries) && (b->pRefFinalList0Entries))
    {
        if (!((a->refFinalList0EntryCount) == (b->refFinalList0EntryCount))) { onFail("a->pRefFinalList0Entries (Error: Lengths not equal)"); };
        if ((a->refFinalList0EntryCount) == (b->refFinalList0EntryCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->refFinalList0EntryCount; ++i)
                {
                    checkEqual_VkVideoEncodeH264DpbSlotInfoEXT(a->pRefFinalList0Entries + i, b->pRefFinalList0Entries + i, onFail);
                }
            }
        }
    }
    if (!((a->refFinalList1EntryCount) == (b->refFinalList1EntryCount))) { onFail("a->refFinalList1EntryCount (Error: Value not equal)"); };
    if ((a->pRefFinalList1Entries) && (b->pRefFinalList1Entries))
    {
        if (!((a->refFinalList1EntryCount) == (b->refFinalList1EntryCount))) { onFail("a->pRefFinalList1Entries (Error: Lengths not equal)"); };
        if ((a->refFinalList1EntryCount) == (b->refFinalList1EntryCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->refFinalList1EntryCount; ++i)
                {
                    checkEqual_VkVideoEncodeH264DpbSlotInfoEXT(a->pRefFinalList1Entries + i, b->pRefFinalList1Entries + i, onFail);
                }
            }
        }
    }
    if (!((a->precedingNaluBytes) == (b->precedingNaluBytes))) { onFail("a->precedingNaluBytes (Error: Value not equal)"); };
    if (!((a->minQp) == (b->minQp))) { onFail("a->minQp (Error: Value not equal)"); };
    if (!((a->maxQp) == (b->maxQp))) { onFail("a->maxQp (Error: Value not equal)"); };
}

void checkEqual_VkVideoEncodeH264VclFrameInfoEXT(
    const VkVideoEncodeH264VclFrameInfoEXT* a,
    const VkVideoEncodeH264VclFrameInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->refDefaultFinalList0EntryCount) == (b->refDefaultFinalList0EntryCount))) { onFail("a->refDefaultFinalList0EntryCount (Error: Value not equal)"); };
    if ((a->pRefDefaultFinalList0Entries) && (b->pRefDefaultFinalList0Entries))
    {
        if (!((a->refDefaultFinalList0EntryCount) == (b->refDefaultFinalList0EntryCount))) { onFail("a->pRefDefaultFinalList0Entries (Error: Lengths not equal)"); };
        if ((a->refDefaultFinalList0EntryCount) == (b->refDefaultFinalList0EntryCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->refDefaultFinalList0EntryCount; ++i)
                {
                    checkEqual_VkVideoEncodeH264DpbSlotInfoEXT(a->pRefDefaultFinalList0Entries + i, b->pRefDefaultFinalList0Entries + i, onFail);
                }
            }
        }
    }
    if (!((a->refDefaultFinalList1EntryCount) == (b->refDefaultFinalList1EntryCount))) { onFail("a->refDefaultFinalList1EntryCount (Error: Value not equal)"); };
    if ((a->pRefDefaultFinalList1Entries) && (b->pRefDefaultFinalList1Entries))
    {
        if (!((a->refDefaultFinalList1EntryCount) == (b->refDefaultFinalList1EntryCount))) { onFail("a->pRefDefaultFinalList1Entries (Error: Lengths not equal)"); };
        if ((a->refDefaultFinalList1EntryCount) == (b->refDefaultFinalList1EntryCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->refDefaultFinalList1EntryCount; ++i)
                {
                    checkEqual_VkVideoEncodeH264DpbSlotInfoEXT(a->pRefDefaultFinalList1Entries + i, b->pRefDefaultFinalList1Entries + i, onFail);
                }
            }
        }
    }
    if (!((a->naluSliceEntryCount) == (b->naluSliceEntryCount))) { onFail("a->naluSliceEntryCount (Error: Value not equal)"); };
    if ((a->pNaluSliceEntries) && (b->pNaluSliceEntries))
    {
        if (!((a->naluSliceEntryCount) == (b->naluSliceEntryCount))) { onFail("a->pNaluSliceEntries (Error: Lengths not equal)"); };
        if ((a->naluSliceEntryCount) == (b->naluSliceEntryCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->naluSliceEntryCount; ++i)
                {
                    checkEqual_VkVideoEncodeH264NaluSliceEXT(a->pNaluSliceEntries + i, b->pNaluSliceEntries + i, onFail);
                }
            }
        }
    }
    if ((a->pCurrentPictureInfo) && (b->pCurrentPictureInfo))
    {
        checkEqual_VkVideoEncodeH264DpbSlotInfoEXT(a->pCurrentPictureInfo, b->pCurrentPictureInfo, onFail);
    }
}

void checkEqual_VkVideoEncodeH264EmitPictureParametersEXT(
    const VkVideoEncodeH264EmitPictureParametersEXT* a,
    const VkVideoEncodeH264EmitPictureParametersEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->spsId) == (b->spsId))) { onFail("a->spsId (Error: Value not equal)"); };
    if (!((a->emitSpsEnable) == (b->emitSpsEnable))) { onFail("a->emitSpsEnable (Error: Value not equal)"); };
    if (!((a->ppsIdEntryCount) == (b->ppsIdEntryCount))) { onFail("a->ppsIdEntryCount (Error: Value not equal)"); };
    if (!((a->ppsIdEntryCount) == (b->ppsIdEntryCount))) { onFail("a->ppsIdEntries (Error: Lengths not equal)"); };
    if (!((memcmp(a->ppsIdEntries, b->ppsIdEntries, a->ppsIdEntryCount * sizeof(const uint8_t)) == 0))) { onFail("a->ppsIdEntries (Error: Unequal dyn array)"); };
}

void checkEqual_VkVideoEncodeH264ProfileEXT(
    const VkVideoEncodeH264ProfileEXT* a,
    const VkVideoEncodeH264ProfileEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->stdProfileIdc) == (b->stdProfileIdc))) { onFail("a->stdProfileIdc (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_video_encode_h265
void checkEqual_VkVideoEncodeH265CapabilitiesEXT(
    const VkVideoEncodeH265CapabilitiesEXT* a,
    const VkVideoEncodeH265CapabilitiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->inputModeFlags) == (b->inputModeFlags))) { onFail("a->inputModeFlags (Error: Value not equal)"); };
    if (!((a->outputModeFlags) == (b->outputModeFlags))) { onFail("a->outputModeFlags (Error: Value not equal)"); };
    if (!((a->ctbSizes) == (b->ctbSizes))) { onFail("a->ctbSizes (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->inputImageDataAlignment, &b->inputImageDataAlignment, onFail);
    if (!((a->maxNumL0ReferenceForP) == (b->maxNumL0ReferenceForP))) { onFail("a->maxNumL0ReferenceForP (Error: Value not equal)"); };
    if (!((a->maxNumL0ReferenceForB) == (b->maxNumL0ReferenceForB))) { onFail("a->maxNumL0ReferenceForB (Error: Value not equal)"); };
    if (!((a->maxNumL1Reference) == (b->maxNumL1Reference))) { onFail("a->maxNumL1Reference (Error: Value not equal)"); };
    if (!((a->maxNumSubLayers) == (b->maxNumSubLayers))) { onFail("a->maxNumSubLayers (Error: Value not equal)"); };
    if (!((a->qualityLevelCount) == (b->qualityLevelCount))) { onFail("a->qualityLevelCount (Error: Value not equal)"); };
    checkEqual_VkExtensionProperties(&a->stdExtensionVersion, &b->stdExtensionVersion, onFail);
}

void checkEqual_VkVideoEncodeH265SessionCreateInfoEXT(
    const VkVideoEncodeH265SessionCreateInfoEXT* a,
    const VkVideoEncodeH265SessionCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if ((a->pStdExtensionVersion) && (b->pStdExtensionVersion))
    {
        checkEqual_VkExtensionProperties(a->pStdExtensionVersion, b->pStdExtensionVersion, onFail);
    }
}

void checkEqual_VkVideoEncodeH265SessionParametersAddInfoEXT(
    const VkVideoEncodeH265SessionParametersAddInfoEXT* a,
    const VkVideoEncodeH265SessionParametersAddInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->vpsStdCount) == (b->vpsStdCount))) { onFail("a->vpsStdCount (Error: Value not equal)"); };
    if (!((!(a->pVpsStd) && !(b->pVpsStd)) || ((a->pVpsStd) && (b->pVpsStd)))) { onFail("a->pVpsStd (Error: Mismatch in optional field)"); };
    if (a->pVpsStd && b->pVpsStd)
    {
        if (!((a->vpsStdCount) == (b->vpsStdCount))) { onFail("a->pVpsStd (Error: Lengths not equal)"); };
        if (!((memcmp(a->pVpsStd, b->pVpsStd, a->vpsStdCount * sizeof(const StdVideoH265VideoParameterSet)) == 0))) { onFail("a->pVpsStd (Error: Unequal dyn array)"); };
    }
    if (!((a->spsStdCount) == (b->spsStdCount))) { onFail("a->spsStdCount (Error: Value not equal)"); };
    if (!((!(a->pSpsStd) && !(b->pSpsStd)) || ((a->pSpsStd) && (b->pSpsStd)))) { onFail("a->pSpsStd (Error: Mismatch in optional field)"); };
    if (a->pSpsStd && b->pSpsStd)
    {
        if (!((a->spsStdCount) == (b->spsStdCount))) { onFail("a->pSpsStd (Error: Lengths not equal)"); };
        if (!((memcmp(a->pSpsStd, b->pSpsStd, a->spsStdCount * sizeof(const StdVideoH265SequenceParameterSet)) == 0))) { onFail("a->pSpsStd (Error: Unequal dyn array)"); };
    }
    if (!((a->ppsStdCount) == (b->ppsStdCount))) { onFail("a->ppsStdCount (Error: Value not equal)"); };
    if (!((!(a->pPpsStd) && !(b->pPpsStd)) || ((a->pPpsStd) && (b->pPpsStd)))) { onFail("a->pPpsStd (Error: Mismatch in optional field)"); };
    if (a->pPpsStd && b->pPpsStd)
    {
        if (!((a->ppsStdCount) == (b->ppsStdCount))) { onFail("a->pPpsStd (Error: Lengths not equal)"); };
        if (!((memcmp(a->pPpsStd, b->pPpsStd, a->ppsStdCount * sizeof(const StdVideoH265PictureParameterSet)) == 0))) { onFail("a->pPpsStd (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkVideoEncodeH265SessionParametersCreateInfoEXT(
    const VkVideoEncodeH265SessionParametersCreateInfoEXT* a,
    const VkVideoEncodeH265SessionParametersCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxVpsStdCount) == (b->maxVpsStdCount))) { onFail("a->maxVpsStdCount (Error: Value not equal)"); };
    if (!((a->maxSpsStdCount) == (b->maxSpsStdCount))) { onFail("a->maxSpsStdCount (Error: Value not equal)"); };
    if (!((a->maxPpsStdCount) == (b->maxPpsStdCount))) { onFail("a->maxPpsStdCount (Error: Value not equal)"); };
    if (!((!(a->pParametersAddInfo) && !(b->pParametersAddInfo)) || ((a->pParametersAddInfo) && (b->pParametersAddInfo)))) { onFail("a->pParametersAddInfo (Error: Mismatch in optional field)"); };
    if (a->pParametersAddInfo && b->pParametersAddInfo)
    {
        if ((a->pParametersAddInfo) && (b->pParametersAddInfo))
        {
            checkEqual_VkVideoEncodeH265SessionParametersAddInfoEXT(a->pParametersAddInfo, b->pParametersAddInfo, onFail);
        }
    }
}

void checkEqual_VkVideoEncodeH265DpbSlotInfoEXT(
    const VkVideoEncodeH265DpbSlotInfoEXT* a,
    const VkVideoEncodeH265DpbSlotInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->slotIndex) == (b->slotIndex))) { onFail("a->slotIndex (Error: Value not equal)"); };
    if (!((memcmp(a->pStdReferenceInfo, b->pStdReferenceInfo, sizeof(const StdVideoEncodeH265ReferenceInfo)) == 0))) { onFail("a->pStdReferenceInfo (Error: Unequal dyn array)"); };
}

void checkEqual_VkVideoEncodeH265ReferenceListsEXT(
    const VkVideoEncodeH265ReferenceListsEXT* a,
    const VkVideoEncodeH265ReferenceListsEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->referenceList0EntryCount) == (b->referenceList0EntryCount))) { onFail("a->referenceList0EntryCount (Error: Value not equal)"); };
    if ((a->pReferenceList0Entries) && (b->pReferenceList0Entries))
    {
        if (!((a->referenceList0EntryCount) == (b->referenceList0EntryCount))) { onFail("a->pReferenceList0Entries (Error: Lengths not equal)"); };
        if ((a->referenceList0EntryCount) == (b->referenceList0EntryCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->referenceList0EntryCount; ++i)
                {
                    checkEqual_VkVideoEncodeH265DpbSlotInfoEXT(a->pReferenceList0Entries + i, b->pReferenceList0Entries + i, onFail);
                }
            }
        }
    }
    if (!((a->referenceList1EntryCount) == (b->referenceList1EntryCount))) { onFail("a->referenceList1EntryCount (Error: Value not equal)"); };
    if ((a->pReferenceList1Entries) && (b->pReferenceList1Entries))
    {
        if (!((a->referenceList1EntryCount) == (b->referenceList1EntryCount))) { onFail("a->pReferenceList1Entries (Error: Lengths not equal)"); };
        if ((a->referenceList1EntryCount) == (b->referenceList1EntryCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->referenceList1EntryCount; ++i)
                {
                    checkEqual_VkVideoEncodeH265DpbSlotInfoEXT(a->pReferenceList1Entries + i, b->pReferenceList1Entries + i, onFail);
                }
            }
        }
    }
    if (!((memcmp(a->pReferenceModifications, b->pReferenceModifications, sizeof(const StdVideoEncodeH265ReferenceModifications)) == 0))) { onFail("a->pReferenceModifications (Error: Unequal dyn array)"); };
}

void checkEqual_VkVideoEncodeH265NaluSliceEXT(
    const VkVideoEncodeH265NaluSliceEXT* a,
    const VkVideoEncodeH265NaluSliceEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->ctbCount) == (b->ctbCount))) { onFail("a->ctbCount (Error: Value not equal)"); };
    if (!((!(a->pReferenceFinalLists) && !(b->pReferenceFinalLists)) || ((a->pReferenceFinalLists) && (b->pReferenceFinalLists)))) { onFail("a->pReferenceFinalLists (Error: Mismatch in optional field)"); };
    if (a->pReferenceFinalLists && b->pReferenceFinalLists)
    {
        if ((a->pReferenceFinalLists) && (b->pReferenceFinalLists))
        {
            checkEqual_VkVideoEncodeH265ReferenceListsEXT(a->pReferenceFinalLists, b->pReferenceFinalLists, onFail);
        }
    }
    if (!((memcmp(a->pSliceHeaderStd, b->pSliceHeaderStd, sizeof(const StdVideoEncodeH265SliceHeader)) == 0))) { onFail("a->pSliceHeaderStd (Error: Unequal dyn array)"); };
}

void checkEqual_VkVideoEncodeH265VclFrameInfoEXT(
    const VkVideoEncodeH265VclFrameInfoEXT* a,
    const VkVideoEncodeH265VclFrameInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pReferenceFinalLists) && !(b->pReferenceFinalLists)) || ((a->pReferenceFinalLists) && (b->pReferenceFinalLists)))) { onFail("a->pReferenceFinalLists (Error: Mismatch in optional field)"); };
    if (a->pReferenceFinalLists && b->pReferenceFinalLists)
    {
        if ((a->pReferenceFinalLists) && (b->pReferenceFinalLists))
        {
            checkEqual_VkVideoEncodeH265ReferenceListsEXT(a->pReferenceFinalLists, b->pReferenceFinalLists, onFail);
        }
    }
    if (!((a->naluSliceEntryCount) == (b->naluSliceEntryCount))) { onFail("a->naluSliceEntryCount (Error: Value not equal)"); };
    if ((a->pNaluSliceEntries) && (b->pNaluSliceEntries))
    {
        if (!((a->naluSliceEntryCount) == (b->naluSliceEntryCount))) { onFail("a->pNaluSliceEntries (Error: Lengths not equal)"); };
        if ((a->naluSliceEntryCount) == (b->naluSliceEntryCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->naluSliceEntryCount; ++i)
                {
                    checkEqual_VkVideoEncodeH265NaluSliceEXT(a->pNaluSliceEntries + i, b->pNaluSliceEntries + i, onFail);
                }
            }
        }
    }
    if (!((memcmp(a->pCurrentPictureInfo, b->pCurrentPictureInfo, sizeof(const StdVideoEncodeH265PictureInfo)) == 0))) { onFail("a->pCurrentPictureInfo (Error: Unequal dyn array)"); };
}

void checkEqual_VkVideoEncodeH265EmitPictureParametersEXT(
    const VkVideoEncodeH265EmitPictureParametersEXT* a,
    const VkVideoEncodeH265EmitPictureParametersEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->vpsId) == (b->vpsId))) { onFail("a->vpsId (Error: Value not equal)"); };
    if (!((a->spsId) == (b->spsId))) { onFail("a->spsId (Error: Value not equal)"); };
    if (!((a->emitVpsEnable) == (b->emitVpsEnable))) { onFail("a->emitVpsEnable (Error: Value not equal)"); };
    if (!((a->emitSpsEnable) == (b->emitSpsEnable))) { onFail("a->emitSpsEnable (Error: Value not equal)"); };
    if (!((a->ppsIdEntryCount) == (b->ppsIdEntryCount))) { onFail("a->ppsIdEntryCount (Error: Value not equal)"); };
    if (!((a->ppsIdEntryCount) == (b->ppsIdEntryCount))) { onFail("a->ppsIdEntries (Error: Lengths not equal)"); };
    if (!((memcmp(a->ppsIdEntries, b->ppsIdEntries, a->ppsIdEntryCount * sizeof(const uint8_t)) == 0))) { onFail("a->ppsIdEntries (Error: Unequal dyn array)"); };
}

void checkEqual_VkVideoEncodeH265ProfileEXT(
    const VkVideoEncodeH265ProfileEXT* a,
    const VkVideoEncodeH265ProfileEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->stdProfileIdc) == (b->stdProfileIdc))) { onFail("a->stdProfileIdc (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_video_decode_h264
void checkEqual_VkVideoDecodeH264ProfileEXT(
    const VkVideoDecodeH264ProfileEXT* a,
    const VkVideoDecodeH264ProfileEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->stdProfileIdc) == (b->stdProfileIdc))) { onFail("a->stdProfileIdc (Error: Value not equal)"); };
    if (!((a->pictureLayout) == (b->pictureLayout))) { onFail("a->pictureLayout (Error: Value not equal)"); };
}

void checkEqual_VkVideoDecodeH264CapabilitiesEXT(
    const VkVideoDecodeH264CapabilitiesEXT* a,
    const VkVideoDecodeH264CapabilitiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxLevel) == (b->maxLevel))) { onFail("a->maxLevel (Error: Value not equal)"); };
    checkEqual_VkOffset2D(&a->fieldOffsetGranularity, &b->fieldOffsetGranularity, onFail);
    checkEqual_VkExtensionProperties(&a->stdExtensionVersion, &b->stdExtensionVersion, onFail);
}

void checkEqual_VkVideoDecodeH264SessionCreateInfoEXT(
    const VkVideoDecodeH264SessionCreateInfoEXT* a,
    const VkVideoDecodeH264SessionCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if ((a->pStdExtensionVersion) && (b->pStdExtensionVersion))
    {
        checkEqual_VkExtensionProperties(a->pStdExtensionVersion, b->pStdExtensionVersion, onFail);
    }
}

void checkEqual_VkVideoDecodeH264SessionParametersAddInfoEXT(
    const VkVideoDecodeH264SessionParametersAddInfoEXT* a,
    const VkVideoDecodeH264SessionParametersAddInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->spsStdCount) == (b->spsStdCount))) { onFail("a->spsStdCount (Error: Value not equal)"); };
    if (!((!(a->pSpsStd) && !(b->pSpsStd)) || ((a->pSpsStd) && (b->pSpsStd)))) { onFail("a->pSpsStd (Error: Mismatch in optional field)"); };
    if (a->pSpsStd && b->pSpsStd)
    {
        if (!((a->spsStdCount) == (b->spsStdCount))) { onFail("a->pSpsStd (Error: Lengths not equal)"); };
        if (!((memcmp(a->pSpsStd, b->pSpsStd, a->spsStdCount * sizeof(const StdVideoH264SequenceParameterSet)) == 0))) { onFail("a->pSpsStd (Error: Unequal dyn array)"); };
    }
    if (!((a->ppsStdCount) == (b->ppsStdCount))) { onFail("a->ppsStdCount (Error: Value not equal)"); };
    if (!((!(a->pPpsStd) && !(b->pPpsStd)) || ((a->pPpsStd) && (b->pPpsStd)))) { onFail("a->pPpsStd (Error: Mismatch in optional field)"); };
    if (a->pPpsStd && b->pPpsStd)
    {
        if (!((a->ppsStdCount) == (b->ppsStdCount))) { onFail("a->pPpsStd (Error: Lengths not equal)"); };
        if (!((memcmp(a->pPpsStd, b->pPpsStd, a->ppsStdCount * sizeof(const StdVideoH264PictureParameterSet)) == 0))) { onFail("a->pPpsStd (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkVideoDecodeH264SessionParametersCreateInfoEXT(
    const VkVideoDecodeH264SessionParametersCreateInfoEXT* a,
    const VkVideoDecodeH264SessionParametersCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxSpsStdCount) == (b->maxSpsStdCount))) { onFail("a->maxSpsStdCount (Error: Value not equal)"); };
    if (!((a->maxPpsStdCount) == (b->maxPpsStdCount))) { onFail("a->maxPpsStdCount (Error: Value not equal)"); };
    if (!((!(a->pParametersAddInfo) && !(b->pParametersAddInfo)) || ((a->pParametersAddInfo) && (b->pParametersAddInfo)))) { onFail("a->pParametersAddInfo (Error: Mismatch in optional field)"); };
    if (a->pParametersAddInfo && b->pParametersAddInfo)
    {
        if ((a->pParametersAddInfo) && (b->pParametersAddInfo))
        {
            checkEqual_VkVideoDecodeH264SessionParametersAddInfoEXT(a->pParametersAddInfo, b->pParametersAddInfo, onFail);
        }
    }
}

void checkEqual_VkVideoDecodeH264PictureInfoEXT(
    const VkVideoDecodeH264PictureInfoEXT* a,
    const VkVideoDecodeH264PictureInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->pStdPictureInfo, b->pStdPictureInfo, sizeof(const StdVideoDecodeH264PictureInfo)) == 0))) { onFail("a->pStdPictureInfo (Error: Unequal dyn array)"); };
    if (!((a->slicesCount) == (b->slicesCount))) { onFail("a->slicesCount (Error: Value not equal)"); };
    if (!((a->slicesCount) == (b->slicesCount))) { onFail("a->pSlicesDataOffsets (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSlicesDataOffsets, b->pSlicesDataOffsets, a->slicesCount * sizeof(const uint32_t)) == 0))) { onFail("a->pSlicesDataOffsets (Error: Unequal dyn array)"); };
}

void checkEqual_VkVideoDecodeH264MvcEXT(
    const VkVideoDecodeH264MvcEXT* a,
    const VkVideoDecodeH264MvcEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->pStdMvc, b->pStdMvc, sizeof(const StdVideoDecodeH264Mvc)) == 0))) { onFail("a->pStdMvc (Error: Unequal dyn array)"); };
}

void checkEqual_VkVideoDecodeH264DpbSlotInfoEXT(
    const VkVideoDecodeH264DpbSlotInfoEXT* a,
    const VkVideoDecodeH264DpbSlotInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->pStdReferenceInfo, b->pStdReferenceInfo, sizeof(const StdVideoDecodeH264ReferenceInfo)) == 0))) { onFail("a->pStdReferenceInfo (Error: Unequal dyn array)"); };
}

#endif
#ifdef VK_AMD_texture_gather_bias_lod
void checkEqual_VkTextureLODGatherFormatPropertiesAMD(
    const VkTextureLODGatherFormatPropertiesAMD* a,
    const VkTextureLODGatherFormatPropertiesAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->supportsTextureGatherLODBiasAMD) == (b->supportsTextureGatherLODBiasAMD))) { onFail("a->supportsTextureGatherLODBiasAMD (Error: Value not equal)"); };
}

#endif
#ifdef VK_AMD_shader_info
void checkEqual_VkShaderResourceUsageAMD(
    const VkShaderResourceUsageAMD* a,
    const VkShaderResourceUsageAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->numUsedVgprs) == (b->numUsedVgprs))) { onFail("a->numUsedVgprs (Error: Value not equal)"); };
    if (!((a->numUsedSgprs) == (b->numUsedSgprs))) { onFail("a->numUsedSgprs (Error: Value not equal)"); };
    if (!((a->ldsSizePerLocalWorkGroup) == (b->ldsSizePerLocalWorkGroup))) { onFail("a->ldsSizePerLocalWorkGroup (Error: Value not equal)"); };
    if (!((a->ldsUsageSizeInBytes) == (b->ldsUsageSizeInBytes))) { onFail("a->ldsUsageSizeInBytes (Error: Value not equal)"); };
    if (!((a->scratchMemUsageInBytes) == (b->scratchMemUsageInBytes))) { onFail("a->scratchMemUsageInBytes (Error: Value not equal)"); };
}

void checkEqual_VkShaderStatisticsInfoAMD(
    const VkShaderStatisticsInfoAMD* a,
    const VkShaderStatisticsInfoAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->shaderStageMask) == (b->shaderStageMask))) { onFail("a->shaderStageMask (Error: Value not equal)"); };
    checkEqual_VkShaderResourceUsageAMD(&a->resourceUsage, &b->resourceUsage, onFail);
    if (!((a->numPhysicalVgprs) == (b->numPhysicalVgprs))) { onFail("a->numPhysicalVgprs (Error: Value not equal)"); };
    if (!((a->numPhysicalSgprs) == (b->numPhysicalSgprs))) { onFail("a->numPhysicalSgprs (Error: Value not equal)"); };
    if (!((a->numAvailableVgprs) == (b->numAvailableVgprs))) { onFail("a->numAvailableVgprs (Error: Value not equal)"); };
    if (!((a->numAvailableSgprs) == (b->numAvailableSgprs))) { onFail("a->numAvailableSgprs (Error: Value not equal)"); };
    if (!((memcmp(a->computeWorkGroupSize, b->computeWorkGroupSize, 3 * sizeof(uint32_t)) == 0))) { onFail("a->computeWorkGroupSize (Error: Unequal static array)"); };
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_GGP_stream_descriptor_surface
void checkEqual_VkStreamDescriptorSurfaceCreateInfoGGP(
    const VkStreamDescriptorSurfaceCreateInfoGGP* a,
    const VkStreamDescriptorSurfaceCreateInfoGGP* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->streamDescriptor) == (b->streamDescriptor))) { onFail("a->streamDescriptor (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_corner_sampled_image
void checkEqual_VkPhysicalDeviceCornerSampledImageFeaturesNV(
    const VkPhysicalDeviceCornerSampledImageFeaturesNV* a,
    const VkPhysicalDeviceCornerSampledImageFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->cornerSampledImage) == (b->cornerSampledImage))) { onFail("a->cornerSampledImage (Error: Value not equal)"); };
}

#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void checkEqual_VkExternalImageFormatPropertiesNV(
    const VkExternalImageFormatPropertiesNV* a,
    const VkExternalImageFormatPropertiesNV* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkImageFormatProperties(&a->imageFormatProperties, &b->imageFormatProperties, onFail);
    if (!((a->externalMemoryFeatures) == (b->externalMemoryFeatures))) { onFail("a->externalMemoryFeatures (Error: Value not equal)"); };
    if (!((a->exportFromImportedHandleTypes) == (b->exportFromImportedHandleTypes))) { onFail("a->exportFromImportedHandleTypes (Error: Value not equal)"); };
    if (!((a->compatibleHandleTypes) == (b->compatibleHandleTypes))) { onFail("a->compatibleHandleTypes (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_external_memory
void checkEqual_VkExternalMemoryImageCreateInfoNV(
    const VkExternalMemoryImageCreateInfoNV* a,
    const VkExternalMemoryImageCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleTypes) == (b->handleTypes))) { onFail("a->handleTypes (Error: Value not equal)"); };
}

void checkEqual_VkExportMemoryAllocateInfoNV(
    const VkExportMemoryAllocateInfoNV* a,
    const VkExportMemoryAllocateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleTypes) == (b->handleTypes))) { onFail("a->handleTypes (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_external_memory_win32
void checkEqual_VkImportMemoryWin32HandleInfoNV(
    const VkImportMemoryWin32HandleInfoNV* a,
    const VkImportMemoryWin32HandleInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->handle) == (b->handle))) { onFail("a->handle (Error: Value not equal)"); };
}

void checkEqual_VkExportMemoryWin32HandleInfoNV(
    const VkExportMemoryWin32HandleInfoNV* a,
    const VkExportMemoryWin32HandleInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pAttributes) && !(b->pAttributes)) || ((a->pAttributes) && (b->pAttributes)))) { onFail("a->pAttributes (Error: Mismatch in optional field)"); };
    if (a->pAttributes && b->pAttributes)
    {
        if (!((memcmp(a->pAttributes, b->pAttributes, sizeof(const SECURITY_ATTRIBUTES)) == 0))) { onFail("a->pAttributes (Error: Unequal dyn array)"); };
    }
    if (!((a->dwAccess) == (b->dwAccess))) { onFail("a->dwAccess (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void checkEqual_VkWin32KeyedMutexAcquireReleaseInfoNV(
    const VkWin32KeyedMutexAcquireReleaseInfoNV* a,
    const VkWin32KeyedMutexAcquireReleaseInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->acquireCount (Error: Value not equal)"); };
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->pAcquireSyncs (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAcquireSyncs, b->pAcquireSyncs, a->acquireCount * sizeof(const VkDeviceMemory)) == 0))) { onFail("a->pAcquireSyncs (Error: Unequal dyn array)"); };
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->pAcquireKeys (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAcquireKeys, b->pAcquireKeys, a->acquireCount * sizeof(const uint64_t)) == 0))) { onFail("a->pAcquireKeys (Error: Unequal dyn array)"); };
    if (!((a->acquireCount) == (b->acquireCount))) { onFail("a->pAcquireTimeoutMilliseconds (Error: Lengths not equal)"); };
    if (!((memcmp(a->pAcquireTimeoutMilliseconds, b->pAcquireTimeoutMilliseconds, a->acquireCount * sizeof(const uint32_t)) == 0))) { onFail("a->pAcquireTimeoutMilliseconds (Error: Unequal dyn array)"); };
    if (!((a->releaseCount) == (b->releaseCount))) { onFail("a->releaseCount (Error: Value not equal)"); };
    if (!((a->releaseCount) == (b->releaseCount))) { onFail("a->pReleaseSyncs (Error: Lengths not equal)"); };
    if (!((memcmp(a->pReleaseSyncs, b->pReleaseSyncs, a->releaseCount * sizeof(const VkDeviceMemory)) == 0))) { onFail("a->pReleaseSyncs (Error: Unequal dyn array)"); };
    if (!((a->releaseCount) == (b->releaseCount))) { onFail("a->pReleaseKeys (Error: Lengths not equal)"); };
    if (!((memcmp(a->pReleaseKeys, b->pReleaseKeys, a->releaseCount * sizeof(const uint64_t)) == 0))) { onFail("a->pReleaseKeys (Error: Unequal dyn array)"); };
}

#endif
#ifdef VK_EXT_validation_flags
void checkEqual_VkValidationFlagsEXT(
    const VkValidationFlagsEXT* a,
    const VkValidationFlagsEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->disabledValidationCheckCount) == (b->disabledValidationCheckCount))) { onFail("a->disabledValidationCheckCount (Error: Value not equal)"); };
    if (!((a->disabledValidationCheckCount) == (b->disabledValidationCheckCount))) { onFail("a->pDisabledValidationChecks (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDisabledValidationChecks, b->pDisabledValidationChecks, a->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT)) == 0))) { onFail("a->pDisabledValidationChecks (Error: Unequal dyn array)"); };
}

#endif
#ifdef VK_NN_vi_surface
void checkEqual_VkViSurfaceCreateInfoNN(
    const VkViSurfaceCreateInfoNN* a,
    const VkViSurfaceCreateInfoNN* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->window) && !(b->window)) || ((a->window) && (b->window)))) { onFail("a->window (Error: Mismatch in optional field)"); };
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
void checkEqual_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(
    const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT* a,
    const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->textureCompressionASTC_HDR) == (b->textureCompressionASTC_HDR))) { onFail("a->textureCompressionASTC_HDR (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_astc_decode_mode
void checkEqual_VkImageViewASTCDecodeModeEXT(
    const VkImageViewASTCDecodeModeEXT* a,
    const VkImageViewASTCDecodeModeEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->decodeMode) == (b->decodeMode))) { onFail("a->decodeMode (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceASTCDecodeFeaturesEXT(
    const VkPhysicalDeviceASTCDecodeFeaturesEXT* a,
    const VkPhysicalDeviceASTCDecodeFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->decodeModeSharedExponent) == (b->decodeModeSharedExponent))) { onFail("a->decodeModeSharedExponent (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_conditional_rendering
void checkEqual_VkConditionalRenderingBeginInfoEXT(
    const VkConditionalRenderingBeginInfoEXT* a,
    const VkConditionalRenderingBeginInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT* a,
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->conditionalRendering) == (b->conditionalRendering))) { onFail("a->conditionalRendering (Error: Value not equal)"); };
    if (!((a->inheritedConditionalRendering) == (b->inheritedConditionalRendering))) { onFail("a->inheritedConditionalRendering (Error: Value not equal)"); };
}

void checkEqual_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* a,
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->conditionalRenderingEnable) == (b->conditionalRenderingEnable))) { onFail("a->conditionalRenderingEnable (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void checkEqual_VkViewportWScalingNV(
    const VkViewportWScalingNV* a,
    const VkViewportWScalingNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->xcoeff) == (b->xcoeff))) { onFail("a->xcoeff (Error: Value not equal)"); };
    if (!((a->ycoeff) == (b->ycoeff))) { onFail("a->ycoeff (Error: Value not equal)"); };
}

void checkEqual_VkPipelineViewportWScalingStateCreateInfoNV(
    const VkPipelineViewportWScalingStateCreateInfoNV* a,
    const VkPipelineViewportWScalingStateCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->viewportWScalingEnable) == (b->viewportWScalingEnable))) { onFail("a->viewportWScalingEnable (Error: Value not equal)"); };
    if (!((a->viewportCount) == (b->viewportCount))) { onFail("a->viewportCount (Error: Value not equal)"); };
    if (!((!(a->pViewportWScalings) && !(b->pViewportWScalings)) || ((a->pViewportWScalings) && (b->pViewportWScalings)))) { onFail("a->pViewportWScalings (Error: Mismatch in optional field)"); };
    if (a->pViewportWScalings && b->pViewportWScalings)
    {
        if ((a->pViewportWScalings) && (b->pViewportWScalings))
        {
            if (!((a->viewportCount) == (b->viewportCount))) { onFail("a->pViewportWScalings (Error: Lengths not equal)"); };
            if ((a->viewportCount) == (b->viewportCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->viewportCount; ++i)
                    {
                        checkEqual_VkViewportWScalingNV(a->pViewportWScalings + i, b->pViewportWScalings + i, onFail);
                    }
                }
            }
        }
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
#endif
#ifdef VK_EXT_acquire_xlib_display
#endif
#ifdef VK_EXT_display_surface_counter
void checkEqual_VkSurfaceCapabilities2EXT(
    const VkSurfaceCapabilities2EXT* a,
    const VkSurfaceCapabilities2EXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->minImageCount) == (b->minImageCount))) { onFail("a->minImageCount (Error: Value not equal)"); };
    if (!((a->maxImageCount) == (b->maxImageCount))) { onFail("a->maxImageCount (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->currentExtent, &b->currentExtent, onFail);
    checkEqual_VkExtent2D(&a->minImageExtent, &b->minImageExtent, onFail);
    checkEqual_VkExtent2D(&a->maxImageExtent, &b->maxImageExtent, onFail);
    if (!((a->maxImageArrayLayers) == (b->maxImageArrayLayers))) { onFail("a->maxImageArrayLayers (Error: Value not equal)"); };
    if (!((a->supportedTransforms) == (b->supportedTransforms))) { onFail("a->supportedTransforms (Error: Value not equal)"); };
    if (!((a->currentTransform) == (b->currentTransform))) { onFail("a->currentTransform (Error: Value not equal)"); };
    if (!((a->supportedCompositeAlpha) == (b->supportedCompositeAlpha))) { onFail("a->supportedCompositeAlpha (Error: Value not equal)"); };
    if (!((a->supportedUsageFlags) == (b->supportedUsageFlags))) { onFail("a->supportedUsageFlags (Error: Value not equal)"); };
    if (!((a->supportedSurfaceCounters) == (b->supportedSurfaceCounters))) { onFail("a->supportedSurfaceCounters (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_display_control
void checkEqual_VkDisplayPowerInfoEXT(
    const VkDisplayPowerInfoEXT* a,
    const VkDisplayPowerInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->powerState) == (b->powerState))) { onFail("a->powerState (Error: Value not equal)"); };
}

void checkEqual_VkDeviceEventInfoEXT(
    const VkDeviceEventInfoEXT* a,
    const VkDeviceEventInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceEvent) == (b->deviceEvent))) { onFail("a->deviceEvent (Error: Value not equal)"); };
}

void checkEqual_VkDisplayEventInfoEXT(
    const VkDisplayEventInfoEXT* a,
    const VkDisplayEventInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->displayEvent) == (b->displayEvent))) { onFail("a->displayEvent (Error: Value not equal)"); };
}

void checkEqual_VkSwapchainCounterCreateInfoEXT(
    const VkSwapchainCounterCreateInfoEXT* a,
    const VkSwapchainCounterCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->surfaceCounters) == (b->surfaceCounters))) { onFail("a->surfaceCounters (Error: Value not equal)"); };
}

#endif
#ifdef VK_GOOGLE_display_timing
void checkEqual_VkRefreshCycleDurationGOOGLE(
    const VkRefreshCycleDurationGOOGLE* a,
    const VkRefreshCycleDurationGOOGLE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->refreshDuration) == (b->refreshDuration))) { onFail("a->refreshDuration (Error: Value not equal)"); };
}

void checkEqual_VkPastPresentationTimingGOOGLE(
    const VkPastPresentationTimingGOOGLE* a,
    const VkPastPresentationTimingGOOGLE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->presentID) == (b->presentID))) { onFail("a->presentID (Error: Value not equal)"); };
    if (!((a->desiredPresentTime) == (b->desiredPresentTime))) { onFail("a->desiredPresentTime (Error: Value not equal)"); };
    if (!((a->actualPresentTime) == (b->actualPresentTime))) { onFail("a->actualPresentTime (Error: Value not equal)"); };
    if (!((a->earliestPresentTime) == (b->earliestPresentTime))) { onFail("a->earliestPresentTime (Error: Value not equal)"); };
    if (!((a->presentMargin) == (b->presentMargin))) { onFail("a->presentMargin (Error: Value not equal)"); };
}

void checkEqual_VkPresentTimeGOOGLE(
    const VkPresentTimeGOOGLE* a,
    const VkPresentTimeGOOGLE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->presentID) == (b->presentID))) { onFail("a->presentID (Error: Value not equal)"); };
    if (!((a->desiredPresentTime) == (b->desiredPresentTime))) { onFail("a->desiredPresentTime (Error: Value not equal)"); };
}

void checkEqual_VkPresentTimesInfoGOOGLE(
    const VkPresentTimesInfoGOOGLE* a,
    const VkPresentTimesInfoGOOGLE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->swapchainCount (Error: Value not equal)"); };
    if (!((!(a->pTimes) && !(b->pTimes)) || ((a->pTimes) && (b->pTimes)))) { onFail("a->pTimes (Error: Mismatch in optional field)"); };
    if (a->pTimes && b->pTimes)
    {
        if ((a->pTimes) && (b->pTimes))
        {
            if (!((a->swapchainCount) == (b->swapchainCount))) { onFail("a->pTimes (Error: Lengths not equal)"); };
            if ((a->swapchainCount) == (b->swapchainCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->swapchainCount; ++i)
                    {
                        checkEqual_VkPresentTimeGOOGLE(a->pTimes + i, b->pTimes + i, onFail);
                    }
                }
            }
        }
    }
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void checkEqual_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* a,
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->perViewPositionAllComponents) == (b->perViewPositionAllComponents))) { onFail("a->perViewPositionAllComponents (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_viewport_swizzle
void checkEqual_VkViewportSwizzleNV(
    const VkViewportSwizzleNV* a,
    const VkViewportSwizzleNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->x) == (b->x))) { onFail("a->x (Error: Value not equal)"); };
    if (!((a->y) == (b->y))) { onFail("a->y (Error: Value not equal)"); };
    if (!((a->z) == (b->z))) { onFail("a->z (Error: Value not equal)"); };
    if (!((a->w) == (b->w))) { onFail("a->w (Error: Value not equal)"); };
}

void checkEqual_VkPipelineViewportSwizzleStateCreateInfoNV(
    const VkPipelineViewportSwizzleStateCreateInfoNV* a,
    const VkPipelineViewportSwizzleStateCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->viewportCount) == (b->viewportCount))) { onFail("a->viewportCount (Error: Value not equal)"); };
    if (!((!(a->pViewportSwizzles) && !(b->pViewportSwizzles)) || ((a->pViewportSwizzles) && (b->pViewportSwizzles)))) { onFail("a->pViewportSwizzles (Error: Mismatch in optional field)"); };
    if (a->pViewportSwizzles && b->pViewportSwizzles)
    {
        if ((a->pViewportSwizzles) && (b->pViewportSwizzles))
        {
            if (!((a->viewportCount) == (b->viewportCount))) { onFail("a->pViewportSwizzles (Error: Lengths not equal)"); };
            if ((a->viewportCount) == (b->viewportCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->viewportCount; ++i)
                    {
                        checkEqual_VkViewportSwizzleNV(a->pViewportSwizzles + i, b->pViewportSwizzles + i, onFail);
                    }
                }
            }
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void checkEqual_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT* a,
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxDiscardRectangles) == (b->maxDiscardRectangles))) { onFail("a->maxDiscardRectangles (Error: Value not equal)"); };
}

void checkEqual_VkPipelineDiscardRectangleStateCreateInfoEXT(
    const VkPipelineDiscardRectangleStateCreateInfoEXT* a,
    const VkPipelineDiscardRectangleStateCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->discardRectangleMode) == (b->discardRectangleMode))) { onFail("a->discardRectangleMode (Error: Value not equal)"); };
    if (!((a->discardRectangleCount) == (b->discardRectangleCount))) { onFail("a->discardRectangleCount (Error: Value not equal)"); };
    if (!((!(a->pDiscardRectangles) && !(b->pDiscardRectangles)) || ((a->pDiscardRectangles) && (b->pDiscardRectangles)))) { onFail("a->pDiscardRectangles (Error: Mismatch in optional field)"); };
    if (a->pDiscardRectangles && b->pDiscardRectangles)
    {
        if ((a->pDiscardRectangles) && (b->pDiscardRectangles))
        {
            if (!((a->discardRectangleCount) == (b->discardRectangleCount))) { onFail("a->pDiscardRectangles (Error: Lengths not equal)"); };
            if ((a->discardRectangleCount) == (b->discardRectangleCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->discardRectangleCount; ++i)
                    {
                        checkEqual_VkRect2D(a->pDiscardRectangles + i, b->pDiscardRectangles + i, onFail);
                    }
                }
            }
        }
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void checkEqual_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* a,
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->primitiveOverestimationSize) == (b->primitiveOverestimationSize))) { onFail("a->primitiveOverestimationSize (Error: Value not equal)"); };
    if (!((a->maxExtraPrimitiveOverestimationSize) == (b->maxExtraPrimitiveOverestimationSize))) { onFail("a->maxExtraPrimitiveOverestimationSize (Error: Value not equal)"); };
    if (!((a->extraPrimitiveOverestimationSizeGranularity) == (b->extraPrimitiveOverestimationSizeGranularity))) { onFail("a->extraPrimitiveOverestimationSizeGranularity (Error: Value not equal)"); };
    if (!((a->primitiveUnderestimation) == (b->primitiveUnderestimation))) { onFail("a->primitiveUnderestimation (Error: Value not equal)"); };
    if (!((a->conservativePointAndLineRasterization) == (b->conservativePointAndLineRasterization))) { onFail("a->conservativePointAndLineRasterization (Error: Value not equal)"); };
    if (!((a->degenerateTrianglesRasterized) == (b->degenerateTrianglesRasterized))) { onFail("a->degenerateTrianglesRasterized (Error: Value not equal)"); };
    if (!((a->degenerateLinesRasterized) == (b->degenerateLinesRasterized))) { onFail("a->degenerateLinesRasterized (Error: Value not equal)"); };
    if (!((a->fullyCoveredFragmentShaderInputVariable) == (b->fullyCoveredFragmentShaderInputVariable))) { onFail("a->fullyCoveredFragmentShaderInputVariable (Error: Value not equal)"); };
    if (!((a->conservativeRasterizationPostDepthCoverage) == (b->conservativeRasterizationPostDepthCoverage))) { onFail("a->conservativeRasterizationPostDepthCoverage (Error: Value not equal)"); };
}

void checkEqual_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* a,
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->conservativeRasterizationMode) == (b->conservativeRasterizationMode))) { onFail("a->conservativeRasterizationMode (Error: Value not equal)"); };
    if (!((a->extraPrimitiveOverestimationSize) == (b->extraPrimitiveOverestimationSize))) { onFail("a->extraPrimitiveOverestimationSize (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_depth_clip_enable
void checkEqual_VkPhysicalDeviceDepthClipEnableFeaturesEXT(
    const VkPhysicalDeviceDepthClipEnableFeaturesEXT* a,
    const VkPhysicalDeviceDepthClipEnableFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->depthClipEnable) == (b->depthClipEnable))) { onFail("a->depthClipEnable (Error: Value not equal)"); };
}

void checkEqual_VkPipelineRasterizationDepthClipStateCreateInfoEXT(
    const VkPipelineRasterizationDepthClipStateCreateInfoEXT* a,
    const VkPipelineRasterizationDepthClipStateCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->depthClipEnable) == (b->depthClipEnable))) { onFail("a->depthClipEnable (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void checkEqual_VkXYColorEXT(
    const VkXYColorEXT* a,
    const VkXYColorEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->x) == (b->x))) { onFail("a->x (Error: Value not equal)"); };
    if (!((a->y) == (b->y))) { onFail("a->y (Error: Value not equal)"); };
}

void checkEqual_VkHdrMetadataEXT(
    const VkHdrMetadataEXT* a,
    const VkHdrMetadataEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkXYColorEXT(&a->displayPrimaryRed, &b->displayPrimaryRed, onFail);
    checkEqual_VkXYColorEXT(&a->displayPrimaryGreen, &b->displayPrimaryGreen, onFail);
    checkEqual_VkXYColorEXT(&a->displayPrimaryBlue, &b->displayPrimaryBlue, onFail);
    checkEqual_VkXYColorEXT(&a->whitePoint, &b->whitePoint, onFail);
    if (!((a->maxLuminance) == (b->maxLuminance))) { onFail("a->maxLuminance (Error: Value not equal)"); };
    if (!((a->minLuminance) == (b->minLuminance))) { onFail("a->minLuminance (Error: Value not equal)"); };
    if (!((a->maxContentLightLevel) == (b->maxContentLightLevel))) { onFail("a->maxContentLightLevel (Error: Value not equal)"); };
    if (!((a->maxFrameAverageLightLevel) == (b->maxFrameAverageLightLevel))) { onFail("a->maxFrameAverageLightLevel (Error: Value not equal)"); };
}

#endif
#ifdef VK_MVK_ios_surface
void checkEqual_VkIOSSurfaceCreateInfoMVK(
    const VkIOSSurfaceCreateInfoMVK* a,
    const VkIOSSurfaceCreateInfoMVK* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->pView) && !(b->pView)) || ((a->pView) && (b->pView)))) { onFail("a->pView (Error: Mismatch in optional field)"); };
}

#endif
#ifdef VK_MVK_macos_surface
void checkEqual_VkMacOSSurfaceCreateInfoMVK(
    const VkMacOSSurfaceCreateInfoMVK* a,
    const VkMacOSSurfaceCreateInfoMVK* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->pView) && !(b->pView)) || ((a->pView) && (b->pView)))) { onFail("a->pView (Error: Mismatch in optional field)"); };
}

#endif
#ifdef VK_MVK_moltenvk
#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void checkEqual_VkDebugUtilsLabelEXT(
    const VkDebugUtilsLabelEXT* a,
    const VkDebugUtilsLabelEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pLabelName) && !(b->pLabelName)) || ((a->pLabelName) && (b->pLabelName)))) { onFail("a->pLabelName (Error: Mismatch in string pointer nullness)"); };
    if ((a->pLabelName) && (b->pLabelName))
    {
        if (!((strcmp(a->pLabelName, b->pLabelName) == 0))) { onFail("a->pLabelName (Error: Unequal strings)"); };
    }
    if (!((memcmp(a->color, b->color, 4 * sizeof(float)) == 0))) { onFail("a->color (Error: Unequal static array)"); };
}

void checkEqual_VkDebugUtilsObjectNameInfoEXT(
    const VkDebugUtilsObjectNameInfoEXT* a,
    const VkDebugUtilsObjectNameInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->objectType) == (b->objectType))) { onFail("a->objectType (Error: Value not equal)"); };
    if (!((a->objectHandle) == (b->objectHandle))) { onFail("a->objectHandle (Error: Value not equal)"); };
    if (!((!(a->pObjectName) && !(b->pObjectName)) || ((a->pObjectName) && (b->pObjectName)))) { onFail("a->pObjectName (Error: Mismatch in optional field)"); };
    if (a->pObjectName && b->pObjectName)
    {
        if (!((!(a->pObjectName) && !(b->pObjectName)) || ((a->pObjectName) && (b->pObjectName)))) { onFail("a->pObjectName (Error: Mismatch in string pointer nullness)"); };
        if ((a->pObjectName) && (b->pObjectName))
        {
            if (!((strcmp(a->pObjectName, b->pObjectName) == 0))) { onFail("a->pObjectName (Error: Unequal strings)"); };
        }
    }
}

void checkEqual_VkDebugUtilsMessengerCallbackDataEXT(
    const VkDebugUtilsMessengerCallbackDataEXT* a,
    const VkDebugUtilsMessengerCallbackDataEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->pMessageIdName) && !(b->pMessageIdName)) || ((a->pMessageIdName) && (b->pMessageIdName)))) { onFail("a->pMessageIdName (Error: Mismatch in optional field)"); };
    if (a->pMessageIdName && b->pMessageIdName)
    {
        if (!((!(a->pMessageIdName) && !(b->pMessageIdName)) || ((a->pMessageIdName) && (b->pMessageIdName)))) { onFail("a->pMessageIdName (Error: Mismatch in string pointer nullness)"); };
        if ((a->pMessageIdName) && (b->pMessageIdName))
        {
            if (!((strcmp(a->pMessageIdName, b->pMessageIdName) == 0))) { onFail("a->pMessageIdName (Error: Unequal strings)"); };
        }
    }
    if (!((a->messageIdNumber) == (b->messageIdNumber))) { onFail("a->messageIdNumber (Error: Value not equal)"); };
    if (!((!(a->pMessage) && !(b->pMessage)) || ((a->pMessage) && (b->pMessage)))) { onFail("a->pMessage (Error: Mismatch in string pointer nullness)"); };
    if ((a->pMessage) && (b->pMessage))
    {
        if (!((strcmp(a->pMessage, b->pMessage) == 0))) { onFail("a->pMessage (Error: Unequal strings)"); };
    }
    if (!((a->queueLabelCount) == (b->queueLabelCount))) { onFail("a->queueLabelCount (Error: Value not equal)"); };
    if (!((!(a->pQueueLabels) && !(b->pQueueLabels)) || ((a->pQueueLabels) && (b->pQueueLabels)))) { onFail("a->pQueueLabels (Error: Mismatch in optional field)"); };
    if (a->pQueueLabels && b->pQueueLabels)
    {
        if ((a->pQueueLabels) && (b->pQueueLabels))
        {
            if (!((a->queueLabelCount) == (b->queueLabelCount))) { onFail("a->pQueueLabels (Error: Lengths not equal)"); };
            if ((a->queueLabelCount) == (b->queueLabelCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->queueLabelCount; ++i)
                    {
                        checkEqual_VkDebugUtilsLabelEXT(a->pQueueLabels + i, b->pQueueLabels + i, onFail);
                    }
                }
            }
        }
    }
    if (!((a->cmdBufLabelCount) == (b->cmdBufLabelCount))) { onFail("a->cmdBufLabelCount (Error: Value not equal)"); };
    if (!((!(a->pCmdBufLabels) && !(b->pCmdBufLabels)) || ((a->pCmdBufLabels) && (b->pCmdBufLabels)))) { onFail("a->pCmdBufLabels (Error: Mismatch in optional field)"); };
    if (a->pCmdBufLabels && b->pCmdBufLabels)
    {
        if ((a->pCmdBufLabels) && (b->pCmdBufLabels))
        {
            if (!((a->cmdBufLabelCount) == (b->cmdBufLabelCount))) { onFail("a->pCmdBufLabels (Error: Lengths not equal)"); };
            if ((a->cmdBufLabelCount) == (b->cmdBufLabelCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->cmdBufLabelCount; ++i)
                    {
                        checkEqual_VkDebugUtilsLabelEXT(a->pCmdBufLabels + i, b->pCmdBufLabels + i, onFail);
                    }
                }
            }
        }
    }
    if (!((a->objectCount) == (b->objectCount))) { onFail("a->objectCount (Error: Value not equal)"); };
    if (!((!(a->pObjects) && !(b->pObjects)) || ((a->pObjects) && (b->pObjects)))) { onFail("a->pObjects (Error: Mismatch in optional field)"); };
    if (a->pObjects && b->pObjects)
    {
        if ((a->pObjects) && (b->pObjects))
        {
            if (!((a->objectCount) == (b->objectCount))) { onFail("a->pObjects (Error: Lengths not equal)"); };
            if ((a->objectCount) == (b->objectCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->objectCount; ++i)
                    {
                        checkEqual_VkDebugUtilsObjectNameInfoEXT(a->pObjects + i, b->pObjects + i, onFail);
                    }
                }
            }
        }
    }
}

void checkEqual_VkDebugUtilsMessengerCreateInfoEXT(
    const VkDebugUtilsMessengerCreateInfoEXT* a,
    const VkDebugUtilsMessengerCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->messageSeverity) == (b->messageSeverity))) { onFail("a->messageSeverity (Error: Value not equal)"); };
    if (!((a->messageType) == (b->messageType))) { onFail("a->messageType (Error: Value not equal)"); };
    if (!((a->pfnUserCallback) == (b->pfnUserCallback))) { onFail("a->pfnUserCallback (Error: Value not equal)"); };
    if (!((!(a->pUserData) && !(b->pUserData)) || ((a->pUserData) && (b->pUserData)))) { onFail("a->pUserData (Error: Mismatch in optional field)"); };
}

void checkEqual_VkDebugUtilsObjectTagInfoEXT(
    const VkDebugUtilsObjectTagInfoEXT* a,
    const VkDebugUtilsObjectTagInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->objectType) == (b->objectType))) { onFail("a->objectType (Error: Value not equal)"); };
    if (!((a->objectHandle) == (b->objectHandle))) { onFail("a->objectHandle (Error: Value not equal)"); };
    if (!((a->tagName) == (b->tagName))) { onFail("a->tagName (Error: Value not equal)"); };
    if (!((a->tagSize) == (b->tagSize))) { onFail("a->tagSize (Error: Value not equal)"); };
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void checkEqual_VkAndroidHardwareBufferUsageANDROID(
    const VkAndroidHardwareBufferUsageANDROID* a,
    const VkAndroidHardwareBufferUsageANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->androidHardwareBufferUsage) == (b->androidHardwareBufferUsage))) { onFail("a->androidHardwareBufferUsage (Error: Value not equal)"); };
}

void checkEqual_VkAndroidHardwareBufferPropertiesANDROID(
    const VkAndroidHardwareBufferPropertiesANDROID* a,
    const VkAndroidHardwareBufferPropertiesANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->allocationSize) == (b->allocationSize))) { onFail("a->allocationSize (Error: Value not equal)"); };
    if (!((a->memoryTypeBits) == (b->memoryTypeBits))) { onFail("a->memoryTypeBits (Error: Value not equal)"); };
}

void checkEqual_VkAndroidHardwareBufferFormatPropertiesANDROID(
    const VkAndroidHardwareBufferFormatPropertiesANDROID* a,
    const VkAndroidHardwareBufferFormatPropertiesANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->externalFormat) == (b->externalFormat))) { onFail("a->externalFormat (Error: Value not equal)"); };
    if (!((a->formatFeatures) == (b->formatFeatures))) { onFail("a->formatFeatures (Error: Value not equal)"); };
    checkEqual_VkComponentMapping(&a->samplerYcbcrConversionComponents, &b->samplerYcbcrConversionComponents, onFail);
    if (!((a->suggestedYcbcrModel) == (b->suggestedYcbcrModel))) { onFail("a->suggestedYcbcrModel (Error: Value not equal)"); };
    if (!((a->suggestedYcbcrRange) == (b->suggestedYcbcrRange))) { onFail("a->suggestedYcbcrRange (Error: Value not equal)"); };
    if (!((a->suggestedXChromaOffset) == (b->suggestedXChromaOffset))) { onFail("a->suggestedXChromaOffset (Error: Value not equal)"); };
    if (!((a->suggestedYChromaOffset) == (b->suggestedYChromaOffset))) { onFail("a->suggestedYChromaOffset (Error: Value not equal)"); };
}

void checkEqual_VkImportAndroidHardwareBufferInfoANDROID(
    const VkImportAndroidHardwareBufferInfoANDROID* a,
    const VkImportAndroidHardwareBufferInfoANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->buffer, b->buffer, sizeof(AHardwareBuffer)) == 0))) { onFail("a->buffer (Error: Unequal dyn array)"); };
}

void checkEqual_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* a,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
}

void checkEqual_VkExternalFormatANDROID(
    const VkExternalFormatANDROID* a,
    const VkExternalFormatANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->externalFormat) == (b->externalFormat))) { onFail("a->externalFormat (Error: Value not equal)"); };
}

void checkEqual_VkAndroidHardwareBufferFormatProperties2ANDROID(
    const VkAndroidHardwareBufferFormatProperties2ANDROID* a,
    const VkAndroidHardwareBufferFormatProperties2ANDROID* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->externalFormat) == (b->externalFormat))) { onFail("a->externalFormat (Error: Value not equal)"); };
    if (!((a->formatFeatures) == (b->formatFeatures))) { onFail("a->formatFeatures (Error: Value not equal)"); };
    checkEqual_VkComponentMapping(&a->samplerYcbcrConversionComponents, &b->samplerYcbcrConversionComponents, onFail);
    if (!((a->suggestedYcbcrModel) == (b->suggestedYcbcrModel))) { onFail("a->suggestedYcbcrModel (Error: Value not equal)"); };
    if (!((a->suggestedYcbcrRange) == (b->suggestedYcbcrRange))) { onFail("a->suggestedYcbcrRange (Error: Value not equal)"); };
    if (!((a->suggestedXChromaOffset) == (b->suggestedXChromaOffset))) { onFail("a->suggestedXChromaOffset (Error: Value not equal)"); };
    if (!((a->suggestedYChromaOffset) == (b->suggestedYChromaOffset))) { onFail("a->suggestedYChromaOffset (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_inline_uniform_block
void checkEqual_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(
    const VkPhysicalDeviceInlineUniformBlockFeaturesEXT* a,
    const VkPhysicalDeviceInlineUniformBlockFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->inlineUniformBlock) == (b->inlineUniformBlock))) { onFail("a->inlineUniformBlock (Error: Value not equal)"); };
    if (!((a->descriptorBindingInlineUniformBlockUpdateAfterBind) == (b->descriptorBindingInlineUniformBlockUpdateAfterBind))) { onFail("a->descriptorBindingInlineUniformBlockUpdateAfterBind (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(
    const VkPhysicalDeviceInlineUniformBlockPropertiesEXT* a,
    const VkPhysicalDeviceInlineUniformBlockPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxInlineUniformBlockSize) == (b->maxInlineUniformBlockSize))) { onFail("a->maxInlineUniformBlockSize (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorInlineUniformBlocks) == (b->maxPerStageDescriptorInlineUniformBlocks))) { onFail("a->maxPerStageDescriptorInlineUniformBlocks (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks) == (b->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks))) { onFail("a->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetInlineUniformBlocks) == (b->maxDescriptorSetInlineUniformBlocks))) { onFail("a->maxDescriptorSetInlineUniformBlocks (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindInlineUniformBlocks) == (b->maxDescriptorSetUpdateAfterBindInlineUniformBlocks))) { onFail("a->maxDescriptorSetUpdateAfterBindInlineUniformBlocks (Error: Value not equal)"); };
}

void checkEqual_VkWriteDescriptorSetInlineUniformBlockEXT(
    const VkWriteDescriptorSetInlineUniformBlockEXT* a,
    const VkWriteDescriptorSetInlineUniformBlockEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->dataSize) == (b->dataSize))) { onFail("a->dataSize (Error: Value not equal)"); };
}

void checkEqual_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(
    const VkDescriptorPoolInlineUniformBlockCreateInfoEXT* a,
    const VkDescriptorPoolInlineUniformBlockCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxInlineUniformBlockBindings) == (b->maxInlineUniformBlockBindings))) { onFail("a->maxInlineUniformBlockBindings (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void checkEqual_VkSampleLocationEXT(
    const VkSampleLocationEXT* a,
    const VkSampleLocationEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->x) == (b->x))) { onFail("a->x (Error: Value not equal)"); };
    if (!((a->y) == (b->y))) { onFail("a->y (Error: Value not equal)"); };
}

void checkEqual_VkSampleLocationsInfoEXT(
    const VkSampleLocationsInfoEXT* a,
    const VkSampleLocationsInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->sampleLocationsPerPixel) == (b->sampleLocationsPerPixel))) { onFail("a->sampleLocationsPerPixel (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->sampleLocationGridSize, &b->sampleLocationGridSize, onFail);
    if (!((a->sampleLocationsCount) == (b->sampleLocationsCount))) { onFail("a->sampleLocationsCount (Error: Value not equal)"); };
    if ((a->pSampleLocations) && (b->pSampleLocations))
    {
        if (!((a->sampleLocationsCount) == (b->sampleLocationsCount))) { onFail("a->pSampleLocations (Error: Lengths not equal)"); };
        if ((a->sampleLocationsCount) == (b->sampleLocationsCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->sampleLocationsCount; ++i)
                {
                    checkEqual_VkSampleLocationEXT(a->pSampleLocations + i, b->pSampleLocations + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkAttachmentSampleLocationsEXT(
    const VkAttachmentSampleLocationsEXT* a,
    const VkAttachmentSampleLocationsEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->attachmentIndex) == (b->attachmentIndex))) { onFail("a->attachmentIndex (Error: Value not equal)"); };
    checkEqual_VkSampleLocationsInfoEXT(&a->sampleLocationsInfo, &b->sampleLocationsInfo, onFail);
}

void checkEqual_VkSubpassSampleLocationsEXT(
    const VkSubpassSampleLocationsEXT* a,
    const VkSubpassSampleLocationsEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->subpassIndex) == (b->subpassIndex))) { onFail("a->subpassIndex (Error: Value not equal)"); };
    checkEqual_VkSampleLocationsInfoEXT(&a->sampleLocationsInfo, &b->sampleLocationsInfo, onFail);
}

void checkEqual_VkRenderPassSampleLocationsBeginInfoEXT(
    const VkRenderPassSampleLocationsBeginInfoEXT* a,
    const VkRenderPassSampleLocationsBeginInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->attachmentInitialSampleLocationsCount) == (b->attachmentInitialSampleLocationsCount))) { onFail("a->attachmentInitialSampleLocationsCount (Error: Value not equal)"); };
    if ((a->pAttachmentInitialSampleLocations) && (b->pAttachmentInitialSampleLocations))
    {
        if (!((a->attachmentInitialSampleLocationsCount) == (b->attachmentInitialSampleLocationsCount))) { onFail("a->pAttachmentInitialSampleLocations (Error: Lengths not equal)"); };
        if ((a->attachmentInitialSampleLocationsCount) == (b->attachmentInitialSampleLocationsCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->attachmentInitialSampleLocationsCount; ++i)
                {
                    checkEqual_VkAttachmentSampleLocationsEXT(a->pAttachmentInitialSampleLocations + i, b->pAttachmentInitialSampleLocations + i, onFail);
                }
            }
        }
    }
    if (!((a->postSubpassSampleLocationsCount) == (b->postSubpassSampleLocationsCount))) { onFail("a->postSubpassSampleLocationsCount (Error: Value not equal)"); };
    if ((a->pPostSubpassSampleLocations) && (b->pPostSubpassSampleLocations))
    {
        if (!((a->postSubpassSampleLocationsCount) == (b->postSubpassSampleLocationsCount))) { onFail("a->pPostSubpassSampleLocations (Error: Lengths not equal)"); };
        if ((a->postSubpassSampleLocationsCount) == (b->postSubpassSampleLocationsCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->postSubpassSampleLocationsCount; ++i)
                {
                    checkEqual_VkSubpassSampleLocationsEXT(a->pPostSubpassSampleLocations + i, b->pPostSubpassSampleLocations + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkPipelineSampleLocationsStateCreateInfoEXT(
    const VkPipelineSampleLocationsStateCreateInfoEXT* a,
    const VkPipelineSampleLocationsStateCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->sampleLocationsEnable) == (b->sampleLocationsEnable))) { onFail("a->sampleLocationsEnable (Error: Value not equal)"); };
    checkEqual_VkSampleLocationsInfoEXT(&a->sampleLocationsInfo, &b->sampleLocationsInfo, onFail);
}

void checkEqual_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    const VkPhysicalDeviceSampleLocationsPropertiesEXT* a,
    const VkPhysicalDeviceSampleLocationsPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->sampleLocationSampleCounts) == (b->sampleLocationSampleCounts))) { onFail("a->sampleLocationSampleCounts (Error: Value not equal)"); };
    checkEqual_VkExtent2D(&a->maxSampleLocationGridSize, &b->maxSampleLocationGridSize, onFail);
    if (!((memcmp(a->sampleLocationCoordinateRange, b->sampleLocationCoordinateRange, 2 * sizeof(float)) == 0))) { onFail("a->sampleLocationCoordinateRange (Error: Unequal static array)"); };
    if (!((a->sampleLocationSubPixelBits) == (b->sampleLocationSubPixelBits))) { onFail("a->sampleLocationSubPixelBits (Error: Value not equal)"); };
    if (!((a->variableSampleLocations) == (b->variableSampleLocations))) { onFail("a->variableSampleLocations (Error: Value not equal)"); };
}

void checkEqual_VkMultisamplePropertiesEXT(
    const VkMultisamplePropertiesEXT* a,
    const VkMultisamplePropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkExtent2D(&a->maxSampleLocationGridSize, &b->maxSampleLocationGridSize, onFail);
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void checkEqual_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* a,
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->advancedBlendCoherentOperations) == (b->advancedBlendCoherentOperations))) { onFail("a->advancedBlendCoherentOperations (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* a,
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->advancedBlendMaxColorAttachments) == (b->advancedBlendMaxColorAttachments))) { onFail("a->advancedBlendMaxColorAttachments (Error: Value not equal)"); };
    if (!((a->advancedBlendIndependentBlend) == (b->advancedBlendIndependentBlend))) { onFail("a->advancedBlendIndependentBlend (Error: Value not equal)"); };
    if (!((a->advancedBlendNonPremultipliedSrcColor) == (b->advancedBlendNonPremultipliedSrcColor))) { onFail("a->advancedBlendNonPremultipliedSrcColor (Error: Value not equal)"); };
    if (!((a->advancedBlendNonPremultipliedDstColor) == (b->advancedBlendNonPremultipliedDstColor))) { onFail("a->advancedBlendNonPremultipliedDstColor (Error: Value not equal)"); };
    if (!((a->advancedBlendCorrelatedOverlap) == (b->advancedBlendCorrelatedOverlap))) { onFail("a->advancedBlendCorrelatedOverlap (Error: Value not equal)"); };
    if (!((a->advancedBlendAllOperations) == (b->advancedBlendAllOperations))) { onFail("a->advancedBlendAllOperations (Error: Value not equal)"); };
}

void checkEqual_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT* a,
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->srcPremultiplied) == (b->srcPremultiplied))) { onFail("a->srcPremultiplied (Error: Value not equal)"); };
    if (!((a->dstPremultiplied) == (b->dstPremultiplied))) { onFail("a->dstPremultiplied (Error: Value not equal)"); };
    if (!((a->blendOverlap) == (b->blendOverlap))) { onFail("a->blendOverlap (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void checkEqual_VkPipelineCoverageToColorStateCreateInfoNV(
    const VkPipelineCoverageToColorStateCreateInfoNV* a,
    const VkPipelineCoverageToColorStateCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->coverageToColorEnable) == (b->coverageToColorEnable))) { onFail("a->coverageToColorEnable (Error: Value not equal)"); };
    if (!((a->coverageToColorLocation) == (b->coverageToColorLocation))) { onFail("a->coverageToColorLocation (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void checkEqual_VkPipelineCoverageModulationStateCreateInfoNV(
    const VkPipelineCoverageModulationStateCreateInfoNV* a,
    const VkPipelineCoverageModulationStateCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->coverageModulationMode) == (b->coverageModulationMode))) { onFail("a->coverageModulationMode (Error: Value not equal)"); };
    if (!((a->coverageModulationTableEnable) == (b->coverageModulationTableEnable))) { onFail("a->coverageModulationTableEnable (Error: Value not equal)"); };
    if (!((a->coverageModulationTableCount) == (b->coverageModulationTableCount))) { onFail("a->coverageModulationTableCount (Error: Value not equal)"); };
    if (!((!(a->pCoverageModulationTable) && !(b->pCoverageModulationTable)) || ((a->pCoverageModulationTable) && (b->pCoverageModulationTable)))) { onFail("a->pCoverageModulationTable (Error: Mismatch in optional field)"); };
    if (a->pCoverageModulationTable && b->pCoverageModulationTable)
    {
        if (!((a->coverageModulationTableCount) == (b->coverageModulationTableCount))) { onFail("a->pCoverageModulationTable (Error: Lengths not equal)"); };
        if (!((memcmp(a->pCoverageModulationTable, b->pCoverageModulationTable, a->coverageModulationTableCount * sizeof(const float)) == 0))) { onFail("a->pCoverageModulationTable (Error: Unequal dyn array)"); };
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_NV_shader_sm_builtins
void checkEqual_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(
    const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* a,
    const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderSMCount) == (b->shaderSMCount))) { onFail("a->shaderSMCount (Error: Value not equal)"); };
    if (!((a->shaderWarpsPerSM) == (b->shaderWarpsPerSM))) { onFail("a->shaderWarpsPerSM (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(
    const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* a,
    const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderSMBuiltins) == (b->shaderSMBuiltins))) { onFail("a->shaderSMBuiltins (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_image_drm_format_modifier
void checkEqual_VkDrmFormatModifierPropertiesEXT(
    const VkDrmFormatModifierPropertiesEXT* a,
    const VkDrmFormatModifierPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->drmFormatModifier) == (b->drmFormatModifier))) { onFail("a->drmFormatModifier (Error: Value not equal)"); };
    if (!((a->drmFormatModifierPlaneCount) == (b->drmFormatModifierPlaneCount))) { onFail("a->drmFormatModifierPlaneCount (Error: Value not equal)"); };
    if (!((a->drmFormatModifierTilingFeatures) == (b->drmFormatModifierTilingFeatures))) { onFail("a->drmFormatModifierTilingFeatures (Error: Value not equal)"); };
}

void checkEqual_VkDrmFormatModifierPropertiesListEXT(
    const VkDrmFormatModifierPropertiesListEXT* a,
    const VkDrmFormatModifierPropertiesListEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->drmFormatModifierCount) == (b->drmFormatModifierCount))) { onFail("a->drmFormatModifierCount (Error: Value not equal)"); };
    if (!((!(a->pDrmFormatModifierProperties) && !(b->pDrmFormatModifierProperties)) || ((a->pDrmFormatModifierProperties) && (b->pDrmFormatModifierProperties)))) { onFail("a->pDrmFormatModifierProperties (Error: Mismatch in optional field)"); };
    if (a->pDrmFormatModifierProperties && b->pDrmFormatModifierProperties)
    {
        if ((a->pDrmFormatModifierProperties) && (b->pDrmFormatModifierProperties))
        {
            if (!((a->drmFormatModifierCount) == (b->drmFormatModifierCount))) { onFail("a->pDrmFormatModifierProperties (Error: Lengths not equal)"); };
            if ((a->drmFormatModifierCount) == (b->drmFormatModifierCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->drmFormatModifierCount; ++i)
                    {
                        checkEqual_VkDrmFormatModifierPropertiesEXT(a->pDrmFormatModifierProperties + i, b->pDrmFormatModifierProperties + i, onFail);
                    }
                }
            }
        }
    }
}

void checkEqual_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(
    const VkPhysicalDeviceImageDrmFormatModifierInfoEXT* a,
    const VkPhysicalDeviceImageDrmFormatModifierInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->drmFormatModifier) == (b->drmFormatModifier))) { onFail("a->drmFormatModifier (Error: Value not equal)"); };
    if (!((a->sharingMode) == (b->sharingMode))) { onFail("a->sharingMode (Error: Value not equal)"); };
    if (!((a->queueFamilyIndexCount) == (b->queueFamilyIndexCount))) { onFail("a->queueFamilyIndexCount (Error: Value not equal)"); };
    if (!((!(a->pQueueFamilyIndices) && !(b->pQueueFamilyIndices)) || ((a->pQueueFamilyIndices) && (b->pQueueFamilyIndices)))) { onFail("a->pQueueFamilyIndices (Error: Mismatch in optional field)"); };
    if (a->pQueueFamilyIndices && b->pQueueFamilyIndices)
    {
        if (!((a->queueFamilyIndexCount) == (b->queueFamilyIndexCount))) { onFail("a->pQueueFamilyIndices (Error: Lengths not equal)"); };
        if (!((memcmp(a->pQueueFamilyIndices, b->pQueueFamilyIndices, a->queueFamilyIndexCount * sizeof(const uint32_t)) == 0))) { onFail("a->pQueueFamilyIndices (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkImageDrmFormatModifierListCreateInfoEXT(
    const VkImageDrmFormatModifierListCreateInfoEXT* a,
    const VkImageDrmFormatModifierListCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->drmFormatModifierCount) == (b->drmFormatModifierCount))) { onFail("a->drmFormatModifierCount (Error: Value not equal)"); };
    if (!((a->drmFormatModifierCount) == (b->drmFormatModifierCount))) { onFail("a->pDrmFormatModifiers (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDrmFormatModifiers, b->pDrmFormatModifiers, a->drmFormatModifierCount * sizeof(const uint64_t)) == 0))) { onFail("a->pDrmFormatModifiers (Error: Unequal dyn array)"); };
}

void checkEqual_VkImageDrmFormatModifierExplicitCreateInfoEXT(
    const VkImageDrmFormatModifierExplicitCreateInfoEXT* a,
    const VkImageDrmFormatModifierExplicitCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->drmFormatModifier) == (b->drmFormatModifier))) { onFail("a->drmFormatModifier (Error: Value not equal)"); };
    if (!((a->drmFormatModifierPlaneCount) == (b->drmFormatModifierPlaneCount))) { onFail("a->drmFormatModifierPlaneCount (Error: Value not equal)"); };
    if ((a->pPlaneLayouts) && (b->pPlaneLayouts))
    {
        if (!((a->drmFormatModifierPlaneCount) == (b->drmFormatModifierPlaneCount))) { onFail("a->pPlaneLayouts (Error: Lengths not equal)"); };
        if ((a->drmFormatModifierPlaneCount) == (b->drmFormatModifierPlaneCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->drmFormatModifierPlaneCount; ++i)
                {
                    checkEqual_VkSubresourceLayout(a->pPlaneLayouts + i, b->pPlaneLayouts + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkImageDrmFormatModifierPropertiesEXT(
    const VkImageDrmFormatModifierPropertiesEXT* a,
    const VkImageDrmFormatModifierPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->drmFormatModifier) == (b->drmFormatModifier))) { onFail("a->drmFormatModifier (Error: Value not equal)"); };
}

void checkEqual_VkDrmFormatModifierProperties2EXT(
    const VkDrmFormatModifierProperties2EXT* a,
    const VkDrmFormatModifierProperties2EXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->drmFormatModifier) == (b->drmFormatModifier))) { onFail("a->drmFormatModifier (Error: Value not equal)"); };
    if (!((a->drmFormatModifierPlaneCount) == (b->drmFormatModifierPlaneCount))) { onFail("a->drmFormatModifierPlaneCount (Error: Value not equal)"); };
    if (!((a->drmFormatModifierTilingFeatures) == (b->drmFormatModifierTilingFeatures))) { onFail("a->drmFormatModifierTilingFeatures (Error: Value not equal)"); };
}

void checkEqual_VkDrmFormatModifierPropertiesList2EXT(
    const VkDrmFormatModifierPropertiesList2EXT* a,
    const VkDrmFormatModifierPropertiesList2EXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->drmFormatModifierCount) == (b->drmFormatModifierCount))) { onFail("a->drmFormatModifierCount (Error: Value not equal)"); };
    if (!((!(a->pDrmFormatModifierProperties) && !(b->pDrmFormatModifierProperties)) || ((a->pDrmFormatModifierProperties) && (b->pDrmFormatModifierProperties)))) { onFail("a->pDrmFormatModifierProperties (Error: Mismatch in optional field)"); };
    if (a->pDrmFormatModifierProperties && b->pDrmFormatModifierProperties)
    {
        if ((a->pDrmFormatModifierProperties) && (b->pDrmFormatModifierProperties))
        {
            if (!((a->drmFormatModifierCount) == (b->drmFormatModifierCount))) { onFail("a->pDrmFormatModifierProperties (Error: Lengths not equal)"); };
            if ((a->drmFormatModifierCount) == (b->drmFormatModifierCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->drmFormatModifierCount; ++i)
                    {
                        checkEqual_VkDrmFormatModifierProperties2EXT(a->pDrmFormatModifierProperties + i, b->pDrmFormatModifierProperties + i, onFail);
                    }
                }
            }
        }
    }
}

#endif
#ifdef VK_EXT_validation_cache
void checkEqual_VkValidationCacheCreateInfoEXT(
    const VkValidationCacheCreateInfoEXT* a,
    const VkValidationCacheCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->initialDataSize) == (b->initialDataSize))) { onFail("a->initialDataSize (Error: Value not equal)"); };
}

void checkEqual_VkShaderModuleValidationCacheCreateInfoEXT(
    const VkShaderModuleValidationCacheCreateInfoEXT* a,
    const VkShaderModuleValidationCacheCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->validationCache) == (b->validationCache))) { onFail("a->validationCache (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_NV_shading_rate_image
void checkEqual_VkShadingRatePaletteNV(
    const VkShadingRatePaletteNV* a,
    const VkShadingRatePaletteNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->shadingRatePaletteEntryCount) == (b->shadingRatePaletteEntryCount))) { onFail("a->shadingRatePaletteEntryCount (Error: Value not equal)"); };
    if (!((a->shadingRatePaletteEntryCount) == (b->shadingRatePaletteEntryCount))) { onFail("a->pShadingRatePaletteEntries (Error: Lengths not equal)"); };
    if (!((memcmp(a->pShadingRatePaletteEntries, b->pShadingRatePaletteEntries, a->shadingRatePaletteEntryCount * sizeof(const VkShadingRatePaletteEntryNV)) == 0))) { onFail("a->pShadingRatePaletteEntries (Error: Unequal dyn array)"); };
}

void checkEqual_VkPipelineViewportShadingRateImageStateCreateInfoNV(
    const VkPipelineViewportShadingRateImageStateCreateInfoNV* a,
    const VkPipelineViewportShadingRateImageStateCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shadingRateImageEnable) == (b->shadingRateImageEnable))) { onFail("a->shadingRateImageEnable (Error: Value not equal)"); };
    if (!((a->viewportCount) == (b->viewportCount))) { onFail("a->viewportCount (Error: Value not equal)"); };
    if (!((!(a->pShadingRatePalettes) && !(b->pShadingRatePalettes)) || ((a->pShadingRatePalettes) && (b->pShadingRatePalettes)))) { onFail("a->pShadingRatePalettes (Error: Mismatch in optional field)"); };
    if (a->pShadingRatePalettes && b->pShadingRatePalettes)
    {
        if ((a->pShadingRatePalettes) && (b->pShadingRatePalettes))
        {
            if (!((a->viewportCount) == (b->viewportCount))) { onFail("a->pShadingRatePalettes (Error: Lengths not equal)"); };
            if ((a->viewportCount) == (b->viewportCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->viewportCount; ++i)
                    {
                        checkEqual_VkShadingRatePaletteNV(a->pShadingRatePalettes + i, b->pShadingRatePalettes + i, onFail);
                    }
                }
            }
        }
    }
}

void checkEqual_VkPhysicalDeviceShadingRateImageFeaturesNV(
    const VkPhysicalDeviceShadingRateImageFeaturesNV* a,
    const VkPhysicalDeviceShadingRateImageFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shadingRateImage) == (b->shadingRateImage))) { onFail("a->shadingRateImage (Error: Value not equal)"); };
    if (!((a->shadingRateCoarseSampleOrder) == (b->shadingRateCoarseSampleOrder))) { onFail("a->shadingRateCoarseSampleOrder (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceShadingRateImagePropertiesNV(
    const VkPhysicalDeviceShadingRateImagePropertiesNV* a,
    const VkPhysicalDeviceShadingRateImagePropertiesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkExtent2D(&a->shadingRateTexelSize, &b->shadingRateTexelSize, onFail);
    if (!((a->shadingRatePaletteSize) == (b->shadingRatePaletteSize))) { onFail("a->shadingRatePaletteSize (Error: Value not equal)"); };
    if (!((a->shadingRateMaxCoarseSamples) == (b->shadingRateMaxCoarseSamples))) { onFail("a->shadingRateMaxCoarseSamples (Error: Value not equal)"); };
}

void checkEqual_VkCoarseSampleLocationNV(
    const VkCoarseSampleLocationNV* a,
    const VkCoarseSampleLocationNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->pixelX) == (b->pixelX))) { onFail("a->pixelX (Error: Value not equal)"); };
    if (!((a->pixelY) == (b->pixelY))) { onFail("a->pixelY (Error: Value not equal)"); };
    if (!((a->sample) == (b->sample))) { onFail("a->sample (Error: Value not equal)"); };
}

void checkEqual_VkCoarseSampleOrderCustomNV(
    const VkCoarseSampleOrderCustomNV* a,
    const VkCoarseSampleOrderCustomNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->shadingRate) == (b->shadingRate))) { onFail("a->shadingRate (Error: Value not equal)"); };
    if (!((a->sampleCount) == (b->sampleCount))) { onFail("a->sampleCount (Error: Value not equal)"); };
    if (!((a->sampleLocationCount) == (b->sampleLocationCount))) { onFail("a->sampleLocationCount (Error: Value not equal)"); };
    if ((a->pSampleLocations) && (b->pSampleLocations))
    {
        if (!((a->sampleLocationCount) == (b->sampleLocationCount))) { onFail("a->pSampleLocations (Error: Lengths not equal)"); };
        if ((a->sampleLocationCount) == (b->sampleLocationCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->sampleLocationCount; ++i)
                {
                    checkEqual_VkCoarseSampleLocationNV(a->pSampleLocations + i, b->pSampleLocations + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(
    const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* a,
    const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->sampleOrderType) == (b->sampleOrderType))) { onFail("a->sampleOrderType (Error: Value not equal)"); };
    if (!((a->customSampleOrderCount) == (b->customSampleOrderCount))) { onFail("a->customSampleOrderCount (Error: Value not equal)"); };
    if ((a->pCustomSampleOrders) && (b->pCustomSampleOrders))
    {
        if (!((a->customSampleOrderCount) == (b->customSampleOrderCount))) { onFail("a->pCustomSampleOrders (Error: Lengths not equal)"); };
        if ((a->customSampleOrderCount) == (b->customSampleOrderCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->customSampleOrderCount; ++i)
                {
                    checkEqual_VkCoarseSampleOrderCustomNV(a->pCustomSampleOrders + i, b->pCustomSampleOrders + i, onFail);
                }
            }
        }
    }
}

#endif
#ifdef VK_NV_ray_tracing
void checkEqual_VkRayTracingShaderGroupCreateInfoNV(
    const VkRayTracingShaderGroupCreateInfoNV* a,
    const VkRayTracingShaderGroupCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->generalShader) == (b->generalShader))) { onFail("a->generalShader (Error: Value not equal)"); };
    if (!((a->closestHitShader) == (b->closestHitShader))) { onFail("a->closestHitShader (Error: Value not equal)"); };
    if (!((a->anyHitShader) == (b->anyHitShader))) { onFail("a->anyHitShader (Error: Value not equal)"); };
    if (!((a->intersectionShader) == (b->intersectionShader))) { onFail("a->intersectionShader (Error: Value not equal)"); };
}

void checkEqual_VkRayTracingPipelineCreateInfoNV(
    const VkRayTracingPipelineCreateInfoNV* a,
    const VkRayTracingPipelineCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->stageCount) == (b->stageCount))) { onFail("a->stageCount (Error: Value not equal)"); };
    if ((a->pStages) && (b->pStages))
    {
        if (!((a->stageCount) == (b->stageCount))) { onFail("a->pStages (Error: Lengths not equal)"); };
        if ((a->stageCount) == (b->stageCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->stageCount; ++i)
                {
                    checkEqual_VkPipelineShaderStageCreateInfo(a->pStages + i, b->pStages + i, onFail);
                }
            }
        }
    }
    if (!((a->groupCount) == (b->groupCount))) { onFail("a->groupCount (Error: Value not equal)"); };
    if ((a->pGroups) && (b->pGroups))
    {
        if (!((a->groupCount) == (b->groupCount))) { onFail("a->pGroups (Error: Lengths not equal)"); };
        if ((a->groupCount) == (b->groupCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->groupCount; ++i)
                {
                    checkEqual_VkRayTracingShaderGroupCreateInfoNV(a->pGroups + i, b->pGroups + i, onFail);
                }
            }
        }
    }
    if (!((a->maxRecursionDepth) == (b->maxRecursionDepth))) { onFail("a->maxRecursionDepth (Error: Value not equal)"); };
    if (!((a->layout) == (b->layout))) { onFail("a->layout (Error: Value not equal)"); };
    if (!((a->basePipelineHandle) == (b->basePipelineHandle))) { onFail("a->basePipelineHandle (Error: Value not equal)"); };
    if (!((a->basePipelineIndex) == (b->basePipelineIndex))) { onFail("a->basePipelineIndex (Error: Value not equal)"); };
}

void checkEqual_VkGeometryTrianglesNV(
    const VkGeometryTrianglesNV* a,
    const VkGeometryTrianglesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->vertexData) == (b->vertexData))) { onFail("a->vertexData (Error: Value not equal)"); };
    if (!((a->vertexOffset) == (b->vertexOffset))) { onFail("a->vertexOffset (Error: Value not equal)"); };
    if (!((a->vertexCount) == (b->vertexCount))) { onFail("a->vertexCount (Error: Value not equal)"); };
    if (!((a->vertexStride) == (b->vertexStride))) { onFail("a->vertexStride (Error: Value not equal)"); };
    if (!((a->vertexFormat) == (b->vertexFormat))) { onFail("a->vertexFormat (Error: Value not equal)"); };
    if (!((a->indexData) == (b->indexData))) { onFail("a->indexData (Error: Value not equal)"); };
    if (!((a->indexOffset) == (b->indexOffset))) { onFail("a->indexOffset (Error: Value not equal)"); };
    if (!((a->indexCount) == (b->indexCount))) { onFail("a->indexCount (Error: Value not equal)"); };
    if (!((a->indexType) == (b->indexType))) { onFail("a->indexType (Error: Value not equal)"); };
    if (!((a->transformData) == (b->transformData))) { onFail("a->transformData (Error: Value not equal)"); };
    if (!((a->transformOffset) == (b->transformOffset))) { onFail("a->transformOffset (Error: Value not equal)"); };
}

void checkEqual_VkGeometryAABBNV(
    const VkGeometryAABBNV* a,
    const VkGeometryAABBNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->aabbData) == (b->aabbData))) { onFail("a->aabbData (Error: Value not equal)"); };
    if (!((a->numAABBs) == (b->numAABBs))) { onFail("a->numAABBs (Error: Value not equal)"); };
    if (!((a->stride) == (b->stride))) { onFail("a->stride (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
}

void checkEqual_VkGeometryDataNV(
    const VkGeometryDataNV* a,
    const VkGeometryDataNV* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkGeometryTrianglesNV(&a->triangles, &b->triangles, onFail);
    checkEqual_VkGeometryAABBNV(&a->aabbs, &b->aabbs, onFail);
}

void checkEqual_VkGeometryNV(
    const VkGeometryNV* a,
    const VkGeometryNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->geometryType) == (b->geometryType))) { onFail("a->geometryType (Error: Value not equal)"); };
    checkEqual_VkGeometryDataNV(&a->geometry, &b->geometry, onFail);
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkAccelerationStructureInfoNV(
    const VkAccelerationStructureInfoNV* a,
    const VkAccelerationStructureInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->instanceCount) == (b->instanceCount))) { onFail("a->instanceCount (Error: Value not equal)"); };
    if (!((a->geometryCount) == (b->geometryCount))) { onFail("a->geometryCount (Error: Value not equal)"); };
    if ((a->pGeometries) && (b->pGeometries))
    {
        if (!((a->geometryCount) == (b->geometryCount))) { onFail("a->pGeometries (Error: Lengths not equal)"); };
        if ((a->geometryCount) == (b->geometryCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->geometryCount; ++i)
                {
                    checkEqual_VkGeometryNV(a->pGeometries + i, b->pGeometries + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkAccelerationStructureCreateInfoNV(
    const VkAccelerationStructureCreateInfoNV* a,
    const VkAccelerationStructureCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->compactedSize) == (b->compactedSize))) { onFail("a->compactedSize (Error: Value not equal)"); };
    checkEqual_VkAccelerationStructureInfoNV(&a->info, &b->info, onFail);
}

void checkEqual_VkBindAccelerationStructureMemoryInfoNV(
    const VkBindAccelerationStructureMemoryInfoNV* a,
    const VkBindAccelerationStructureMemoryInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->accelerationStructure) == (b->accelerationStructure))) { onFail("a->accelerationStructure (Error: Value not equal)"); };
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->memoryOffset) == (b->memoryOffset))) { onFail("a->memoryOffset (Error: Value not equal)"); };
    if (!((a->deviceIndexCount) == (b->deviceIndexCount))) { onFail("a->deviceIndexCount (Error: Value not equal)"); };
    if (!((a->deviceIndexCount) == (b->deviceIndexCount))) { onFail("a->pDeviceIndices (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDeviceIndices, b->pDeviceIndices, a->deviceIndexCount * sizeof(const uint32_t)) == 0))) { onFail("a->pDeviceIndices (Error: Unequal dyn array)"); };
}

void checkEqual_VkWriteDescriptorSetAccelerationStructureNV(
    const VkWriteDescriptorSetAccelerationStructureNV* a,
    const VkWriteDescriptorSetAccelerationStructureNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->accelerationStructureCount) == (b->accelerationStructureCount))) { onFail("a->accelerationStructureCount (Error: Value not equal)"); };
    if (!((!(a->pAccelerationStructures) && !(b->pAccelerationStructures)) || ((a->pAccelerationStructures) && (b->pAccelerationStructures)))) { onFail("a->pAccelerationStructures (Error: Mismatch in optional field)"); };
    if (a->pAccelerationStructures && b->pAccelerationStructures)
    {
        if (!((a->accelerationStructureCount) == (b->accelerationStructureCount))) { onFail("a->pAccelerationStructures (Error: Lengths not equal)"); };
        if (!((memcmp(a->pAccelerationStructures, b->pAccelerationStructures, a->accelerationStructureCount * sizeof(const VkAccelerationStructureNV)) == 0))) { onFail("a->pAccelerationStructures (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkAccelerationStructureMemoryRequirementsInfoNV(
    const VkAccelerationStructureMemoryRequirementsInfoNV* a,
    const VkAccelerationStructureMemoryRequirementsInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->accelerationStructure) == (b->accelerationStructure))) { onFail("a->accelerationStructure (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceRayTracingPropertiesNV(
    const VkPhysicalDeviceRayTracingPropertiesNV* a,
    const VkPhysicalDeviceRayTracingPropertiesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderGroupHandleSize) == (b->shaderGroupHandleSize))) { onFail("a->shaderGroupHandleSize (Error: Value not equal)"); };
    if (!((a->maxRecursionDepth) == (b->maxRecursionDepth))) { onFail("a->maxRecursionDepth (Error: Value not equal)"); };
    if (!((a->maxShaderGroupStride) == (b->maxShaderGroupStride))) { onFail("a->maxShaderGroupStride (Error: Value not equal)"); };
    if (!((a->shaderGroupBaseAlignment) == (b->shaderGroupBaseAlignment))) { onFail("a->shaderGroupBaseAlignment (Error: Value not equal)"); };
    if (!((a->maxGeometryCount) == (b->maxGeometryCount))) { onFail("a->maxGeometryCount (Error: Value not equal)"); };
    if (!((a->maxInstanceCount) == (b->maxInstanceCount))) { onFail("a->maxInstanceCount (Error: Value not equal)"); };
    if (!((a->maxTriangleCount) == (b->maxTriangleCount))) { onFail("a->maxTriangleCount (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetAccelerationStructures) == (b->maxDescriptorSetAccelerationStructures))) { onFail("a->maxDescriptorSetAccelerationStructures (Error: Value not equal)"); };
}

void checkEqual_VkTransformMatrixKHR(
    const VkTransformMatrixKHR* a,
    const VkTransformMatrixKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((memcmp(a->matrix, b->matrix, ((3)*(4)) * sizeof(float)) == 0))) { onFail("a->matrix (Error: Unequal static array)"); };
}

void checkEqual_VkAabbPositionsKHR(
    const VkAabbPositionsKHR* a,
    const VkAabbPositionsKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->minX) == (b->minX))) { onFail("a->minX (Error: Value not equal)"); };
    if (!((a->minY) == (b->minY))) { onFail("a->minY (Error: Value not equal)"); };
    if (!((a->minZ) == (b->minZ))) { onFail("a->minZ (Error: Value not equal)"); };
    if (!((a->maxX) == (b->maxX))) { onFail("a->maxX (Error: Value not equal)"); };
    if (!((a->maxY) == (b->maxY))) { onFail("a->maxY (Error: Value not equal)"); };
    if (!((a->maxZ) == (b->maxZ))) { onFail("a->maxZ (Error: Value not equal)"); };
}

void checkEqual_VkAccelerationStructureInstanceKHR(
    const VkAccelerationStructureInstanceKHR* a,
    const VkAccelerationStructureInstanceKHR* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkTransformMatrixKHR(&a->transform, &b->transform, onFail);
    if (!((a->instanceCustomIndex) == (b->instanceCustomIndex))) { onFail("a->instanceCustomIndex (Error: Value not equal)"); };
    if (!((a->mask) == (b->mask))) { onFail("a->mask (Error: Value not equal)"); };
    if (!((a->instanceShaderBindingTableRecordOffset) == (b->instanceShaderBindingTableRecordOffset))) { onFail("a->instanceShaderBindingTableRecordOffset (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->accelerationStructureReference) == (b->accelerationStructureReference))) { onFail("a->accelerationStructureReference (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_representative_fragment_test
void checkEqual_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(
    const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* a,
    const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->representativeFragmentTest) == (b->representativeFragmentTest))) { onFail("a->representativeFragmentTest (Error: Value not equal)"); };
}

void checkEqual_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(
    const VkPipelineRepresentativeFragmentTestStateCreateInfoNV* a,
    const VkPipelineRepresentativeFragmentTestStateCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->representativeFragmentTestEnable) == (b->representativeFragmentTestEnable))) { onFail("a->representativeFragmentTestEnable (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_filter_cubic
void checkEqual_VkPhysicalDeviceImageViewImageFormatInfoEXT(
    const VkPhysicalDeviceImageViewImageFormatInfoEXT* a,
    const VkPhysicalDeviceImageViewImageFormatInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->imageViewType) == (b->imageViewType))) { onFail("a->imageViewType (Error: Value not equal)"); };
}

void checkEqual_VkFilterCubicImageViewImageFormatPropertiesEXT(
    const VkFilterCubicImageViewImageFormatPropertiesEXT* a,
    const VkFilterCubicImageViewImageFormatPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->filterCubic) == (b->filterCubic))) { onFail("a->filterCubic (Error: Value not equal)"); };
    if (!((a->filterCubicMinmax) == (b->filterCubicMinmax))) { onFail("a->filterCubicMinmax (Error: Value not equal)"); };
}

#endif
#ifdef VK_QCOM_render_pass_shader_resolve
#endif
#ifdef VK_EXT_global_priority
void checkEqual_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    const VkDeviceQueueGlobalPriorityCreateInfoEXT* a,
    const VkDeviceQueueGlobalPriorityCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->globalPriority) == (b->globalPriority))) { onFail("a->globalPriority (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_external_memory_host
void checkEqual_VkImportMemoryHostPointerInfoEXT(
    const VkImportMemoryHostPointerInfoEXT* a,
    const VkImportMemoryHostPointerInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((!(a->pHostPointer) && !(b->pHostPointer)) || ((a->pHostPointer) && (b->pHostPointer)))) { onFail("a->pHostPointer (Error: Mismatch in optional field)"); };
}

void checkEqual_VkMemoryHostPointerPropertiesEXT(
    const VkMemoryHostPointerPropertiesEXT* a,
    const VkMemoryHostPointerPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memoryTypeBits) == (b->memoryTypeBits))) { onFail("a->memoryTypeBits (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* a,
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->minImportedHostPointerAlignment) == (b->minImportedHostPointerAlignment))) { onFail("a->minImportedHostPointerAlignment (Error: Value not equal)"); };
}

#endif
#ifdef VK_AMD_buffer_marker
#endif
#ifdef VK_AMD_pipeline_compiler_control
void checkEqual_VkPipelineCompilerControlCreateInfoAMD(
    const VkPipelineCompilerControlCreateInfoAMD* a,
    const VkPipelineCompilerControlCreateInfoAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->compilerControlFlags) == (b->compilerControlFlags))) { onFail("a->compilerControlFlags (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_calibrated_timestamps
void checkEqual_VkCalibratedTimestampInfoEXT(
    const VkCalibratedTimestampInfoEXT* a,
    const VkCalibratedTimestampInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->timeDomain) == (b->timeDomain))) { onFail("a->timeDomain (Error: Value not equal)"); };
}

#endif
#ifdef VK_AMD_shader_core_properties
void checkEqual_VkPhysicalDeviceShaderCorePropertiesAMD(
    const VkPhysicalDeviceShaderCorePropertiesAMD* a,
    const VkPhysicalDeviceShaderCorePropertiesAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderEngineCount) == (b->shaderEngineCount))) { onFail("a->shaderEngineCount (Error: Value not equal)"); };
    if (!((a->shaderArraysPerEngineCount) == (b->shaderArraysPerEngineCount))) { onFail("a->shaderArraysPerEngineCount (Error: Value not equal)"); };
    if (!((a->computeUnitsPerShaderArray) == (b->computeUnitsPerShaderArray))) { onFail("a->computeUnitsPerShaderArray (Error: Value not equal)"); };
    if (!((a->simdPerComputeUnit) == (b->simdPerComputeUnit))) { onFail("a->simdPerComputeUnit (Error: Value not equal)"); };
    if (!((a->wavefrontsPerSimd) == (b->wavefrontsPerSimd))) { onFail("a->wavefrontsPerSimd (Error: Value not equal)"); };
    if (!((a->wavefrontSize) == (b->wavefrontSize))) { onFail("a->wavefrontSize (Error: Value not equal)"); };
    if (!((a->sgprsPerSimd) == (b->sgprsPerSimd))) { onFail("a->sgprsPerSimd (Error: Value not equal)"); };
    if (!((a->minSgprAllocation) == (b->minSgprAllocation))) { onFail("a->minSgprAllocation (Error: Value not equal)"); };
    if (!((a->maxSgprAllocation) == (b->maxSgprAllocation))) { onFail("a->maxSgprAllocation (Error: Value not equal)"); };
    if (!((a->sgprAllocationGranularity) == (b->sgprAllocationGranularity))) { onFail("a->sgprAllocationGranularity (Error: Value not equal)"); };
    if (!((a->vgprsPerSimd) == (b->vgprsPerSimd))) { onFail("a->vgprsPerSimd (Error: Value not equal)"); };
    if (!((a->minVgprAllocation) == (b->minVgprAllocation))) { onFail("a->minVgprAllocation (Error: Value not equal)"); };
    if (!((a->maxVgprAllocation) == (b->maxVgprAllocation))) { onFail("a->maxVgprAllocation (Error: Value not equal)"); };
    if (!((a->vgprAllocationGranularity) == (b->vgprAllocationGranularity))) { onFail("a->vgprAllocationGranularity (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_video_decode_h265
void checkEqual_VkVideoDecodeH265ProfileEXT(
    const VkVideoDecodeH265ProfileEXT* a,
    const VkVideoDecodeH265ProfileEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->stdProfileIdc) == (b->stdProfileIdc))) { onFail("a->stdProfileIdc (Error: Value not equal)"); };
}

void checkEqual_VkVideoDecodeH265CapabilitiesEXT(
    const VkVideoDecodeH265CapabilitiesEXT* a,
    const VkVideoDecodeH265CapabilitiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxLevel) == (b->maxLevel))) { onFail("a->maxLevel (Error: Value not equal)"); };
    checkEqual_VkExtensionProperties(&a->stdExtensionVersion, &b->stdExtensionVersion, onFail);
}

void checkEqual_VkVideoDecodeH265SessionCreateInfoEXT(
    const VkVideoDecodeH265SessionCreateInfoEXT* a,
    const VkVideoDecodeH265SessionCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if ((a->pStdExtensionVersion) && (b->pStdExtensionVersion))
    {
        checkEqual_VkExtensionProperties(a->pStdExtensionVersion, b->pStdExtensionVersion, onFail);
    }
}

void checkEqual_VkVideoDecodeH265SessionParametersAddInfoEXT(
    const VkVideoDecodeH265SessionParametersAddInfoEXT* a,
    const VkVideoDecodeH265SessionParametersAddInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->spsStdCount) == (b->spsStdCount))) { onFail("a->spsStdCount (Error: Value not equal)"); };
    if (!((!(a->pSpsStd) && !(b->pSpsStd)) || ((a->pSpsStd) && (b->pSpsStd)))) { onFail("a->pSpsStd (Error: Mismatch in optional field)"); };
    if (a->pSpsStd && b->pSpsStd)
    {
        if (!((a->spsStdCount) == (b->spsStdCount))) { onFail("a->pSpsStd (Error: Lengths not equal)"); };
        if (!((memcmp(a->pSpsStd, b->pSpsStd, a->spsStdCount * sizeof(const StdVideoH265SequenceParameterSet)) == 0))) { onFail("a->pSpsStd (Error: Unequal dyn array)"); };
    }
    if (!((a->ppsStdCount) == (b->ppsStdCount))) { onFail("a->ppsStdCount (Error: Value not equal)"); };
    if (!((!(a->pPpsStd) && !(b->pPpsStd)) || ((a->pPpsStd) && (b->pPpsStd)))) { onFail("a->pPpsStd (Error: Mismatch in optional field)"); };
    if (a->pPpsStd && b->pPpsStd)
    {
        if (!((a->ppsStdCount) == (b->ppsStdCount))) { onFail("a->pPpsStd (Error: Lengths not equal)"); };
        if (!((memcmp(a->pPpsStd, b->pPpsStd, a->ppsStdCount * sizeof(const StdVideoH265PictureParameterSet)) == 0))) { onFail("a->pPpsStd (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkVideoDecodeH265SessionParametersCreateInfoEXT(
    const VkVideoDecodeH265SessionParametersCreateInfoEXT* a,
    const VkVideoDecodeH265SessionParametersCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxSpsStdCount) == (b->maxSpsStdCount))) { onFail("a->maxSpsStdCount (Error: Value not equal)"); };
    if (!((a->maxPpsStdCount) == (b->maxPpsStdCount))) { onFail("a->maxPpsStdCount (Error: Value not equal)"); };
    if (!((!(a->pParametersAddInfo) && !(b->pParametersAddInfo)) || ((a->pParametersAddInfo) && (b->pParametersAddInfo)))) { onFail("a->pParametersAddInfo (Error: Mismatch in optional field)"); };
    if (a->pParametersAddInfo && b->pParametersAddInfo)
    {
        if ((a->pParametersAddInfo) && (b->pParametersAddInfo))
        {
            checkEqual_VkVideoDecodeH265SessionParametersAddInfoEXT(a->pParametersAddInfo, b->pParametersAddInfo, onFail);
        }
    }
}

void checkEqual_VkVideoDecodeH265PictureInfoEXT(
    const VkVideoDecodeH265PictureInfoEXT* a,
    const VkVideoDecodeH265PictureInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->pStdPictureInfo, b->pStdPictureInfo, sizeof(StdVideoDecodeH265PictureInfo)) == 0))) { onFail("a->pStdPictureInfo (Error: Unequal dyn array)"); };
    if (!((a->slicesCount) == (b->slicesCount))) { onFail("a->slicesCount (Error: Value not equal)"); };
    if (!((a->slicesCount) == (b->slicesCount))) { onFail("a->pSlicesDataOffsets (Error: Lengths not equal)"); };
    if (!((memcmp(a->pSlicesDataOffsets, b->pSlicesDataOffsets, a->slicesCount * sizeof(const uint32_t)) == 0))) { onFail("a->pSlicesDataOffsets (Error: Unequal dyn array)"); };
}

void checkEqual_VkVideoDecodeH265DpbSlotInfoEXT(
    const VkVideoDecodeH265DpbSlotInfoEXT* a,
    const VkVideoDecodeH265DpbSlotInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->pStdReferenceInfo, b->pStdReferenceInfo, sizeof(const StdVideoDecodeH265ReferenceInfo)) == 0))) { onFail("a->pStdReferenceInfo (Error: Unequal dyn array)"); };
}

#endif
#ifdef VK_AMD_memory_overallocation_behavior
void checkEqual_VkDeviceMemoryOverallocationCreateInfoAMD(
    const VkDeviceMemoryOverallocationCreateInfoAMD* a,
    const VkDeviceMemoryOverallocationCreateInfoAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->overallocationBehavior) == (b->overallocationBehavior))) { onFail("a->overallocationBehavior (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void checkEqual_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* a,
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxVertexAttribDivisor) == (b->maxVertexAttribDivisor))) { onFail("a->maxVertexAttribDivisor (Error: Value not equal)"); };
}

void checkEqual_VkVertexInputBindingDivisorDescriptionEXT(
    const VkVertexInputBindingDivisorDescriptionEXT* a,
    const VkVertexInputBindingDivisorDescriptionEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->binding) == (b->binding))) { onFail("a->binding (Error: Value not equal)"); };
    if (!((a->divisor) == (b->divisor))) { onFail("a->divisor (Error: Value not equal)"); };
}

void checkEqual_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    const VkPipelineVertexInputDivisorStateCreateInfoEXT* a,
    const VkPipelineVertexInputDivisorStateCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->vertexBindingDivisorCount) == (b->vertexBindingDivisorCount))) { onFail("a->vertexBindingDivisorCount (Error: Value not equal)"); };
    if ((a->pVertexBindingDivisors) && (b->pVertexBindingDivisors))
    {
        if (!((a->vertexBindingDivisorCount) == (b->vertexBindingDivisorCount))) { onFail("a->pVertexBindingDivisors (Error: Lengths not equal)"); };
        if ((a->vertexBindingDivisorCount) == (b->vertexBindingDivisorCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->vertexBindingDivisorCount; ++i)
                {
                    checkEqual_VkVertexInputBindingDivisorDescriptionEXT(a->pVertexBindingDivisors + i, b->pVertexBindingDivisors + i, onFail);
                }
            }
        }
    }
}

void checkEqual_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(
    const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* a,
    const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->vertexAttributeInstanceRateDivisor) == (b->vertexAttributeInstanceRateDivisor))) { onFail("a->vertexAttributeInstanceRateDivisor (Error: Value not equal)"); };
    if (!((a->vertexAttributeInstanceRateZeroDivisor) == (b->vertexAttributeInstanceRateZeroDivisor))) { onFail("a->vertexAttributeInstanceRateZeroDivisor (Error: Value not equal)"); };
}

#endif
#ifdef VK_GGP_frame_token
void checkEqual_VkPresentFrameTokenGGP(
    const VkPresentFrameTokenGGP* a,
    const VkPresentFrameTokenGGP* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->frameToken) == (b->frameToken))) { onFail("a->frameToken (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_pipeline_creation_feedback
void checkEqual_VkPipelineCreationFeedbackEXT(
    const VkPipelineCreationFeedbackEXT* a,
    const VkPipelineCreationFeedbackEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->duration) == (b->duration))) { onFail("a->duration (Error: Value not equal)"); };
}

void checkEqual_VkPipelineCreationFeedbackCreateInfoEXT(
    const VkPipelineCreationFeedbackCreateInfoEXT* a,
    const VkPipelineCreationFeedbackCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if ((a->pPipelineCreationFeedback) && (b->pPipelineCreationFeedback))
    {
        checkEqual_VkPipelineCreationFeedbackEXT(a->pPipelineCreationFeedback, b->pPipelineCreationFeedback, onFail);
    }
    if (!((a->pipelineStageCreationFeedbackCount) == (b->pipelineStageCreationFeedbackCount))) { onFail("a->pipelineStageCreationFeedbackCount (Error: Value not equal)"); };
    if ((a->pPipelineStageCreationFeedbacks) && (b->pPipelineStageCreationFeedbacks))
    {
        if (!((a->pipelineStageCreationFeedbackCount) == (b->pipelineStageCreationFeedbackCount))) { onFail("a->pPipelineStageCreationFeedbacks (Error: Lengths not equal)"); };
        if ((a->pipelineStageCreationFeedbackCount) == (b->pipelineStageCreationFeedbackCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->pipelineStageCreationFeedbackCount; ++i)
                {
                    checkEqual_VkPipelineCreationFeedbackEXT(a->pPipelineStageCreationFeedbacks + i, b->pPipelineStageCreationFeedbacks + i, onFail);
                }
            }
        }
    }
}

#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_compute_shader_derivatives
void checkEqual_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(
    const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* a,
    const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->computeDerivativeGroupQuads) == (b->computeDerivativeGroupQuads))) { onFail("a->computeDerivativeGroupQuads (Error: Value not equal)"); };
    if (!((a->computeDerivativeGroupLinear) == (b->computeDerivativeGroupLinear))) { onFail("a->computeDerivativeGroupLinear (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_mesh_shader
void checkEqual_VkPhysicalDeviceMeshShaderFeaturesNV(
    const VkPhysicalDeviceMeshShaderFeaturesNV* a,
    const VkPhysicalDeviceMeshShaderFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->taskShader) == (b->taskShader))) { onFail("a->taskShader (Error: Value not equal)"); };
    if (!((a->meshShader) == (b->meshShader))) { onFail("a->meshShader (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceMeshShaderPropertiesNV(
    const VkPhysicalDeviceMeshShaderPropertiesNV* a,
    const VkPhysicalDeviceMeshShaderPropertiesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxDrawMeshTasksCount) == (b->maxDrawMeshTasksCount))) { onFail("a->maxDrawMeshTasksCount (Error: Value not equal)"); };
    if (!((a->maxTaskWorkGroupInvocations) == (b->maxTaskWorkGroupInvocations))) { onFail("a->maxTaskWorkGroupInvocations (Error: Value not equal)"); };
    if (!((memcmp(a->maxTaskWorkGroupSize, b->maxTaskWorkGroupSize, 3 * sizeof(uint32_t)) == 0))) { onFail("a->maxTaskWorkGroupSize (Error: Unequal static array)"); };
    if (!((a->maxTaskTotalMemorySize) == (b->maxTaskTotalMemorySize))) { onFail("a->maxTaskTotalMemorySize (Error: Value not equal)"); };
    if (!((a->maxTaskOutputCount) == (b->maxTaskOutputCount))) { onFail("a->maxTaskOutputCount (Error: Value not equal)"); };
    if (!((a->maxMeshWorkGroupInvocations) == (b->maxMeshWorkGroupInvocations))) { onFail("a->maxMeshWorkGroupInvocations (Error: Value not equal)"); };
    if (!((memcmp(a->maxMeshWorkGroupSize, b->maxMeshWorkGroupSize, 3 * sizeof(uint32_t)) == 0))) { onFail("a->maxMeshWorkGroupSize (Error: Unequal static array)"); };
    if (!((a->maxMeshTotalMemorySize) == (b->maxMeshTotalMemorySize))) { onFail("a->maxMeshTotalMemorySize (Error: Value not equal)"); };
    if (!((a->maxMeshOutputVertices) == (b->maxMeshOutputVertices))) { onFail("a->maxMeshOutputVertices (Error: Value not equal)"); };
    if (!((a->maxMeshOutputPrimitives) == (b->maxMeshOutputPrimitives))) { onFail("a->maxMeshOutputPrimitives (Error: Value not equal)"); };
    if (!((a->maxMeshMultiviewViewCount) == (b->maxMeshMultiviewViewCount))) { onFail("a->maxMeshMultiviewViewCount (Error: Value not equal)"); };
    if (!((a->meshOutputPerVertexGranularity) == (b->meshOutputPerVertexGranularity))) { onFail("a->meshOutputPerVertexGranularity (Error: Value not equal)"); };
    if (!((a->meshOutputPerPrimitiveGranularity) == (b->meshOutputPerPrimitiveGranularity))) { onFail("a->meshOutputPerPrimitiveGranularity (Error: Value not equal)"); };
}

void checkEqual_VkDrawMeshTasksIndirectCommandNV(
    const VkDrawMeshTasksIndirectCommandNV* a,
    const VkDrawMeshTasksIndirectCommandNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->taskCount) == (b->taskCount))) { onFail("a->taskCount (Error: Value not equal)"); };
    if (!((a->firstTask) == (b->firstTask))) { onFail("a->firstTask (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_fragment_shader_barycentric
void checkEqual_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(
    const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV* a,
    const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fragmentShaderBarycentric) == (b->fragmentShaderBarycentric))) { onFail("a->fragmentShaderBarycentric (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_shader_image_footprint
void checkEqual_VkPhysicalDeviceShaderImageFootprintFeaturesNV(
    const VkPhysicalDeviceShaderImageFootprintFeaturesNV* a,
    const VkPhysicalDeviceShaderImageFootprintFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->imageFootprint) == (b->imageFootprint))) { onFail("a->imageFootprint (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_scissor_exclusive
void checkEqual_VkPipelineViewportExclusiveScissorStateCreateInfoNV(
    const VkPipelineViewportExclusiveScissorStateCreateInfoNV* a,
    const VkPipelineViewportExclusiveScissorStateCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->exclusiveScissorCount) == (b->exclusiveScissorCount))) { onFail("a->exclusiveScissorCount (Error: Value not equal)"); };
    if (!((!(a->pExclusiveScissors) && !(b->pExclusiveScissors)) || ((a->pExclusiveScissors) && (b->pExclusiveScissors)))) { onFail("a->pExclusiveScissors (Error: Mismatch in optional field)"); };
    if (a->pExclusiveScissors && b->pExclusiveScissors)
    {
        if ((a->pExclusiveScissors) && (b->pExclusiveScissors))
        {
            if (!((a->exclusiveScissorCount) == (b->exclusiveScissorCount))) { onFail("a->pExclusiveScissors (Error: Lengths not equal)"); };
            if ((a->exclusiveScissorCount) == (b->exclusiveScissorCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->exclusiveScissorCount; ++i)
                    {
                        checkEqual_VkRect2D(a->pExclusiveScissors + i, b->pExclusiveScissors + i, onFail);
                    }
                }
            }
        }
    }
}

void checkEqual_VkPhysicalDeviceExclusiveScissorFeaturesNV(
    const VkPhysicalDeviceExclusiveScissorFeaturesNV* a,
    const VkPhysicalDeviceExclusiveScissorFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->exclusiveScissor) == (b->exclusiveScissor))) { onFail("a->exclusiveScissor (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void checkEqual_VkQueueFamilyCheckpointPropertiesNV(
    const VkQueueFamilyCheckpointPropertiesNV* a,
    const VkQueueFamilyCheckpointPropertiesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->checkpointExecutionStageMask) == (b->checkpointExecutionStageMask))) { onFail("a->checkpointExecutionStageMask (Error: Value not equal)"); };
}

void checkEqual_VkCheckpointDataNV(
    const VkCheckpointDataNV* a,
    const VkCheckpointDataNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->stage) == (b->stage))) { onFail("a->stage (Error: Value not equal)"); };
    if (!((!(a->pCheckpointMarker) && !(b->pCheckpointMarker)) || ((a->pCheckpointMarker) && (b->pCheckpointMarker)))) { onFail("a->pCheckpointMarker (Error: Mismatch in optional field)"); };
}

#endif
#ifdef VK_INTEL_shader_integer_functions2
void checkEqual_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
    const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* a,
    const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderIntegerFunctions2) == (b->shaderIntegerFunctions2))) { onFail("a->shaderIntegerFunctions2 (Error: Value not equal)"); };
}

#endif
#ifdef VK_INTEL_performance_query
void checkEqual_VkPerformanceValueDataINTEL(
    const VkPerformanceValueDataINTEL* a,
    const VkPerformanceValueDataINTEL* b,
    OnFailCompareFunc onFail)
{
    if (!((a->value32) == (b->value32))) { onFail("a->value32 (Error: Value not equal)"); };
    if (!((a->value64) == (b->value64))) { onFail("a->value64 (Error: Value not equal)"); };
    if (!((a->valueFloat) == (b->valueFloat))) { onFail("a->valueFloat (Error: Value not equal)"); };
    if (!((a->valueBool) == (b->valueBool))) { onFail("a->valueBool (Error: Value not equal)"); };
    if (!((!(a->valueString) && !(b->valueString)) || ((a->valueString) && (b->valueString)))) { onFail("a->valueString (Error: Mismatch in string pointer nullness)"); };
    if ((a->valueString) && (b->valueString))
    {
        if (!((strcmp(a->valueString, b->valueString) == 0))) { onFail("a->valueString (Error: Unequal strings)"); };
    }
}

void checkEqual_VkPerformanceValueINTEL(
    const VkPerformanceValueINTEL* a,
    const VkPerformanceValueINTEL* b,
    OnFailCompareFunc onFail)
{
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    checkEqual_VkPerformanceValueDataINTEL(&a->data, &b->data, onFail);
}

void checkEqual_VkInitializePerformanceApiInfoINTEL(
    const VkInitializePerformanceApiInfoINTEL* a,
    const VkInitializePerformanceApiInfoINTEL* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((!(a->pUserData) && !(b->pUserData)) || ((a->pUserData) && (b->pUserData)))) { onFail("a->pUserData (Error: Mismatch in optional field)"); };
}

void checkEqual_VkQueryPoolPerformanceQueryCreateInfoINTEL(
    const VkQueryPoolPerformanceQueryCreateInfoINTEL* a,
    const VkQueryPoolPerformanceQueryCreateInfoINTEL* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->performanceCountersSampling) == (b->performanceCountersSampling))) { onFail("a->performanceCountersSampling (Error: Value not equal)"); };
}

void checkEqual_VkPerformanceMarkerInfoINTEL(
    const VkPerformanceMarkerInfoINTEL* a,
    const VkPerformanceMarkerInfoINTEL* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->marker) == (b->marker))) { onFail("a->marker (Error: Value not equal)"); };
}

void checkEqual_VkPerformanceStreamMarkerInfoINTEL(
    const VkPerformanceStreamMarkerInfoINTEL* a,
    const VkPerformanceStreamMarkerInfoINTEL* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->marker) == (b->marker))) { onFail("a->marker (Error: Value not equal)"); };
}

void checkEqual_VkPerformanceOverrideInfoINTEL(
    const VkPerformanceOverrideInfoINTEL* a,
    const VkPerformanceOverrideInfoINTEL* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->enable) == (b->enable))) { onFail("a->enable (Error: Value not equal)"); };
    if (!((a->parameter) == (b->parameter))) { onFail("a->parameter (Error: Value not equal)"); };
}

void checkEqual_VkPerformanceConfigurationAcquireInfoINTEL(
    const VkPerformanceConfigurationAcquireInfoINTEL* a,
    const VkPerformanceConfigurationAcquireInfoINTEL* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_pci_bus_info
void checkEqual_VkPhysicalDevicePCIBusInfoPropertiesEXT(
    const VkPhysicalDevicePCIBusInfoPropertiesEXT* a,
    const VkPhysicalDevicePCIBusInfoPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->pciDomain) == (b->pciDomain))) { onFail("a->pciDomain (Error: Value not equal)"); };
    if (!((a->pciBus) == (b->pciBus))) { onFail("a->pciBus (Error: Value not equal)"); };
    if (!((a->pciDevice) == (b->pciDevice))) { onFail("a->pciDevice (Error: Value not equal)"); };
    if (!((a->pciFunction) == (b->pciFunction))) { onFail("a->pciFunction (Error: Value not equal)"); };
}

#endif
#ifdef VK_AMD_display_native_hdr
void checkEqual_VkDisplayNativeHdrSurfaceCapabilitiesAMD(
    const VkDisplayNativeHdrSurfaceCapabilitiesAMD* a,
    const VkDisplayNativeHdrSurfaceCapabilitiesAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->localDimmingSupport) == (b->localDimmingSupport))) { onFail("a->localDimmingSupport (Error: Value not equal)"); };
}

void checkEqual_VkSwapchainDisplayNativeHdrCreateInfoAMD(
    const VkSwapchainDisplayNativeHdrCreateInfoAMD* a,
    const VkSwapchainDisplayNativeHdrCreateInfoAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->localDimmingEnable) == (b->localDimmingEnable))) { onFail("a->localDimmingEnable (Error: Value not equal)"); };
}

#endif
#ifdef VK_FUCHSIA_imagepipe_surface
void checkEqual_VkImagePipeSurfaceCreateInfoFUCHSIA(
    const VkImagePipeSurfaceCreateInfoFUCHSIA* a,
    const VkImagePipeSurfaceCreateInfoFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->imagePipeHandle) == (b->imagePipeHandle))) { onFail("a->imagePipeHandle (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_metal_surface
void checkEqual_VkMetalSurfaceCreateInfoEXT(
    const VkMetalSurfaceCreateInfoEXT* a,
    const VkMetalSurfaceCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->pLayer) && !(b->pLayer)) || ((a->pLayer) && (b->pLayer)))) { onFail("a->pLayer (Error: Mismatch in optional field)"); };
    if (a->pLayer && b->pLayer)
    {
        if (!((memcmp(a->pLayer, b->pLayer, sizeof(const CAMetalLayer)) == 0))) { onFail("a->pLayer (Error: Unequal dyn array)"); };
    }
}

#endif
#ifdef VK_EXT_fragment_density_map
void checkEqual_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(
    const VkPhysicalDeviceFragmentDensityMapFeaturesEXT* a,
    const VkPhysicalDeviceFragmentDensityMapFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fragmentDensityMap) == (b->fragmentDensityMap))) { onFail("a->fragmentDensityMap (Error: Value not equal)"); };
    if (!((a->fragmentDensityMapDynamic) == (b->fragmentDensityMapDynamic))) { onFail("a->fragmentDensityMapDynamic (Error: Value not equal)"); };
    if (!((a->fragmentDensityMapNonSubsampledImages) == (b->fragmentDensityMapNonSubsampledImages))) { onFail("a->fragmentDensityMapNonSubsampledImages (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(
    const VkPhysicalDeviceFragmentDensityMapPropertiesEXT* a,
    const VkPhysicalDeviceFragmentDensityMapPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkExtent2D(&a->minFragmentDensityTexelSize, &b->minFragmentDensityTexelSize, onFail);
    checkEqual_VkExtent2D(&a->maxFragmentDensityTexelSize, &b->maxFragmentDensityTexelSize, onFail);
    if (!((a->fragmentDensityInvocations) == (b->fragmentDensityInvocations))) { onFail("a->fragmentDensityInvocations (Error: Value not equal)"); };
}

void checkEqual_VkRenderPassFragmentDensityMapCreateInfoEXT(
    const VkRenderPassFragmentDensityMapCreateInfoEXT* a,
    const VkRenderPassFragmentDensityMapCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkAttachmentReference(&a->fragmentDensityMapAttachment, &b->fragmentDensityMapAttachment, onFail);
}

#endif
#ifdef VK_EXT_scalar_block_layout
#endif
#ifdef VK_GOOGLE_hlsl_functionality1
#endif
#ifdef VK_GOOGLE_decorate_string
#endif
#ifdef VK_EXT_subgroup_size_control
void checkEqual_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(
    const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT* a,
    const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->subgroupSizeControl) == (b->subgroupSizeControl))) { onFail("a->subgroupSizeControl (Error: Value not equal)"); };
    if (!((a->computeFullSubgroups) == (b->computeFullSubgroups))) { onFail("a->computeFullSubgroups (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(
    const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT* a,
    const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->minSubgroupSize) == (b->minSubgroupSize))) { onFail("a->minSubgroupSize (Error: Value not equal)"); };
    if (!((a->maxSubgroupSize) == (b->maxSubgroupSize))) { onFail("a->maxSubgroupSize (Error: Value not equal)"); };
    if (!((a->maxComputeWorkgroupSubgroups) == (b->maxComputeWorkgroupSubgroups))) { onFail("a->maxComputeWorkgroupSubgroups (Error: Value not equal)"); };
    if (!((a->requiredSubgroupSizeStages) == (b->requiredSubgroupSizeStages))) { onFail("a->requiredSubgroupSizeStages (Error: Value not equal)"); };
}

void checkEqual_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(
    const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT* a,
    const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->requiredSubgroupSize) == (b->requiredSubgroupSize))) { onFail("a->requiredSubgroupSize (Error: Value not equal)"); };
}

#endif
#ifdef VK_AMD_shader_core_properties2
void checkEqual_VkPhysicalDeviceShaderCoreProperties2AMD(
    const VkPhysicalDeviceShaderCoreProperties2AMD* a,
    const VkPhysicalDeviceShaderCoreProperties2AMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderCoreFeatures) == (b->shaderCoreFeatures))) { onFail("a->shaderCoreFeatures (Error: Value not equal)"); };
    if (!((a->activeComputeUnitCount) == (b->activeComputeUnitCount))) { onFail("a->activeComputeUnitCount (Error: Value not equal)"); };
}

#endif
#ifdef VK_AMD_device_coherent_memory
void checkEqual_VkPhysicalDeviceCoherentMemoryFeaturesAMD(
    const VkPhysicalDeviceCoherentMemoryFeaturesAMD* a,
    const VkPhysicalDeviceCoherentMemoryFeaturesAMD* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceCoherentMemory) == (b->deviceCoherentMemory))) { onFail("a->deviceCoherentMemory (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_shader_image_atomic_int64
void checkEqual_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
    const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* a,
    const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderImageInt64Atomics) == (b->shaderImageInt64Atomics))) { onFail("a->shaderImageInt64Atomics (Error: Value not equal)"); };
    if (!((a->sparseImageInt64Atomics) == (b->sparseImageInt64Atomics))) { onFail("a->sparseImageInt64Atomics (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_memory_budget
void checkEqual_VkPhysicalDeviceMemoryBudgetPropertiesEXT(
    const VkPhysicalDeviceMemoryBudgetPropertiesEXT* a,
    const VkPhysicalDeviceMemoryBudgetPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->heapBudget, b->heapBudget, VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize)) == 0))) { onFail("a->heapBudget (Error: Unequal static array)"); };
    if (!((memcmp(a->heapUsage, b->heapUsage, VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize)) == 0))) { onFail("a->heapUsage (Error: Unequal static array)"); };
}

#endif
#ifdef VK_EXT_memory_priority
void checkEqual_VkPhysicalDeviceMemoryPriorityFeaturesEXT(
    const VkPhysicalDeviceMemoryPriorityFeaturesEXT* a,
    const VkPhysicalDeviceMemoryPriorityFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memoryPriority) == (b->memoryPriority))) { onFail("a->memoryPriority (Error: Value not equal)"); };
}

void checkEqual_VkMemoryPriorityAllocateInfoEXT(
    const VkMemoryPriorityAllocateInfoEXT* a,
    const VkMemoryPriorityAllocateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->priority) == (b->priority))) { onFail("a->priority (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
void checkEqual_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
    const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* a,
    const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->dedicatedAllocationImageAliasing) == (b->dedicatedAllocationImageAliasing))) { onFail("a->dedicatedAllocationImageAliasing (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_buffer_device_address
void checkEqual_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(
    const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* a,
    const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->bufferDeviceAddress) == (b->bufferDeviceAddress))) { onFail("a->bufferDeviceAddress (Error: Value not equal)"); };
    if (!((a->bufferDeviceAddressCaptureReplay) == (b->bufferDeviceAddressCaptureReplay))) { onFail("a->bufferDeviceAddressCaptureReplay (Error: Value not equal)"); };
    if (!((a->bufferDeviceAddressMultiDevice) == (b->bufferDeviceAddressMultiDevice))) { onFail("a->bufferDeviceAddressMultiDevice (Error: Value not equal)"); };
}

void checkEqual_VkBufferDeviceAddressCreateInfoEXT(
    const VkBufferDeviceAddressCreateInfoEXT* a,
    const VkBufferDeviceAddressCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceAddress) == (b->deviceAddress))) { onFail("a->deviceAddress (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_tooling_info
void checkEqual_VkPhysicalDeviceToolPropertiesEXT(
    const VkPhysicalDeviceToolPropertiesEXT* a,
    const VkPhysicalDeviceToolPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((memcmp(a->name, b->name, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char)) == 0))) { onFail("a->name (Error: Unequal static array)"); };
    if (!((memcmp(a->version, b->version, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char)) == 0))) { onFail("a->version (Error: Unequal static array)"); };
    if (!((a->purposes) == (b->purposes))) { onFail("a->purposes (Error: Value not equal)"); };
    if (!((memcmp(a->description, b->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char)) == 0))) { onFail("a->description (Error: Unequal static array)"); };
    if (!((memcmp(a->layer, b->layer, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char)) == 0))) { onFail("a->layer (Error: Unequal static array)"); };
}

#endif
#ifdef VK_EXT_separate_stencil_usage
#endif
#ifdef VK_EXT_validation_features
void checkEqual_VkValidationFeaturesEXT(
    const VkValidationFeaturesEXT* a,
    const VkValidationFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->enabledValidationFeatureCount) == (b->enabledValidationFeatureCount))) { onFail("a->enabledValidationFeatureCount (Error: Value not equal)"); };
    if (!((a->enabledValidationFeatureCount) == (b->enabledValidationFeatureCount))) { onFail("a->pEnabledValidationFeatures (Error: Lengths not equal)"); };
    if (!((memcmp(a->pEnabledValidationFeatures, b->pEnabledValidationFeatures, a->enabledValidationFeatureCount * sizeof(const VkValidationFeatureEnableEXT)) == 0))) { onFail("a->pEnabledValidationFeatures (Error: Unequal dyn array)"); };
    if (!((a->disabledValidationFeatureCount) == (b->disabledValidationFeatureCount))) { onFail("a->disabledValidationFeatureCount (Error: Value not equal)"); };
    if (!((a->disabledValidationFeatureCount) == (b->disabledValidationFeatureCount))) { onFail("a->pDisabledValidationFeatures (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDisabledValidationFeatures, b->pDisabledValidationFeatures, a->disabledValidationFeatureCount * sizeof(const VkValidationFeatureDisableEXT)) == 0))) { onFail("a->pDisabledValidationFeatures (Error: Unequal dyn array)"); };
}

#endif
#ifdef VK_NV_cooperative_matrix
void checkEqual_VkCooperativeMatrixPropertiesNV(
    const VkCooperativeMatrixPropertiesNV* a,
    const VkCooperativeMatrixPropertiesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->MSize) == (b->MSize))) { onFail("a->MSize (Error: Value not equal)"); };
    if (!((a->NSize) == (b->NSize))) { onFail("a->NSize (Error: Value not equal)"); };
    if (!((a->KSize) == (b->KSize))) { onFail("a->KSize (Error: Value not equal)"); };
    if (!((a->AType) == (b->AType))) { onFail("a->AType (Error: Value not equal)"); };
    if (!((a->BType) == (b->BType))) { onFail("a->BType (Error: Value not equal)"); };
    if (!((a->CType) == (b->CType))) { onFail("a->CType (Error: Value not equal)"); };
    if (!((a->DType) == (b->DType))) { onFail("a->DType (Error: Value not equal)"); };
    if (!((a->scope) == (b->scope))) { onFail("a->scope (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceCooperativeMatrixFeaturesNV(
    const VkPhysicalDeviceCooperativeMatrixFeaturesNV* a,
    const VkPhysicalDeviceCooperativeMatrixFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->cooperativeMatrix) == (b->cooperativeMatrix))) { onFail("a->cooperativeMatrix (Error: Value not equal)"); };
    if (!((a->cooperativeMatrixRobustBufferAccess) == (b->cooperativeMatrixRobustBufferAccess))) { onFail("a->cooperativeMatrixRobustBufferAccess (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceCooperativeMatrixPropertiesNV(
    const VkPhysicalDeviceCooperativeMatrixPropertiesNV* a,
    const VkPhysicalDeviceCooperativeMatrixPropertiesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->cooperativeMatrixSupportedStages) == (b->cooperativeMatrixSupportedStages))) { onFail("a->cooperativeMatrixSupportedStages (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_coverage_reduction_mode
void checkEqual_VkPhysicalDeviceCoverageReductionModeFeaturesNV(
    const VkPhysicalDeviceCoverageReductionModeFeaturesNV* a,
    const VkPhysicalDeviceCoverageReductionModeFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->coverageReductionMode) == (b->coverageReductionMode))) { onFail("a->coverageReductionMode (Error: Value not equal)"); };
}

void checkEqual_VkPipelineCoverageReductionStateCreateInfoNV(
    const VkPipelineCoverageReductionStateCreateInfoNV* a,
    const VkPipelineCoverageReductionStateCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->coverageReductionMode) == (b->coverageReductionMode))) { onFail("a->coverageReductionMode (Error: Value not equal)"); };
}

void checkEqual_VkFramebufferMixedSamplesCombinationNV(
    const VkFramebufferMixedSamplesCombinationNV* a,
    const VkFramebufferMixedSamplesCombinationNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->coverageReductionMode) == (b->coverageReductionMode))) { onFail("a->coverageReductionMode (Error: Value not equal)"); };
    if (!((a->rasterizationSamples) == (b->rasterizationSamples))) { onFail("a->rasterizationSamples (Error: Value not equal)"); };
    if (!((a->depthStencilSamples) == (b->depthStencilSamples))) { onFail("a->depthStencilSamples (Error: Value not equal)"); };
    if (!((a->colorSamples) == (b->colorSamples))) { onFail("a->colorSamples (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_fragment_shader_interlock
void checkEqual_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(
    const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* a,
    const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fragmentShaderSampleInterlock) == (b->fragmentShaderSampleInterlock))) { onFail("a->fragmentShaderSampleInterlock (Error: Value not equal)"); };
    if (!((a->fragmentShaderPixelInterlock) == (b->fragmentShaderPixelInterlock))) { onFail("a->fragmentShaderPixelInterlock (Error: Value not equal)"); };
    if (!((a->fragmentShaderShadingRateInterlock) == (b->fragmentShaderShadingRateInterlock))) { onFail("a->fragmentShaderShadingRateInterlock (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_ycbcr_image_arrays
void checkEqual_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(
    const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* a,
    const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->ycbcrImageArrays) == (b->ycbcrImageArrays))) { onFail("a->ycbcrImageArrays (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_provoking_vertex
void checkEqual_VkPhysicalDeviceProvokingVertexFeaturesEXT(
    const VkPhysicalDeviceProvokingVertexFeaturesEXT* a,
    const VkPhysicalDeviceProvokingVertexFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->provokingVertexLast) == (b->provokingVertexLast))) { onFail("a->provokingVertexLast (Error: Value not equal)"); };
    if (!((a->transformFeedbackPreservesProvokingVertex) == (b->transformFeedbackPreservesProvokingVertex))) { onFail("a->transformFeedbackPreservesProvokingVertex (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceProvokingVertexPropertiesEXT(
    const VkPhysicalDeviceProvokingVertexPropertiesEXT* a,
    const VkPhysicalDeviceProvokingVertexPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->provokingVertexModePerPipeline) == (b->provokingVertexModePerPipeline))) { onFail("a->provokingVertexModePerPipeline (Error: Value not equal)"); };
    if (!((a->transformFeedbackPreservesTriangleFanProvokingVertex) == (b->transformFeedbackPreservesTriangleFanProvokingVertex))) { onFail("a->transformFeedbackPreservesTriangleFanProvokingVertex (Error: Value not equal)"); };
}

void checkEqual_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
    const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* a,
    const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->provokingVertexMode) == (b->provokingVertexMode))) { onFail("a->provokingVertexMode (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_full_screen_exclusive
void checkEqual_VkSurfaceFullScreenExclusiveInfoEXT(
    const VkSurfaceFullScreenExclusiveInfoEXT* a,
    const VkSurfaceFullScreenExclusiveInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fullScreenExclusive) == (b->fullScreenExclusive))) { onFail("a->fullScreenExclusive (Error: Value not equal)"); };
}

void checkEqual_VkSurfaceCapabilitiesFullScreenExclusiveEXT(
    const VkSurfaceCapabilitiesFullScreenExclusiveEXT* a,
    const VkSurfaceCapabilitiesFullScreenExclusiveEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fullScreenExclusiveSupported) == (b->fullScreenExclusiveSupported))) { onFail("a->fullScreenExclusiveSupported (Error: Value not equal)"); };
}

void checkEqual_VkSurfaceFullScreenExclusiveWin32InfoEXT(
    const VkSurfaceFullScreenExclusiveWin32InfoEXT* a,
    const VkSurfaceFullScreenExclusiveWin32InfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->hmonitor) == (b->hmonitor))) { onFail("a->hmonitor (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_headless_surface
void checkEqual_VkHeadlessSurfaceCreateInfoEXT(
    const VkHeadlessSurfaceCreateInfoEXT* a,
    const VkHeadlessSurfaceCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_line_rasterization
void checkEqual_VkPhysicalDeviceLineRasterizationFeaturesEXT(
    const VkPhysicalDeviceLineRasterizationFeaturesEXT* a,
    const VkPhysicalDeviceLineRasterizationFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->rectangularLines) == (b->rectangularLines))) { onFail("a->rectangularLines (Error: Value not equal)"); };
    if (!((a->bresenhamLines) == (b->bresenhamLines))) { onFail("a->bresenhamLines (Error: Value not equal)"); };
    if (!((a->smoothLines) == (b->smoothLines))) { onFail("a->smoothLines (Error: Value not equal)"); };
    if (!((a->stippledRectangularLines) == (b->stippledRectangularLines))) { onFail("a->stippledRectangularLines (Error: Value not equal)"); };
    if (!((a->stippledBresenhamLines) == (b->stippledBresenhamLines))) { onFail("a->stippledBresenhamLines (Error: Value not equal)"); };
    if (!((a->stippledSmoothLines) == (b->stippledSmoothLines))) { onFail("a->stippledSmoothLines (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceLineRasterizationPropertiesEXT(
    const VkPhysicalDeviceLineRasterizationPropertiesEXT* a,
    const VkPhysicalDeviceLineRasterizationPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->lineSubPixelPrecisionBits) == (b->lineSubPixelPrecisionBits))) { onFail("a->lineSubPixelPrecisionBits (Error: Value not equal)"); };
}

void checkEqual_VkPipelineRasterizationLineStateCreateInfoEXT(
    const VkPipelineRasterizationLineStateCreateInfoEXT* a,
    const VkPipelineRasterizationLineStateCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->lineRasterizationMode) == (b->lineRasterizationMode))) { onFail("a->lineRasterizationMode (Error: Value not equal)"); };
    if (!((a->stippledLineEnable) == (b->stippledLineEnable))) { onFail("a->stippledLineEnable (Error: Value not equal)"); };
    if (!((a->lineStippleFactor) == (b->lineStippleFactor))) { onFail("a->lineStippleFactor (Error: Value not equal)"); };
    if (!((a->lineStipplePattern) == (b->lineStipplePattern))) { onFail("a->lineStipplePattern (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_shader_atomic_float
void checkEqual_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(
    const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* a,
    const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderBufferFloat32Atomics) == (b->shaderBufferFloat32Atomics))) { onFail("a->shaderBufferFloat32Atomics (Error: Value not equal)"); };
    if (!((a->shaderBufferFloat32AtomicAdd) == (b->shaderBufferFloat32AtomicAdd))) { onFail("a->shaderBufferFloat32AtomicAdd (Error: Value not equal)"); };
    if (!((a->shaderBufferFloat64Atomics) == (b->shaderBufferFloat64Atomics))) { onFail("a->shaderBufferFloat64Atomics (Error: Value not equal)"); };
    if (!((a->shaderBufferFloat64AtomicAdd) == (b->shaderBufferFloat64AtomicAdd))) { onFail("a->shaderBufferFloat64AtomicAdd (Error: Value not equal)"); };
    if (!((a->shaderSharedFloat32Atomics) == (b->shaderSharedFloat32Atomics))) { onFail("a->shaderSharedFloat32Atomics (Error: Value not equal)"); };
    if (!((a->shaderSharedFloat32AtomicAdd) == (b->shaderSharedFloat32AtomicAdd))) { onFail("a->shaderSharedFloat32AtomicAdd (Error: Value not equal)"); };
    if (!((a->shaderSharedFloat64Atomics) == (b->shaderSharedFloat64Atomics))) { onFail("a->shaderSharedFloat64Atomics (Error: Value not equal)"); };
    if (!((a->shaderSharedFloat64AtomicAdd) == (b->shaderSharedFloat64AtomicAdd))) { onFail("a->shaderSharedFloat64AtomicAdd (Error: Value not equal)"); };
    if (!((a->shaderImageFloat32Atomics) == (b->shaderImageFloat32Atomics))) { onFail("a->shaderImageFloat32Atomics (Error: Value not equal)"); };
    if (!((a->shaderImageFloat32AtomicAdd) == (b->shaderImageFloat32AtomicAdd))) { onFail("a->shaderImageFloat32AtomicAdd (Error: Value not equal)"); };
    if (!((a->sparseImageFloat32Atomics) == (b->sparseImageFloat32Atomics))) { onFail("a->sparseImageFloat32Atomics (Error: Value not equal)"); };
    if (!((a->sparseImageFloat32AtomicAdd) == (b->sparseImageFloat32AtomicAdd))) { onFail("a->sparseImageFloat32AtomicAdd (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_host_query_reset
#endif
#ifdef VK_EXT_index_type_uint8
void checkEqual_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
    const VkPhysicalDeviceIndexTypeUint8FeaturesEXT* a,
    const VkPhysicalDeviceIndexTypeUint8FeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->indexTypeUint8) == (b->indexTypeUint8))) { onFail("a->indexTypeUint8 (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_extended_dynamic_state
void checkEqual_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
    const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* a,
    const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->extendedDynamicState) == (b->extendedDynamicState))) { onFail("a->extendedDynamicState (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_shader_atomic_float2
void checkEqual_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(
    const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* a,
    const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderBufferFloat16Atomics) == (b->shaderBufferFloat16Atomics))) { onFail("a->shaderBufferFloat16Atomics (Error: Value not equal)"); };
    if (!((a->shaderBufferFloat16AtomicAdd) == (b->shaderBufferFloat16AtomicAdd))) { onFail("a->shaderBufferFloat16AtomicAdd (Error: Value not equal)"); };
    if (!((a->shaderBufferFloat16AtomicMinMax) == (b->shaderBufferFloat16AtomicMinMax))) { onFail("a->shaderBufferFloat16AtomicMinMax (Error: Value not equal)"); };
    if (!((a->shaderBufferFloat32AtomicMinMax) == (b->shaderBufferFloat32AtomicMinMax))) { onFail("a->shaderBufferFloat32AtomicMinMax (Error: Value not equal)"); };
    if (!((a->shaderBufferFloat64AtomicMinMax) == (b->shaderBufferFloat64AtomicMinMax))) { onFail("a->shaderBufferFloat64AtomicMinMax (Error: Value not equal)"); };
    if (!((a->shaderSharedFloat16Atomics) == (b->shaderSharedFloat16Atomics))) { onFail("a->shaderSharedFloat16Atomics (Error: Value not equal)"); };
    if (!((a->shaderSharedFloat16AtomicAdd) == (b->shaderSharedFloat16AtomicAdd))) { onFail("a->shaderSharedFloat16AtomicAdd (Error: Value not equal)"); };
    if (!((a->shaderSharedFloat16AtomicMinMax) == (b->shaderSharedFloat16AtomicMinMax))) { onFail("a->shaderSharedFloat16AtomicMinMax (Error: Value not equal)"); };
    if (!((a->shaderSharedFloat32AtomicMinMax) == (b->shaderSharedFloat32AtomicMinMax))) { onFail("a->shaderSharedFloat32AtomicMinMax (Error: Value not equal)"); };
    if (!((a->shaderSharedFloat64AtomicMinMax) == (b->shaderSharedFloat64AtomicMinMax))) { onFail("a->shaderSharedFloat64AtomicMinMax (Error: Value not equal)"); };
    if (!((a->shaderImageFloat32AtomicMinMax) == (b->shaderImageFloat32AtomicMinMax))) { onFail("a->shaderImageFloat32AtomicMinMax (Error: Value not equal)"); };
    if (!((a->sparseImageFloat32AtomicMinMax) == (b->sparseImageFloat32AtomicMinMax))) { onFail("a->sparseImageFloat32AtomicMinMax (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
void checkEqual_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(
    const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT* a,
    const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderDemoteToHelperInvocation) == (b->shaderDemoteToHelperInvocation))) { onFail("a->shaderDemoteToHelperInvocation (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_device_generated_commands
void checkEqual_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
    const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* a,
    const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxGraphicsShaderGroupCount) == (b->maxGraphicsShaderGroupCount))) { onFail("a->maxGraphicsShaderGroupCount (Error: Value not equal)"); };
    if (!((a->maxIndirectSequenceCount) == (b->maxIndirectSequenceCount))) { onFail("a->maxIndirectSequenceCount (Error: Value not equal)"); };
    if (!((a->maxIndirectCommandsTokenCount) == (b->maxIndirectCommandsTokenCount))) { onFail("a->maxIndirectCommandsTokenCount (Error: Value not equal)"); };
    if (!((a->maxIndirectCommandsStreamCount) == (b->maxIndirectCommandsStreamCount))) { onFail("a->maxIndirectCommandsStreamCount (Error: Value not equal)"); };
    if (!((a->maxIndirectCommandsTokenOffset) == (b->maxIndirectCommandsTokenOffset))) { onFail("a->maxIndirectCommandsTokenOffset (Error: Value not equal)"); };
    if (!((a->maxIndirectCommandsStreamStride) == (b->maxIndirectCommandsStreamStride))) { onFail("a->maxIndirectCommandsStreamStride (Error: Value not equal)"); };
    if (!((a->minSequencesCountBufferOffsetAlignment) == (b->minSequencesCountBufferOffsetAlignment))) { onFail("a->minSequencesCountBufferOffsetAlignment (Error: Value not equal)"); };
    if (!((a->minSequencesIndexBufferOffsetAlignment) == (b->minSequencesIndexBufferOffsetAlignment))) { onFail("a->minSequencesIndexBufferOffsetAlignment (Error: Value not equal)"); };
    if (!((a->minIndirectCommandsBufferOffsetAlignment) == (b->minIndirectCommandsBufferOffsetAlignment))) { onFail("a->minIndirectCommandsBufferOffsetAlignment (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
    const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* a,
    const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceGeneratedCommands) == (b->deviceGeneratedCommands))) { onFail("a->deviceGeneratedCommands (Error: Value not equal)"); };
}

void checkEqual_VkGraphicsShaderGroupCreateInfoNV(
    const VkGraphicsShaderGroupCreateInfoNV* a,
    const VkGraphicsShaderGroupCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->stageCount) == (b->stageCount))) { onFail("a->stageCount (Error: Value not equal)"); };
    if ((a->pStages) && (b->pStages))
    {
        if (!((a->stageCount) == (b->stageCount))) { onFail("a->pStages (Error: Lengths not equal)"); };
        if ((a->stageCount) == (b->stageCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->stageCount; ++i)
                {
                    checkEqual_VkPipelineShaderStageCreateInfo(a->pStages + i, b->pStages + i, onFail);
                }
            }
        }
    }
    if (!((!(a->pVertexInputState) && !(b->pVertexInputState)) || ((a->pVertexInputState) && (b->pVertexInputState)))) { onFail("a->pVertexInputState (Error: Mismatch in optional field)"); };
    if (a->pVertexInputState && b->pVertexInputState)
    {
        if ((a->pVertexInputState) && (b->pVertexInputState))
        {
            checkEqual_VkPipelineVertexInputStateCreateInfo(a->pVertexInputState, b->pVertexInputState, onFail);
        }
    }
    if (!((!(a->pTessellationState) && !(b->pTessellationState)) || ((a->pTessellationState) && (b->pTessellationState)))) { onFail("a->pTessellationState (Error: Mismatch in optional field)"); };
    if (a->pTessellationState && b->pTessellationState)
    {
        if ((a->pTessellationState) && (b->pTessellationState))
        {
            checkEqual_VkPipelineTessellationStateCreateInfo(a->pTessellationState, b->pTessellationState, onFail);
        }
    }
}

void checkEqual_VkGraphicsPipelineShaderGroupsCreateInfoNV(
    const VkGraphicsPipelineShaderGroupsCreateInfoNV* a,
    const VkGraphicsPipelineShaderGroupsCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->groupCount) == (b->groupCount))) { onFail("a->groupCount (Error: Value not equal)"); };
    if ((a->pGroups) && (b->pGroups))
    {
        if (!((a->groupCount) == (b->groupCount))) { onFail("a->pGroups (Error: Lengths not equal)"); };
        if ((a->groupCount) == (b->groupCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->groupCount; ++i)
                {
                    checkEqual_VkGraphicsShaderGroupCreateInfoNV(a->pGroups + i, b->pGroups + i, onFail);
                }
            }
        }
    }
    if (!((a->pipelineCount) == (b->pipelineCount))) { onFail("a->pipelineCount (Error: Value not equal)"); };
    if (!((a->pipelineCount) == (b->pipelineCount))) { onFail("a->pPipelines (Error: Lengths not equal)"); };
    if (!((memcmp(a->pPipelines, b->pPipelines, a->pipelineCount * sizeof(const VkPipeline)) == 0))) { onFail("a->pPipelines (Error: Unequal dyn array)"); };
}

void checkEqual_VkBindShaderGroupIndirectCommandNV(
    const VkBindShaderGroupIndirectCommandNV* a,
    const VkBindShaderGroupIndirectCommandNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->groupIndex) == (b->groupIndex))) { onFail("a->groupIndex (Error: Value not equal)"); };
}

void checkEqual_VkBindIndexBufferIndirectCommandNV(
    const VkBindIndexBufferIndirectCommandNV* a,
    const VkBindIndexBufferIndirectCommandNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->bufferAddress) == (b->bufferAddress))) { onFail("a->bufferAddress (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->indexType) == (b->indexType))) { onFail("a->indexType (Error: Value not equal)"); };
}

void checkEqual_VkBindVertexBufferIndirectCommandNV(
    const VkBindVertexBufferIndirectCommandNV* a,
    const VkBindVertexBufferIndirectCommandNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->bufferAddress) == (b->bufferAddress))) { onFail("a->bufferAddress (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->stride) == (b->stride))) { onFail("a->stride (Error: Value not equal)"); };
}

void checkEqual_VkSetStateFlagsIndirectCommandNV(
    const VkSetStateFlagsIndirectCommandNV* a,
    const VkSetStateFlagsIndirectCommandNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->data) == (b->data))) { onFail("a->data (Error: Value not equal)"); };
}

void checkEqual_VkIndirectCommandsStreamNV(
    const VkIndirectCommandsStreamNV* a,
    const VkIndirectCommandsStreamNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
}

void checkEqual_VkIndirectCommandsLayoutTokenNV(
    const VkIndirectCommandsLayoutTokenNV* a,
    const VkIndirectCommandsLayoutTokenNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->tokenType) == (b->tokenType))) { onFail("a->tokenType (Error: Value not equal)"); };
    if (!((a->stream) == (b->stream))) { onFail("a->stream (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->vertexBindingUnit) == (b->vertexBindingUnit))) { onFail("a->vertexBindingUnit (Error: Value not equal)"); };
    if (!((a->vertexDynamicStride) == (b->vertexDynamicStride))) { onFail("a->vertexDynamicStride (Error: Value not equal)"); };
    if (!((a->pushconstantPipelineLayout) == (b->pushconstantPipelineLayout))) { onFail("a->pushconstantPipelineLayout (Error: Value not equal)"); };
    if (!((a->pushconstantShaderStageFlags) == (b->pushconstantShaderStageFlags))) { onFail("a->pushconstantShaderStageFlags (Error: Value not equal)"); };
    if (!((a->pushconstantOffset) == (b->pushconstantOffset))) { onFail("a->pushconstantOffset (Error: Value not equal)"); };
    if (!((a->pushconstantSize) == (b->pushconstantSize))) { onFail("a->pushconstantSize (Error: Value not equal)"); };
    if (!((a->indirectStateFlags) == (b->indirectStateFlags))) { onFail("a->indirectStateFlags (Error: Value not equal)"); };
    if (!((a->indexTypeCount) == (b->indexTypeCount))) { onFail("a->indexTypeCount (Error: Value not equal)"); };
    if (!((a->indexTypeCount) == (b->indexTypeCount))) { onFail("a->pIndexTypes (Error: Lengths not equal)"); };
    if (!((memcmp(a->pIndexTypes, b->pIndexTypes, a->indexTypeCount * sizeof(const VkIndexType)) == 0))) { onFail("a->pIndexTypes (Error: Unequal dyn array)"); };
    if (!((a->indexTypeCount) == (b->indexTypeCount))) { onFail("a->pIndexTypeValues (Error: Lengths not equal)"); };
    if (!((memcmp(a->pIndexTypeValues, b->pIndexTypeValues, a->indexTypeCount * sizeof(const uint32_t)) == 0))) { onFail("a->pIndexTypeValues (Error: Unequal dyn array)"); };
}

void checkEqual_VkIndirectCommandsLayoutCreateInfoNV(
    const VkIndirectCommandsLayoutCreateInfoNV* a,
    const VkIndirectCommandsLayoutCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->pipelineBindPoint) == (b->pipelineBindPoint))) { onFail("a->pipelineBindPoint (Error: Value not equal)"); };
    if (!((a->tokenCount) == (b->tokenCount))) { onFail("a->tokenCount (Error: Value not equal)"); };
    if ((a->pTokens) && (b->pTokens))
    {
        if (!((a->tokenCount) == (b->tokenCount))) { onFail("a->pTokens (Error: Lengths not equal)"); };
        if ((a->tokenCount) == (b->tokenCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->tokenCount; ++i)
                {
                    checkEqual_VkIndirectCommandsLayoutTokenNV(a->pTokens + i, b->pTokens + i, onFail);
                }
            }
        }
    }
    if (!((a->streamCount) == (b->streamCount))) { onFail("a->streamCount (Error: Value not equal)"); };
    if (!((a->streamCount) == (b->streamCount))) { onFail("a->pStreamStrides (Error: Lengths not equal)"); };
    if (!((memcmp(a->pStreamStrides, b->pStreamStrides, a->streamCount * sizeof(const uint32_t)) == 0))) { onFail("a->pStreamStrides (Error: Unequal dyn array)"); };
}

void checkEqual_VkGeneratedCommandsInfoNV(
    const VkGeneratedCommandsInfoNV* a,
    const VkGeneratedCommandsInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->pipelineBindPoint) == (b->pipelineBindPoint))) { onFail("a->pipelineBindPoint (Error: Value not equal)"); };
    if (!((a->pipeline) == (b->pipeline))) { onFail("a->pipeline (Error: Value not equal)"); };
    if (!((a->indirectCommandsLayout) == (b->indirectCommandsLayout))) { onFail("a->indirectCommandsLayout (Error: Value not equal)"); };
    if (!((a->streamCount) == (b->streamCount))) { onFail("a->streamCount (Error: Value not equal)"); };
    if ((a->pStreams) && (b->pStreams))
    {
        if (!((a->streamCount) == (b->streamCount))) { onFail("a->pStreams (Error: Lengths not equal)"); };
        if ((a->streamCount) == (b->streamCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->streamCount; ++i)
                {
                    checkEqual_VkIndirectCommandsStreamNV(a->pStreams + i, b->pStreams + i, onFail);
                }
            }
        }
    }
    if (!((a->sequencesCount) == (b->sequencesCount))) { onFail("a->sequencesCount (Error: Value not equal)"); };
    if (!((a->preprocessBuffer) == (b->preprocessBuffer))) { onFail("a->preprocessBuffer (Error: Value not equal)"); };
    if (!((a->preprocessOffset) == (b->preprocessOffset))) { onFail("a->preprocessOffset (Error: Value not equal)"); };
    if (!((a->preprocessSize) == (b->preprocessSize))) { onFail("a->preprocessSize (Error: Value not equal)"); };
    if (!((a->sequencesCountBuffer) == (b->sequencesCountBuffer))) { onFail("a->sequencesCountBuffer (Error: Value not equal)"); };
    if (!((a->sequencesCountOffset) == (b->sequencesCountOffset))) { onFail("a->sequencesCountOffset (Error: Value not equal)"); };
    if (!((a->sequencesIndexBuffer) == (b->sequencesIndexBuffer))) { onFail("a->sequencesIndexBuffer (Error: Value not equal)"); };
    if (!((a->sequencesIndexOffset) == (b->sequencesIndexOffset))) { onFail("a->sequencesIndexOffset (Error: Value not equal)"); };
}

void checkEqual_VkGeneratedCommandsMemoryRequirementsInfoNV(
    const VkGeneratedCommandsMemoryRequirementsInfoNV* a,
    const VkGeneratedCommandsMemoryRequirementsInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->pipelineBindPoint) == (b->pipelineBindPoint))) { onFail("a->pipelineBindPoint (Error: Value not equal)"); };
    if (!((a->pipeline) == (b->pipeline))) { onFail("a->pipeline (Error: Value not equal)"); };
    if (!((a->indirectCommandsLayout) == (b->indirectCommandsLayout))) { onFail("a->indirectCommandsLayout (Error: Value not equal)"); };
    if (!((a->maxSequencesCount) == (b->maxSequencesCount))) { onFail("a->maxSequencesCount (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_inherited_viewport_scissor
void checkEqual_VkPhysicalDeviceInheritedViewportScissorFeaturesNV(
    const VkPhysicalDeviceInheritedViewportScissorFeaturesNV* a,
    const VkPhysicalDeviceInheritedViewportScissorFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->inheritedViewportScissor2D) == (b->inheritedViewportScissor2D))) { onFail("a->inheritedViewportScissor2D (Error: Value not equal)"); };
}

void checkEqual_VkCommandBufferInheritanceViewportScissorInfoNV(
    const VkCommandBufferInheritanceViewportScissorInfoNV* a,
    const VkCommandBufferInheritanceViewportScissorInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->viewportScissor2D) == (b->viewportScissor2D))) { onFail("a->viewportScissor2D (Error: Value not equal)"); };
    if (!((a->viewportDepthCount) == (b->viewportDepthCount))) { onFail("a->viewportDepthCount (Error: Value not equal)"); };
    if (!((!(a->pViewportDepths) && !(b->pViewportDepths)) || ((a->pViewportDepths) && (b->pViewportDepths)))) { onFail("a->pViewportDepths (Error: Mismatch in optional field)"); };
    if (a->pViewportDepths && b->pViewportDepths)
    {
        if ((a->pViewportDepths) && (b->pViewportDepths))
        {
            checkEqual_VkViewport(a->pViewportDepths, b->pViewportDepths, onFail);
        }
    }
}

#endif
#ifdef VK_EXT_texel_buffer_alignment
void checkEqual_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
    const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* a,
    const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->texelBufferAlignment) == (b->texelBufferAlignment))) { onFail("a->texelBufferAlignment (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(
    const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT* a,
    const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->storageTexelBufferOffsetAlignmentBytes) == (b->storageTexelBufferOffsetAlignmentBytes))) { onFail("a->storageTexelBufferOffsetAlignmentBytes (Error: Value not equal)"); };
    if (!((a->storageTexelBufferOffsetSingleTexelAlignment) == (b->storageTexelBufferOffsetSingleTexelAlignment))) { onFail("a->storageTexelBufferOffsetSingleTexelAlignment (Error: Value not equal)"); };
    if (!((a->uniformTexelBufferOffsetAlignmentBytes) == (b->uniformTexelBufferOffsetAlignmentBytes))) { onFail("a->uniformTexelBufferOffsetAlignmentBytes (Error: Value not equal)"); };
    if (!((a->uniformTexelBufferOffsetSingleTexelAlignment) == (b->uniformTexelBufferOffsetSingleTexelAlignment))) { onFail("a->uniformTexelBufferOffsetSingleTexelAlignment (Error: Value not equal)"); };
}

#endif
#ifdef VK_QCOM_render_pass_transform
void checkEqual_VkRenderPassTransformBeginInfoQCOM(
    const VkRenderPassTransformBeginInfoQCOM* a,
    const VkRenderPassTransformBeginInfoQCOM* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->transform) == (b->transform))) { onFail("a->transform (Error: Value not equal)"); };
}

void checkEqual_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(
    const VkCommandBufferInheritanceRenderPassTransformInfoQCOM* a,
    const VkCommandBufferInheritanceRenderPassTransformInfoQCOM* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->transform) == (b->transform))) { onFail("a->transform (Error: Value not equal)"); };
    checkEqual_VkRect2D(&a->renderArea, &b->renderArea, onFail);
}

#endif
#ifdef VK_EXT_device_memory_report
void checkEqual_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
    const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* a,
    const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->deviceMemoryReport) == (b->deviceMemoryReport))) { onFail("a->deviceMemoryReport (Error: Value not equal)"); };
}

void checkEqual_VkDeviceMemoryReportCallbackDataEXT(
    const VkDeviceMemoryReportCallbackDataEXT* a,
    const VkDeviceMemoryReportCallbackDataEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->memoryObjectId) == (b->memoryObjectId))) { onFail("a->memoryObjectId (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->objectType) == (b->objectType))) { onFail("a->objectType (Error: Value not equal)"); };
    if (!((a->objectHandle) == (b->objectHandle))) { onFail("a->objectHandle (Error: Value not equal)"); };
    if (!((a->heapIndex) == (b->heapIndex))) { onFail("a->heapIndex (Error: Value not equal)"); };
}

void checkEqual_VkDeviceDeviceMemoryReportCreateInfoEXT(
    const VkDeviceDeviceMemoryReportCreateInfoEXT* a,
    const VkDeviceDeviceMemoryReportCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->pfnUserCallback) == (b->pfnUserCallback))) { onFail("a->pfnUserCallback (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_acquire_drm_display
#endif
#ifdef VK_EXT_robustness2
void checkEqual_VkPhysicalDeviceRobustness2FeaturesEXT(
    const VkPhysicalDeviceRobustness2FeaturesEXT* a,
    const VkPhysicalDeviceRobustness2FeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->robustBufferAccess2) == (b->robustBufferAccess2))) { onFail("a->robustBufferAccess2 (Error: Value not equal)"); };
    if (!((a->robustImageAccess2) == (b->robustImageAccess2))) { onFail("a->robustImageAccess2 (Error: Value not equal)"); };
    if (!((a->nullDescriptor) == (b->nullDescriptor))) { onFail("a->nullDescriptor (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceRobustness2PropertiesEXT(
    const VkPhysicalDeviceRobustness2PropertiesEXT* a,
    const VkPhysicalDeviceRobustness2PropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->robustStorageBufferAccessSizeAlignment) == (b->robustStorageBufferAccessSizeAlignment))) { onFail("a->robustStorageBufferAccessSizeAlignment (Error: Value not equal)"); };
    if (!((a->robustUniformBufferAccessSizeAlignment) == (b->robustUniformBufferAccessSizeAlignment))) { onFail("a->robustUniformBufferAccessSizeAlignment (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_custom_border_color
void checkEqual_VkSamplerCustomBorderColorCreateInfoEXT(
    const VkSamplerCustomBorderColorCreateInfoEXT* a,
    const VkSamplerCustomBorderColorCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkClearColorValue(&a->customBorderColor, &b->customBorderColor, onFail);
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceCustomBorderColorPropertiesEXT(
    const VkPhysicalDeviceCustomBorderColorPropertiesEXT* a,
    const VkPhysicalDeviceCustomBorderColorPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxCustomBorderColorSamplers) == (b->maxCustomBorderColorSamplers))) { onFail("a->maxCustomBorderColorSamplers (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceCustomBorderColorFeaturesEXT(
    const VkPhysicalDeviceCustomBorderColorFeaturesEXT* a,
    const VkPhysicalDeviceCustomBorderColorFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->customBorderColors) == (b->customBorderColors))) { onFail("a->customBorderColors (Error: Value not equal)"); };
    if (!((a->customBorderColorWithoutFormat) == (b->customBorderColorWithoutFormat))) { onFail("a->customBorderColorWithoutFormat (Error: Value not equal)"); };
}

#endif
#ifdef VK_GOOGLE_user_type
#endif
#ifdef VK_EXT_private_data
void checkEqual_VkPhysicalDevicePrivateDataFeaturesEXT(
    const VkPhysicalDevicePrivateDataFeaturesEXT* a,
    const VkPhysicalDevicePrivateDataFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->privateData) == (b->privateData))) { onFail("a->privateData (Error: Value not equal)"); };
}

void checkEqual_VkDevicePrivateDataCreateInfoEXT(
    const VkDevicePrivateDataCreateInfoEXT* a,
    const VkDevicePrivateDataCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->privateDataSlotRequestCount) == (b->privateDataSlotRequestCount))) { onFail("a->privateDataSlotRequestCount (Error: Value not equal)"); };
}

void checkEqual_VkPrivateDataSlotCreateInfoEXT(
    const VkPrivateDataSlotCreateInfoEXT* a,
    const VkPrivateDataSlotCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_pipeline_creation_cache_control
void checkEqual_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(
    const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT* a,
    const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->pipelineCreationCacheControl) == (b->pipelineCreationCacheControl))) { onFail("a->pipelineCreationCacheControl (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_device_diagnostics_config
void checkEqual_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(
    const VkPhysicalDeviceDiagnosticsConfigFeaturesNV* a,
    const VkPhysicalDeviceDiagnosticsConfigFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->diagnosticsConfig) == (b->diagnosticsConfig))) { onFail("a->diagnosticsConfig (Error: Value not equal)"); };
}

void checkEqual_VkDeviceDiagnosticsConfigCreateInfoNV(
    const VkDeviceDiagnosticsConfigCreateInfoNV* a,
    const VkDeviceDiagnosticsConfigCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

#endif
#ifdef VK_QCOM_render_pass_store_ops
#endif
#ifdef VK_NV_fragment_shading_rate_enums
void checkEqual_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
    const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* a,
    const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fragmentShadingRateEnums) == (b->fragmentShadingRateEnums))) { onFail("a->fragmentShadingRateEnums (Error: Value not equal)"); };
    if (!((a->supersampleFragmentShadingRates) == (b->supersampleFragmentShadingRates))) { onFail("a->supersampleFragmentShadingRates (Error: Value not equal)"); };
    if (!((a->noInvocationFragmentShadingRates) == (b->noInvocationFragmentShadingRates))) { onFail("a->noInvocationFragmentShadingRates (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
    const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* a,
    const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxFragmentShadingRateInvocationCount) == (b->maxFragmentShadingRateInvocationCount))) { onFail("a->maxFragmentShadingRateInvocationCount (Error: Value not equal)"); };
}

void checkEqual_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(
    const VkPipelineFragmentShadingRateEnumStateCreateInfoNV* a,
    const VkPipelineFragmentShadingRateEnumStateCreateInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shadingRateType) == (b->shadingRateType))) { onFail("a->shadingRateType (Error: Value not equal)"); };
    if (!((a->shadingRate) == (b->shadingRate))) { onFail("a->shadingRate (Error: Value not equal)"); };
    if (!((memcmp(a->combinerOps, b->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR)) == 0))) { onFail("a->combinerOps (Error: Unequal static array)"); };
}

#endif
#ifdef VK_NV_ray_tracing_motion_blur
void checkEqual_VkDeviceOrHostAddressConstKHR(
    const VkDeviceOrHostAddressConstKHR* a,
    const VkDeviceOrHostAddressConstKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->deviceAddress) == (b->deviceAddress))) { onFail("a->deviceAddress (Error: Value not equal)"); };
    if (!((!(a->hostAddress) && !(b->hostAddress)) || ((a->hostAddress) && (b->hostAddress)))) { onFail("a->hostAddress (Error: Mismatch in optional field)"); };
}

void checkEqual_VkAccelerationStructureGeometryMotionTrianglesDataNV(
    const VkAccelerationStructureGeometryMotionTrianglesDataNV* a,
    const VkAccelerationStructureGeometryMotionTrianglesDataNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkDeviceOrHostAddressConstKHR(&a->vertexData, &b->vertexData, onFail);
}

void checkEqual_VkAccelerationStructureMotionInfoNV(
    const VkAccelerationStructureMotionInfoNV* a,
    const VkAccelerationStructureMotionInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxInstances) == (b->maxInstances))) { onFail("a->maxInstances (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkAccelerationStructureMatrixMotionInstanceNV(
    const VkAccelerationStructureMatrixMotionInstanceNV* a,
    const VkAccelerationStructureMatrixMotionInstanceNV* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkTransformMatrixKHR(&a->transformT0, &b->transformT0, onFail);
    checkEqual_VkTransformMatrixKHR(&a->transformT1, &b->transformT1, onFail);
    if (!((a->instanceCustomIndex) == (b->instanceCustomIndex))) { onFail("a->instanceCustomIndex (Error: Value not equal)"); };
    if (!((a->mask) == (b->mask))) { onFail("a->mask (Error: Value not equal)"); };
    if (!((a->instanceShaderBindingTableRecordOffset) == (b->instanceShaderBindingTableRecordOffset))) { onFail("a->instanceShaderBindingTableRecordOffset (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->accelerationStructureReference) == (b->accelerationStructureReference))) { onFail("a->accelerationStructureReference (Error: Value not equal)"); };
}

void checkEqual_VkSRTDataNV(
    const VkSRTDataNV* a,
    const VkSRTDataNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sx) == (b->sx))) { onFail("a->sx (Error: Value not equal)"); };
    if (!((a->a) == (b->a))) { onFail("a->a (Error: Value not equal)"); };
    if (!((a->b) == (b->b))) { onFail("a->b (Error: Value not equal)"); };
    if (!((a->pvx) == (b->pvx))) { onFail("a->pvx (Error: Value not equal)"); };
    if (!((a->sy) == (b->sy))) { onFail("a->sy (Error: Value not equal)"); };
    if (!((a->c) == (b->c))) { onFail("a->c (Error: Value not equal)"); };
    if (!((a->pvy) == (b->pvy))) { onFail("a->pvy (Error: Value not equal)"); };
    if (!((a->sz) == (b->sz))) { onFail("a->sz (Error: Value not equal)"); };
    if (!((a->pvz) == (b->pvz))) { onFail("a->pvz (Error: Value not equal)"); };
    if (!((a->qx) == (b->qx))) { onFail("a->qx (Error: Value not equal)"); };
    if (!((a->qy) == (b->qy))) { onFail("a->qy (Error: Value not equal)"); };
    if (!((a->qz) == (b->qz))) { onFail("a->qz (Error: Value not equal)"); };
    if (!((a->qw) == (b->qw))) { onFail("a->qw (Error: Value not equal)"); };
    if (!((a->tx) == (b->tx))) { onFail("a->tx (Error: Value not equal)"); };
    if (!((a->ty) == (b->ty))) { onFail("a->ty (Error: Value not equal)"); };
    if (!((a->tz) == (b->tz))) { onFail("a->tz (Error: Value not equal)"); };
}

void checkEqual_VkAccelerationStructureSRTMotionInstanceNV(
    const VkAccelerationStructureSRTMotionInstanceNV* a,
    const VkAccelerationStructureSRTMotionInstanceNV* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkSRTDataNV(&a->transformT0, &b->transformT0, onFail);
    checkEqual_VkSRTDataNV(&a->transformT1, &b->transformT1, onFail);
    if (!((a->instanceCustomIndex) == (b->instanceCustomIndex))) { onFail("a->instanceCustomIndex (Error: Value not equal)"); };
    if (!((a->mask) == (b->mask))) { onFail("a->mask (Error: Value not equal)"); };
    if (!((a->instanceShaderBindingTableRecordOffset) == (b->instanceShaderBindingTableRecordOffset))) { onFail("a->instanceShaderBindingTableRecordOffset (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->accelerationStructureReference) == (b->accelerationStructureReference))) { onFail("a->accelerationStructureReference (Error: Value not equal)"); };
}

void checkEqual_VkAccelerationStructureMotionInstanceDataNV(
    const VkAccelerationStructureMotionInstanceDataNV* a,
    const VkAccelerationStructureMotionInstanceDataNV* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkAccelerationStructureInstanceKHR(&a->staticInstance, &b->staticInstance, onFail);
    checkEqual_VkAccelerationStructureMatrixMotionInstanceNV(&a->matrixMotionInstance, &b->matrixMotionInstance, onFail);
    checkEqual_VkAccelerationStructureSRTMotionInstanceNV(&a->srtMotionInstance, &b->srtMotionInstance, onFail);
}

void checkEqual_VkAccelerationStructureMotionInstanceNV(
    const VkAccelerationStructureMotionInstanceNV* a,
    const VkAccelerationStructureMotionInstanceNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    checkEqual_VkAccelerationStructureMotionInstanceDataNV(&a->data, &b->data, onFail);
}

void checkEqual_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(
    const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* a,
    const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->rayTracingMotionBlur) == (b->rayTracingMotionBlur))) { onFail("a->rayTracingMotionBlur (Error: Value not equal)"); };
    if (!((a->rayTracingMotionBlurPipelineTraceRaysIndirect) == (b->rayTracingMotionBlurPipelineTraceRaysIndirect))) { onFail("a->rayTracingMotionBlurPipelineTraceRaysIndirect (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_ycbcr_2plane_444_formats
void checkEqual_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(
    const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* a,
    const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->ycbcr2plane444Formats) == (b->ycbcr2plane444Formats))) { onFail("a->ycbcr2plane444Formats (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_fragment_density_map2
void checkEqual_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(
    const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* a,
    const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->fragmentDensityMapDeferred) == (b->fragmentDensityMapDeferred))) { onFail("a->fragmentDensityMapDeferred (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(
    const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* a,
    const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->subsampledLoads) == (b->subsampledLoads))) { onFail("a->subsampledLoads (Error: Value not equal)"); };
    if (!((a->subsampledCoarseReconstructionEarlyAccess) == (b->subsampledCoarseReconstructionEarlyAccess))) { onFail("a->subsampledCoarseReconstructionEarlyAccess (Error: Value not equal)"); };
    if (!((a->maxSubsampledArrayLayers) == (b->maxSubsampledArrayLayers))) { onFail("a->maxSubsampledArrayLayers (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetSubsampledSamplers) == (b->maxDescriptorSetSubsampledSamplers))) { onFail("a->maxDescriptorSetSubsampledSamplers (Error: Value not equal)"); };
}

#endif
#ifdef VK_QCOM_rotated_copy_commands
void checkEqual_VkCopyCommandTransformInfoQCOM(
    const VkCopyCommandTransformInfoQCOM* a,
    const VkCopyCommandTransformInfoQCOM* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->transform) == (b->transform))) { onFail("a->transform (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_image_robustness
void checkEqual_VkPhysicalDeviceImageRobustnessFeaturesEXT(
    const VkPhysicalDeviceImageRobustnessFeaturesEXT* a,
    const VkPhysicalDeviceImageRobustnessFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->robustImageAccess) == (b->robustImageAccess))) { onFail("a->robustImageAccess (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_4444_formats
void checkEqual_VkPhysicalDevice4444FormatsFeaturesEXT(
    const VkPhysicalDevice4444FormatsFeaturesEXT* a,
    const VkPhysicalDevice4444FormatsFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->formatA4R4G4B4) == (b->formatA4R4G4B4))) { onFail("a->formatA4R4G4B4 (Error: Value not equal)"); };
    if (!((a->formatA4B4G4R4) == (b->formatA4B4G4R4))) { onFail("a->formatA4B4G4R4 (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_rgba10x6_formats
void checkEqual_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(
    const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* a,
    const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->formatRgba10x6WithoutYCbCrSampler) == (b->formatRgba10x6WithoutYCbCrSampler))) { onFail("a->formatRgba10x6WithoutYCbCrSampler (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_acquire_winrt_display
#endif
#ifdef VK_EXT_directfb_surface
void checkEqual_VkDirectFBSurfaceCreateInfoEXT(
    const VkDirectFBSurfaceCreateInfoEXT* a,
    const VkDirectFBSurfaceCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->dfb) && !(b->dfb)) || ((a->dfb) && (b->dfb)))) { onFail("a->dfb (Error: Mismatch in optional field)"); };
    if (a->dfb && b->dfb)
    {
        if (!((memcmp(a->dfb, b->dfb, sizeof(IDirectFB)) == 0))) { onFail("a->dfb (Error: Unequal dyn array)"); };
    }
    if (!((!(a->surface) && !(b->surface)) || ((a->surface) && (b->surface)))) { onFail("a->surface (Error: Mismatch in optional field)"); };
    if (a->surface && b->surface)
    {
        if (!((memcmp(a->surface, b->surface, sizeof(IDirectFBSurface)) == 0))) { onFail("a->surface (Error: Unequal dyn array)"); };
    }
}

#endif
#ifdef VK_VALVE_mutable_descriptor_type
void checkEqual_VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE(
    const VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE* a,
    const VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->mutableDescriptorType) == (b->mutableDescriptorType))) { onFail("a->mutableDescriptorType (Error: Value not equal)"); };
}

void checkEqual_VkMutableDescriptorTypeListVALVE(
    const VkMutableDescriptorTypeListVALVE* a,
    const VkMutableDescriptorTypeListVALVE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->descriptorTypeCount) == (b->descriptorTypeCount))) { onFail("a->descriptorTypeCount (Error: Value not equal)"); };
    if (!((a->descriptorTypeCount) == (b->descriptorTypeCount))) { onFail("a->pDescriptorTypes (Error: Lengths not equal)"); };
    if (!((memcmp(a->pDescriptorTypes, b->pDescriptorTypes, a->descriptorTypeCount * sizeof(const VkDescriptorType)) == 0))) { onFail("a->pDescriptorTypes (Error: Unequal dyn array)"); };
}

void checkEqual_VkMutableDescriptorTypeCreateInfoVALVE(
    const VkMutableDescriptorTypeCreateInfoVALVE* a,
    const VkMutableDescriptorTypeCreateInfoVALVE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->mutableDescriptorTypeListCount) == (b->mutableDescriptorTypeListCount))) { onFail("a->mutableDescriptorTypeListCount (Error: Value not equal)"); };
    if ((a->pMutableDescriptorTypeLists) && (b->pMutableDescriptorTypeLists))
    {
        if (!((a->mutableDescriptorTypeListCount) == (b->mutableDescriptorTypeListCount))) { onFail("a->pMutableDescriptorTypeLists (Error: Lengths not equal)"); };
        if ((a->mutableDescriptorTypeListCount) == (b->mutableDescriptorTypeListCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->mutableDescriptorTypeListCount; ++i)
                {
                    checkEqual_VkMutableDescriptorTypeListVALVE(a->pMutableDescriptorTypeLists + i, b->pMutableDescriptorTypeLists + i, onFail);
                }
            }
        }
    }
}

#endif
#ifdef VK_EXT_vertex_input_dynamic_state
void checkEqual_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(
    const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* a,
    const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->vertexInputDynamicState) == (b->vertexInputDynamicState))) { onFail("a->vertexInputDynamicState (Error: Value not equal)"); };
}

void checkEqual_VkVertexInputBindingDescription2EXT(
    const VkVertexInputBindingDescription2EXT* a,
    const VkVertexInputBindingDescription2EXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->binding) == (b->binding))) { onFail("a->binding (Error: Value not equal)"); };
    if (!((a->stride) == (b->stride))) { onFail("a->stride (Error: Value not equal)"); };
    if (!((a->inputRate) == (b->inputRate))) { onFail("a->inputRate (Error: Value not equal)"); };
    if (!((a->divisor) == (b->divisor))) { onFail("a->divisor (Error: Value not equal)"); };
}

void checkEqual_VkVertexInputAttributeDescription2EXT(
    const VkVertexInputAttributeDescription2EXT* a,
    const VkVertexInputAttributeDescription2EXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->location) == (b->location))) { onFail("a->location (Error: Value not equal)"); };
    if (!((a->binding) == (b->binding))) { onFail("a->binding (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_physical_device_drm
void checkEqual_VkPhysicalDeviceDrmPropertiesEXT(
    const VkPhysicalDeviceDrmPropertiesEXT* a,
    const VkPhysicalDeviceDrmPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->hasPrimary) == (b->hasPrimary))) { onFail("a->hasPrimary (Error: Value not equal)"); };
    if (!((a->hasRender) == (b->hasRender))) { onFail("a->hasRender (Error: Value not equal)"); };
    if (!((a->primaryMajor) == (b->primaryMajor))) { onFail("a->primaryMajor (Error: Value not equal)"); };
    if (!((a->primaryMinor) == (b->primaryMinor))) { onFail("a->primaryMinor (Error: Value not equal)"); };
    if (!((a->renderMajor) == (b->renderMajor))) { onFail("a->renderMajor (Error: Value not equal)"); };
    if (!((a->renderMinor) == (b->renderMinor))) { onFail("a->renderMinor (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_primitive_topology_list_restart
void checkEqual_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(
    const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* a,
    const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->primitiveTopologyListRestart) == (b->primitiveTopologyListRestart))) { onFail("a->primitiveTopologyListRestart (Error: Value not equal)"); };
    if (!((a->primitiveTopologyPatchListRestart) == (b->primitiveTopologyPatchListRestart))) { onFail("a->primitiveTopologyPatchListRestart (Error: Value not equal)"); };
}

#endif
#ifdef VK_FUCHSIA_external_memory
void checkEqual_VkImportMemoryZirconHandleInfoFUCHSIA(
    const VkImportMemoryZirconHandleInfoFUCHSIA* a,
    const VkImportMemoryZirconHandleInfoFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->handle) == (b->handle))) { onFail("a->handle (Error: Value not equal)"); };
}

void checkEqual_VkMemoryZirconHandlePropertiesFUCHSIA(
    const VkMemoryZirconHandlePropertiesFUCHSIA* a,
    const VkMemoryZirconHandlePropertiesFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memoryTypeBits) == (b->memoryTypeBits))) { onFail("a->memoryTypeBits (Error: Value not equal)"); };
}

void checkEqual_VkMemoryGetZirconHandleInfoFUCHSIA(
    const VkMemoryGetZirconHandleInfoFUCHSIA* a,
    const VkMemoryGetZirconHandleInfoFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

#endif
#ifdef VK_FUCHSIA_external_semaphore
void checkEqual_VkImportSemaphoreZirconHandleInfoFUCHSIA(
    const VkImportSemaphoreZirconHandleInfoFUCHSIA* a,
    const VkImportSemaphoreZirconHandleInfoFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->semaphore) == (b->semaphore))) { onFail("a->semaphore (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
    if (!((a->zirconHandle) == (b->zirconHandle))) { onFail("a->zirconHandle (Error: Value not equal)"); };
}

void checkEqual_VkSemaphoreGetZirconHandleInfoFUCHSIA(
    const VkSemaphoreGetZirconHandleInfoFUCHSIA* a,
    const VkSemaphoreGetZirconHandleInfoFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->semaphore) == (b->semaphore))) { onFail("a->semaphore (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

#endif
#ifdef VK_FUCHSIA_buffer_collection
void checkEqual_VkBufferCollectionCreateInfoFUCHSIA(
    const VkBufferCollectionCreateInfoFUCHSIA* a,
    const VkBufferCollectionCreateInfoFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->collectionToken) == (b->collectionToken))) { onFail("a->collectionToken (Error: Value not equal)"); };
}

void checkEqual_VkImportMemoryBufferCollectionFUCHSIA(
    const VkImportMemoryBufferCollectionFUCHSIA* a,
    const VkImportMemoryBufferCollectionFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->collection) == (b->collection))) { onFail("a->collection (Error: Value not equal)"); };
    if (!((a->index) == (b->index))) { onFail("a->index (Error: Value not equal)"); };
}

void checkEqual_VkBufferCollectionImageCreateInfoFUCHSIA(
    const VkBufferCollectionImageCreateInfoFUCHSIA* a,
    const VkBufferCollectionImageCreateInfoFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->collection) == (b->collection))) { onFail("a->collection (Error: Value not equal)"); };
    if (!((a->index) == (b->index))) { onFail("a->index (Error: Value not equal)"); };
}

void checkEqual_VkBufferCollectionConstraintsInfoFUCHSIA(
    const VkBufferCollectionConstraintsInfoFUCHSIA* a,
    const VkBufferCollectionConstraintsInfoFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->minBufferCount) == (b->minBufferCount))) { onFail("a->minBufferCount (Error: Value not equal)"); };
    if (!((a->maxBufferCount) == (b->maxBufferCount))) { onFail("a->maxBufferCount (Error: Value not equal)"); };
    if (!((a->minBufferCountForCamping) == (b->minBufferCountForCamping))) { onFail("a->minBufferCountForCamping (Error: Value not equal)"); };
    if (!((a->minBufferCountForDedicatedSlack) == (b->minBufferCountForDedicatedSlack))) { onFail("a->minBufferCountForDedicatedSlack (Error: Value not equal)"); };
    if (!((a->minBufferCountForSharedSlack) == (b->minBufferCountForSharedSlack))) { onFail("a->minBufferCountForSharedSlack (Error: Value not equal)"); };
}

void checkEqual_VkBufferConstraintsInfoFUCHSIA(
    const VkBufferConstraintsInfoFUCHSIA* a,
    const VkBufferConstraintsInfoFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkBufferCreateInfo(&a->createInfo, &b->createInfo, onFail);
    if (!((a->requiredFormatFeatures) == (b->requiredFormatFeatures))) { onFail("a->requiredFormatFeatures (Error: Value not equal)"); };
    checkEqual_VkBufferCollectionConstraintsInfoFUCHSIA(&a->bufferCollectionConstraints, &b->bufferCollectionConstraints, onFail);
}

void checkEqual_VkBufferCollectionBufferCreateInfoFUCHSIA(
    const VkBufferCollectionBufferCreateInfoFUCHSIA* a,
    const VkBufferCollectionBufferCreateInfoFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->collection) == (b->collection))) { onFail("a->collection (Error: Value not equal)"); };
    if (!((a->index) == (b->index))) { onFail("a->index (Error: Value not equal)"); };
}

void checkEqual_VkSysmemColorSpaceFUCHSIA(
    const VkSysmemColorSpaceFUCHSIA* a,
    const VkSysmemColorSpaceFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->colorSpace) == (b->colorSpace))) { onFail("a->colorSpace (Error: Value not equal)"); };
}

void checkEqual_VkBufferCollectionPropertiesFUCHSIA(
    const VkBufferCollectionPropertiesFUCHSIA* a,
    const VkBufferCollectionPropertiesFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memoryTypeBits) == (b->memoryTypeBits))) { onFail("a->memoryTypeBits (Error: Value not equal)"); };
    if (!((a->bufferCount) == (b->bufferCount))) { onFail("a->bufferCount (Error: Value not equal)"); };
    if (!((a->createInfoIndex) == (b->createInfoIndex))) { onFail("a->createInfoIndex (Error: Value not equal)"); };
    if (!((a->sysmemPixelFormat) == (b->sysmemPixelFormat))) { onFail("a->sysmemPixelFormat (Error: Value not equal)"); };
    if (!((a->formatFeatures) == (b->formatFeatures))) { onFail("a->formatFeatures (Error: Value not equal)"); };
    checkEqual_VkSysmemColorSpaceFUCHSIA(&a->sysmemColorSpaceIndex, &b->sysmemColorSpaceIndex, onFail);
    checkEqual_VkComponentMapping(&a->samplerYcbcrConversionComponents, &b->samplerYcbcrConversionComponents, onFail);
    if (!((a->suggestedYcbcrModel) == (b->suggestedYcbcrModel))) { onFail("a->suggestedYcbcrModel (Error: Value not equal)"); };
    if (!((a->suggestedYcbcrRange) == (b->suggestedYcbcrRange))) { onFail("a->suggestedYcbcrRange (Error: Value not equal)"); };
    if (!((a->suggestedXChromaOffset) == (b->suggestedXChromaOffset))) { onFail("a->suggestedXChromaOffset (Error: Value not equal)"); };
    if (!((a->suggestedYChromaOffset) == (b->suggestedYChromaOffset))) { onFail("a->suggestedYChromaOffset (Error: Value not equal)"); };
}

void checkEqual_VkImageFormatConstraintsInfoFUCHSIA(
    const VkImageFormatConstraintsInfoFUCHSIA* a,
    const VkImageFormatConstraintsInfoFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkImageCreateInfo(&a->imageCreateInfo, &b->imageCreateInfo, onFail);
    if (!((a->requiredFormatFeatures) == (b->requiredFormatFeatures))) { onFail("a->requiredFormatFeatures (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->sysmemPixelFormat) == (b->sysmemPixelFormat))) { onFail("a->sysmemPixelFormat (Error: Value not equal)"); };
    if (!((a->colorSpaceCount) == (b->colorSpaceCount))) { onFail("a->colorSpaceCount (Error: Value not equal)"); };
    if ((a->pColorSpaces) && (b->pColorSpaces))
    {
        checkEqual_VkSysmemColorSpaceFUCHSIA(a->pColorSpaces, b->pColorSpaces, onFail);
    }
}

void checkEqual_VkImageConstraintsInfoFUCHSIA(
    const VkImageConstraintsInfoFUCHSIA* a,
    const VkImageConstraintsInfoFUCHSIA* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->formatConstraintsCount) == (b->formatConstraintsCount))) { onFail("a->formatConstraintsCount (Error: Value not equal)"); };
    if ((a->pFormatConstraints) && (b->pFormatConstraints))
    {
        if (!((a->formatConstraintsCount) == (b->formatConstraintsCount))) { onFail("a->pFormatConstraints (Error: Lengths not equal)"); };
        if ((a->formatConstraintsCount) == (b->formatConstraintsCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->formatConstraintsCount; ++i)
                {
                    checkEqual_VkImageFormatConstraintsInfoFUCHSIA(a->pFormatConstraints + i, b->pFormatConstraints + i, onFail);
                }
            }
        }
    }
    checkEqual_VkBufferCollectionConstraintsInfoFUCHSIA(&a->bufferCollectionConstraints, &b->bufferCollectionConstraints, onFail);
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

#endif
#ifdef VK_HUAWEI_subpass_shading
void checkEqual_VkSubpassShadingPipelineCreateInfoHUAWEI(
    const VkSubpassShadingPipelineCreateInfoHUAWEI* a,
    const VkSubpassShadingPipelineCreateInfoHUAWEI* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->renderPass) == (b->renderPass))) { onFail("a->renderPass (Error: Value not equal)"); };
    if (!((a->subpass) == (b->subpass))) { onFail("a->subpass (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(
    const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* a,
    const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->subpassShading) == (b->subpassShading))) { onFail("a->subpassShading (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(
    const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI* a,
    const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxSubpassShadingWorkgroupSizeAspectRatio) == (b->maxSubpassShadingWorkgroupSizeAspectRatio))) { onFail("a->maxSubpassShadingWorkgroupSizeAspectRatio (Error: Value not equal)"); };
}

#endif
#ifdef VK_HUAWEI_invocation_mask
void checkEqual_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(
    const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* a,
    const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->invocationMask) == (b->invocationMask))) { onFail("a->invocationMask (Error: Value not equal)"); };
}

#endif
#ifdef VK_NV_external_memory_rdma
void checkEqual_VkMemoryGetRemoteAddressInfoNV(
    const VkMemoryGetRemoteAddressInfoNV* a,
    const VkMemoryGetRemoteAddressInfoNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->memory) == (b->memory))) { onFail("a->memory (Error: Value not equal)"); };
    if (!((a->handleType) == (b->handleType))) { onFail("a->handleType (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(
    const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* a,
    const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->externalMemoryRDMA) == (b->externalMemoryRDMA))) { onFail("a->externalMemoryRDMA (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_extended_dynamic_state2
void checkEqual_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(
    const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* a,
    const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->extendedDynamicState2) == (b->extendedDynamicState2))) { onFail("a->extendedDynamicState2 (Error: Value not equal)"); };
    if (!((a->extendedDynamicState2LogicOp) == (b->extendedDynamicState2LogicOp))) { onFail("a->extendedDynamicState2LogicOp (Error: Value not equal)"); };
    if (!((a->extendedDynamicState2PatchControlPoints) == (b->extendedDynamicState2PatchControlPoints))) { onFail("a->extendedDynamicState2PatchControlPoints (Error: Value not equal)"); };
}

#endif
#ifdef VK_QNX_screen_surface
void checkEqual_VkScreenSurfaceCreateInfoQNX(
    const VkScreenSurfaceCreateInfoQNX* a,
    const VkScreenSurfaceCreateInfoQNX* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((!(a->context) && !(b->context)) || ((a->context) && (b->context)))) { onFail("a->context (Error: Mismatch in optional field)"); };
    if (a->context && b->context)
    {
        if (!((memcmp(a->context, b->context, sizeof(_screen_context)) == 0))) { onFail("a->context (Error: Unequal dyn array)"); };
    }
    if (!((!(a->window) && !(b->window)) || ((a->window) && (b->window)))) { onFail("a->window (Error: Mismatch in optional field)"); };
    if (a->window && b->window)
    {
        if (!((memcmp(a->window, b->window, sizeof(_screen_window)) == 0))) { onFail("a->window (Error: Unequal dyn array)"); };
    }
}

#endif
#ifdef VK_EXT_color_write_enable
void checkEqual_VkPhysicalDeviceColorWriteEnableFeaturesEXT(
    const VkPhysicalDeviceColorWriteEnableFeaturesEXT* a,
    const VkPhysicalDeviceColorWriteEnableFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->colorWriteEnable) == (b->colorWriteEnable))) { onFail("a->colorWriteEnable (Error: Value not equal)"); };
}

void checkEqual_VkPipelineColorWriteCreateInfoEXT(
    const VkPipelineColorWriteCreateInfoEXT* a,
    const VkPipelineColorWriteCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->attachmentCount (Error: Value not equal)"); };
    if (!((a->attachmentCount) == (b->attachmentCount))) { onFail("a->pColorWriteEnables (Error: Lengths not equal)"); };
    if (!((memcmp(a->pColorWriteEnables, b->pColorWriteEnables, a->attachmentCount * sizeof(const VkBool32)) == 0))) { onFail("a->pColorWriteEnables (Error: Unequal dyn array)"); };
}

#endif
#ifdef VK_GOOGLE_gfxstream
void checkEqual_VkImportColorBufferGOOGLE(
    const VkImportColorBufferGOOGLE* a,
    const VkImportColorBufferGOOGLE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->colorBuffer) == (b->colorBuffer))) { onFail("a->colorBuffer (Error: Value not equal)"); };
}

void checkEqual_VkImportBufferGOOGLE(
    const VkImportBufferGOOGLE* a,
    const VkImportBufferGOOGLE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
}

void checkEqual_VkImportPhysicalAddressGOOGLE(
    const VkImportPhysicalAddressGOOGLE* a,
    const VkImportPhysicalAddressGOOGLE* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->physicalAddress) == (b->physicalAddress))) { onFail("a->physicalAddress (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->format) == (b->format))) { onFail("a->format (Error: Value not equal)"); };
    if (!((a->tiling) == (b->tiling))) { onFail("a->tiling (Error: Value not equal)"); };
    if (!((a->tilingParameter) == (b->tilingParameter))) { onFail("a->tilingParameter (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_global_priority_query
void checkEqual_VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT(
    const VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT* a,
    const VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->globalPriorityQuery) == (b->globalPriorityQuery))) { onFail("a->globalPriorityQuery (Error: Value not equal)"); };
}

void checkEqual_VkQueueFamilyGlobalPriorityPropertiesEXT(
    const VkQueueFamilyGlobalPriorityPropertiesEXT* a,
    const VkQueueFamilyGlobalPriorityPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->priorityCount) == (b->priorityCount))) { onFail("a->priorityCount (Error: Value not equal)"); };
    if (!((memcmp(a->priorities, b->priorities, VK_MAX_GLOBAL_PRIORITY_SIZE_EXT * sizeof(VkQueueGlobalPriorityEXT)) == 0))) { onFail("a->priorities (Error: Unequal static array)"); };
}

#endif
#ifdef VK_EXT_multi_draw
void checkEqual_VkPhysicalDeviceMultiDrawFeaturesEXT(
    const VkPhysicalDeviceMultiDrawFeaturesEXT* a,
    const VkPhysicalDeviceMultiDrawFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->multiDraw) == (b->multiDraw))) { onFail("a->multiDraw (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceMultiDrawPropertiesEXT(
    const VkPhysicalDeviceMultiDrawPropertiesEXT* a,
    const VkPhysicalDeviceMultiDrawPropertiesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxMultiDrawCount) == (b->maxMultiDrawCount))) { onFail("a->maxMultiDrawCount (Error: Value not equal)"); };
}

void checkEqual_VkMultiDrawInfoEXT(
    const VkMultiDrawInfoEXT* a,
    const VkMultiDrawInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->firstVertex) == (b->firstVertex))) { onFail("a->firstVertex (Error: Value not equal)"); };
    if (!((a->vertexCount) == (b->vertexCount))) { onFail("a->vertexCount (Error: Value not equal)"); };
}

void checkEqual_VkMultiDrawIndexedInfoEXT(
    const VkMultiDrawIndexedInfoEXT* a,
    const VkMultiDrawIndexedInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->firstIndex) == (b->firstIndex))) { onFail("a->firstIndex (Error: Value not equal)"); };
    if (!((a->indexCount) == (b->indexCount))) { onFail("a->indexCount (Error: Value not equal)"); };
    if (!((a->vertexOffset) == (b->vertexOffset))) { onFail("a->vertexOffset (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_load_store_op_none
#endif
#ifdef VK_EXT_border_color_swizzle
void checkEqual_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(
    const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* a,
    const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->borderColorSwizzle) == (b->borderColorSwizzle))) { onFail("a->borderColorSwizzle (Error: Value not equal)"); };
    if (!((a->borderColorSwizzleFromImage) == (b->borderColorSwizzleFromImage))) { onFail("a->borderColorSwizzleFromImage (Error: Value not equal)"); };
}

void checkEqual_VkSamplerBorderColorComponentMappingCreateInfoEXT(
    const VkSamplerBorderColorComponentMappingCreateInfoEXT* a,
    const VkSamplerBorderColorComponentMappingCreateInfoEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkComponentMapping(&a->components, &b->components, onFail);
    if (!((a->srgb) == (b->srgb))) { onFail("a->srgb (Error: Value not equal)"); };
}

#endif
#ifdef VK_EXT_pageable_device_local_memory
void checkEqual_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(
    const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* a,
    const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->pageableDeviceLocalMemory) == (b->pageableDeviceLocalMemory))) { onFail("a->pageableDeviceLocalMemory (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_acceleration_structure
void checkEqual_VkDeviceOrHostAddressKHR(
    const VkDeviceOrHostAddressKHR* a,
    const VkDeviceOrHostAddressKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->deviceAddress) == (b->deviceAddress))) { onFail("a->deviceAddress (Error: Value not equal)"); };
    if (!((!(a->hostAddress) && !(b->hostAddress)) || ((a->hostAddress) && (b->hostAddress)))) { onFail("a->hostAddress (Error: Mismatch in optional field)"); };
}

void checkEqual_VkAccelerationStructureBuildRangeInfoKHR(
    const VkAccelerationStructureBuildRangeInfoKHR* a,
    const VkAccelerationStructureBuildRangeInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->primitiveCount) == (b->primitiveCount))) { onFail("a->primitiveCount (Error: Value not equal)"); };
    if (!((a->primitiveOffset) == (b->primitiveOffset))) { onFail("a->primitiveOffset (Error: Value not equal)"); };
    if (!((a->firstVertex) == (b->firstVertex))) { onFail("a->firstVertex (Error: Value not equal)"); };
    if (!((a->transformOffset) == (b->transformOffset))) { onFail("a->transformOffset (Error: Value not equal)"); };
}

void checkEqual_VkAccelerationStructureGeometryTrianglesDataKHR(
    const VkAccelerationStructureGeometryTrianglesDataKHR* a,
    const VkAccelerationStructureGeometryTrianglesDataKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->vertexFormat) == (b->vertexFormat))) { onFail("a->vertexFormat (Error: Value not equal)"); };
    checkEqual_VkDeviceOrHostAddressConstKHR(&a->vertexData, &b->vertexData, onFail);
    if (!((a->vertexStride) == (b->vertexStride))) { onFail("a->vertexStride (Error: Value not equal)"); };
    if (!((a->maxVertex) == (b->maxVertex))) { onFail("a->maxVertex (Error: Value not equal)"); };
    if (!((a->indexType) == (b->indexType))) { onFail("a->indexType (Error: Value not equal)"); };
    checkEqual_VkDeviceOrHostAddressConstKHR(&a->indexData, &b->indexData, onFail);
    checkEqual_VkDeviceOrHostAddressConstKHR(&a->transformData, &b->transformData, onFail);
}

void checkEqual_VkAccelerationStructureGeometryAabbsDataKHR(
    const VkAccelerationStructureGeometryAabbsDataKHR* a,
    const VkAccelerationStructureGeometryAabbsDataKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkDeviceOrHostAddressConstKHR(&a->data, &b->data, onFail);
    if (!((a->stride) == (b->stride))) { onFail("a->stride (Error: Value not equal)"); };
}

void checkEqual_VkAccelerationStructureGeometryInstancesDataKHR(
    const VkAccelerationStructureGeometryInstancesDataKHR* a,
    const VkAccelerationStructureGeometryInstancesDataKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->arrayOfPointers) == (b->arrayOfPointers))) { onFail("a->arrayOfPointers (Error: Value not equal)"); };
    checkEqual_VkDeviceOrHostAddressConstKHR(&a->data, &b->data, onFail);
}

void checkEqual_VkAccelerationStructureGeometryDataKHR(
    const VkAccelerationStructureGeometryDataKHR* a,
    const VkAccelerationStructureGeometryDataKHR* b,
    OnFailCompareFunc onFail)
{
    checkEqual_VkAccelerationStructureGeometryTrianglesDataKHR(&a->triangles, &b->triangles, onFail);
    checkEqual_VkAccelerationStructureGeometryAabbsDataKHR(&a->aabbs, &b->aabbs, onFail);
    checkEqual_VkAccelerationStructureGeometryInstancesDataKHR(&a->instances, &b->instances, onFail);
}

void checkEqual_VkAccelerationStructureGeometryKHR(
    const VkAccelerationStructureGeometryKHR* a,
    const VkAccelerationStructureGeometryKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->geometryType) == (b->geometryType))) { onFail("a->geometryType (Error: Value not equal)"); };
    checkEqual_VkAccelerationStructureGeometryDataKHR(&a->geometry, &b->geometry, onFail);
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
}

void checkEqual_VkAccelerationStructureBuildGeometryInfoKHR(
    const VkAccelerationStructureBuildGeometryInfoKHR* a,
    const VkAccelerationStructureBuildGeometryInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->mode) == (b->mode))) { onFail("a->mode (Error: Value not equal)"); };
    if (!((a->srcAccelerationStructure) == (b->srcAccelerationStructure))) { onFail("a->srcAccelerationStructure (Error: Value not equal)"); };
    if (!((a->dstAccelerationStructure) == (b->dstAccelerationStructure))) { onFail("a->dstAccelerationStructure (Error: Value not equal)"); };
    if (!((a->geometryCount) == (b->geometryCount))) { onFail("a->geometryCount (Error: Value not equal)"); };
    if (!((!(a->pGeometries) && !(b->pGeometries)) || ((a->pGeometries) && (b->pGeometries)))) { onFail("a->pGeometries (Error: Mismatch in optional field)"); };
    if (a->pGeometries && b->pGeometries)
    {
        if ((a->pGeometries) && (b->pGeometries))
        {
            if (!((a->geometryCount) == (b->geometryCount))) { onFail("a->pGeometries (Error: Lengths not equal)"); };
            if ((a->geometryCount) == (b->geometryCount))
            {
                if (a)
                {
                    for (uint32_t i = 0; i < (uint32_t)a->geometryCount; ++i)
                    {
                        checkEqual_VkAccelerationStructureGeometryKHR(a->pGeometries + i, b->pGeometries + i, onFail);
                    }
                }
            }
        }
    }
    checkEqual_VkDeviceOrHostAddressKHR(&a->scratchData, &b->scratchData, onFail);
}

void checkEqual_VkAccelerationStructureCreateInfoKHR(
    const VkAccelerationStructureCreateInfoKHR* a,
    const VkAccelerationStructureCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->createFlags) == (b->createFlags))) { onFail("a->createFlags (Error: Value not equal)"); };
    if (!((a->buffer) == (b->buffer))) { onFail("a->buffer (Error: Value not equal)"); };
    if (!((a->offset) == (b->offset))) { onFail("a->offset (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->deviceAddress) == (b->deviceAddress))) { onFail("a->deviceAddress (Error: Value not equal)"); };
}

void checkEqual_VkWriteDescriptorSetAccelerationStructureKHR(
    const VkWriteDescriptorSetAccelerationStructureKHR* a,
    const VkWriteDescriptorSetAccelerationStructureKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->accelerationStructureCount) == (b->accelerationStructureCount))) { onFail("a->accelerationStructureCount (Error: Value not equal)"); };
    if (!((!(a->pAccelerationStructures) && !(b->pAccelerationStructures)) || ((a->pAccelerationStructures) && (b->pAccelerationStructures)))) { onFail("a->pAccelerationStructures (Error: Mismatch in optional field)"); };
    if (a->pAccelerationStructures && b->pAccelerationStructures)
    {
        if (!((a->accelerationStructureCount) == (b->accelerationStructureCount))) { onFail("a->pAccelerationStructures (Error: Lengths not equal)"); };
        if (!((memcmp(a->pAccelerationStructures, b->pAccelerationStructures, a->accelerationStructureCount * sizeof(const VkAccelerationStructureKHR)) == 0))) { onFail("a->pAccelerationStructures (Error: Unequal dyn array)"); };
    }
}

void checkEqual_VkPhysicalDeviceAccelerationStructureFeaturesKHR(
    const VkPhysicalDeviceAccelerationStructureFeaturesKHR* a,
    const VkPhysicalDeviceAccelerationStructureFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->accelerationStructure) == (b->accelerationStructure))) { onFail("a->accelerationStructure (Error: Value not equal)"); };
    if (!((a->accelerationStructureCaptureReplay) == (b->accelerationStructureCaptureReplay))) { onFail("a->accelerationStructureCaptureReplay (Error: Value not equal)"); };
    if (!((a->accelerationStructureIndirectBuild) == (b->accelerationStructureIndirectBuild))) { onFail("a->accelerationStructureIndirectBuild (Error: Value not equal)"); };
    if (!((a->accelerationStructureHostCommands) == (b->accelerationStructureHostCommands))) { onFail("a->accelerationStructureHostCommands (Error: Value not equal)"); };
    if (!((a->descriptorBindingAccelerationStructureUpdateAfterBind) == (b->descriptorBindingAccelerationStructureUpdateAfterBind))) { onFail("a->descriptorBindingAccelerationStructureUpdateAfterBind (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceAccelerationStructurePropertiesKHR(
    const VkPhysicalDeviceAccelerationStructurePropertiesKHR* a,
    const VkPhysicalDeviceAccelerationStructurePropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxGeometryCount) == (b->maxGeometryCount))) { onFail("a->maxGeometryCount (Error: Value not equal)"); };
    if (!((a->maxInstanceCount) == (b->maxInstanceCount))) { onFail("a->maxInstanceCount (Error: Value not equal)"); };
    if (!((a->maxPrimitiveCount) == (b->maxPrimitiveCount))) { onFail("a->maxPrimitiveCount (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorAccelerationStructures) == (b->maxPerStageDescriptorAccelerationStructures))) { onFail("a->maxPerStageDescriptorAccelerationStructures (Error: Value not equal)"); };
    if (!((a->maxPerStageDescriptorUpdateAfterBindAccelerationStructures) == (b->maxPerStageDescriptorUpdateAfterBindAccelerationStructures))) { onFail("a->maxPerStageDescriptorUpdateAfterBindAccelerationStructures (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetAccelerationStructures) == (b->maxDescriptorSetAccelerationStructures))) { onFail("a->maxDescriptorSetAccelerationStructures (Error: Value not equal)"); };
    if (!((a->maxDescriptorSetUpdateAfterBindAccelerationStructures) == (b->maxDescriptorSetUpdateAfterBindAccelerationStructures))) { onFail("a->maxDescriptorSetUpdateAfterBindAccelerationStructures (Error: Value not equal)"); };
    if (!((a->minAccelerationStructureScratchOffsetAlignment) == (b->minAccelerationStructureScratchOffsetAlignment))) { onFail("a->minAccelerationStructureScratchOffsetAlignment (Error: Value not equal)"); };
}

void checkEqual_VkAccelerationStructureDeviceAddressInfoKHR(
    const VkAccelerationStructureDeviceAddressInfoKHR* a,
    const VkAccelerationStructureDeviceAddressInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->accelerationStructure) == (b->accelerationStructure))) { onFail("a->accelerationStructure (Error: Value not equal)"); };
}

void checkEqual_VkAccelerationStructureVersionInfoKHR(
    const VkAccelerationStructureVersionInfoKHR* a,
    const VkAccelerationStructureVersionInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((2*VK_UUID_SIZE) == (2*VK_UUID_SIZE))) { onFail("a->pVersionData (Error: Lengths not equal)"); };
    if (!((memcmp(a->pVersionData, b->pVersionData, 2*VK_UUID_SIZE * sizeof(const uint8_t)) == 0))) { onFail("a->pVersionData (Error: Unequal dyn array)"); };
}

void checkEqual_VkCopyAccelerationStructureToMemoryInfoKHR(
    const VkCopyAccelerationStructureToMemoryInfoKHR* a,
    const VkCopyAccelerationStructureToMemoryInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->src) == (b->src))) { onFail("a->src (Error: Value not equal)"); };
    checkEqual_VkDeviceOrHostAddressKHR(&a->dst, &b->dst, onFail);
    if (!((a->mode) == (b->mode))) { onFail("a->mode (Error: Value not equal)"); };
}

void checkEqual_VkCopyMemoryToAccelerationStructureInfoKHR(
    const VkCopyMemoryToAccelerationStructureInfoKHR* a,
    const VkCopyMemoryToAccelerationStructureInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    checkEqual_VkDeviceOrHostAddressConstKHR(&a->src, &b->src, onFail);
    if (!((a->dst) == (b->dst))) { onFail("a->dst (Error: Value not equal)"); };
    if (!((a->mode) == (b->mode))) { onFail("a->mode (Error: Value not equal)"); };
}

void checkEqual_VkCopyAccelerationStructureInfoKHR(
    const VkCopyAccelerationStructureInfoKHR* a,
    const VkCopyAccelerationStructureInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->src) == (b->src))) { onFail("a->src (Error: Value not equal)"); };
    if (!((a->dst) == (b->dst))) { onFail("a->dst (Error: Value not equal)"); };
    if (!((a->mode) == (b->mode))) { onFail("a->mode (Error: Value not equal)"); };
}

void checkEqual_VkAccelerationStructureBuildSizesInfoKHR(
    const VkAccelerationStructureBuildSizesInfoKHR* a,
    const VkAccelerationStructureBuildSizesInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->accelerationStructureSize) == (b->accelerationStructureSize))) { onFail("a->accelerationStructureSize (Error: Value not equal)"); };
    if (!((a->updateScratchSize) == (b->updateScratchSize))) { onFail("a->updateScratchSize (Error: Value not equal)"); };
    if (!((a->buildScratchSize) == (b->buildScratchSize))) { onFail("a->buildScratchSize (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_ray_tracing_pipeline
void checkEqual_VkRayTracingShaderGroupCreateInfoKHR(
    const VkRayTracingShaderGroupCreateInfoKHR* a,
    const VkRayTracingShaderGroupCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->type) == (b->type))) { onFail("a->type (Error: Value not equal)"); };
    if (!((a->generalShader) == (b->generalShader))) { onFail("a->generalShader (Error: Value not equal)"); };
    if (!((a->closestHitShader) == (b->closestHitShader))) { onFail("a->closestHitShader (Error: Value not equal)"); };
    if (!((a->anyHitShader) == (b->anyHitShader))) { onFail("a->anyHitShader (Error: Value not equal)"); };
    if (!((a->intersectionShader) == (b->intersectionShader))) { onFail("a->intersectionShader (Error: Value not equal)"); };
    if (!((!(a->pShaderGroupCaptureReplayHandle) && !(b->pShaderGroupCaptureReplayHandle)) || ((a->pShaderGroupCaptureReplayHandle) && (b->pShaderGroupCaptureReplayHandle)))) { onFail("a->pShaderGroupCaptureReplayHandle (Error: Mismatch in optional field)"); };
}

void checkEqual_VkRayTracingPipelineInterfaceCreateInfoKHR(
    const VkRayTracingPipelineInterfaceCreateInfoKHR* a,
    const VkRayTracingPipelineInterfaceCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->maxPipelineRayPayloadSize) == (b->maxPipelineRayPayloadSize))) { onFail("a->maxPipelineRayPayloadSize (Error: Value not equal)"); };
    if (!((a->maxPipelineRayHitAttributeSize) == (b->maxPipelineRayHitAttributeSize))) { onFail("a->maxPipelineRayHitAttributeSize (Error: Value not equal)"); };
}

void checkEqual_VkRayTracingPipelineCreateInfoKHR(
    const VkRayTracingPipelineCreateInfoKHR* a,
    const VkRayTracingPipelineCreateInfoKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->flags) == (b->flags))) { onFail("a->flags (Error: Value not equal)"); };
    if (!((a->stageCount) == (b->stageCount))) { onFail("a->stageCount (Error: Value not equal)"); };
    if ((a->pStages) && (b->pStages))
    {
        if (!((a->stageCount) == (b->stageCount))) { onFail("a->pStages (Error: Lengths not equal)"); };
        if ((a->stageCount) == (b->stageCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->stageCount; ++i)
                {
                    checkEqual_VkPipelineShaderStageCreateInfo(a->pStages + i, b->pStages + i, onFail);
                }
            }
        }
    }
    if (!((a->groupCount) == (b->groupCount))) { onFail("a->groupCount (Error: Value not equal)"); };
    if ((a->pGroups) && (b->pGroups))
    {
        if (!((a->groupCount) == (b->groupCount))) { onFail("a->pGroups (Error: Lengths not equal)"); };
        if ((a->groupCount) == (b->groupCount))
        {
            if (a)
            {
                for (uint32_t i = 0; i < (uint32_t)a->groupCount; ++i)
                {
                    checkEqual_VkRayTracingShaderGroupCreateInfoKHR(a->pGroups + i, b->pGroups + i, onFail);
                }
            }
        }
    }
    if (!((a->maxPipelineRayRecursionDepth) == (b->maxPipelineRayRecursionDepth))) { onFail("a->maxPipelineRayRecursionDepth (Error: Value not equal)"); };
    if (!((!(a->pLibraryInfo) && !(b->pLibraryInfo)) || ((a->pLibraryInfo) && (b->pLibraryInfo)))) { onFail("a->pLibraryInfo (Error: Mismatch in optional field)"); };
    if (a->pLibraryInfo && b->pLibraryInfo)
    {
        if ((a->pLibraryInfo) && (b->pLibraryInfo))
        {
            checkEqual_VkPipelineLibraryCreateInfoKHR(a->pLibraryInfo, b->pLibraryInfo, onFail);
        }
    }
    if (!((!(a->pLibraryInterface) && !(b->pLibraryInterface)) || ((a->pLibraryInterface) && (b->pLibraryInterface)))) { onFail("a->pLibraryInterface (Error: Mismatch in optional field)"); };
    if (a->pLibraryInterface && b->pLibraryInterface)
    {
        if ((a->pLibraryInterface) && (b->pLibraryInterface))
        {
            checkEqual_VkRayTracingPipelineInterfaceCreateInfoKHR(a->pLibraryInterface, b->pLibraryInterface, onFail);
        }
    }
    if (!((!(a->pDynamicState) && !(b->pDynamicState)) || ((a->pDynamicState) && (b->pDynamicState)))) { onFail("a->pDynamicState (Error: Mismatch in optional field)"); };
    if (a->pDynamicState && b->pDynamicState)
    {
        if ((a->pDynamicState) && (b->pDynamicState))
        {
            checkEqual_VkPipelineDynamicStateCreateInfo(a->pDynamicState, b->pDynamicState, onFail);
        }
    }
    if (!((a->layout) == (b->layout))) { onFail("a->layout (Error: Value not equal)"); };
    if (!((a->basePipelineHandle) == (b->basePipelineHandle))) { onFail("a->basePipelineHandle (Error: Value not equal)"); };
    if (!((a->basePipelineIndex) == (b->basePipelineIndex))) { onFail("a->basePipelineIndex (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(
    const VkPhysicalDeviceRayTracingPipelineFeaturesKHR* a,
    const VkPhysicalDeviceRayTracingPipelineFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->rayTracingPipeline) == (b->rayTracingPipeline))) { onFail("a->rayTracingPipeline (Error: Value not equal)"); };
    if (!((a->rayTracingPipelineShaderGroupHandleCaptureReplay) == (b->rayTracingPipelineShaderGroupHandleCaptureReplay))) { onFail("a->rayTracingPipelineShaderGroupHandleCaptureReplay (Error: Value not equal)"); };
    if (!((a->rayTracingPipelineShaderGroupHandleCaptureReplayMixed) == (b->rayTracingPipelineShaderGroupHandleCaptureReplayMixed))) { onFail("a->rayTracingPipelineShaderGroupHandleCaptureReplayMixed (Error: Value not equal)"); };
    if (!((a->rayTracingPipelineTraceRaysIndirect) == (b->rayTracingPipelineTraceRaysIndirect))) { onFail("a->rayTracingPipelineTraceRaysIndirect (Error: Value not equal)"); };
    if (!((a->rayTraversalPrimitiveCulling) == (b->rayTraversalPrimitiveCulling))) { onFail("a->rayTraversalPrimitiveCulling (Error: Value not equal)"); };
}

void checkEqual_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(
    const VkPhysicalDeviceRayTracingPipelinePropertiesKHR* a,
    const VkPhysicalDeviceRayTracingPipelinePropertiesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->shaderGroupHandleSize) == (b->shaderGroupHandleSize))) { onFail("a->shaderGroupHandleSize (Error: Value not equal)"); };
    if (!((a->maxRayRecursionDepth) == (b->maxRayRecursionDepth))) { onFail("a->maxRayRecursionDepth (Error: Value not equal)"); };
    if (!((a->maxShaderGroupStride) == (b->maxShaderGroupStride))) { onFail("a->maxShaderGroupStride (Error: Value not equal)"); };
    if (!((a->shaderGroupBaseAlignment) == (b->shaderGroupBaseAlignment))) { onFail("a->shaderGroupBaseAlignment (Error: Value not equal)"); };
    if (!((a->shaderGroupHandleCaptureReplaySize) == (b->shaderGroupHandleCaptureReplaySize))) { onFail("a->shaderGroupHandleCaptureReplaySize (Error: Value not equal)"); };
    if (!((a->maxRayDispatchInvocationCount) == (b->maxRayDispatchInvocationCount))) { onFail("a->maxRayDispatchInvocationCount (Error: Value not equal)"); };
    if (!((a->shaderGroupHandleAlignment) == (b->shaderGroupHandleAlignment))) { onFail("a->shaderGroupHandleAlignment (Error: Value not equal)"); };
    if (!((a->maxRayHitAttributeSize) == (b->maxRayHitAttributeSize))) { onFail("a->maxRayHitAttributeSize (Error: Value not equal)"); };
}

void checkEqual_VkStridedDeviceAddressRegionKHR(
    const VkStridedDeviceAddressRegionKHR* a,
    const VkStridedDeviceAddressRegionKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->deviceAddress) == (b->deviceAddress))) { onFail("a->deviceAddress (Error: Value not equal)"); };
    if (!((a->stride) == (b->stride))) { onFail("a->stride (Error: Value not equal)"); };
    if (!((a->size) == (b->size))) { onFail("a->size (Error: Value not equal)"); };
}

void checkEqual_VkTraceRaysIndirectCommandKHR(
    const VkTraceRaysIndirectCommandKHR* a,
    const VkTraceRaysIndirectCommandKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->width) == (b->width))) { onFail("a->width (Error: Value not equal)"); };
    if (!((a->height) == (b->height))) { onFail("a->height (Error: Value not equal)"); };
    if (!((a->depth) == (b->depth))) { onFail("a->depth (Error: Value not equal)"); };
}

#endif
#ifdef VK_KHR_ray_query
void checkEqual_VkPhysicalDeviceRayQueryFeaturesKHR(
    const VkPhysicalDeviceRayQueryFeaturesKHR* a,
    const VkPhysicalDeviceRayQueryFeaturesKHR* b,
    OnFailCompareFunc onFail)
{
    if (!((a->sType) == (b->sType))) { onFail("a->sType (Error: Value not equal)"); };
    if (a->pNext)
    {
        checkEqual_extension_struct(a->pNext, b->pNext, onFail);
    }
    if (!((a->rayQuery) == (b->rayQuery))) { onFail("a->rayQuery (Error: Value not equal)"); };
}

#endif
void checkEqual_extension_struct(
    const void* structExtension,
    const void* structExtension2,
    OnFailCompareFunc onFail)
{
    if (!structExtension)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceSubgroupProperties(reinterpret_cast<const VkPhysicalDeviceSubgroupProperties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceSubgroupProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            checkEqual_VkPhysicalDevice16BitStorageFeatures(reinterpret_cast<const VkPhysicalDevice16BitStorageFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDevice16BitStorageFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            checkEqual_VkMemoryDedicatedRequirements(reinterpret_cast<const VkMemoryDedicatedRequirements*>(structExtension), reinterpret_cast<const VkMemoryDedicatedRequirements*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            checkEqual_VkMemoryDedicatedAllocateInfo(reinterpret_cast<const VkMemoryDedicatedAllocateInfo*>(structExtension), reinterpret_cast<const VkMemoryDedicatedAllocateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            checkEqual_VkMemoryAllocateFlagsInfo(reinterpret_cast<const VkMemoryAllocateFlagsInfo*>(structExtension), reinterpret_cast<const VkMemoryAllocateFlagsInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            checkEqual_VkDeviceGroupRenderPassBeginInfo(reinterpret_cast<const VkDeviceGroupRenderPassBeginInfo*>(structExtension), reinterpret_cast<const VkDeviceGroupRenderPassBeginInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            checkEqual_VkDeviceGroupCommandBufferBeginInfo(reinterpret_cast<const VkDeviceGroupCommandBufferBeginInfo*>(structExtension), reinterpret_cast<const VkDeviceGroupCommandBufferBeginInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            checkEqual_VkDeviceGroupSubmitInfo(reinterpret_cast<const VkDeviceGroupSubmitInfo*>(structExtension), reinterpret_cast<const VkDeviceGroupSubmitInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            checkEqual_VkDeviceGroupBindSparseInfo(reinterpret_cast<const VkDeviceGroupBindSparseInfo*>(structExtension), reinterpret_cast<const VkDeviceGroupBindSparseInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            checkEqual_VkBindBufferMemoryDeviceGroupInfo(reinterpret_cast<const VkBindBufferMemoryDeviceGroupInfo*>(structExtension), reinterpret_cast<const VkBindBufferMemoryDeviceGroupInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            checkEqual_VkBindImageMemoryDeviceGroupInfo(reinterpret_cast<const VkBindImageMemoryDeviceGroupInfo*>(structExtension), reinterpret_cast<const VkBindImageMemoryDeviceGroupInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            checkEqual_VkDeviceGroupDeviceCreateInfo(reinterpret_cast<const VkDeviceGroupDeviceCreateInfo*>(structExtension), reinterpret_cast<const VkDeviceGroupDeviceCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            checkEqual_VkPhysicalDeviceFeatures2(reinterpret_cast<const VkPhysicalDeviceFeatures2*>(structExtension), reinterpret_cast<const VkPhysicalDeviceFeatures2*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            checkEqual_VkPhysicalDevicePointClippingProperties(reinterpret_cast<const VkPhysicalDevicePointClippingProperties*>(structExtension), reinterpret_cast<const VkPhysicalDevicePointClippingProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            checkEqual_VkRenderPassInputAttachmentAspectCreateInfo(reinterpret_cast<const VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension), reinterpret_cast<const VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            checkEqual_VkImageViewUsageCreateInfo(reinterpret_cast<const VkImageViewUsageCreateInfo*>(structExtension), reinterpret_cast<const VkImageViewUsageCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            checkEqual_VkPipelineTessellationDomainOriginStateCreateInfo(reinterpret_cast<const VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension), reinterpret_cast<const VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            checkEqual_VkRenderPassMultiviewCreateInfo(reinterpret_cast<const VkRenderPassMultiviewCreateInfo*>(structExtension), reinterpret_cast<const VkRenderPassMultiviewCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            checkEqual_VkPhysicalDeviceMultiviewFeatures(reinterpret_cast<const VkPhysicalDeviceMultiviewFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMultiviewFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceMultiviewProperties(reinterpret_cast<const VkPhysicalDeviceMultiviewProperties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMultiviewProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            checkEqual_VkPhysicalDeviceVariablePointersFeatures(reinterpret_cast<const VkPhysicalDeviceVariablePointersFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceVariablePointersFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            checkEqual_VkPhysicalDeviceProtectedMemoryFeatures(reinterpret_cast<const VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceProtectedMemoryProperties(reinterpret_cast<const VkPhysicalDeviceProtectedMemoryProperties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceProtectedMemoryProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            checkEqual_VkProtectedSubmitInfo(reinterpret_cast<const VkProtectedSubmitInfo*>(structExtension), reinterpret_cast<const VkProtectedSubmitInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            checkEqual_VkSamplerYcbcrConversionInfo(reinterpret_cast<const VkSamplerYcbcrConversionInfo*>(structExtension), reinterpret_cast<const VkSamplerYcbcrConversionInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            checkEqual_VkBindImagePlaneMemoryInfo(reinterpret_cast<const VkBindImagePlaneMemoryInfo*>(structExtension), reinterpret_cast<const VkBindImagePlaneMemoryInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            checkEqual_VkImagePlaneMemoryRequirementsInfo(reinterpret_cast<const VkImagePlaneMemoryRequirementsInfo*>(structExtension), reinterpret_cast<const VkImagePlaneMemoryRequirementsInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            checkEqual_VkPhysicalDeviceSamplerYcbcrConversionFeatures(reinterpret_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            checkEqual_VkSamplerYcbcrConversionImageFormatProperties(reinterpret_cast<const VkSamplerYcbcrConversionImageFormatProperties*>(structExtension), reinterpret_cast<const VkSamplerYcbcrConversionImageFormatProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            checkEqual_VkPhysicalDeviceExternalImageFormatInfo(reinterpret_cast<const VkPhysicalDeviceExternalImageFormatInfo*>(structExtension), reinterpret_cast<const VkPhysicalDeviceExternalImageFormatInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            checkEqual_VkExternalImageFormatProperties(reinterpret_cast<const VkExternalImageFormatProperties*>(structExtension), reinterpret_cast<const VkExternalImageFormatProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceIDProperties(reinterpret_cast<const VkPhysicalDeviceIDProperties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceIDProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            checkEqual_VkExternalMemoryImageCreateInfo(reinterpret_cast<const VkExternalMemoryImageCreateInfo*>(structExtension), reinterpret_cast<const VkExternalMemoryImageCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            checkEqual_VkExternalMemoryBufferCreateInfo(reinterpret_cast<const VkExternalMemoryBufferCreateInfo*>(structExtension), reinterpret_cast<const VkExternalMemoryBufferCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            checkEqual_VkExportMemoryAllocateInfo(reinterpret_cast<const VkExportMemoryAllocateInfo*>(structExtension), reinterpret_cast<const VkExportMemoryAllocateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            checkEqual_VkExportFenceCreateInfo(reinterpret_cast<const VkExportFenceCreateInfo*>(structExtension), reinterpret_cast<const VkExportFenceCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            checkEqual_VkExportSemaphoreCreateInfo(reinterpret_cast<const VkExportSemaphoreCreateInfo*>(structExtension), reinterpret_cast<const VkExportSemaphoreCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceMaintenance3Properties(reinterpret_cast<const VkPhysicalDeviceMaintenance3Properties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMaintenance3Properties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            checkEqual_VkPhysicalDeviceShaderDrawParametersFeatures(reinterpret_cast<const VkPhysicalDeviceShaderDrawParametersFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderDrawParametersFeatures*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_VERSION_1_2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            checkEqual_VkPhysicalDeviceVulkan11Features(reinterpret_cast<const VkPhysicalDeviceVulkan11Features*>(structExtension), reinterpret_cast<const VkPhysicalDeviceVulkan11Features*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceVulkan11Properties(reinterpret_cast<const VkPhysicalDeviceVulkan11Properties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceVulkan11Properties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            checkEqual_VkPhysicalDeviceVulkan12Features(reinterpret_cast<const VkPhysicalDeviceVulkan12Features*>(structExtension), reinterpret_cast<const VkPhysicalDeviceVulkan12Features*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceVulkan12Properties(reinterpret_cast<const VkPhysicalDeviceVulkan12Properties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceVulkan12Properties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            checkEqual_VkImageFormatListCreateInfo(reinterpret_cast<const VkImageFormatListCreateInfo*>(structExtension), reinterpret_cast<const VkImageFormatListCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            checkEqual_VkPhysicalDevice8BitStorageFeatures(reinterpret_cast<const VkPhysicalDevice8BitStorageFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDevice8BitStorageFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceDriverProperties(reinterpret_cast<const VkPhysicalDeviceDriverProperties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDriverProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            checkEqual_VkPhysicalDeviceShaderAtomicInt64Features(reinterpret_cast<const VkPhysicalDeviceShaderAtomicInt64Features*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderAtomicInt64Features*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            checkEqual_VkPhysicalDeviceShaderFloat16Int8Features(reinterpret_cast<const VkPhysicalDeviceShaderFloat16Int8Features*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderFloat16Int8Features*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceFloatControlsProperties(reinterpret_cast<const VkPhysicalDeviceFloatControlsProperties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceFloatControlsProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
        {
            checkEqual_VkDescriptorSetLayoutBindingFlagsCreateInfo(reinterpret_cast<const VkDescriptorSetLayoutBindingFlagsCreateInfo*>(structExtension), reinterpret_cast<const VkDescriptorSetLayoutBindingFlagsCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            checkEqual_VkPhysicalDeviceDescriptorIndexingFeatures(reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceDescriptorIndexingProperties(reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingProperties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
        {
            checkEqual_VkDescriptorSetVariableDescriptorCountAllocateInfo(reinterpret_cast<const VkDescriptorSetVariableDescriptorCountAllocateInfo*>(structExtension), reinterpret_cast<const VkDescriptorSetVariableDescriptorCountAllocateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
            checkEqual_VkDescriptorSetVariableDescriptorCountLayoutSupport(reinterpret_cast<const VkDescriptorSetVariableDescriptorCountLayoutSupport*>(structExtension), reinterpret_cast<const VkDescriptorSetVariableDescriptorCountLayoutSupport*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
        {
            checkEqual_VkSubpassDescriptionDepthStencilResolve(reinterpret_cast<const VkSubpassDescriptionDepthStencilResolve*>(structExtension), reinterpret_cast<const VkSubpassDescriptionDepthStencilResolve*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceDepthStencilResolveProperties(reinterpret_cast<const VkPhysicalDeviceDepthStencilResolveProperties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDepthStencilResolveProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            checkEqual_VkPhysicalDeviceScalarBlockLayoutFeatures(reinterpret_cast<const VkPhysicalDeviceScalarBlockLayoutFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceScalarBlockLayoutFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            checkEqual_VkImageStencilUsageCreateInfo(reinterpret_cast<const VkImageStencilUsageCreateInfo*>(structExtension), reinterpret_cast<const VkImageStencilUsageCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
        {
            checkEqual_VkSamplerReductionModeCreateInfo(reinterpret_cast<const VkSamplerReductionModeCreateInfo*>(structExtension), reinterpret_cast<const VkSamplerReductionModeCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceSamplerFilterMinmaxProperties(reinterpret_cast<const VkPhysicalDeviceSamplerFilterMinmaxProperties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceSamplerFilterMinmaxProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            checkEqual_VkPhysicalDeviceVulkanMemoryModelFeatures(reinterpret_cast<const VkPhysicalDeviceVulkanMemoryModelFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceVulkanMemoryModelFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            checkEqual_VkPhysicalDeviceImagelessFramebufferFeatures(reinterpret_cast<const VkPhysicalDeviceImagelessFramebufferFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceImagelessFramebufferFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
        {
            checkEqual_VkFramebufferAttachmentsCreateInfo(reinterpret_cast<const VkFramebufferAttachmentsCreateInfo*>(structExtension), reinterpret_cast<const VkFramebufferAttachmentsCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
        {
            checkEqual_VkRenderPassAttachmentBeginInfo(reinterpret_cast<const VkRenderPassAttachmentBeginInfo*>(structExtension), reinterpret_cast<const VkRenderPassAttachmentBeginInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            checkEqual_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(reinterpret_cast<const VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            checkEqual_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(reinterpret_cast<const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            checkEqual_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(reinterpret_cast<const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
        {
            checkEqual_VkAttachmentReferenceStencilLayout(reinterpret_cast<const VkAttachmentReferenceStencilLayout*>(structExtension), reinterpret_cast<const VkAttachmentReferenceStencilLayout*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
        {
            checkEqual_VkAttachmentDescriptionStencilLayout(reinterpret_cast<const VkAttachmentDescriptionStencilLayout*>(structExtension), reinterpret_cast<const VkAttachmentDescriptionStencilLayout*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            checkEqual_VkPhysicalDeviceHostQueryResetFeatures(reinterpret_cast<const VkPhysicalDeviceHostQueryResetFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceHostQueryResetFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            checkEqual_VkPhysicalDeviceTimelineSemaphoreFeatures(reinterpret_cast<const VkPhysicalDeviceTimelineSemaphoreFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceTimelineSemaphoreFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
            checkEqual_VkPhysicalDeviceTimelineSemaphoreProperties(reinterpret_cast<const VkPhysicalDeviceTimelineSemaphoreProperties*>(structExtension), reinterpret_cast<const VkPhysicalDeviceTimelineSemaphoreProperties*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
            checkEqual_VkSemaphoreTypeCreateInfo(reinterpret_cast<const VkSemaphoreTypeCreateInfo*>(structExtension), reinterpret_cast<const VkSemaphoreTypeCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            checkEqual_VkTimelineSemaphoreSubmitInfo(reinterpret_cast<const VkTimelineSemaphoreSubmitInfo*>(structExtension), reinterpret_cast<const VkTimelineSemaphoreSubmitInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            checkEqual_VkPhysicalDeviceBufferDeviceAddressFeatures(reinterpret_cast<const VkPhysicalDeviceBufferDeviceAddressFeatures*>(structExtension), reinterpret_cast<const VkPhysicalDeviceBufferDeviceAddressFeatures*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
            checkEqual_VkBufferOpaqueCaptureAddressCreateInfo(reinterpret_cast<const VkBufferOpaqueCaptureAddressCreateInfo*>(structExtension), reinterpret_cast<const VkBufferOpaqueCaptureAddressCreateInfo*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
            checkEqual_VkMemoryOpaqueCaptureAddressAllocateInfo(reinterpret_cast<const VkMemoryOpaqueCaptureAddressAllocateInfo*>(structExtension), reinterpret_cast<const VkMemoryOpaqueCaptureAddressAllocateInfo*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            checkEqual_VkImageSwapchainCreateInfoKHR(reinterpret_cast<const VkImageSwapchainCreateInfoKHR*>(structExtension), reinterpret_cast<const VkImageSwapchainCreateInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            checkEqual_VkBindImageMemorySwapchainInfoKHR(reinterpret_cast<const VkBindImageMemorySwapchainInfoKHR*>(structExtension), reinterpret_cast<const VkBindImageMemorySwapchainInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            checkEqual_VkDeviceGroupPresentInfoKHR(reinterpret_cast<const VkDeviceGroupPresentInfoKHR*>(structExtension), reinterpret_cast<const VkDeviceGroupPresentInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            checkEqual_VkDeviceGroupSwapchainCreateInfoKHR(reinterpret_cast<const VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension), reinterpret_cast<const VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            checkEqual_VkDisplayPresentInfoKHR(reinterpret_cast<const VkDisplayPresentInfoKHR*>(structExtension), reinterpret_cast<const VkDisplayPresentInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_video_queue
        case VK_STRUCTURE_TYPE_VIDEO_QUEUE_FAMILY_PROPERTIES_2_KHR:
        {
            checkEqual_VkVideoQueueFamilyProperties2KHR(reinterpret_cast<const VkVideoQueueFamilyProperties2KHR*>(structExtension), reinterpret_cast<const VkVideoQueueFamilyProperties2KHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_KHR:
        {
            checkEqual_VkVideoProfileKHR(reinterpret_cast<const VkVideoProfileKHR*>(structExtension), reinterpret_cast<const VkVideoProfileKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILES_KHR:
        {
            checkEqual_VkVideoProfilesKHR(reinterpret_cast<const VkVideoProfilesKHR*>(structExtension), reinterpret_cast<const VkVideoProfilesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_dynamic_rendering
        case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR:
        {
            checkEqual_VkPipelineRenderingCreateInfoKHR(reinterpret_cast<const VkPipelineRenderingCreateInfoKHR*>(structExtension), reinterpret_cast<const VkPipelineRenderingCreateInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDeviceDynamicRenderingFeaturesKHR(reinterpret_cast<const VkPhysicalDeviceDynamicRenderingFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDynamicRenderingFeaturesKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR:
        {
            checkEqual_VkCommandBufferInheritanceRenderingInfoKHR(reinterpret_cast<const VkCommandBufferInheritanceRenderingInfoKHR*>(structExtension), reinterpret_cast<const VkCommandBufferInheritanceRenderingInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
            checkEqual_VkRenderingFragmentShadingRateAttachmentInfoKHR(reinterpret_cast<const VkRenderingFragmentShadingRateAttachmentInfoKHR*>(structExtension), reinterpret_cast<const VkRenderingFragmentShadingRateAttachmentInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT:
        {
            checkEqual_VkRenderingFragmentDensityMapAttachmentInfoEXT(reinterpret_cast<const VkRenderingFragmentDensityMapAttachmentInfoEXT*>(structExtension), reinterpret_cast<const VkRenderingFragmentDensityMapAttachmentInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
        {
            checkEqual_VkAttachmentSampleCountInfoAMD(reinterpret_cast<const VkAttachmentSampleCountInfoAMD*>(structExtension), reinterpret_cast<const VkAttachmentSampleCountInfoAMD*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX:
        {
            checkEqual_VkMultiviewPerViewAttributesInfoNVX(reinterpret_cast<const VkMultiviewPerViewAttributesInfoNVX*>(structExtension), reinterpret_cast<const VkMultiviewPerViewAttributesInfoNVX*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            checkEqual_VkImportMemoryWin32HandleInfoKHR(reinterpret_cast<const VkImportMemoryWin32HandleInfoKHR*>(structExtension), reinterpret_cast<const VkImportMemoryWin32HandleInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            checkEqual_VkExportMemoryWin32HandleInfoKHR(reinterpret_cast<const VkExportMemoryWin32HandleInfoKHR*>(structExtension), reinterpret_cast<const VkExportMemoryWin32HandleInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            checkEqual_VkImportMemoryFdInfoKHR(reinterpret_cast<const VkImportMemoryFdInfoKHR*>(structExtension), reinterpret_cast<const VkImportMemoryFdInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            checkEqual_VkWin32KeyedMutexAcquireReleaseInfoKHR(reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension), reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            checkEqual_VkExportSemaphoreWin32HandleInfoKHR(reinterpret_cast<const VkExportSemaphoreWin32HandleInfoKHR*>(structExtension), reinterpret_cast<const VkExportSemaphoreWin32HandleInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            checkEqual_VkD3D12FenceSubmitInfoKHR(reinterpret_cast<const VkD3D12FenceSubmitInfoKHR*>(structExtension), reinterpret_cast<const VkD3D12FenceSubmitInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            checkEqual_VkPhysicalDevicePushDescriptorPropertiesKHR(reinterpret_cast<const VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            checkEqual_VkPresentRegionsKHR(reinterpret_cast<const VkPresentRegionsKHR*>(structExtension), reinterpret_cast<const VkPresentRegionsKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            checkEqual_VkSharedPresentSurfaceCapabilitiesKHR(reinterpret_cast<const VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension), reinterpret_cast<const VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            checkEqual_VkExportFenceWin32HandleInfoKHR(reinterpret_cast<const VkExportFenceWin32HandleInfoKHR*>(structExtension), reinterpret_cast<const VkExportFenceWin32HandleInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_performance_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDevicePerformanceQueryFeaturesKHR(reinterpret_cast<const VkPhysicalDevicePerformanceQueryFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDevicePerformanceQueryFeaturesKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {
            checkEqual_VkPhysicalDevicePerformanceQueryPropertiesKHR(reinterpret_cast<const VkPhysicalDevicePerformanceQueryPropertiesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDevicePerformanceQueryPropertiesKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
        {
            checkEqual_VkQueryPoolPerformanceCreateInfoKHR(reinterpret_cast<const VkQueryPoolPerformanceCreateInfoKHR*>(structExtension), reinterpret_cast<const VkQueryPoolPerformanceCreateInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            checkEqual_VkPerformanceQuerySubmitInfoKHR(reinterpret_cast<const VkPerformanceQuerySubmitInfoKHR*>(structExtension), reinterpret_cast<const VkPerformanceQuerySubmitInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_portability_subset
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDevicePortabilitySubsetFeaturesKHR(reinterpret_cast<const VkPhysicalDevicePortabilitySubsetFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDevicePortabilitySubsetFeaturesKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR:
        {
            checkEqual_VkPhysicalDevicePortabilitySubsetPropertiesKHR(reinterpret_cast<const VkPhysicalDevicePortabilitySubsetPropertiesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDevicePortabilitySubsetPropertiesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_shader_clock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDeviceShaderClockFeaturesKHR(reinterpret_cast<const VkPhysicalDeviceShaderClockFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderClockFeaturesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_shader_terminate_invocation
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(reinterpret_cast<const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_fragment_shading_rate
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
            checkEqual_VkFragmentShadingRateAttachmentInfoKHR(reinterpret_cast<const VkFragmentShadingRateAttachmentInfoKHR*>(structExtension), reinterpret_cast<const VkFragmentShadingRateAttachmentInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {
            checkEqual_VkPipelineFragmentShadingRateStateCreateInfoKHR(reinterpret_cast<const VkPipelineFragmentShadingRateStateCreateInfoKHR*>(structExtension), reinterpret_cast<const VkPipelineFragmentShadingRateStateCreateInfoKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateFeaturesKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {
            checkEqual_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(reinterpret_cast<const VkPhysicalDeviceFragmentShadingRatePropertiesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceFragmentShadingRatePropertiesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_surface_protected_capabilities
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
        {
            checkEqual_VkSurfaceProtectedCapabilitiesKHR(reinterpret_cast<const VkSurfaceProtectedCapabilitiesKHR*>(structExtension), reinterpret_cast<const VkSurfaceProtectedCapabilitiesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_present_wait
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDevicePresentWaitFeaturesKHR(reinterpret_cast<const VkPhysicalDevicePresentWaitFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDevicePresentWaitFeaturesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_pipeline_executable_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(reinterpret_cast<const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_shader_integer_dot_product
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR(reinterpret_cast<const VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR:
        {
            checkEqual_VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR(reinterpret_cast<const VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_present_id
        case VK_STRUCTURE_TYPE_PRESENT_ID_KHR:
        {
            checkEqual_VkPresentIdKHR(reinterpret_cast<const VkPresentIdKHR*>(structExtension), reinterpret_cast<const VkPresentIdKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDevicePresentIdFeaturesKHR(reinterpret_cast<const VkPhysicalDevicePresentIdFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDevicePresentIdFeaturesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_video_encode_queue
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR:
        {
            checkEqual_VkVideoEncodeRateControlInfoKHR(reinterpret_cast<const VkVideoEncodeRateControlInfoKHR*>(structExtension), reinterpret_cast<const VkVideoEncodeRateControlInfoKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_synchronization2
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR:
        {
            checkEqual_VkMemoryBarrier2KHR(reinterpret_cast<const VkMemoryBarrier2KHR*>(structExtension), reinterpret_cast<const VkMemoryBarrier2KHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDeviceSynchronization2FeaturesKHR(reinterpret_cast<const VkPhysicalDeviceSynchronization2FeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceSynchronization2FeaturesKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
        {
            checkEqual_VkQueueFamilyCheckpointProperties2NV(reinterpret_cast<const VkQueueFamilyCheckpointProperties2NV*>(structExtension), reinterpret_cast<const VkQueueFamilyCheckpointProperties2NV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_shader_subgroup_uniform_control_flow
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(reinterpret_cast<const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_zero_initialize_workgroup_memory
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR(reinterpret_cast<const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_workgroup_memory_explicit_layout
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(reinterpret_cast<const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_format_feature_flags2
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR:
        {
            checkEqual_VkFormatProperties3KHR(reinterpret_cast<const VkFormatProperties3KHR*>(structExtension), reinterpret_cast<const VkFormatProperties3KHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_maintenance4
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDeviceMaintenance4FeaturesKHR(reinterpret_cast<const VkPhysicalDeviceMaintenance4FeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMaintenance4FeaturesKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR:
        {
            checkEqual_VkPhysicalDeviceMaintenance4PropertiesKHR(reinterpret_cast<const VkPhysicalDeviceMaintenance4PropertiesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMaintenance4PropertiesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            checkEqual_VkNativeBufferANDROID(reinterpret_cast<const VkNativeBufferANDROID*>(structExtension), reinterpret_cast<const VkNativeBufferANDROID*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            checkEqual_VkDebugReportCallbackCreateInfoEXT(reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT*>(structExtension), reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            checkEqual_VkPipelineRasterizationStateRasterizationOrderAMD(reinterpret_cast<const VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension), reinterpret_cast<const VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            checkEqual_VkDedicatedAllocationImageCreateInfoNV(reinterpret_cast<const VkDedicatedAllocationImageCreateInfoNV*>(structExtension), reinterpret_cast<const VkDedicatedAllocationImageCreateInfoNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            checkEqual_VkDedicatedAllocationBufferCreateInfoNV(reinterpret_cast<const VkDedicatedAllocationBufferCreateInfoNV*>(structExtension), reinterpret_cast<const VkDedicatedAllocationBufferCreateInfoNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            checkEqual_VkDedicatedAllocationMemoryAllocateInfoNV(reinterpret_cast<const VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension), reinterpret_cast<const VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_transform_feedback
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceTransformFeedbackFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceTransformFeedbackPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineRasterizationStateStreamCreateInfoEXT(reinterpret_cast<const VkPipelineRasterizationStateStreamCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineRasterizationStateStreamCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_video_encode_h264
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT:
        {
            checkEqual_VkVideoEncodeH264CapabilitiesEXT(reinterpret_cast<const VkVideoEncodeH264CapabilitiesEXT*>(structExtension), reinterpret_cast<const VkVideoEncodeH264CapabilitiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT:
        {
            checkEqual_VkVideoEncodeH264SessionCreateInfoEXT(reinterpret_cast<const VkVideoEncodeH264SessionCreateInfoEXT*>(structExtension), reinterpret_cast<const VkVideoEncodeH264SessionCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT:
        {
            checkEqual_VkVideoEncodeH264SessionParametersAddInfoEXT(reinterpret_cast<const VkVideoEncodeH264SessionParametersAddInfoEXT*>(structExtension), reinterpret_cast<const VkVideoEncodeH264SessionParametersAddInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT:
        {
            checkEqual_VkVideoEncodeH264SessionParametersCreateInfoEXT(reinterpret_cast<const VkVideoEncodeH264SessionParametersCreateInfoEXT*>(structExtension), reinterpret_cast<const VkVideoEncodeH264SessionParametersCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT:
        {
            checkEqual_VkVideoEncodeH264VclFrameInfoEXT(reinterpret_cast<const VkVideoEncodeH264VclFrameInfoEXT*>(structExtension), reinterpret_cast<const VkVideoEncodeH264VclFrameInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_EXT:
        {
            checkEqual_VkVideoEncodeH264EmitPictureParametersEXT(reinterpret_cast<const VkVideoEncodeH264EmitPictureParametersEXT*>(structExtension), reinterpret_cast<const VkVideoEncodeH264EmitPictureParametersEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_EXT:
        {
            checkEqual_VkVideoEncodeH264ProfileEXT(reinterpret_cast<const VkVideoEncodeH264ProfileEXT*>(structExtension), reinterpret_cast<const VkVideoEncodeH264ProfileEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_video_encode_h265
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT:
        {
            checkEqual_VkVideoEncodeH265CapabilitiesEXT(reinterpret_cast<const VkVideoEncodeH265CapabilitiesEXT*>(structExtension), reinterpret_cast<const VkVideoEncodeH265CapabilitiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_EXT:
        {
            checkEqual_VkVideoEncodeH265SessionCreateInfoEXT(reinterpret_cast<const VkVideoEncodeH265SessionCreateInfoEXT*>(structExtension), reinterpret_cast<const VkVideoEncodeH265SessionCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT:
        {
            checkEqual_VkVideoEncodeH265SessionParametersAddInfoEXT(reinterpret_cast<const VkVideoEncodeH265SessionParametersAddInfoEXT*>(structExtension), reinterpret_cast<const VkVideoEncodeH265SessionParametersAddInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT:
        {
            checkEqual_VkVideoEncodeH265SessionParametersCreateInfoEXT(reinterpret_cast<const VkVideoEncodeH265SessionParametersCreateInfoEXT*>(structExtension), reinterpret_cast<const VkVideoEncodeH265SessionParametersCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT:
        {
            checkEqual_VkVideoEncodeH265VclFrameInfoEXT(reinterpret_cast<const VkVideoEncodeH265VclFrameInfoEXT*>(structExtension), reinterpret_cast<const VkVideoEncodeH265VclFrameInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_EMIT_PICTURE_PARAMETERS_EXT:
        {
            checkEqual_VkVideoEncodeH265EmitPictureParametersEXT(reinterpret_cast<const VkVideoEncodeH265EmitPictureParametersEXT*>(structExtension), reinterpret_cast<const VkVideoEncodeH265EmitPictureParametersEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_EXT:
        {
            checkEqual_VkVideoEncodeH265ProfileEXT(reinterpret_cast<const VkVideoEncodeH265ProfileEXT*>(structExtension), reinterpret_cast<const VkVideoEncodeH265ProfileEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_video_decode_h264
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_EXT:
        {
            checkEqual_VkVideoDecodeH264ProfileEXT(reinterpret_cast<const VkVideoDecodeH264ProfileEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH264ProfileEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_EXT:
        {
            checkEqual_VkVideoDecodeH264CapabilitiesEXT(reinterpret_cast<const VkVideoDecodeH264CapabilitiesEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH264CapabilitiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_CREATE_INFO_EXT:
        {
            checkEqual_VkVideoDecodeH264SessionCreateInfoEXT(reinterpret_cast<const VkVideoDecodeH264SessionCreateInfoEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH264SessionCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT:
        {
            checkEqual_VkVideoDecodeH264SessionParametersAddInfoEXT(reinterpret_cast<const VkVideoDecodeH264SessionParametersAddInfoEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH264SessionParametersAddInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT:
        {
            checkEqual_VkVideoDecodeH264SessionParametersCreateInfoEXT(reinterpret_cast<const VkVideoDecodeH264SessionParametersCreateInfoEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH264SessionParametersCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_EXT:
        {
            checkEqual_VkVideoDecodeH264PictureInfoEXT(reinterpret_cast<const VkVideoDecodeH264PictureInfoEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH264PictureInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_MVC_EXT:
        {
            checkEqual_VkVideoDecodeH264MvcEXT(reinterpret_cast<const VkVideoDecodeH264MvcEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH264MvcEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT:
        {
            checkEqual_VkVideoDecodeH264DpbSlotInfoEXT(reinterpret_cast<const VkVideoDecodeH264DpbSlotInfoEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH264DpbSlotInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            checkEqual_VkTextureLODGatherFormatPropertiesAMD(reinterpret_cast<const VkTextureLODGatherFormatPropertiesAMD*>(structExtension), reinterpret_cast<const VkTextureLODGatherFormatPropertiesAMD*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_corner_sampled_image
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceCornerSampledImageFeaturesNV(reinterpret_cast<const VkPhysicalDeviceCornerSampledImageFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceCornerSampledImageFeaturesNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            checkEqual_VkExternalMemoryImageCreateInfoNV(reinterpret_cast<const VkExternalMemoryImageCreateInfoNV*>(structExtension), reinterpret_cast<const VkExternalMemoryImageCreateInfoNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            checkEqual_VkExportMemoryAllocateInfoNV(reinterpret_cast<const VkExportMemoryAllocateInfoNV*>(structExtension), reinterpret_cast<const VkExportMemoryAllocateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            checkEqual_VkImportMemoryWin32HandleInfoNV(reinterpret_cast<const VkImportMemoryWin32HandleInfoNV*>(structExtension), reinterpret_cast<const VkImportMemoryWin32HandleInfoNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            checkEqual_VkExportMemoryWin32HandleInfoNV(reinterpret_cast<const VkExportMemoryWin32HandleInfoNV*>(structExtension), reinterpret_cast<const VkExportMemoryWin32HandleInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            checkEqual_VkWin32KeyedMutexAcquireReleaseInfoNV(reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension), reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            checkEqual_VkValidationFlagsEXT(reinterpret_cast<const VkValidationFlagsEXT*>(structExtension), reinterpret_cast<const VkValidationFlagsEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_astc_decode_mode
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
        {
            checkEqual_VkImageViewASTCDecodeModeEXT(reinterpret_cast<const VkImageViewASTCDecodeModeEXT*>(structExtension), reinterpret_cast<const VkImageViewASTCDecodeModeEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceASTCDecodeFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceASTCDecodeFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceASTCDecodeFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceConditionalRenderingFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            checkEqual_VkCommandBufferInheritanceConditionalRenderingInfoEXT(reinterpret_cast<const VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension), reinterpret_cast<const VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            checkEqual_VkPipelineViewportWScalingStateCreateInfoNV(reinterpret_cast<const VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension), reinterpret_cast<const VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            checkEqual_VkSwapchainCounterCreateInfoEXT(reinterpret_cast<const VkSwapchainCounterCreateInfoEXT*>(structExtension), reinterpret_cast<const VkSwapchainCounterCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            checkEqual_VkPresentTimesInfoGOOGLE(reinterpret_cast<const VkPresentTimesInfoGOOGLE*>(structExtension), reinterpret_cast<const VkPresentTimesInfoGOOGLE*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            checkEqual_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(reinterpret_cast<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            checkEqual_VkPipelineViewportSwizzleStateCreateInfoNV(reinterpret_cast<const VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension), reinterpret_cast<const VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceDiscardRectanglePropertiesEXT(reinterpret_cast<const VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineDiscardRectangleStateCreateInfoEXT(reinterpret_cast<const VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineRasterizationConservativeStateCreateInfoEXT(reinterpret_cast<const VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_depth_clip_enable
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceDepthClipEnableFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineRasterizationDepthClipStateCreateInfoEXT(reinterpret_cast<const VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            checkEqual_VkDebugUtilsMessengerCreateInfoEXT(reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT*>(structExtension), reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            checkEqual_VkAndroidHardwareBufferUsageANDROID(reinterpret_cast<const VkAndroidHardwareBufferUsageANDROID*>(structExtension), reinterpret_cast<const VkAndroidHardwareBufferUsageANDROID*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            checkEqual_VkAndroidHardwareBufferFormatPropertiesANDROID(reinterpret_cast<const VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension), reinterpret_cast<const VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            checkEqual_VkImportAndroidHardwareBufferInfoANDROID(reinterpret_cast<const VkImportAndroidHardwareBufferInfoANDROID*>(structExtension), reinterpret_cast<const VkImportAndroidHardwareBufferInfoANDROID*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            checkEqual_VkExternalFormatANDROID(reinterpret_cast<const VkExternalFormatANDROID*>(structExtension), reinterpret_cast<const VkExternalFormatANDROID*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID:
        {
            checkEqual_VkAndroidHardwareBufferFormatProperties2ANDROID(reinterpret_cast<const VkAndroidHardwareBufferFormatProperties2ANDROID*>(structExtension), reinterpret_cast<const VkAndroidHardwareBufferFormatProperties2ANDROID*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_inline_uniform_block
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockPropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
        {
            checkEqual_VkWriteDescriptorSetInlineUniformBlockEXT(reinterpret_cast<const VkWriteDescriptorSetInlineUniformBlockEXT*>(structExtension), reinterpret_cast<const VkWriteDescriptorSetInlineUniformBlockEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
        {
            checkEqual_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(reinterpret_cast<const VkDescriptorPoolInlineUniformBlockCreateInfoEXT*>(structExtension), reinterpret_cast<const VkDescriptorPoolInlineUniformBlockCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            checkEqual_VkSampleLocationsInfoEXT(reinterpret_cast<const VkSampleLocationsInfoEXT*>(structExtension), reinterpret_cast<const VkSampleLocationsInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            checkEqual_VkRenderPassSampleLocationsBeginInfoEXT(reinterpret_cast<const VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension), reinterpret_cast<const VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineSampleLocationsStateCreateInfoEXT(reinterpret_cast<const VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceSampleLocationsPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineColorBlendAdvancedStateCreateInfoEXT(reinterpret_cast<const VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            checkEqual_VkPipelineCoverageToColorStateCreateInfoNV(reinterpret_cast<const VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension), reinterpret_cast<const VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            checkEqual_VkPipelineCoverageModulationStateCreateInfoNV(reinterpret_cast<const VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension), reinterpret_cast<const VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_shader_sm_builtins
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {
            checkEqual_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(reinterpret_cast<const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(reinterpret_cast<const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_image_drm_format_modifier
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
        {
            checkEqual_VkDrmFormatModifierPropertiesListEXT(reinterpret_cast<const VkDrmFormatModifierPropertiesListEXT*>(structExtension), reinterpret_cast<const VkDrmFormatModifierPropertiesListEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
        {
            checkEqual_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(reinterpret_cast<const VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
        {
            checkEqual_VkImageDrmFormatModifierListCreateInfoEXT(reinterpret_cast<const VkImageDrmFormatModifierListCreateInfoEXT*>(structExtension), reinterpret_cast<const VkImageDrmFormatModifierListCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
        {
            checkEqual_VkImageDrmFormatModifierExplicitCreateInfoEXT(reinterpret_cast<const VkImageDrmFormatModifierExplicitCreateInfoEXT*>(structExtension), reinterpret_cast<const VkImageDrmFormatModifierExplicitCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT:
        {
            checkEqual_VkDrmFormatModifierPropertiesList2EXT(reinterpret_cast<const VkDrmFormatModifierPropertiesList2EXT*>(structExtension), reinterpret_cast<const VkDrmFormatModifierPropertiesList2EXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            checkEqual_VkShaderModuleValidationCacheCreateInfoEXT(reinterpret_cast<const VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension), reinterpret_cast<const VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_shading_rate_image
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
        {
            checkEqual_VkPipelineViewportShadingRateImageStateCreateInfoNV(reinterpret_cast<const VkPipelineViewportShadingRateImageStateCreateInfoNV*>(structExtension), reinterpret_cast<const VkPipelineViewportShadingRateImageStateCreateInfoNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceShadingRateImageFeaturesNV(reinterpret_cast<const VkPhysicalDeviceShadingRateImageFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShadingRateImageFeaturesNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {
            checkEqual_VkPhysicalDeviceShadingRateImagePropertiesNV(reinterpret_cast<const VkPhysicalDeviceShadingRateImagePropertiesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShadingRateImagePropertiesNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
        {
            checkEqual_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(reinterpret_cast<const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(structExtension), reinterpret_cast<const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_ray_tracing
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
        {
            checkEqual_VkWriteDescriptorSetAccelerationStructureNV(reinterpret_cast<const VkWriteDescriptorSetAccelerationStructureNV*>(structExtension), reinterpret_cast<const VkWriteDescriptorSetAccelerationStructureNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {
            checkEqual_VkPhysicalDeviceRayTracingPropertiesNV(reinterpret_cast<const VkPhysicalDeviceRayTracingPropertiesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceRayTracingPropertiesNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_representative_fragment_test
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(reinterpret_cast<const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {
            checkEqual_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(reinterpret_cast<const VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(structExtension), reinterpret_cast<const VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_filter_cubic
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {
            checkEqual_VkPhysicalDeviceImageViewImageFormatInfoEXT(reinterpret_cast<const VkPhysicalDeviceImageViewImageFormatInfoEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceImageViewImageFormatInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {
            checkEqual_VkFilterCubicImageViewImageFormatPropertiesEXT(reinterpret_cast<const VkFilterCubicImageViewImageFormatPropertiesEXT*>(structExtension), reinterpret_cast<const VkFilterCubicImageViewImageFormatPropertiesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            checkEqual_VkDeviceQueueGlobalPriorityCreateInfoEXT(reinterpret_cast<const VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension), reinterpret_cast<const VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            checkEqual_VkImportMemoryHostPointerInfoEXT(reinterpret_cast<const VkImportMemoryHostPointerInfoEXT*>(structExtension), reinterpret_cast<const VkImportMemoryHostPointerInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_AMD_pipeline_compiler_control
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
            checkEqual_VkPipelineCompilerControlCreateInfoAMD(reinterpret_cast<const VkPipelineCompilerControlCreateInfoAMD*>(structExtension), reinterpret_cast<const VkPipelineCompilerControlCreateInfoAMD*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            checkEqual_VkPhysicalDeviceShaderCorePropertiesAMD(reinterpret_cast<const VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_video_decode_h265
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_EXT:
        {
            checkEqual_VkVideoDecodeH265ProfileEXT(reinterpret_cast<const VkVideoDecodeH265ProfileEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH265ProfileEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_EXT:
        {
            checkEqual_VkVideoDecodeH265CapabilitiesEXT(reinterpret_cast<const VkVideoDecodeH265CapabilitiesEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH265CapabilitiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_CREATE_INFO_EXT:
        {
            checkEqual_VkVideoDecodeH265SessionCreateInfoEXT(reinterpret_cast<const VkVideoDecodeH265SessionCreateInfoEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH265SessionCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT:
        {
            checkEqual_VkVideoDecodeH265SessionParametersAddInfoEXT(reinterpret_cast<const VkVideoDecodeH265SessionParametersAddInfoEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH265SessionParametersAddInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT:
        {
            checkEqual_VkVideoDecodeH265SessionParametersCreateInfoEXT(reinterpret_cast<const VkVideoDecodeH265SessionParametersCreateInfoEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH265SessionParametersCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_EXT:
        {
            checkEqual_VkVideoDecodeH265PictureInfoEXT(reinterpret_cast<const VkVideoDecodeH265PictureInfoEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH265PictureInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT:
        {
            checkEqual_VkVideoDecodeH265DpbSlotInfoEXT(reinterpret_cast<const VkVideoDecodeH265DpbSlotInfoEXT*>(structExtension), reinterpret_cast<const VkVideoDecodeH265DpbSlotInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_AMD_memory_overallocation_behavior
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {
            checkEqual_VkDeviceMemoryOverallocationCreateInfoAMD(reinterpret_cast<const VkDeviceMemoryOverallocationCreateInfoAMD*>(structExtension), reinterpret_cast<const VkDeviceMemoryOverallocationCreateInfoAMD*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineVertexInputDivisorStateCreateInfoEXT(reinterpret_cast<const VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_GGP_frame_token
        case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
        {
            checkEqual_VkPresentFrameTokenGGP(reinterpret_cast<const VkPresentFrameTokenGGP*>(structExtension), reinterpret_cast<const VkPresentFrameTokenGGP*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_pipeline_creation_feedback
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineCreationFeedbackCreateInfoEXT(reinterpret_cast<const VkPipelineCreationFeedbackCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineCreationFeedbackCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_compute_shader_derivatives
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(reinterpret_cast<const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_mesh_shader
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceMeshShaderFeaturesNV(reinterpret_cast<const VkPhysicalDeviceMeshShaderFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMeshShaderFeaturesNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {
            checkEqual_VkPhysicalDeviceMeshShaderPropertiesNV(reinterpret_cast<const VkPhysicalDeviceMeshShaderPropertiesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMeshShaderPropertiesNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_fragment_shader_barycentric
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(reinterpret_cast<const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_shader_image_footprint
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceShaderImageFootprintFeaturesNV(reinterpret_cast<const VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_scissor_exclusive
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
        {
            checkEqual_VkPipelineViewportExclusiveScissorStateCreateInfoNV(reinterpret_cast<const VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(structExtension), reinterpret_cast<const VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceExclusiveScissorFeaturesNV(reinterpret_cast<const VkPhysicalDeviceExclusiveScissorFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceExclusiveScissorFeaturesNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            checkEqual_VkQueueFamilyCheckpointPropertiesNV(reinterpret_cast<const VkQueueFamilyCheckpointPropertiesNV*>(structExtension), reinterpret_cast<const VkQueueFamilyCheckpointPropertiesNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_INTEL_shader_integer_functions2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            checkEqual_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(reinterpret_cast<const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_INTEL_performance_query
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
        {
            checkEqual_VkQueryPoolPerformanceQueryCreateInfoINTEL(reinterpret_cast<const VkQueryPoolPerformanceQueryCreateInfoINTEL*>(structExtension), reinterpret_cast<const VkQueryPoolPerformanceQueryCreateInfoINTEL*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_pci_bus_info
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDevicePCIBusInfoPropertiesEXT(reinterpret_cast<const VkPhysicalDevicePCIBusInfoPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDevicePCIBusInfoPropertiesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_AMD_display_native_hdr
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
        {
            checkEqual_VkDisplayNativeHdrSurfaceCapabilitiesAMD(reinterpret_cast<const VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(structExtension), reinterpret_cast<const VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
        {
            checkEqual_VkSwapchainDisplayNativeHdrCreateInfoAMD(reinterpret_cast<const VkSwapchainDisplayNativeHdrCreateInfoAMD*>(structExtension), reinterpret_cast<const VkSwapchainDisplayNativeHdrCreateInfoAMD*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_fragment_density_map
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
        {
            checkEqual_VkRenderPassFragmentDensityMapCreateInfoEXT(reinterpret_cast<const VkRenderPassFragmentDensityMapCreateInfoEXT*>(structExtension), reinterpret_cast<const VkRenderPassFragmentDensityMapCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_subgroup_size_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(reinterpret_cast<const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {
            checkEqual_VkPhysicalDeviceShaderCoreProperties2AMD(reinterpret_cast<const VkPhysicalDeviceShaderCoreProperties2AMD*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderCoreProperties2AMD*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_AMD_device_coherent_memory
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            checkEqual_VkPhysicalDeviceCoherentMemoryFeaturesAMD(reinterpret_cast<const VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(structExtension), reinterpret_cast<const VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_shader_image_atomic_int64
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(reinterpret_cast<const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_memory_budget
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceMemoryBudgetPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_memory_priority
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceMemoryPriorityFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {
            checkEqual_VkMemoryPriorityAllocateInfoEXT(reinterpret_cast<const VkMemoryPriorityAllocateInfoEXT*>(structExtension), reinterpret_cast<const VkMemoryPriorityAllocateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(reinterpret_cast<const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_buffer_device_address
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {
            checkEqual_VkBufferDeviceAddressCreateInfoEXT(reinterpret_cast<const VkBufferDeviceAddressCreateInfoEXT*>(structExtension), reinterpret_cast<const VkBufferDeviceAddressCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_validation_features
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
            checkEqual_VkValidationFeaturesEXT(reinterpret_cast<const VkValidationFeaturesEXT*>(structExtension), reinterpret_cast<const VkValidationFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_cooperative_matrix
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceCooperativeMatrixFeaturesNV(reinterpret_cast<const VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
            checkEqual_VkPhysicalDeviceCooperativeMatrixPropertiesNV(reinterpret_cast<const VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_coverage_reduction_mode
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceCoverageReductionModeFeaturesNV(reinterpret_cast<const VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
        {
            checkEqual_VkPipelineCoverageReductionStateCreateInfoNV(reinterpret_cast<const VkPipelineCoverageReductionStateCreateInfoNV*>(structExtension), reinterpret_cast<const VkPipelineCoverageReductionStateCreateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_fragment_shader_interlock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_ycbcr_image_arrays
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_provoking_vertex
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceProvokingVertexFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceProvokingVertexFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceProvokingVertexFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceProvokingVertexPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceProvokingVertexPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceProvokingVertexPropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(reinterpret_cast<const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_full_screen_exclusive
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
        {
            checkEqual_VkSurfaceFullScreenExclusiveInfoEXT(reinterpret_cast<const VkSurfaceFullScreenExclusiveInfoEXT*>(structExtension), reinterpret_cast<const VkSurfaceFullScreenExclusiveInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
        {
            checkEqual_VkSurfaceCapabilitiesFullScreenExclusiveEXT(reinterpret_cast<const VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(structExtension), reinterpret_cast<const VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
        {
            checkEqual_VkSurfaceFullScreenExclusiveWin32InfoEXT(reinterpret_cast<const VkSurfaceFullScreenExclusiveWin32InfoEXT*>(structExtension), reinterpret_cast<const VkSurfaceFullScreenExclusiveWin32InfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_line_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceLineRasterizationFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceLineRasterizationFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceLineRasterizationFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceLineRasterizationPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceLineRasterizationPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceLineRasterizationPropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineRasterizationLineStateCreateInfoEXT(reinterpret_cast<const VkPipelineRasterizationLineStateCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineRasterizationLineStateCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_shader_atomic_float
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_index_type_uint8
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(reinterpret_cast<const VkPhysicalDeviceIndexTypeUint8FeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceIndexTypeUint8FeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_shader_atomic_float2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(reinterpret_cast<const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_device_generated_commands
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {
            checkEqual_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {
            checkEqual_VkGraphicsPipelineShaderGroupsCreateInfoNV(reinterpret_cast<const VkGraphicsPipelineShaderGroupsCreateInfoNV*>(structExtension), reinterpret_cast<const VkGraphicsPipelineShaderGroupsCreateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_inherited_viewport_scissor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceInheritedViewportScissorFeaturesNV(reinterpret_cast<const VkPhysicalDeviceInheritedViewportScissorFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceInheritedViewportScissorFeaturesNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:
        {
            checkEqual_VkCommandBufferInheritanceViewportScissorInfoNV(reinterpret_cast<const VkCommandBufferInheritanceViewportScissorInfoNV*>(structExtension), reinterpret_cast<const VkCommandBufferInheritanceViewportScissorInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_texel_buffer_alignment
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_QCOM_render_pass_transform
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
        {
            checkEqual_VkRenderPassTransformBeginInfoQCOM(reinterpret_cast<const VkRenderPassTransformBeginInfoQCOM*>(structExtension), reinterpret_cast<const VkRenderPassTransformBeginInfoQCOM*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
        {
            checkEqual_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(reinterpret_cast<const VkCommandBufferInheritanceRenderPassTransformInfoQCOM*>(structExtension), reinterpret_cast<const VkCommandBufferInheritanceRenderPassTransformInfoQCOM*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_device_memory_report
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
        {
            checkEqual_VkDeviceDeviceMemoryReportCreateInfoEXT(reinterpret_cast<const VkDeviceDeviceMemoryReportCreateInfoEXT*>(structExtension), reinterpret_cast<const VkDeviceDeviceMemoryReportCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_robustness2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceRobustness2FeaturesEXT(reinterpret_cast<const VkPhysicalDeviceRobustness2FeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceRobustness2FeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceRobustness2PropertiesEXT(reinterpret_cast<const VkPhysicalDeviceRobustness2PropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceRobustness2PropertiesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_custom_border_color
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
        {
            checkEqual_VkSamplerCustomBorderColorCreateInfoEXT(reinterpret_cast<const VkSamplerCustomBorderColorCreateInfoEXT*>(structExtension), reinterpret_cast<const VkSamplerCustomBorderColorCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceCustomBorderColorPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceCustomBorderColorPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceCustomBorderColorPropertiesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceCustomBorderColorFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_private_data
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDevicePrivateDataFeaturesEXT(reinterpret_cast<const VkPhysicalDevicePrivateDataFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDevicePrivateDataFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT:
        {
            checkEqual_VkDevicePrivateDataCreateInfoEXT(reinterpret_cast<const VkDevicePrivateDataCreateInfoEXT*>(structExtension), reinterpret_cast<const VkDevicePrivateDataCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_pipeline_creation_cache_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(reinterpret_cast<const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_device_diagnostics_config
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(reinterpret_cast<const VkPhysicalDeviceDiagnosticsConfigFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDiagnosticsConfigFeaturesNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {
            checkEqual_VkDeviceDiagnosticsConfigCreateInfoNV(reinterpret_cast<const VkDeviceDiagnosticsConfigCreateInfoNV*>(structExtension), reinterpret_cast<const VkDeviceDiagnosticsConfigCreateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_fragment_shading_rate_enums
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {
            checkEqual_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {
            checkEqual_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(reinterpret_cast<const VkPipelineFragmentShadingRateEnumStateCreateInfoNV*>(structExtension), reinterpret_cast<const VkPipelineFragmentShadingRateEnumStateCreateInfoNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_ray_tracing_motion_blur
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV:
        {
            checkEqual_VkAccelerationStructureGeometryMotionTrianglesDataNV(reinterpret_cast<const VkAccelerationStructureGeometryMotionTrianglesDataNV*>(structExtension), reinterpret_cast<const VkAccelerationStructureGeometryMotionTrianglesDataNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV:
        {
            checkEqual_VkAccelerationStructureMotionInfoNV(reinterpret_cast<const VkAccelerationStructureMotionInfoNV*>(structExtension), reinterpret_cast<const VkAccelerationStructureMotionInfoNV*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(reinterpret_cast<const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_ycbcr_2plane_444_formats
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_fragment_density_map2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(reinterpret_cast<const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(reinterpret_cast<const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_QCOM_rotated_copy_commands
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {
            checkEqual_VkCopyCommandTransformInfoQCOM(reinterpret_cast<const VkCopyCommandTransformInfoQCOM*>(structExtension), reinterpret_cast<const VkCopyCommandTransformInfoQCOM*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_image_robustness
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceImageRobustnessFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceImageRobustnessFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceImageRobustnessFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_4444_formats
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDevice4444FormatsFeaturesEXT(reinterpret_cast<const VkPhysicalDevice4444FormatsFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDevice4444FormatsFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_rgba10x6_formats
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_VALVE_mutable_descriptor_type
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE:
        {
            checkEqual_VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE(reinterpret_cast<const VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE:
        {
            checkEqual_VkMutableDescriptorTypeCreateInfoVALVE(reinterpret_cast<const VkMutableDescriptorTypeCreateInfoVALVE*>(structExtension), reinterpret_cast<const VkMutableDescriptorTypeCreateInfoVALVE*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_physical_device_drm
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceDrmPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceDrmPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceDrmPropertiesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_primitive_topology_list_restart
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(reinterpret_cast<const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_FUCHSIA_external_memory
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA:
        {
            checkEqual_VkImportMemoryZirconHandleInfoFUCHSIA(reinterpret_cast<const VkImportMemoryZirconHandleInfoFUCHSIA*>(structExtension), reinterpret_cast<const VkImportMemoryZirconHandleInfoFUCHSIA*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_FUCHSIA_buffer_collection
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA:
        {
            checkEqual_VkImportMemoryBufferCollectionFUCHSIA(reinterpret_cast<const VkImportMemoryBufferCollectionFUCHSIA*>(structExtension), reinterpret_cast<const VkImportMemoryBufferCollectionFUCHSIA*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA:
        {
            checkEqual_VkBufferCollectionImageCreateInfoFUCHSIA(reinterpret_cast<const VkBufferCollectionImageCreateInfoFUCHSIA*>(structExtension), reinterpret_cast<const VkBufferCollectionImageCreateInfoFUCHSIA*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA:
        {
            checkEqual_VkBufferCollectionBufferCreateInfoFUCHSIA(reinterpret_cast<const VkBufferCollectionBufferCreateInfoFUCHSIA*>(structExtension), reinterpret_cast<const VkBufferCollectionBufferCreateInfoFUCHSIA*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_HUAWEI_subpass_shading
        case VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI:
        {
            checkEqual_VkSubpassShadingPipelineCreateInfoHUAWEI(reinterpret_cast<const VkSubpassShadingPipelineCreateInfoHUAWEI*>(structExtension), reinterpret_cast<const VkSubpassShadingPipelineCreateInfoHUAWEI*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
        {
            checkEqual_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(reinterpret_cast<const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI*>(structExtension), reinterpret_cast<const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI:
        {
            checkEqual_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(reinterpret_cast<const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI*>(structExtension), reinterpret_cast<const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_HUAWEI_invocation_mask
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
        {
            checkEqual_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(reinterpret_cast<const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*>(structExtension), reinterpret_cast<const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_NV_external_memory_rdma
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV:
        {
            checkEqual_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(reinterpret_cast<const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV*>(structExtension), reinterpret_cast<const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_extended_dynamic_state2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(reinterpret_cast<const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_color_write_enable
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceColorWriteEnableFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceColorWriteEnableFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceColorWriteEnableFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT:
        {
            checkEqual_VkPipelineColorWriteCreateInfoEXT(reinterpret_cast<const VkPipelineColorWriteCreateInfoEXT*>(structExtension), reinterpret_cast<const VkPipelineColorWriteCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_GOOGLE_gfxstream
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE:
        {
            checkEqual_VkImportColorBufferGOOGLE(reinterpret_cast<const VkImportColorBufferGOOGLE*>(structExtension), reinterpret_cast<const VkImportColorBufferGOOGLE*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_BUFFER_GOOGLE:
        {
            checkEqual_VkImportBufferGOOGLE(reinterpret_cast<const VkImportBufferGOOGLE*>(structExtension), reinterpret_cast<const VkImportBufferGOOGLE*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE:
        {
            checkEqual_VkImportPhysicalAddressGOOGLE(reinterpret_cast<const VkImportPhysicalAddressGOOGLE*>(structExtension), reinterpret_cast<const VkImportPhysicalAddressGOOGLE*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_global_priority_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT:
        {
            checkEqual_VkQueueFamilyGlobalPriorityPropertiesEXT(reinterpret_cast<const VkQueueFamilyGlobalPriorityPropertiesEXT*>(structExtension), reinterpret_cast<const VkQueueFamilyGlobalPriorityPropertiesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_multi_draw
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceMultiDrawFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceMultiDrawFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMultiDrawFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
        {
            checkEqual_VkPhysicalDeviceMultiDrawPropertiesEXT(reinterpret_cast<const VkPhysicalDeviceMultiDrawPropertiesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceMultiDrawPropertiesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_border_color_swizzle
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(reinterpret_cast<const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT:
        {
            checkEqual_VkSamplerBorderColorComponentMappingCreateInfoEXT(reinterpret_cast<const VkSamplerBorderColorComponentMappingCreateInfoEXT*>(structExtension), reinterpret_cast<const VkSamplerBorderColorComponentMappingCreateInfoEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_EXT_pageable_device_local_memory
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
        {
            checkEqual_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(reinterpret_cast<const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*>(structExtension), reinterpret_cast<const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
        {
            checkEqual_VkWriteDescriptorSetAccelerationStructureKHR(reinterpret_cast<const VkWriteDescriptorSetAccelerationStructureKHR*>(structExtension), reinterpret_cast<const VkWriteDescriptorSetAccelerationStructureKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDeviceAccelerationStructureFeaturesKHR(reinterpret_cast<const VkPhysicalDeviceAccelerationStructureFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceAccelerationStructureFeaturesKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {
            checkEqual_VkPhysicalDeviceAccelerationStructurePropertiesKHR(reinterpret_cast<const VkPhysicalDeviceAccelerationStructurePropertiesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceAccelerationStructurePropertiesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(reinterpret_cast<const VkPhysicalDeviceRayTracingPipelineFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceRayTracingPipelineFeaturesKHR*>(structExtension2), onFail);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {
            checkEqual_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(reinterpret_cast<const VkPhysicalDeviceRayTracingPipelinePropertiesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceRayTracingPipelinePropertiesKHR*>(structExtension2), onFail);
            break;
        }
#endif
#ifdef VK_KHR_ray_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            checkEqual_VkPhysicalDeviceRayQueryFeaturesKHR(reinterpret_cast<const VkPhysicalDeviceRayQueryFeaturesKHR*>(structExtension), reinterpret_cast<const VkPhysicalDeviceRayQueryFeaturesKHR*>(structExtension2), onFail);
            break;
        }
#endif
        default:
        {
            return;
        }
    }
}


} // namespace goldfish_vk
