// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_marshaling
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "goldfish_vk_marshaling.h"


#include "goldfish_vk_extension_structs.h"
#include "goldfish_vk_private_defs.h"


namespace goldfish_vk {

void marshal_extension_struct(
    VulkanStream* vkStream,
    const void* structExtension);

void unmarshal_extension_struct(
    VulkanStream* vkStream,
    void* structExtension_out);

#ifdef VK_VERSION_1_0
void marshal_VkExtent2D(
    VulkanStream* vkStream,
    const VkExtent2D* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->height, sizeof(uint32_t));
}

void unmarshal_VkExtent2D(
    VulkanStream* vkStream,
    VkExtent2D* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->width, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->height, sizeof(uint32_t));
}

void marshal_VkExtent3D(
    VulkanStream* vkStream,
    const VkExtent3D* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->depth, sizeof(uint32_t));
}

void unmarshal_VkExtent3D(
    VulkanStream* vkStream,
    VkExtent3D* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->width, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->height, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->depth, sizeof(uint32_t));
}

void marshal_VkOffset2D(
    VulkanStream* vkStream,
    const VkOffset2D* forMarshaling)
{
    vkStream->write((int32_t*)&forMarshaling->x, sizeof(int32_t));
    vkStream->write((int32_t*)&forMarshaling->y, sizeof(int32_t));
}

void unmarshal_VkOffset2D(
    VulkanStream* vkStream,
    VkOffset2D* forUnmarshaling)
{
    vkStream->read((int32_t*)&forUnmarshaling->x, sizeof(int32_t));
    vkStream->read((int32_t*)&forUnmarshaling->y, sizeof(int32_t));
}

void marshal_VkOffset3D(
    VulkanStream* vkStream,
    const VkOffset3D* forMarshaling)
{
    vkStream->write((int32_t*)&forMarshaling->x, sizeof(int32_t));
    vkStream->write((int32_t*)&forMarshaling->y, sizeof(int32_t));
    vkStream->write((int32_t*)&forMarshaling->z, sizeof(int32_t));
}

void unmarshal_VkOffset3D(
    VulkanStream* vkStream,
    VkOffset3D* forUnmarshaling)
{
    vkStream->read((int32_t*)&forUnmarshaling->x, sizeof(int32_t));
    vkStream->read((int32_t*)&forUnmarshaling->y, sizeof(int32_t));
    vkStream->read((int32_t*)&forUnmarshaling->z, sizeof(int32_t));
}

void marshal_VkRect2D(
    VulkanStream* vkStream,
    const VkRect2D* forMarshaling)
{
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->offset));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->extent));
}

void unmarshal_VkRect2D(
    VulkanStream* vkStream,
    VkRect2D* forUnmarshaling)
{
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->offset));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->extent));
}

void marshal_VkBaseInStructure(
    VulkanStream* vkStream,
    const VkBaseInStructure* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
}

void unmarshal_VkBaseInStructure(
    VulkanStream* vkStream,
    VkBaseInStructure* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((VkBaseInStructure*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
}

void marshal_VkBaseOutStructure(
    VulkanStream* vkStream,
    const VkBaseOutStructure* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
}

void unmarshal_VkBaseOutStructure(
    VulkanStream* vkStream,
    VkBaseOutStructure* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((VkBaseOutStructure*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
}

void marshal_VkBufferMemoryBarrier(
    VulkanStream* vkStream,
    const VkBufferMemoryBarrier* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->write((uint32_t*)&forMarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
}

void unmarshal_VkBufferMemoryBarrier(
    VulkanStream* vkStream,
    VkBufferMemoryBarrier* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_0, (VkBuffer*)&forUnmarshaling->buffer, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
}

void marshal_VkDispatchIndirectCommand(
    VulkanStream* vkStream,
    const VkDispatchIndirectCommand* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->x, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->y, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->z, sizeof(uint32_t));
}

void unmarshal_VkDispatchIndirectCommand(
    VulkanStream* vkStream,
    VkDispatchIndirectCommand* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->x, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->y, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->z, sizeof(uint32_t));
}

void marshal_VkDrawIndexedIndirectCommand(
    VulkanStream* vkStream,
    const VkDrawIndexedIndirectCommand* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->indexCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->instanceCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->firstIndex, sizeof(uint32_t));
    vkStream->write((int32_t*)&forMarshaling->vertexOffset, sizeof(int32_t));
    vkStream->write((uint32_t*)&forMarshaling->firstInstance, sizeof(uint32_t));
}

void unmarshal_VkDrawIndexedIndirectCommand(
    VulkanStream* vkStream,
    VkDrawIndexedIndirectCommand* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->indexCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->instanceCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->firstIndex, sizeof(uint32_t));
    vkStream->read((int32_t*)&forUnmarshaling->vertexOffset, sizeof(int32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->firstInstance, sizeof(uint32_t));
}

void marshal_VkDrawIndirectCommand(
    VulkanStream* vkStream,
    const VkDrawIndirectCommand* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->vertexCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->instanceCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->firstVertex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->firstInstance, sizeof(uint32_t));
}

void unmarshal_VkDrawIndirectCommand(
    VulkanStream* vkStream,
    VkDrawIndirectCommand* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->vertexCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->instanceCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->firstVertex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->firstInstance, sizeof(uint32_t));
}

void marshal_VkImageSubresourceRange(
    VulkanStream* vkStream,
    const VkImageSubresourceRange* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->write((uint32_t*)&forMarshaling->baseMipLevel, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->levelCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
}

void unmarshal_VkImageSubresourceRange(
    VulkanStream* vkStream,
    VkImageSubresourceRange* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->baseMipLevel, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->levelCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->layerCount, sizeof(uint32_t));
}

void marshal_VkImageMemoryBarrier(
    VulkanStream* vkStream,
    const VkImageMemoryBarrier* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkImageLayout*)&forMarshaling->oldLayout, sizeof(VkImageLayout));
    vkStream->write((VkImageLayout*)&forMarshaling->newLayout, sizeof(VkImageLayout));
    vkStream->write((uint32_t*)&forMarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    marshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forMarshaling->subresourceRange));
}

void unmarshal_VkImageMemoryBarrier(
    VulkanStream* vkStream,
    VkImageMemoryBarrier* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkImageLayout*)&forUnmarshaling->oldLayout, sizeof(VkImageLayout));
    vkStream->read((VkImageLayout*)&forUnmarshaling->newLayout, sizeof(VkImageLayout));
    vkStream->read((uint32_t*)&forUnmarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_0, (VkImage*)&forUnmarshaling->image, 1);
    unmarshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forUnmarshaling->subresourceRange));
}

void marshal_VkMemoryBarrier(
    VulkanStream* vkStream,
    const VkMemoryBarrier* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
}

void unmarshal_VkMemoryBarrier(
    VulkanStream* vkStream,
    VkMemoryBarrier* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
}

void marshal_VkAllocationCallbacks(
    VulkanStream* vkStream,
    const VkAllocationCallbacks* forMarshaling)
{
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pUserData;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pUserData)
    {
        vkStream->write((void*)forMarshaling->pUserData, sizeof(uint8_t));
    }
    uint64_t cgen_var_1 = (uint64_t)forMarshaling->pfnAllocation;
    vkStream->putBe64(cgen_var_1);
    uint64_t cgen_var_2 = (uint64_t)forMarshaling->pfnReallocation;
    vkStream->putBe64(cgen_var_2);
    uint64_t cgen_var_3 = (uint64_t)forMarshaling->pfnFree;
    vkStream->putBe64(cgen_var_3);
    uint64_t cgen_var_4 = (uint64_t)forMarshaling->pfnInternalAllocation;
    vkStream->putBe64(cgen_var_4);
    uint64_t cgen_var_5 = (uint64_t)forMarshaling->pfnInternalFree;
    vkStream->putBe64(cgen_var_5);
}

void unmarshal_VkAllocationCallbacks(
    VulkanStream* vkStream,
    VkAllocationCallbacks* forUnmarshaling)
{
    // WARNING PTR CHECK
    forUnmarshaling->pUserData = (void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pUserData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
        vkStream->read((void*)forUnmarshaling->pUserData, sizeof(uint8_t));
    }
    forUnmarshaling->pfnAllocation = (PFN_vkAllocationFunction)vkStream->getBe64();
    forUnmarshaling->pfnReallocation = (PFN_vkReallocationFunction)vkStream->getBe64();
    forUnmarshaling->pfnFree = (PFN_vkFreeFunction)vkStream->getBe64();
    forUnmarshaling->pfnInternalAllocation = (PFN_vkInternalAllocationNotification)vkStream->getBe64();
    forUnmarshaling->pfnInternalFree = (PFN_vkInternalFreeNotification)vkStream->getBe64();
}

void marshal_VkApplicationInfo(
    VulkanStream* vkStream,
    const VkApplicationInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pApplicationName;
        vkStream->putBe64(cgen_var_0);
        if (forMarshaling->pApplicationName)
        {
            vkStream->putString(forMarshaling->pApplicationName);
        }
    }
    else
    {
        vkStream->putString(forMarshaling->pApplicationName);
    }
    vkStream->write((uint32_t*)&forMarshaling->applicationVersion, sizeof(uint32_t));
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pEngineName;
        vkStream->putBe64(cgen_var_0);
        if (forMarshaling->pEngineName)
        {
            vkStream->putString(forMarshaling->pEngineName);
        }
    }
    else
    {
        vkStream->putString(forMarshaling->pEngineName);
    }
    vkStream->write((uint32_t*)&forMarshaling->engineVersion, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->apiVersion, sizeof(uint32_t));
}

void unmarshal_VkApplicationInfo(
    VulkanStream* vkStream,
    VkApplicationInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        forUnmarshaling->pApplicationName = (const char*)(uintptr_t)vkStream->getBe64();
        if (forUnmarshaling->pApplicationName)
        {
            vkStream->loadStringInPlace((char**)&forUnmarshaling->pApplicationName);
        }
    }
    else
    {
        vkStream->loadStringInPlace((char**)&forUnmarshaling->pApplicationName);
    }
    vkStream->read((uint32_t*)&forUnmarshaling->applicationVersion, sizeof(uint32_t));
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        forUnmarshaling->pEngineName = (const char*)(uintptr_t)vkStream->getBe64();
        if (forUnmarshaling->pEngineName)
        {
            vkStream->loadStringInPlace((char**)&forUnmarshaling->pEngineName);
        }
    }
    else
    {
        vkStream->loadStringInPlace((char**)&forUnmarshaling->pEngineName);
    }
    vkStream->read((uint32_t*)&forUnmarshaling->engineVersion, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->apiVersion, sizeof(uint32_t));
}

void marshal_VkFormatProperties(
    VulkanStream* vkStream,
    const VkFormatProperties* forMarshaling)
{
    vkStream->write((VkFormatFeatureFlags*)&forMarshaling->linearTilingFeatures, sizeof(VkFormatFeatureFlags));
    vkStream->write((VkFormatFeatureFlags*)&forMarshaling->optimalTilingFeatures, sizeof(VkFormatFeatureFlags));
    vkStream->write((VkFormatFeatureFlags*)&forMarshaling->bufferFeatures, sizeof(VkFormatFeatureFlags));
}

void unmarshal_VkFormatProperties(
    VulkanStream* vkStream,
    VkFormatProperties* forUnmarshaling)
{
    vkStream->read((VkFormatFeatureFlags*)&forUnmarshaling->linearTilingFeatures, sizeof(VkFormatFeatureFlags));
    vkStream->read((VkFormatFeatureFlags*)&forUnmarshaling->optimalTilingFeatures, sizeof(VkFormatFeatureFlags));
    vkStream->read((VkFormatFeatureFlags*)&forUnmarshaling->bufferFeatures, sizeof(VkFormatFeatureFlags));
}

void marshal_VkImageFormatProperties(
    VulkanStream* vkStream,
    const VkImageFormatProperties* forMarshaling)
{
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->maxExtent));
    vkStream->write((uint32_t*)&forMarshaling->maxMipLevels, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxArrayLayers, sizeof(uint32_t));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkDeviceSize*)&forMarshaling->maxResourceSize, sizeof(VkDeviceSize));
}

void unmarshal_VkImageFormatProperties(
    VulkanStream* vkStream,
    VkImageFormatProperties* forUnmarshaling)
{
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->maxExtent));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMipLevels, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxArrayLayers, sizeof(uint32_t));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->maxResourceSize, sizeof(VkDeviceSize));
}

void marshal_VkInstanceCreateInfo(
    VulkanStream* vkStream,
    const VkInstanceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkInstanceCreateFlags*)&forMarshaling->flags, sizeof(VkInstanceCreateFlags));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pApplicationInfo;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pApplicationInfo)
    {
        marshal_VkApplicationInfo(vkStream, (const VkApplicationInfo*)(forMarshaling->pApplicationInfo));
    }
    vkStream->write((uint32_t*)&forMarshaling->enabledLayerCount, sizeof(uint32_t));
    saveStringArray(vkStream, forMarshaling->ppEnabledLayerNames, forMarshaling->enabledLayerCount);
    vkStream->write((uint32_t*)&forMarshaling->enabledExtensionCount, sizeof(uint32_t));
    saveStringArray(vkStream, forMarshaling->ppEnabledExtensionNames, forMarshaling->enabledExtensionCount);
}

void unmarshal_VkInstanceCreateInfo(
    VulkanStream* vkStream,
    VkInstanceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkInstanceCreateFlags*)&forUnmarshaling->flags, sizeof(VkInstanceCreateFlags));
    // WARNING PTR CHECK
    forUnmarshaling->pApplicationInfo = (const VkApplicationInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pApplicationInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pApplicationInfo, sizeof(const VkApplicationInfo));
        unmarshal_VkApplicationInfo(vkStream, (VkApplicationInfo*)(forUnmarshaling->pApplicationInfo));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->enabledLayerCount, sizeof(uint32_t));
    vkStream->loadStringArrayInPlace((char***)&forUnmarshaling->ppEnabledLayerNames);
    vkStream->read((uint32_t*)&forUnmarshaling->enabledExtensionCount, sizeof(uint32_t));
    vkStream->loadStringArrayInPlace((char***)&forUnmarshaling->ppEnabledExtensionNames);
}

void marshal_VkMemoryHeap(
    VulkanStream* vkStream,
    const VkMemoryHeap* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkMemoryHeapFlags*)&forMarshaling->flags, sizeof(VkMemoryHeapFlags));
}

void unmarshal_VkMemoryHeap(
    VulkanStream* vkStream,
    VkMemoryHeap* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkMemoryHeapFlags*)&forUnmarshaling->flags, sizeof(VkMemoryHeapFlags));
}

void marshal_VkMemoryType(
    VulkanStream* vkStream,
    const VkMemoryType* forMarshaling)
{
    vkStream->write((VkMemoryPropertyFlags*)&forMarshaling->propertyFlags, sizeof(VkMemoryPropertyFlags));
    vkStream->write((uint32_t*)&forMarshaling->heapIndex, sizeof(uint32_t));
}

void unmarshal_VkMemoryType(
    VulkanStream* vkStream,
    VkMemoryType* forUnmarshaling)
{
    vkStream->read((VkMemoryPropertyFlags*)&forUnmarshaling->propertyFlags, sizeof(VkMemoryPropertyFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->heapIndex, sizeof(uint32_t));
}

void marshal_VkPhysicalDeviceFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceFeatures* forMarshaling)
{
    vkStream->write((VkBool32*)&forMarshaling->robustBufferAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fullDrawIndexUint32, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->imageCubeArray, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->independentBlend, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->geometryShader, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->tessellationShader, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sampleRateShading, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->dualSrcBlend, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->logicOp, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiDrawIndirect, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->drawIndirectFirstInstance, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->depthClamp, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->depthBiasClamp, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fillModeNonSolid, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->depthBounds, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->wideLines, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->largePoints, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->alphaToOne, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiViewport, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->samplerAnisotropy, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->textureCompressionETC2, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->textureCompressionASTC_LDR, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->textureCompressionBC, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->occlusionQueryPrecise, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->pipelineStatisticsQuery, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->vertexPipelineStoresAndAtomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fragmentStoresAndAtomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderTessellationAndGeometryPointSize, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderImageGatherExtended, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageExtendedFormats, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageMultisample, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageReadWithoutFormat, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageWriteWithoutFormat, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSampledImageArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderClipDistance, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderCullDistance, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderFloat64, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInt64, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInt16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderResourceResidency, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderResourceMinLod, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseBinding, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidencyBuffer, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidencyImage2D, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidencyImage3D, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidency2Samples, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidency4Samples, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidency8Samples, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidency16Samples, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidencyAliased, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->variableMultisampleRate, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->inheritedQueries, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceFeatures* forUnmarshaling)
{
    vkStream->read((VkBool32*)&forUnmarshaling->robustBufferAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fullDrawIndexUint32, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->imageCubeArray, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->independentBlend, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->geometryShader, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->tessellationShader, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sampleRateShading, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->dualSrcBlend, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->logicOp, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiDrawIndirect, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->drawIndirectFirstInstance, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->depthClamp, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->depthBiasClamp, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fillModeNonSolid, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->depthBounds, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->wideLines, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->largePoints, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->alphaToOne, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiViewport, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->samplerAnisotropy, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->textureCompressionETC2, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->textureCompressionASTC_LDR, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->textureCompressionBC, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->occlusionQueryPrecise, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->pipelineStatisticsQuery, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->vertexPipelineStoresAndAtomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentStoresAndAtomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderTessellationAndGeometryPointSize, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderImageGatherExtended, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageExtendedFormats, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageMultisample, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageReadWithoutFormat, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageWriteWithoutFormat, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSampledImageArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderClipDistance, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderCullDistance, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderFloat64, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInt64, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInt16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderResourceResidency, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderResourceMinLod, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseBinding, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidencyBuffer, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidencyImage2D, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidencyImage3D, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidency2Samples, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidency4Samples, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidency8Samples, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidency16Samples, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidencyAliased, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->variableMultisampleRate, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->inheritedQueries, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceLimits(
    VulkanStream* vkStream,
    const VkPhysicalDeviceLimits* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->maxImageDimension1D, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageDimension2D, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageDimension3D, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageDimensionCube, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTexelBufferElements, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxUniformBufferRange, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxStorageBufferRange, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPushConstantsSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxMemoryAllocationCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxSamplerAllocationCount, sizeof(uint32_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->bufferImageGranularity, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->sparseAddressSpaceSize, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->maxBoundDescriptorSets, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorSamplers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUniformBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorStorageBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorSampledImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorStorageImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorInputAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageResources, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetSamplers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUniformBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUniformBuffersDynamic, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetStorageBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetStorageBuffersDynamic, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetSampledImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetStorageImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetInputAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexInputAttributes, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexInputBindings, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexInputAttributeOffset, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexInputBindingStride, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationGenerationLevel, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationPatchSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationControlPerVertexInputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationControlPerVertexOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationControlPerPatchOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationControlTotalOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationEvaluationInputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationEvaluationOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryShaderInvocations, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryInputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryOutputVertices, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryTotalOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentInputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentOutputAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentDualSrcAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentCombinedOutputResources, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxComputeSharedMemorySize, sizeof(uint32_t));
    vkStream->write((uint32_t*)forMarshaling->maxComputeWorkGroupCount, 3 * sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxComputeWorkGroupInvocations, sizeof(uint32_t));
    vkStream->write((uint32_t*)forMarshaling->maxComputeWorkGroupSize, 3 * sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->subPixelPrecisionBits, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->subTexelPrecisionBits, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->mipmapPrecisionBits, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDrawIndexedIndexValue, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDrawIndirectCount, sizeof(uint32_t));
    vkStream->write((float*)&forMarshaling->maxSamplerLodBias, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxSamplerAnisotropy, sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->maxViewports, sizeof(uint32_t));
    vkStream->write((uint32_t*)forMarshaling->maxViewportDimensions, 2 * sizeof(uint32_t));
    vkStream->write((float*)forMarshaling->viewportBoundsRange, 2 * sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->viewportSubPixelBits, sizeof(uint32_t));
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->minMemoryMapAlignment;
    vkStream->putBe64(cgen_var_0);
    vkStream->write((VkDeviceSize*)&forMarshaling->minTexelBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->minUniformBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->minStorageBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->write((int32_t*)&forMarshaling->minTexelOffset, sizeof(int32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTexelOffset, sizeof(uint32_t));
    vkStream->write((int32_t*)&forMarshaling->minTexelGatherOffset, sizeof(int32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTexelGatherOffset, sizeof(uint32_t));
    vkStream->write((float*)&forMarshaling->minInterpolationOffset, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxInterpolationOffset, sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->subPixelInterpolationOffsetBits, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFramebufferWidth, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFramebufferHeight, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFramebufferLayers, sizeof(uint32_t));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->framebufferColorSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->framebufferDepthSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->framebufferStencilSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->framebufferNoAttachmentsSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((uint32_t*)&forMarshaling->maxColorAttachments, sizeof(uint32_t));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampledImageColorSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampledImageIntegerSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampledImageDepthSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampledImageStencilSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->storageImageSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((uint32_t*)&forMarshaling->maxSampleMaskWords, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->timestampComputeAndGraphics, sizeof(VkBool32));
    vkStream->write((float*)&forMarshaling->timestampPeriod, sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->maxClipDistances, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxCullDistances, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxCombinedClipAndCullDistances, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->discreteQueuePriorities, sizeof(uint32_t));
    vkStream->write((float*)forMarshaling->pointSizeRange, 2 * sizeof(float));
    vkStream->write((float*)forMarshaling->lineWidthRange, 2 * sizeof(float));
    vkStream->write((float*)&forMarshaling->pointSizeGranularity, sizeof(float));
    vkStream->write((float*)&forMarshaling->lineWidthGranularity, sizeof(float));
    vkStream->write((VkBool32*)&forMarshaling->strictLines, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->standardSampleLocations, sizeof(VkBool32));
    vkStream->write((VkDeviceSize*)&forMarshaling->optimalBufferCopyOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->optimalBufferCopyRowPitchAlignment, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->nonCoherentAtomSize, sizeof(VkDeviceSize));
}

void unmarshal_VkPhysicalDeviceLimits(
    VulkanStream* vkStream,
    VkPhysicalDeviceLimits* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageDimension1D, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageDimension2D, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageDimension3D, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageDimensionCube, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTexelBufferElements, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxUniformBufferRange, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxStorageBufferRange, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPushConstantsSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMemoryAllocationCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSamplerAllocationCount, sizeof(uint32_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->bufferImageGranularity, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->sparseAddressSpaceSize, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->maxBoundDescriptorSets, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorSamplers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUniformBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorStorageBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorSampledImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorStorageImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorInputAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageResources, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetSamplers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUniformBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUniformBuffersDynamic, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageBuffersDynamic, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetSampledImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetInputAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexInputAttributes, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexInputBindings, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexInputAttributeOffset, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexInputBindingStride, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationGenerationLevel, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationPatchSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationControlPerVertexInputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationControlPerVertexOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationControlPerPatchOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationControlTotalOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationEvaluationInputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationEvaluationOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryShaderInvocations, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryInputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryOutputVertices, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryTotalOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentInputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentOutputAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentDualSrcAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentCombinedOutputResources, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxComputeSharedMemorySize, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->maxComputeWorkGroupCount, 3 * sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxComputeWorkGroupInvocations, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->maxComputeWorkGroupSize, 3 * sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->subPixelPrecisionBits, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->subTexelPrecisionBits, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->mipmapPrecisionBits, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDrawIndexedIndexValue, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDrawIndirectCount, sizeof(uint32_t));
    vkStream->read((float*)&forUnmarshaling->maxSamplerLodBias, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxSamplerAnisotropy, sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->maxViewports, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->maxViewportDimensions, 2 * sizeof(uint32_t));
    vkStream->read((float*)forUnmarshaling->viewportBoundsRange, 2 * sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->viewportSubPixelBits, sizeof(uint32_t));
    forUnmarshaling->minMemoryMapAlignment = (size_t)vkStream->getBe64();
    vkStream->read((VkDeviceSize*)&forUnmarshaling->minTexelBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->minUniformBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->minStorageBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->read((int32_t*)&forUnmarshaling->minTexelOffset, sizeof(int32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTexelOffset, sizeof(uint32_t));
    vkStream->read((int32_t*)&forUnmarshaling->minTexelGatherOffset, sizeof(int32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTexelGatherOffset, sizeof(uint32_t));
    vkStream->read((float*)&forUnmarshaling->minInterpolationOffset, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxInterpolationOffset, sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->subPixelInterpolationOffsetBits, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFramebufferWidth, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFramebufferHeight, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFramebufferLayers, sizeof(uint32_t));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->framebufferColorSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->framebufferDepthSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->framebufferStencilSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->framebufferNoAttachmentsSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->maxColorAttachments, sizeof(uint32_t));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampledImageColorSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampledImageIntegerSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampledImageDepthSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampledImageStencilSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->storageImageSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSampleMaskWords, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->timestampComputeAndGraphics, sizeof(VkBool32));
    vkStream->read((float*)&forUnmarshaling->timestampPeriod, sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->maxClipDistances, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxCullDistances, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxCombinedClipAndCullDistances, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->discreteQueuePriorities, sizeof(uint32_t));
    vkStream->read((float*)forUnmarshaling->pointSizeRange, 2 * sizeof(float));
    vkStream->read((float*)forUnmarshaling->lineWidthRange, 2 * sizeof(float));
    vkStream->read((float*)&forUnmarshaling->pointSizeGranularity, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->lineWidthGranularity, sizeof(float));
    vkStream->read((VkBool32*)&forUnmarshaling->strictLines, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->standardSampleLocations, sizeof(VkBool32));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->optimalBufferCopyOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->optimalBufferCopyRowPitchAlignment, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->nonCoherentAtomSize, sizeof(VkDeviceSize));
}

void marshal_VkPhysicalDeviceMemoryProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMemoryProperties* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        marshal_VkMemoryType(vkStream, (VkMemoryType*)(forMarshaling->memoryTypes + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->memoryHeapCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        marshal_VkMemoryHeap(vkStream, (VkMemoryHeap*)(forMarshaling->memoryHeaps + i));
    }
}

void unmarshal_VkPhysicalDeviceMemoryProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceMemoryProperties* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        unmarshal_VkMemoryType(vkStream, (VkMemoryType*)(forUnmarshaling->memoryTypes + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->memoryHeapCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        unmarshal_VkMemoryHeap(vkStream, (VkMemoryHeap*)(forUnmarshaling->memoryHeaps + i));
    }
}

void marshal_VkPhysicalDeviceSparseProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSparseProperties* forMarshaling)
{
    vkStream->write((VkBool32*)&forMarshaling->residencyStandard2DBlockShape, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->residencyStandard2DMultisampleBlockShape, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->residencyStandard3DBlockShape, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->residencyAlignedMipSize, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->residencyNonResidentStrict, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSparseProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceSparseProperties* forUnmarshaling)
{
    vkStream->read((VkBool32*)&forUnmarshaling->residencyStandard2DBlockShape, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->residencyStandard2DMultisampleBlockShape, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->residencyStandard3DBlockShape, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->residencyAlignedMipSize, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->residencyNonResidentStrict, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceProperties* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->apiVersion, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->driverVersion, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->vendorID, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->deviceID, sizeof(uint32_t));
    vkStream->write((VkPhysicalDeviceType*)&forMarshaling->deviceType, sizeof(VkPhysicalDeviceType));
    vkStream->write((char*)forMarshaling->deviceName, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char));
    vkStream->write((uint8_t*)forMarshaling->pipelineCacheUUID, VK_UUID_SIZE * sizeof(uint8_t));
    marshal_VkPhysicalDeviceLimits(vkStream, (VkPhysicalDeviceLimits*)(&forMarshaling->limits));
    marshal_VkPhysicalDeviceSparseProperties(vkStream, (VkPhysicalDeviceSparseProperties*)(&forMarshaling->sparseProperties));
}

void unmarshal_VkPhysicalDeviceProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceProperties* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->apiVersion, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->driverVersion, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->vendorID, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceID, sizeof(uint32_t));
    vkStream->read((VkPhysicalDeviceType*)&forUnmarshaling->deviceType, sizeof(VkPhysicalDeviceType));
    vkStream->read((char*)forUnmarshaling->deviceName, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char));
    vkStream->read((uint8_t*)forUnmarshaling->pipelineCacheUUID, VK_UUID_SIZE * sizeof(uint8_t));
    unmarshal_VkPhysicalDeviceLimits(vkStream, (VkPhysicalDeviceLimits*)(&forUnmarshaling->limits));
    unmarshal_VkPhysicalDeviceSparseProperties(vkStream, (VkPhysicalDeviceSparseProperties*)(&forUnmarshaling->sparseProperties));
}

void marshal_VkQueueFamilyProperties(
    VulkanStream* vkStream,
    const VkQueueFamilyProperties* forMarshaling)
{
    vkStream->write((VkQueueFlags*)&forMarshaling->queueFlags, sizeof(VkQueueFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->timestampValidBits, sizeof(uint32_t));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->minImageTransferGranularity));
}

void unmarshal_VkQueueFamilyProperties(
    VulkanStream* vkStream,
    VkQueueFamilyProperties* forUnmarshaling)
{
    vkStream->read((VkQueueFlags*)&forUnmarshaling->queueFlags, sizeof(VkQueueFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->timestampValidBits, sizeof(uint32_t));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->minImageTransferGranularity));
}

void marshal_VkDeviceQueueCreateInfo(
    VulkanStream* vkStream,
    const VkDeviceQueueCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceQueueCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->queueCount, sizeof(uint32_t));
    vkStream->write((const float*)forMarshaling->pQueuePriorities, forMarshaling->queueCount * sizeof(const float));
}

void unmarshal_VkDeviceQueueCreateInfo(
    VulkanStream* vkStream,
    VkDeviceQueueCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceQueueCreateFlags*)&forUnmarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->queueCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pQueuePriorities, forUnmarshaling->queueCount * sizeof(const float));
    vkStream->read((float*)forUnmarshaling->pQueuePriorities, forUnmarshaling->queueCount * sizeof(const float));
}

void marshal_VkDeviceCreateInfo(
    VulkanStream* vkStream,
    const VkDeviceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueCreateInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->queueCreateInfoCount; ++i)
    {
        marshal_VkDeviceQueueCreateInfo(vkStream, (const VkDeviceQueueCreateInfo*)(forMarshaling->pQueueCreateInfos + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->enabledLayerCount, sizeof(uint32_t));
    saveStringArray(vkStream, forMarshaling->ppEnabledLayerNames, forMarshaling->enabledLayerCount);
    vkStream->write((uint32_t*)&forMarshaling->enabledExtensionCount, sizeof(uint32_t));
    saveStringArray(vkStream, forMarshaling->ppEnabledExtensionNames, forMarshaling->enabledExtensionCount);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pEnabledFeatures;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pEnabledFeatures)
    {
        marshal_VkPhysicalDeviceFeatures(vkStream, (const VkPhysicalDeviceFeatures*)(forMarshaling->pEnabledFeatures));
    }
}

void unmarshal_VkDeviceCreateInfo(
    VulkanStream* vkStream,
    VkDeviceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceCreateFlags*)&forUnmarshaling->flags, sizeof(VkDeviceCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueCreateInfoCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pQueueCreateInfos, forUnmarshaling->queueCreateInfoCount * sizeof(const VkDeviceQueueCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->queueCreateInfoCount; ++i)
    {
        unmarshal_VkDeviceQueueCreateInfo(vkStream, (VkDeviceQueueCreateInfo*)(forUnmarshaling->pQueueCreateInfos + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->enabledLayerCount, sizeof(uint32_t));
    vkStream->loadStringArrayInPlace((char***)&forUnmarshaling->ppEnabledLayerNames);
    vkStream->read((uint32_t*)&forUnmarshaling->enabledExtensionCount, sizeof(uint32_t));
    vkStream->loadStringArrayInPlace((char***)&forUnmarshaling->ppEnabledExtensionNames);
    // WARNING PTR CHECK
    forUnmarshaling->pEnabledFeatures = (const VkPhysicalDeviceFeatures*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pEnabledFeatures)
    {
        vkStream->alloc((void**)&forUnmarshaling->pEnabledFeatures, sizeof(const VkPhysicalDeviceFeatures));
        unmarshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(forUnmarshaling->pEnabledFeatures));
    }
}

void marshal_VkExtensionProperties(
    VulkanStream* vkStream,
    const VkExtensionProperties* forMarshaling)
{
    vkStream->write((char*)forMarshaling->extensionName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->write((uint32_t*)&forMarshaling->specVersion, sizeof(uint32_t));
}

void unmarshal_VkExtensionProperties(
    VulkanStream* vkStream,
    VkExtensionProperties* forUnmarshaling)
{
    vkStream->read((char*)forUnmarshaling->extensionName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->read((uint32_t*)&forUnmarshaling->specVersion, sizeof(uint32_t));
}

void marshal_VkLayerProperties(
    VulkanStream* vkStream,
    const VkLayerProperties* forMarshaling)
{
    vkStream->write((char*)forMarshaling->layerName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->write((uint32_t*)&forMarshaling->specVersion, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->implementationVersion, sizeof(uint32_t));
    vkStream->write((char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
}

void unmarshal_VkLayerProperties(
    VulkanStream* vkStream,
    VkLayerProperties* forUnmarshaling)
{
    vkStream->read((char*)forUnmarshaling->layerName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->read((uint32_t*)&forUnmarshaling->specVersion, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->implementationVersion, sizeof(uint32_t));
    vkStream->read((char*)forUnmarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
}

void marshal_VkSubmitInfo(
    VulkanStream* vkStream,
    const VkSubmitInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    if (forMarshaling->waitSemaphoreCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forMarshaling->waitSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_VkSemaphore_u64(forMarshaling->pWaitSemaphores, cgen_var_0, forMarshaling->waitSemaphoreCount);
        vkStream->write((uint64_t*)cgen_var_0, forMarshaling->waitSemaphoreCount * 8);
    }
    vkStream->write((const VkPipelineStageFlags*)forMarshaling->pWaitDstStageMask, forMarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    vkStream->write((uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
    if (forMarshaling->commandBufferCount)
    {
        uint64_t* cgen_var_1;
        vkStream->alloc((void**)&cgen_var_1, forMarshaling->commandBufferCount * 8);
        vkStream->handleMapping()->mapHandles_VkCommandBuffer_u64(forMarshaling->pCommandBuffers, cgen_var_1, forMarshaling->commandBufferCount);
        vkStream->write((uint64_t*)cgen_var_1, forMarshaling->commandBufferCount * 8);
    }
    vkStream->write((uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    if (forMarshaling->signalSemaphoreCount)
    {
        uint64_t* cgen_var_2;
        vkStream->alloc((void**)&cgen_var_2, forMarshaling->signalSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_VkSemaphore_u64(forMarshaling->pSignalSemaphores, cgen_var_2, forMarshaling->signalSemaphoreCount);
        vkStream->write((uint64_t*)cgen_var_2, forMarshaling->signalSemaphoreCount * 8);
    }
}

void unmarshal_VkSubmitInfo(
    VulkanStream* vkStream,
    VkSubmitInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->waitSemaphoreCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forUnmarshaling->waitSemaphoreCount * 8);
        vkStream->read((uint64_t*)cgen_var_0, forUnmarshaling->waitSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkSemaphore(cgen_var_0, (VkSemaphore*)forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount);
    }
    vkStream->alloc((void**)&forUnmarshaling->pWaitDstStageMask, forUnmarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    vkStream->read((VkPipelineStageFlags*)forUnmarshaling->pWaitDstStageMask, forUnmarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->commandBufferCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pCommandBuffers, forUnmarshaling->commandBufferCount * sizeof(const VkCommandBuffer));
    if (forUnmarshaling->commandBufferCount)
    {
        uint64_t* cgen_var_1;
        vkStream->alloc((void**)&cgen_var_1, forUnmarshaling->commandBufferCount * 8);
        vkStream->read((uint64_t*)cgen_var_1, forUnmarshaling->commandBufferCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_1, (VkCommandBuffer*)forUnmarshaling->pCommandBuffers, forUnmarshaling->commandBufferCount);
    }
    vkStream->read((uint32_t*)&forUnmarshaling->signalSemaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphores, forUnmarshaling->signalSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->signalSemaphoreCount)
    {
        uint64_t* cgen_var_2;
        vkStream->alloc((void**)&cgen_var_2, forUnmarshaling->signalSemaphoreCount * 8);
        vkStream->read((uint64_t*)cgen_var_2, forUnmarshaling->signalSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkSemaphore(cgen_var_2, (VkSemaphore*)forUnmarshaling->pSignalSemaphores, forUnmarshaling->signalSemaphoreCount);
    }
}

void marshal_VkMappedMemoryRange(
    VulkanStream* vkStream,
    const VkMappedMemoryRange* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
}

void unmarshal_VkMappedMemoryRange(
    VulkanStream* vkStream,
    VkMappedMemoryRange* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_0, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
}

void marshal_VkMemoryAllocateInfo(
    VulkanStream* vkStream,
    const VkMemoryAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceSize*)&forMarshaling->allocationSize, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeIndex, sizeof(uint32_t));
}

void unmarshal_VkMemoryAllocateInfo(
    VulkanStream* vkStream,
    VkMemoryAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceSize*)&forUnmarshaling->allocationSize, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeIndex, sizeof(uint32_t));
}

void marshal_VkMemoryRequirements(
    VulkanStream* vkStream,
    const VkMemoryRequirements* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->alignment, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkMemoryRequirements(
    VulkanStream* vkStream,
    VkMemoryRequirements* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->alignment, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_VkSparseMemoryBind(
    VulkanStream* vkStream,
    const VkSparseMemoryBind* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->resourceOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    vkStream->write((VkSparseMemoryBindFlags*)&forMarshaling->flags, sizeof(VkSparseMemoryBindFlags));
}

void unmarshal_VkSparseMemoryBind(
    VulkanStream* vkStream,
    VkSparseMemoryBind* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->resourceOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_0, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->memoryOffset, sizeof(VkDeviceSize));
    vkStream->read((VkSparseMemoryBindFlags*)&forUnmarshaling->flags, sizeof(VkSparseMemoryBindFlags));
}

void marshal_VkSparseBufferMemoryBindInfo(
    VulkanStream* vkStream,
    const VkSparseBufferMemoryBindInfo* forMarshaling)
{
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        marshal_VkSparseMemoryBind(vkStream, (const VkSparseMemoryBind*)(forMarshaling->pBinds + i));
    }
}

void unmarshal_VkSparseBufferMemoryBindInfo(
    VulkanStream* vkStream,
    VkSparseBufferMemoryBindInfo* forUnmarshaling)
{
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_0, (VkBuffer*)&forUnmarshaling->buffer, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->bindCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pBinds, forUnmarshaling->bindCount * sizeof(const VkSparseMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        unmarshal_VkSparseMemoryBind(vkStream, (VkSparseMemoryBind*)(forUnmarshaling->pBinds + i));
    }
}

void marshal_VkSparseImageOpaqueMemoryBindInfo(
    VulkanStream* vkStream,
    const VkSparseImageOpaqueMemoryBindInfo* forMarshaling)
{
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        marshal_VkSparseMemoryBind(vkStream, (const VkSparseMemoryBind*)(forMarshaling->pBinds + i));
    }
}

void unmarshal_VkSparseImageOpaqueMemoryBindInfo(
    VulkanStream* vkStream,
    VkSparseImageOpaqueMemoryBindInfo* forUnmarshaling)
{
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_0, (VkImage*)&forUnmarshaling->image, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->bindCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pBinds, forUnmarshaling->bindCount * sizeof(const VkSparseMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        unmarshal_VkSparseMemoryBind(vkStream, (VkSparseMemoryBind*)(forUnmarshaling->pBinds + i));
    }
}

void marshal_VkImageSubresource(
    VulkanStream* vkStream,
    const VkImageSubresource* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->write((uint32_t*)&forMarshaling->mipLevel, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->arrayLayer, sizeof(uint32_t));
}

void unmarshal_VkImageSubresource(
    VulkanStream* vkStream,
    VkImageSubresource* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->mipLevel, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->arrayLayer, sizeof(uint32_t));
}

void marshal_VkSparseImageMemoryBind(
    VulkanStream* vkStream,
    const VkSparseImageMemoryBind* forMarshaling)
{
    marshal_VkImageSubresource(vkStream, (VkImageSubresource*)(&forMarshaling->subresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->offset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    vkStream->write((VkSparseMemoryBindFlags*)&forMarshaling->flags, sizeof(VkSparseMemoryBindFlags));
}

void unmarshal_VkSparseImageMemoryBind(
    VulkanStream* vkStream,
    VkSparseImageMemoryBind* forUnmarshaling)
{
    unmarshal_VkImageSubresource(vkStream, (VkImageSubresource*)(&forUnmarshaling->subresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->offset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_0, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->memoryOffset, sizeof(VkDeviceSize));
    vkStream->read((VkSparseMemoryBindFlags*)&forUnmarshaling->flags, sizeof(VkSparseMemoryBindFlags));
}

void marshal_VkSparseImageMemoryBindInfo(
    VulkanStream* vkStream,
    const VkSparseImageMemoryBindInfo* forMarshaling)
{
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        marshal_VkSparseImageMemoryBind(vkStream, (const VkSparseImageMemoryBind*)(forMarshaling->pBinds + i));
    }
}

void unmarshal_VkSparseImageMemoryBindInfo(
    VulkanStream* vkStream,
    VkSparseImageMemoryBindInfo* forUnmarshaling)
{
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_0, (VkImage*)&forUnmarshaling->image, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->bindCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pBinds, forUnmarshaling->bindCount * sizeof(const VkSparseImageMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        unmarshal_VkSparseImageMemoryBind(vkStream, (VkSparseImageMemoryBind*)(forUnmarshaling->pBinds + i));
    }
}

void marshal_VkBindSparseInfo(
    VulkanStream* vkStream,
    const VkBindSparseInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    if (forMarshaling->waitSemaphoreCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forMarshaling->waitSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_VkSemaphore_u64(forMarshaling->pWaitSemaphores, cgen_var_0, forMarshaling->waitSemaphoreCount);
        vkStream->write((uint64_t*)cgen_var_0, forMarshaling->waitSemaphoreCount * 8);
    }
    vkStream->write((uint32_t*)&forMarshaling->bufferBindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bufferBindCount; ++i)
    {
        marshal_VkSparseBufferMemoryBindInfo(vkStream, (const VkSparseBufferMemoryBindInfo*)(forMarshaling->pBufferBinds + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->imageOpaqueBindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->imageOpaqueBindCount; ++i)
    {
        marshal_VkSparseImageOpaqueMemoryBindInfo(vkStream, (const VkSparseImageOpaqueMemoryBindInfo*)(forMarshaling->pImageOpaqueBinds + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->imageBindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->imageBindCount; ++i)
    {
        marshal_VkSparseImageMemoryBindInfo(vkStream, (const VkSparseImageMemoryBindInfo*)(forMarshaling->pImageBinds + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    if (forMarshaling->signalSemaphoreCount)
    {
        uint64_t* cgen_var_1;
        vkStream->alloc((void**)&cgen_var_1, forMarshaling->signalSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_VkSemaphore_u64(forMarshaling->pSignalSemaphores, cgen_var_1, forMarshaling->signalSemaphoreCount);
        vkStream->write((uint64_t*)cgen_var_1, forMarshaling->signalSemaphoreCount * 8);
    }
}

void unmarshal_VkBindSparseInfo(
    VulkanStream* vkStream,
    VkBindSparseInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->waitSemaphoreCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forUnmarshaling->waitSemaphoreCount * 8);
        vkStream->read((uint64_t*)cgen_var_0, forUnmarshaling->waitSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkSemaphore(cgen_var_0, (VkSemaphore*)forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount);
    }
    vkStream->read((uint32_t*)&forUnmarshaling->bufferBindCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pBufferBinds, forUnmarshaling->bufferBindCount * sizeof(const VkSparseBufferMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bufferBindCount; ++i)
    {
        unmarshal_VkSparseBufferMemoryBindInfo(vkStream, (VkSparseBufferMemoryBindInfo*)(forUnmarshaling->pBufferBinds + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->imageOpaqueBindCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pImageOpaqueBinds, forUnmarshaling->imageOpaqueBindCount * sizeof(const VkSparseImageOpaqueMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->imageOpaqueBindCount; ++i)
    {
        unmarshal_VkSparseImageOpaqueMemoryBindInfo(vkStream, (VkSparseImageOpaqueMemoryBindInfo*)(forUnmarshaling->pImageOpaqueBinds + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->imageBindCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pImageBinds, forUnmarshaling->imageBindCount * sizeof(const VkSparseImageMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->imageBindCount; ++i)
    {
        unmarshal_VkSparseImageMemoryBindInfo(vkStream, (VkSparseImageMemoryBindInfo*)(forUnmarshaling->pImageBinds + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->signalSemaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphores, forUnmarshaling->signalSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->signalSemaphoreCount)
    {
        uint64_t* cgen_var_1;
        vkStream->alloc((void**)&cgen_var_1, forUnmarshaling->signalSemaphoreCount * 8);
        vkStream->read((uint64_t*)cgen_var_1, forUnmarshaling->signalSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkSemaphore(cgen_var_1, (VkSemaphore*)forUnmarshaling->pSignalSemaphores, forUnmarshaling->signalSemaphoreCount);
    }
}

void marshal_VkSparseImageFormatProperties(
    VulkanStream* vkStream,
    const VkSparseImageFormatProperties* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->imageGranularity));
    vkStream->write((VkSparseImageFormatFlags*)&forMarshaling->flags, sizeof(VkSparseImageFormatFlags));
}

void unmarshal_VkSparseImageFormatProperties(
    VulkanStream* vkStream,
    VkSparseImageFormatProperties* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->imageGranularity));
    vkStream->read((VkSparseImageFormatFlags*)&forUnmarshaling->flags, sizeof(VkSparseImageFormatFlags));
}

void marshal_VkSparseImageMemoryRequirements(
    VulkanStream* vkStream,
    const VkSparseImageMemoryRequirements* forMarshaling)
{
    marshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forMarshaling->formatProperties));
    vkStream->write((uint32_t*)&forMarshaling->imageMipTailFirstLod, sizeof(uint32_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->imageMipTailSize, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->imageMipTailOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->imageMipTailStride, sizeof(VkDeviceSize));
}

void unmarshal_VkSparseImageMemoryRequirements(
    VulkanStream* vkStream,
    VkSparseImageMemoryRequirements* forUnmarshaling)
{
    unmarshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forUnmarshaling->formatProperties));
    vkStream->read((uint32_t*)&forUnmarshaling->imageMipTailFirstLod, sizeof(uint32_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->imageMipTailSize, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->imageMipTailOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->imageMipTailStride, sizeof(VkDeviceSize));
}

void marshal_VkFenceCreateInfo(
    VulkanStream* vkStream,
    const VkFenceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkFenceCreateFlags*)&forMarshaling->flags, sizeof(VkFenceCreateFlags));
}

void unmarshal_VkFenceCreateInfo(
    VulkanStream* vkStream,
    VkFenceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFenceCreateFlags*)&forUnmarshaling->flags, sizeof(VkFenceCreateFlags));
}

void marshal_VkSemaphoreCreateInfo(
    VulkanStream* vkStream,
    const VkSemaphoreCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSemaphoreCreateFlags*)&forMarshaling->flags, sizeof(VkSemaphoreCreateFlags));
}

void unmarshal_VkSemaphoreCreateInfo(
    VulkanStream* vkStream,
    VkSemaphoreCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSemaphoreCreateFlags*)&forUnmarshaling->flags, sizeof(VkSemaphoreCreateFlags));
}

void marshal_VkEventCreateInfo(
    VulkanStream* vkStream,
    const VkEventCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkEventCreateFlags*)&forMarshaling->flags, sizeof(VkEventCreateFlags));
}

void unmarshal_VkEventCreateInfo(
    VulkanStream* vkStream,
    VkEventCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkEventCreateFlags*)&forUnmarshaling->flags, sizeof(VkEventCreateFlags));
}

void marshal_VkQueryPoolCreateInfo(
    VulkanStream* vkStream,
    const VkQueryPoolCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkQueryPoolCreateFlags*)&forMarshaling->flags, sizeof(VkQueryPoolCreateFlags));
    vkStream->write((VkQueryType*)&forMarshaling->queryType, sizeof(VkQueryType));
    vkStream->write((uint32_t*)&forMarshaling->queryCount, sizeof(uint32_t));
    vkStream->write((VkQueryPipelineStatisticFlags*)&forMarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
}

void unmarshal_VkQueryPoolCreateInfo(
    VulkanStream* vkStream,
    VkQueryPoolCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkQueryPoolCreateFlags*)&forUnmarshaling->flags, sizeof(VkQueryPoolCreateFlags));
    vkStream->read((VkQueryType*)&forUnmarshaling->queryType, sizeof(VkQueryType));
    vkStream->read((uint32_t*)&forUnmarshaling->queryCount, sizeof(uint32_t));
    vkStream->read((VkQueryPipelineStatisticFlags*)&forUnmarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
}

void marshal_VkBufferCreateInfo(
    VulkanStream* vkStream,
    const VkBufferCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBufferCreateFlags*)&forMarshaling->flags, sizeof(VkBufferCreateFlags));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkBufferUsageFlags*)&forMarshaling->usage, sizeof(VkBufferUsageFlags));
    vkStream->write((VkSharingMode*)&forMarshaling->sharingMode, sizeof(VkSharingMode));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pQueueFamilyIndices;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pQueueFamilyIndices)
    {
        vkStream->write((const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
}

void unmarshal_VkBufferCreateInfo(
    VulkanStream* vkStream,
    VkBufferCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBufferCreateFlags*)&forUnmarshaling->flags, sizeof(VkBufferCreateFlags));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkBufferUsageFlags*)&forUnmarshaling->usage, sizeof(VkBufferUsageFlags));
    vkStream->read((VkSharingMode*)&forUnmarshaling->sharingMode, sizeof(VkSharingMode));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pQueueFamilyIndices = (const uint32_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        vkStream->read((uint32_t*)forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
}

void marshal_VkBufferViewCreateInfo(
    VulkanStream* vkStream,
    const VkBufferViewCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBufferViewCreateFlags*)&forMarshaling->flags, sizeof(VkBufferViewCreateFlags));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->range, sizeof(VkDeviceSize));
}

void unmarshal_VkBufferViewCreateInfo(
    VulkanStream* vkStream,
    VkBufferViewCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBufferViewCreateFlags*)&forUnmarshaling->flags, sizeof(VkBufferViewCreateFlags));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_0, (VkBuffer*)&forUnmarshaling->buffer, 1);
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->range, sizeof(VkDeviceSize));
}

void marshal_VkImageCreateInfo(
    VulkanStream* vkStream,
    const VkImageCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkImageCreateFlags*)&forMarshaling->flags, sizeof(VkImageCreateFlags));
    vkStream->write((VkImageType*)&forMarshaling->imageType, sizeof(VkImageType));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent));
    vkStream->write((uint32_t*)&forMarshaling->mipLevels, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->arrayLayers, sizeof(uint32_t));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->write((VkSharingMode*)&forMarshaling->sharingMode, sizeof(VkSharingMode));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pQueueFamilyIndices;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pQueueFamilyIndices)
    {
        vkStream->write((const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
    vkStream->write((VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
}

void unmarshal_VkImageCreateInfo(
    VulkanStream* vkStream,
    VkImageCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageCreateFlags*)&forUnmarshaling->flags, sizeof(VkImageCreateFlags));
    vkStream->read((VkImageType*)&forUnmarshaling->imageType, sizeof(VkImageType));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent));
    vkStream->read((uint32_t*)&forUnmarshaling->mipLevels, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->arrayLayers, sizeof(uint32_t));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkImageTiling*)&forUnmarshaling->tiling, sizeof(VkImageTiling));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->read((VkSharingMode*)&forUnmarshaling->sharingMode, sizeof(VkSharingMode));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pQueueFamilyIndices = (const uint32_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        vkStream->read((uint32_t*)forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
    vkStream->read((VkImageLayout*)&forUnmarshaling->initialLayout, sizeof(VkImageLayout));
}

void marshal_VkSubresourceLayout(
    VulkanStream* vkStream,
    const VkSubresourceLayout* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->rowPitch, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->arrayPitch, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->depthPitch, sizeof(VkDeviceSize));
}

void unmarshal_VkSubresourceLayout(
    VulkanStream* vkStream,
    VkSubresourceLayout* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->rowPitch, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->arrayPitch, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->depthPitch, sizeof(VkDeviceSize));
}

void marshal_VkComponentMapping(
    VulkanStream* vkStream,
    const VkComponentMapping* forMarshaling)
{
    vkStream->write((VkComponentSwizzle*)&forMarshaling->r, sizeof(VkComponentSwizzle));
    vkStream->write((VkComponentSwizzle*)&forMarshaling->g, sizeof(VkComponentSwizzle));
    vkStream->write((VkComponentSwizzle*)&forMarshaling->b, sizeof(VkComponentSwizzle));
    vkStream->write((VkComponentSwizzle*)&forMarshaling->a, sizeof(VkComponentSwizzle));
}

void unmarshal_VkComponentMapping(
    VulkanStream* vkStream,
    VkComponentMapping* forUnmarshaling)
{
    vkStream->read((VkComponentSwizzle*)&forUnmarshaling->r, sizeof(VkComponentSwizzle));
    vkStream->read((VkComponentSwizzle*)&forUnmarshaling->g, sizeof(VkComponentSwizzle));
    vkStream->read((VkComponentSwizzle*)&forUnmarshaling->b, sizeof(VkComponentSwizzle));
    vkStream->read((VkComponentSwizzle*)&forUnmarshaling->a, sizeof(VkComponentSwizzle));
}

void marshal_VkImageViewCreateInfo(
    VulkanStream* vkStream,
    const VkImageViewCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkImageViewCreateFlags*)&forMarshaling->flags, sizeof(VkImageViewCreateFlags));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkImageViewType*)&forMarshaling->viewType, sizeof(VkImageViewType));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    marshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forMarshaling->components));
    marshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forMarshaling->subresourceRange));
}

void unmarshal_VkImageViewCreateInfo(
    VulkanStream* vkStream,
    VkImageViewCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageViewCreateFlags*)&forUnmarshaling->flags, sizeof(VkImageViewCreateFlags));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_0, (VkImage*)&forUnmarshaling->image, 1);
    vkStream->read((VkImageViewType*)&forUnmarshaling->viewType, sizeof(VkImageViewType));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    unmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forUnmarshaling->components));
    unmarshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forUnmarshaling->subresourceRange));
}

void marshal_VkShaderModuleCreateInfo(
    VulkanStream* vkStream,
    const VkShaderModuleCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkShaderModuleCreateFlags*)&forMarshaling->flags, sizeof(VkShaderModuleCreateFlags));
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->codeSize;
    vkStream->putBe64(cgen_var_0);
    vkStream->write((const uint32_t*)forMarshaling->pCode, (forMarshaling->codeSize / 4) * sizeof(const uint32_t));
}

void unmarshal_VkShaderModuleCreateInfo(
    VulkanStream* vkStream,
    VkShaderModuleCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkShaderModuleCreateFlags*)&forUnmarshaling->flags, sizeof(VkShaderModuleCreateFlags));
    forUnmarshaling->codeSize = (size_t)vkStream->getBe64();
    vkStream->alloc((void**)&forUnmarshaling->pCode, (forUnmarshaling->codeSize / 4) * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pCode, (forUnmarshaling->codeSize / 4) * sizeof(const uint32_t));
}

void marshal_VkPipelineCacheCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineCacheCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineCacheCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCacheCreateFlags));
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->initialDataSize;
    vkStream->putBe64(cgen_var_0);
    vkStream->write((const void*)forMarshaling->pInitialData, forMarshaling->initialDataSize * sizeof(const uint8_t));
}

void unmarshal_VkPipelineCacheCreateInfo(
    VulkanStream* vkStream,
    VkPipelineCacheCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineCacheCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineCacheCreateFlags));
    forUnmarshaling->initialDataSize = (size_t)vkStream->getBe64();
    vkStream->alloc((void**)&forUnmarshaling->pInitialData, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
    vkStream->read((void*)forUnmarshaling->pInitialData, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
}

void marshal_VkSpecializationMapEntry(
    VulkanStream* vkStream,
    const VkSpecializationMapEntry* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->constantID, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->size;
    vkStream->putBe64(cgen_var_0);
}

void unmarshal_VkSpecializationMapEntry(
    VulkanStream* vkStream,
    VkSpecializationMapEntry* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->constantID, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->offset, sizeof(uint32_t));
    forUnmarshaling->size = (size_t)vkStream->getBe64();
}

void marshal_VkSpecializationInfo(
    VulkanStream* vkStream,
    const VkSpecializationInfo* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->mapEntryCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->mapEntryCount; ++i)
    {
        marshal_VkSpecializationMapEntry(vkStream, (const VkSpecializationMapEntry*)(forMarshaling->pMapEntries + i));
    }
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->dataSize;
    vkStream->putBe64(cgen_var_0);
    vkStream->write((const void*)forMarshaling->pData, forMarshaling->dataSize * sizeof(const uint8_t));
}

void unmarshal_VkSpecializationInfo(
    VulkanStream* vkStream,
    VkSpecializationInfo* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->mapEntryCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pMapEntries, forUnmarshaling->mapEntryCount * sizeof(const VkSpecializationMapEntry));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->mapEntryCount; ++i)
    {
        unmarshal_VkSpecializationMapEntry(vkStream, (VkSpecializationMapEntry*)(forUnmarshaling->pMapEntries + i));
    }
    forUnmarshaling->dataSize = (size_t)vkStream->getBe64();
    vkStream->alloc((void**)&forUnmarshaling->pData, forUnmarshaling->dataSize * sizeof(const uint8_t));
    vkStream->read((void*)forUnmarshaling->pData, forUnmarshaling->dataSize * sizeof(const uint8_t));
}

void marshal_VkPipelineShaderStageCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineShaderStageCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineShaderStageCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineShaderStageCreateFlags));
    vkStream->write((VkShaderStageFlagBits*)&forMarshaling->stage, sizeof(VkShaderStageFlagBits));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkShaderModule_u64(&forMarshaling->module, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->putString(forMarshaling->pName);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pSpecializationInfo;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pSpecializationInfo)
    {
        marshal_VkSpecializationInfo(vkStream, (const VkSpecializationInfo*)(forMarshaling->pSpecializationInfo));
    }
}

void unmarshal_VkPipelineShaderStageCreateInfo(
    VulkanStream* vkStream,
    VkPipelineShaderStageCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineShaderStageCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineShaderStageCreateFlags));
    vkStream->read((VkShaderStageFlagBits*)&forUnmarshaling->stage, sizeof(VkShaderStageFlagBits));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkShaderModule(&cgen_var_0, (VkShaderModule*)&forUnmarshaling->module, 1);
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pName);
    // WARNING PTR CHECK
    forUnmarshaling->pSpecializationInfo = (const VkSpecializationInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pSpecializationInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pSpecializationInfo, sizeof(const VkSpecializationInfo));
        unmarshal_VkSpecializationInfo(vkStream, (VkSpecializationInfo*)(forUnmarshaling->pSpecializationInfo));
    }
}

void marshal_VkComputePipelineCreateInfo(
    VulkanStream* vkStream,
    const VkComputePipelineCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCreateFlags));
    marshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(&forMarshaling->stage));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&forMarshaling->layout, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkPipeline_u64(&forMarshaling->basePipelineHandle, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((int32_t*)&forMarshaling->basePipelineIndex, sizeof(int32_t));
}

void unmarshal_VkComputePipelineCreateInfo(
    VulkanStream* vkStream,
    VkComputePipelineCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineCreateFlags));
    unmarshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(&forUnmarshaling->stage));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_0, (VkPipelineLayout*)&forUnmarshaling->layout, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_1, (VkPipeline*)&forUnmarshaling->basePipelineHandle, 1);
    vkStream->read((int32_t*)&forUnmarshaling->basePipelineIndex, sizeof(int32_t));
}

void marshal_VkVertexInputBindingDescription(
    VulkanStream* vkStream,
    const VkVertexInputBindingDescription* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->stride, sizeof(uint32_t));
    vkStream->write((VkVertexInputRate*)&forMarshaling->inputRate, sizeof(VkVertexInputRate));
}

void unmarshal_VkVertexInputBindingDescription(
    VulkanStream* vkStream,
    VkVertexInputBindingDescription* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->binding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->stride, sizeof(uint32_t));
    vkStream->read((VkVertexInputRate*)&forUnmarshaling->inputRate, sizeof(VkVertexInputRate));
}

void marshal_VkVertexInputAttributeDescription(
    VulkanStream* vkStream,
    const VkVertexInputAttributeDescription* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->location, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
}

void unmarshal_VkVertexInputAttributeDescription(
    VulkanStream* vkStream,
    VkVertexInputAttributeDescription* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->location, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->binding, sizeof(uint32_t));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((uint32_t*)&forUnmarshaling->offset, sizeof(uint32_t));
}

void marshal_VkPipelineVertexInputStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineVertexInputStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineVertexInputStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineVertexInputStateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->vertexBindingDescriptionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexBindingDescriptionCount; ++i)
    {
        marshal_VkVertexInputBindingDescription(vkStream, (const VkVertexInputBindingDescription*)(forMarshaling->pVertexBindingDescriptions + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->vertexAttributeDescriptionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexAttributeDescriptionCount; ++i)
    {
        marshal_VkVertexInputAttributeDescription(vkStream, (const VkVertexInputAttributeDescription*)(forMarshaling->pVertexAttributeDescriptions + i));
    }
}

void unmarshal_VkPipelineVertexInputStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineVertexInputStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineVertexInputStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineVertexInputStateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->vertexBindingDescriptionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pVertexBindingDescriptions, forUnmarshaling->vertexBindingDescriptionCount * sizeof(const VkVertexInputBindingDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexBindingDescriptionCount; ++i)
    {
        unmarshal_VkVertexInputBindingDescription(vkStream, (VkVertexInputBindingDescription*)(forUnmarshaling->pVertexBindingDescriptions + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->vertexAttributeDescriptionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pVertexAttributeDescriptions, forUnmarshaling->vertexAttributeDescriptionCount * sizeof(const VkVertexInputAttributeDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexAttributeDescriptionCount; ++i)
    {
        unmarshal_VkVertexInputAttributeDescription(vkStream, (VkVertexInputAttributeDescription*)(forUnmarshaling->pVertexAttributeDescriptions + i));
    }
}

void marshal_VkPipelineInputAssemblyStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineInputAssemblyStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineInputAssemblyStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineInputAssemblyStateCreateFlags));
    vkStream->write((VkPrimitiveTopology*)&forMarshaling->topology, sizeof(VkPrimitiveTopology));
    vkStream->write((VkBool32*)&forMarshaling->primitiveRestartEnable, sizeof(VkBool32));
}

void unmarshal_VkPipelineInputAssemblyStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineInputAssemblyStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineInputAssemblyStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineInputAssemblyStateCreateFlags));
    vkStream->read((VkPrimitiveTopology*)&forUnmarshaling->topology, sizeof(VkPrimitiveTopology));
    vkStream->read((VkBool32*)&forUnmarshaling->primitiveRestartEnable, sizeof(VkBool32));
}

void marshal_VkPipelineTessellationStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineTessellationStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineTessellationStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineTessellationStateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->patchControlPoints, sizeof(uint32_t));
}

void unmarshal_VkPipelineTessellationStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineTessellationStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineTessellationStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineTessellationStateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->patchControlPoints, sizeof(uint32_t));
}

void marshal_VkViewport(
    VulkanStream* vkStream,
    const VkViewport* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->x, sizeof(float));
    vkStream->write((float*)&forMarshaling->y, sizeof(float));
    vkStream->write((float*)&forMarshaling->width, sizeof(float));
    vkStream->write((float*)&forMarshaling->height, sizeof(float));
    vkStream->write((float*)&forMarshaling->minDepth, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxDepth, sizeof(float));
}

void unmarshal_VkViewport(
    VulkanStream* vkStream,
    VkViewport* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->x, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->y, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->width, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->height, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->minDepth, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxDepth, sizeof(float));
}

void marshal_VkPipelineViewportStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineViewportStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineViewportStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineViewportStateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pViewports;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pViewports)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            marshal_VkViewport(vkStream, (const VkViewport*)(forMarshaling->pViewports + i));
        }
    }
    vkStream->write((uint32_t*)&forMarshaling->scissorCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pScissors;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->scissorCount; ++i)
        {
            marshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pScissors + i));
        }
    }
}

void unmarshal_VkPipelineViewportStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineViewportStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineViewportStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineViewportStateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->viewportCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pViewports = (const VkViewport*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pViewports)
    {
        vkStream->alloc((void**)&forUnmarshaling->pViewports, forUnmarshaling->viewportCount * sizeof(const VkViewport));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            unmarshal_VkViewport(vkStream, (VkViewport*)(forUnmarshaling->pViewports + i));
        }
    }
    vkStream->read((uint32_t*)&forUnmarshaling->scissorCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pScissors = (const VkRect2D*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pScissors)
    {
        vkStream->alloc((void**)&forUnmarshaling->pScissors, forUnmarshaling->scissorCount * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->scissorCount; ++i)
        {
            unmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pScissors + i));
        }
    }
}

void marshal_VkPipelineRasterizationStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineRasterizationStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineRasterizationStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineRasterizationStateCreateFlags));
    vkStream->write((VkBool32*)&forMarshaling->depthClampEnable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->rasterizerDiscardEnable, sizeof(VkBool32));
    vkStream->write((VkPolygonMode*)&forMarshaling->polygonMode, sizeof(VkPolygonMode));
    vkStream->write((VkCullModeFlags*)&forMarshaling->cullMode, sizeof(VkCullModeFlags));
    vkStream->write((VkFrontFace*)&forMarshaling->frontFace, sizeof(VkFrontFace));
    vkStream->write((VkBool32*)&forMarshaling->depthBiasEnable, sizeof(VkBool32));
    vkStream->write((float*)&forMarshaling->depthBiasConstantFactor, sizeof(float));
    vkStream->write((float*)&forMarshaling->depthBiasClamp, sizeof(float));
    vkStream->write((float*)&forMarshaling->depthBiasSlopeFactor, sizeof(float));
    vkStream->write((float*)&forMarshaling->lineWidth, sizeof(float));
}

void unmarshal_VkPipelineRasterizationStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineRasterizationStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineRasterizationStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineRasterizationStateCreateFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->depthClampEnable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->rasterizerDiscardEnable, sizeof(VkBool32));
    vkStream->read((VkPolygonMode*)&forUnmarshaling->polygonMode, sizeof(VkPolygonMode));
    vkStream->read((VkCullModeFlags*)&forUnmarshaling->cullMode, sizeof(VkCullModeFlags));
    vkStream->read((VkFrontFace*)&forUnmarshaling->frontFace, sizeof(VkFrontFace));
    vkStream->read((VkBool32*)&forUnmarshaling->depthBiasEnable, sizeof(VkBool32));
    vkStream->read((float*)&forUnmarshaling->depthBiasConstantFactor, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->depthBiasClamp, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->depthBiasSlopeFactor, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->lineWidth, sizeof(float));
}

void marshal_VkPipelineMultisampleStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineMultisampleStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineMultisampleStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineMultisampleStateCreateFlags));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->rasterizationSamples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkBool32*)&forMarshaling->sampleShadingEnable, sizeof(VkBool32));
    vkStream->write((float*)&forMarshaling->minSampleShading, sizeof(float));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pSampleMask;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pSampleMask)
    {
        vkStream->write((const VkSampleMask*)forMarshaling->pSampleMask, (((forMarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
    }
    vkStream->write((VkBool32*)&forMarshaling->alphaToCoverageEnable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->alphaToOneEnable, sizeof(VkBool32));
}

void unmarshal_VkPipelineMultisampleStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineMultisampleStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineMultisampleStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineMultisampleStateCreateFlags));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->rasterizationSamples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkBool32*)&forUnmarshaling->sampleShadingEnable, sizeof(VkBool32));
    vkStream->read((float*)&forUnmarshaling->minSampleShading, sizeof(float));
    // WARNING PTR CHECK
    forUnmarshaling->pSampleMask = (const VkSampleMask*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pSampleMask)
    {
        vkStream->alloc((void**)&forUnmarshaling->pSampleMask, (((forUnmarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
        vkStream->read((VkSampleMask*)forUnmarshaling->pSampleMask, (((forUnmarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->alphaToCoverageEnable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->alphaToOneEnable, sizeof(VkBool32));
}

void marshal_VkStencilOpState(
    VulkanStream* vkStream,
    const VkStencilOpState* forMarshaling)
{
    vkStream->write((VkStencilOp*)&forMarshaling->failOp, sizeof(VkStencilOp));
    vkStream->write((VkStencilOp*)&forMarshaling->passOp, sizeof(VkStencilOp));
    vkStream->write((VkStencilOp*)&forMarshaling->depthFailOp, sizeof(VkStencilOp));
    vkStream->write((VkCompareOp*)&forMarshaling->compareOp, sizeof(VkCompareOp));
    vkStream->write((uint32_t*)&forMarshaling->compareMask, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->writeMask, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->reference, sizeof(uint32_t));
}

void unmarshal_VkStencilOpState(
    VulkanStream* vkStream,
    VkStencilOpState* forUnmarshaling)
{
    vkStream->read((VkStencilOp*)&forUnmarshaling->failOp, sizeof(VkStencilOp));
    vkStream->read((VkStencilOp*)&forUnmarshaling->passOp, sizeof(VkStencilOp));
    vkStream->read((VkStencilOp*)&forUnmarshaling->depthFailOp, sizeof(VkStencilOp));
    vkStream->read((VkCompareOp*)&forUnmarshaling->compareOp, sizeof(VkCompareOp));
    vkStream->read((uint32_t*)&forUnmarshaling->compareMask, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->writeMask, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->reference, sizeof(uint32_t));
}

void marshal_VkPipelineDepthStencilStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineDepthStencilStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineDepthStencilStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineDepthStencilStateCreateFlags));
    vkStream->write((VkBool32*)&forMarshaling->depthTestEnable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->depthWriteEnable, sizeof(VkBool32));
    vkStream->write((VkCompareOp*)&forMarshaling->depthCompareOp, sizeof(VkCompareOp));
    vkStream->write((VkBool32*)&forMarshaling->depthBoundsTestEnable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->stencilTestEnable, sizeof(VkBool32));
    marshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forMarshaling->front));
    marshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forMarshaling->back));
    vkStream->write((float*)&forMarshaling->minDepthBounds, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxDepthBounds, sizeof(float));
}

void unmarshal_VkPipelineDepthStencilStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineDepthStencilStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineDepthStencilStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineDepthStencilStateCreateFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->depthTestEnable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->depthWriteEnable, sizeof(VkBool32));
    vkStream->read((VkCompareOp*)&forUnmarshaling->depthCompareOp, sizeof(VkCompareOp));
    vkStream->read((VkBool32*)&forUnmarshaling->depthBoundsTestEnable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->stencilTestEnable, sizeof(VkBool32));
    unmarshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forUnmarshaling->front));
    unmarshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forUnmarshaling->back));
    vkStream->read((float*)&forUnmarshaling->minDepthBounds, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxDepthBounds, sizeof(float));
}

void marshal_VkPipelineColorBlendAttachmentState(
    VulkanStream* vkStream,
    const VkPipelineColorBlendAttachmentState* forMarshaling)
{
    vkStream->write((VkBool32*)&forMarshaling->blendEnable, sizeof(VkBool32));
    vkStream->write((VkBlendFactor*)&forMarshaling->srcColorBlendFactor, sizeof(VkBlendFactor));
    vkStream->write((VkBlendFactor*)&forMarshaling->dstColorBlendFactor, sizeof(VkBlendFactor));
    vkStream->write((VkBlendOp*)&forMarshaling->colorBlendOp, sizeof(VkBlendOp));
    vkStream->write((VkBlendFactor*)&forMarshaling->srcAlphaBlendFactor, sizeof(VkBlendFactor));
    vkStream->write((VkBlendFactor*)&forMarshaling->dstAlphaBlendFactor, sizeof(VkBlendFactor));
    vkStream->write((VkBlendOp*)&forMarshaling->alphaBlendOp, sizeof(VkBlendOp));
    vkStream->write((VkColorComponentFlags*)&forMarshaling->colorWriteMask, sizeof(VkColorComponentFlags));
}

void unmarshal_VkPipelineColorBlendAttachmentState(
    VulkanStream* vkStream,
    VkPipelineColorBlendAttachmentState* forUnmarshaling)
{
    vkStream->read((VkBool32*)&forUnmarshaling->blendEnable, sizeof(VkBool32));
    vkStream->read((VkBlendFactor*)&forUnmarshaling->srcColorBlendFactor, sizeof(VkBlendFactor));
    vkStream->read((VkBlendFactor*)&forUnmarshaling->dstColorBlendFactor, sizeof(VkBlendFactor));
    vkStream->read((VkBlendOp*)&forUnmarshaling->colorBlendOp, sizeof(VkBlendOp));
    vkStream->read((VkBlendFactor*)&forUnmarshaling->srcAlphaBlendFactor, sizeof(VkBlendFactor));
    vkStream->read((VkBlendFactor*)&forUnmarshaling->dstAlphaBlendFactor, sizeof(VkBlendFactor));
    vkStream->read((VkBlendOp*)&forUnmarshaling->alphaBlendOp, sizeof(VkBlendOp));
    vkStream->read((VkColorComponentFlags*)&forUnmarshaling->colorWriteMask, sizeof(VkColorComponentFlags));
}

void marshal_VkPipelineColorBlendStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineColorBlendStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineColorBlendStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineColorBlendStateCreateFlags));
    vkStream->write((VkBool32*)&forMarshaling->logicOpEnable, sizeof(VkBool32));
    vkStream->write((VkLogicOp*)&forMarshaling->logicOp, sizeof(VkLogicOp));
    vkStream->write((uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        marshal_VkPipelineColorBlendAttachmentState(vkStream, (const VkPipelineColorBlendAttachmentState*)(forMarshaling->pAttachments + i));
    }
    vkStream->write((float*)forMarshaling->blendConstants, 4 * sizeof(float));
}

void unmarshal_VkPipelineColorBlendStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineColorBlendStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineColorBlendStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineColorBlendStateCreateFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->logicOpEnable, sizeof(VkBool32));
    vkStream->read((VkLogicOp*)&forUnmarshaling->logicOp, sizeof(VkLogicOp));
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkPipelineColorBlendAttachmentState));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        unmarshal_VkPipelineColorBlendAttachmentState(vkStream, (VkPipelineColorBlendAttachmentState*)(forUnmarshaling->pAttachments + i));
    }
    vkStream->read((float*)forUnmarshaling->blendConstants, 4 * sizeof(float));
}

void marshal_VkPipelineDynamicStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineDynamicStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineDynamicStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineDynamicStateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->dynamicStateCount, sizeof(uint32_t));
    vkStream->write((const VkDynamicState*)forMarshaling->pDynamicStates, forMarshaling->dynamicStateCount * sizeof(const VkDynamicState));
}

void unmarshal_VkPipelineDynamicStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineDynamicStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineDynamicStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineDynamicStateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->dynamicStateCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDynamicStates, forUnmarshaling->dynamicStateCount * sizeof(const VkDynamicState));
    vkStream->read((VkDynamicState*)forUnmarshaling->pDynamicStates, forUnmarshaling->dynamicStateCount * sizeof(const VkDynamicState));
}

void marshal_VkGraphicsPipelineCreateInfo(
    VulkanStream* vkStream,
    const VkGraphicsPipelineCreateInfo* forMarshaling)
{
    uint32_t hasRasterization = 1;
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        hasRasterization = (((0 == forMarshaling->pRasterizationState)) ? (0) : (!((*(forMarshaling->pRasterizationState)).rasterizerDiscardEnable)));
        uint32_t cgen_var_0 = (uint32_t)hasRasterization;
        vkStream->putBe32(cgen_var_0);
    }
    uint32_t hasTessellation = 1;
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        hasTessellation = arrayany(forMarshaling->pStages, 0, forMarshaling->stageCount, [](VkPipelineShaderStageCreateInfo s) { return ((s.stage == VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT) || (s.stage == VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT)); });
        uint32_t cgen_var_0 = (uint32_t)hasTessellation;
        vkStream->putBe32(cgen_var_0);
    }
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->stageCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->stageCount; ++i)
    {
        marshal_VkPipelineShaderStageCreateInfo(vkStream, (const VkPipelineShaderStageCreateInfo*)(forMarshaling->pStages + i));
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pVertexInputState;
        vkStream->putBe64(cgen_var_0);
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forMarshaling->pVertexInputState))
    {
        marshal_VkPipelineVertexInputStateCreateInfo(vkStream, (const VkPipelineVertexInputStateCreateInfo*)(forMarshaling->pVertexInputState));
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pInputAssemblyState;
        vkStream->putBe64(cgen_var_0);
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forMarshaling->pInputAssemblyState))
    {
        marshal_VkPipelineInputAssemblyStateCreateInfo(vkStream, (const VkPipelineInputAssemblyStateCreateInfo*)(forMarshaling->pInputAssemblyState));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pTessellationState;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pTessellationState)
    {
        if (hasTessellation)
        {
            marshal_VkPipelineTessellationStateCreateInfo(vkStream, (const VkPipelineTessellationStateCreateInfo*)(forMarshaling->pTessellationState));
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pViewportState;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pViewportState)
    {
        if (hasRasterization)
        {
            marshal_VkPipelineViewportStateCreateInfo(vkStream, (const VkPipelineViewportStateCreateInfo*)(forMarshaling->pViewportState));
        }
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        uint64_t cgen_var_1_0 = (uint64_t)(uintptr_t)forMarshaling->pRasterizationState;
        vkStream->putBe64(cgen_var_1_0);
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forMarshaling->pRasterizationState))
    {
        marshal_VkPipelineRasterizationStateCreateInfo(vkStream, (const VkPipelineRasterizationStateCreateInfo*)(forMarshaling->pRasterizationState));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pMultisampleState;
    vkStream->putBe64(cgen_var_2);
    if (forMarshaling->pMultisampleState)
    {
        if (hasRasterization)
        {
            marshal_VkPipelineMultisampleStateCreateInfo(vkStream, (const VkPipelineMultisampleStateCreateInfo*)(forMarshaling->pMultisampleState));
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)forMarshaling->pDepthStencilState;
    vkStream->putBe64(cgen_var_3);
    if (forMarshaling->pDepthStencilState)
    {
        if (hasRasterization)
        {
            marshal_VkPipelineDepthStencilStateCreateInfo(vkStream, (const VkPipelineDepthStencilStateCreateInfo*)(forMarshaling->pDepthStencilState));
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_4 = (uint64_t)(uintptr_t)forMarshaling->pColorBlendState;
    vkStream->putBe64(cgen_var_4);
    if (forMarshaling->pColorBlendState)
    {
        if (hasRasterization)
        {
            marshal_VkPipelineColorBlendStateCreateInfo(vkStream, (const VkPipelineColorBlendStateCreateInfo*)(forMarshaling->pColorBlendState));
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_5 = (uint64_t)(uintptr_t)forMarshaling->pDynamicState;
    vkStream->putBe64(cgen_var_5);
    if (forMarshaling->pDynamicState)
    {
        marshal_VkPipelineDynamicStateCreateInfo(vkStream, (const VkPipelineDynamicStateCreateInfo*)(forMarshaling->pDynamicState));
    }
    uint64_t cgen_var_6;
    vkStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&forMarshaling->layout, &cgen_var_6, 1);
    vkStream->write((uint64_t*)&cgen_var_6, 1 * 8);
    uint64_t cgen_var_7;
    vkStream->handleMapping()->mapHandles_VkRenderPass_u64(&forMarshaling->renderPass, &cgen_var_7, 1);
    vkStream->write((uint64_t*)&cgen_var_7, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    uint64_t cgen_var_8;
    vkStream->handleMapping()->mapHandles_VkPipeline_u64(&forMarshaling->basePipelineHandle, &cgen_var_8, 1);
    vkStream->write((uint64_t*)&cgen_var_8, 1 * 8);
    vkStream->write((int32_t*)&forMarshaling->basePipelineIndex, sizeof(int32_t));
}

void unmarshal_VkGraphicsPipelineCreateInfo(
    VulkanStream* vkStream,
    VkGraphicsPipelineCreateInfo* forUnmarshaling)
{
    uint32_t hasRasterization = 1;
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        hasRasterization = (const uint32_t)vkStream->getBe32();
    }
    uint32_t hasTessellation = 1;
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        hasTessellation = (const uint32_t)vkStream->getBe32();
    }
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->stageCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pStages, forUnmarshaling->stageCount * sizeof(const VkPipelineShaderStageCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->stageCount; ++i)
    {
        unmarshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(forUnmarshaling->pStages + i));
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        forUnmarshaling->pVertexInputState = (const VkPipelineVertexInputStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forUnmarshaling->pVertexInputState))
    {
        vkStream->alloc((void**)&forUnmarshaling->pVertexInputState, sizeof(const VkPipelineVertexInputStateCreateInfo));
        unmarshal_VkPipelineVertexInputStateCreateInfo(vkStream, (VkPipelineVertexInputStateCreateInfo*)(forUnmarshaling->pVertexInputState));
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        forUnmarshaling->pInputAssemblyState = (const VkPipelineInputAssemblyStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forUnmarshaling->pInputAssemblyState))
    {
        vkStream->alloc((void**)&forUnmarshaling->pInputAssemblyState, sizeof(const VkPipelineInputAssemblyStateCreateInfo));
        unmarshal_VkPipelineInputAssemblyStateCreateInfo(vkStream, (VkPipelineInputAssemblyStateCreateInfo*)(forUnmarshaling->pInputAssemblyState));
    }
    // WARNING PTR CHECK
    forUnmarshaling->pTessellationState = (const VkPipelineTessellationStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pTessellationState)
    {
        if (hasTessellation)
        {
            vkStream->alloc((void**)&forUnmarshaling->pTessellationState, sizeof(const VkPipelineTessellationStateCreateInfo));
            unmarshal_VkPipelineTessellationStateCreateInfo(vkStream, (VkPipelineTessellationStateCreateInfo*)(forUnmarshaling->pTessellationState));
        }
        else
        {
            forUnmarshaling->pTessellationState = 0;
        }
    }
    // WARNING PTR CHECK
    forUnmarshaling->pViewportState = (const VkPipelineViewportStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pViewportState)
    {
        if (hasRasterization)
        {
            vkStream->alloc((void**)&forUnmarshaling->pViewportState, sizeof(const VkPipelineViewportStateCreateInfo));
            unmarshal_VkPipelineViewportStateCreateInfo(vkStream, (VkPipelineViewportStateCreateInfo*)(forUnmarshaling->pViewportState));
        }
        else
        {
            forUnmarshaling->pViewportState = 0;
        }
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        forUnmarshaling->pRasterizationState = (const VkPipelineRasterizationStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forUnmarshaling->pRasterizationState))
    {
        vkStream->alloc((void**)&forUnmarshaling->pRasterizationState, sizeof(const VkPipelineRasterizationStateCreateInfo));
        unmarshal_VkPipelineRasterizationStateCreateInfo(vkStream, (VkPipelineRasterizationStateCreateInfo*)(forUnmarshaling->pRasterizationState));
    }
    // WARNING PTR CHECK
    forUnmarshaling->pMultisampleState = (const VkPipelineMultisampleStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pMultisampleState)
    {
        if (hasRasterization)
        {
            vkStream->alloc((void**)&forUnmarshaling->pMultisampleState, sizeof(const VkPipelineMultisampleStateCreateInfo));
            unmarshal_VkPipelineMultisampleStateCreateInfo(vkStream, (VkPipelineMultisampleStateCreateInfo*)(forUnmarshaling->pMultisampleState));
        }
        else
        {
            forUnmarshaling->pMultisampleState = 0;
        }
    }
    // WARNING PTR CHECK
    forUnmarshaling->pDepthStencilState = (const VkPipelineDepthStencilStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pDepthStencilState)
    {
        if (hasRasterization)
        {
            vkStream->alloc((void**)&forUnmarshaling->pDepthStencilState, sizeof(const VkPipelineDepthStencilStateCreateInfo));
            unmarshal_VkPipelineDepthStencilStateCreateInfo(vkStream, (VkPipelineDepthStencilStateCreateInfo*)(forUnmarshaling->pDepthStencilState));
        }
        else
        {
            forUnmarshaling->pDepthStencilState = 0;
        }
    }
    // WARNING PTR CHECK
    forUnmarshaling->pColorBlendState = (const VkPipelineColorBlendStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pColorBlendState)
    {
        if (hasRasterization)
        {
            vkStream->alloc((void**)&forUnmarshaling->pColorBlendState, sizeof(const VkPipelineColorBlendStateCreateInfo));
            unmarshal_VkPipelineColorBlendStateCreateInfo(vkStream, (VkPipelineColorBlendStateCreateInfo*)(forUnmarshaling->pColorBlendState));
        }
        else
        {
            forUnmarshaling->pColorBlendState = 0;
        }
    }
    // WARNING PTR CHECK
    forUnmarshaling->pDynamicState = (const VkPipelineDynamicStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pDynamicState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDynamicState, sizeof(const VkPipelineDynamicStateCreateInfo));
        unmarshal_VkPipelineDynamicStateCreateInfo(vkStream, (VkPipelineDynamicStateCreateInfo*)(forUnmarshaling->pDynamicState));
    }
    uint64_t cgen_var_6;
    vkStream->read((uint64_t*)&cgen_var_6, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_6, (VkPipelineLayout*)&forUnmarshaling->layout, 1);
    uint64_t cgen_var_7;
    vkStream->read((uint64_t*)&cgen_var_7, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_7, (VkRenderPass*)&forUnmarshaling->renderPass, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->subpass, sizeof(uint32_t));
    uint64_t cgen_var_8;
    vkStream->read((uint64_t*)&cgen_var_8, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_8, (VkPipeline*)&forUnmarshaling->basePipelineHandle, 1);
    vkStream->read((int32_t*)&forUnmarshaling->basePipelineIndex, sizeof(int32_t));
}

void marshal_VkPushConstantRange(
    VulkanStream* vkStream,
    const VkPushConstantRange* forMarshaling)
{
    vkStream->write((VkShaderStageFlags*)&forMarshaling->stageFlags, sizeof(VkShaderStageFlags));
    vkStream->write((uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->size, sizeof(uint32_t));
}

void unmarshal_VkPushConstantRange(
    VulkanStream* vkStream,
    VkPushConstantRange* forUnmarshaling)
{
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->stageFlags, sizeof(VkShaderStageFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->offset, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->size, sizeof(uint32_t));
}

void marshal_VkPipelineLayoutCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineLayoutCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineLayoutCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineLayoutCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->setLayoutCount, sizeof(uint32_t));
    if (forMarshaling->setLayoutCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forMarshaling->setLayoutCount * 8);
        vkStream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(forMarshaling->pSetLayouts, cgen_var_0, forMarshaling->setLayoutCount);
        vkStream->write((uint64_t*)cgen_var_0, forMarshaling->setLayoutCount * 8);
    }
    vkStream->write((uint32_t*)&forMarshaling->pushConstantRangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->pushConstantRangeCount; ++i)
    {
        marshal_VkPushConstantRange(vkStream, (const VkPushConstantRange*)(forMarshaling->pPushConstantRanges + i));
    }
}

void unmarshal_VkPipelineLayoutCreateInfo(
    VulkanStream* vkStream,
    VkPipelineLayoutCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineLayoutCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineLayoutCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->setLayoutCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSetLayouts, forUnmarshaling->setLayoutCount * sizeof(const VkDescriptorSetLayout));
    if (forUnmarshaling->setLayoutCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forUnmarshaling->setLayoutCount * 8);
        vkStream->read((uint64_t*)cgen_var_0, forUnmarshaling->setLayoutCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(cgen_var_0, (VkDescriptorSetLayout*)forUnmarshaling->pSetLayouts, forUnmarshaling->setLayoutCount);
    }
    vkStream->read((uint32_t*)&forUnmarshaling->pushConstantRangeCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPushConstantRanges, forUnmarshaling->pushConstantRangeCount * sizeof(const VkPushConstantRange));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->pushConstantRangeCount; ++i)
    {
        unmarshal_VkPushConstantRange(vkStream, (VkPushConstantRange*)(forUnmarshaling->pPushConstantRanges + i));
    }
}

void marshal_VkSamplerCreateInfo(
    VulkanStream* vkStream,
    const VkSamplerCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSamplerCreateFlags*)&forMarshaling->flags, sizeof(VkSamplerCreateFlags));
    vkStream->write((VkFilter*)&forMarshaling->magFilter, sizeof(VkFilter));
    vkStream->write((VkFilter*)&forMarshaling->minFilter, sizeof(VkFilter));
    vkStream->write((VkSamplerMipmapMode*)&forMarshaling->mipmapMode, sizeof(VkSamplerMipmapMode));
    vkStream->write((VkSamplerAddressMode*)&forMarshaling->addressModeU, sizeof(VkSamplerAddressMode));
    vkStream->write((VkSamplerAddressMode*)&forMarshaling->addressModeV, sizeof(VkSamplerAddressMode));
    vkStream->write((VkSamplerAddressMode*)&forMarshaling->addressModeW, sizeof(VkSamplerAddressMode));
    vkStream->write((float*)&forMarshaling->mipLodBias, sizeof(float));
    vkStream->write((VkBool32*)&forMarshaling->anisotropyEnable, sizeof(VkBool32));
    vkStream->write((float*)&forMarshaling->maxAnisotropy, sizeof(float));
    vkStream->write((VkBool32*)&forMarshaling->compareEnable, sizeof(VkBool32));
    vkStream->write((VkCompareOp*)&forMarshaling->compareOp, sizeof(VkCompareOp));
    vkStream->write((float*)&forMarshaling->minLod, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxLod, sizeof(float));
    vkStream->write((VkBorderColor*)&forMarshaling->borderColor, sizeof(VkBorderColor));
    vkStream->write((VkBool32*)&forMarshaling->unnormalizedCoordinates, sizeof(VkBool32));
}

void unmarshal_VkSamplerCreateInfo(
    VulkanStream* vkStream,
    VkSamplerCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSamplerCreateFlags*)&forUnmarshaling->flags, sizeof(VkSamplerCreateFlags));
    vkStream->read((VkFilter*)&forUnmarshaling->magFilter, sizeof(VkFilter));
    vkStream->read((VkFilter*)&forUnmarshaling->minFilter, sizeof(VkFilter));
    vkStream->read((VkSamplerMipmapMode*)&forUnmarshaling->mipmapMode, sizeof(VkSamplerMipmapMode));
    vkStream->read((VkSamplerAddressMode*)&forUnmarshaling->addressModeU, sizeof(VkSamplerAddressMode));
    vkStream->read((VkSamplerAddressMode*)&forUnmarshaling->addressModeV, sizeof(VkSamplerAddressMode));
    vkStream->read((VkSamplerAddressMode*)&forUnmarshaling->addressModeW, sizeof(VkSamplerAddressMode));
    vkStream->read((float*)&forUnmarshaling->mipLodBias, sizeof(float));
    vkStream->read((VkBool32*)&forUnmarshaling->anisotropyEnable, sizeof(VkBool32));
    vkStream->read((float*)&forUnmarshaling->maxAnisotropy, sizeof(float));
    vkStream->read((VkBool32*)&forUnmarshaling->compareEnable, sizeof(VkBool32));
    vkStream->read((VkCompareOp*)&forUnmarshaling->compareOp, sizeof(VkCompareOp));
    vkStream->read((float*)&forUnmarshaling->minLod, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxLod, sizeof(float));
    vkStream->read((VkBorderColor*)&forUnmarshaling->borderColor, sizeof(VkBorderColor));
    vkStream->read((VkBool32*)&forUnmarshaling->unnormalizedCoordinates, sizeof(VkBool32));
}

void marshal_VkCopyDescriptorSet(
    VulkanStream* vkStream,
    const VkCopyDescriptorSet* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDescriptorSet_u64(&forMarshaling->srcSet, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->srcBinding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->srcArrayElement, sizeof(uint32_t));
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkDescriptorSet_u64(&forMarshaling->dstSet, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
}

void unmarshal_VkCopyDescriptorSet(
    VulkanStream* vkStream,
    VkCopyDescriptorSet* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_0, (VkDescriptorSet*)&forUnmarshaling->srcSet, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->srcBinding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->srcArrayElement, sizeof(uint32_t));
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_1, (VkDescriptorSet*)&forUnmarshaling->dstSet, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->dstBinding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
}

void marshal_VkDescriptorBufferInfo(
    VulkanStream* vkStream,
    const VkDescriptorBufferInfo* forMarshaling)
{
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->range, sizeof(VkDeviceSize));
}

void unmarshal_VkDescriptorBufferInfo(
    VulkanStream* vkStream,
    VkDescriptorBufferInfo* forUnmarshaling)
{
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_0, (VkBuffer*)&forUnmarshaling->buffer, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->range, sizeof(VkDeviceSize));
}

void marshal_VkDescriptorImageInfo(
    VulkanStream* vkStream,
    const VkDescriptorImageInfo* forMarshaling)
{
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkSampler_u64(&forMarshaling->sampler, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkImageView_u64(&forMarshaling->imageView, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((VkImageLayout*)&forMarshaling->imageLayout, sizeof(VkImageLayout));
}

void unmarshal_VkDescriptorImageInfo(
    VulkanStream* vkStream,
    VkDescriptorImageInfo* forUnmarshaling)
{
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSampler(&cgen_var_0, (VkSampler*)&forUnmarshaling->sampler, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImageView(&cgen_var_1, (VkImageView*)&forUnmarshaling->imageView, 1);
    vkStream->read((VkImageLayout*)&forUnmarshaling->imageLayout, sizeof(VkImageLayout));
}

void marshal_VkDescriptorPoolSize(
    VulkanStream* vkStream,
    const VkDescriptorPoolSize* forMarshaling)
{
    vkStream->write((VkDescriptorType*)&forMarshaling->type, sizeof(VkDescriptorType));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
}

void unmarshal_VkDescriptorPoolSize(
    VulkanStream* vkStream,
    VkDescriptorPoolSize* forUnmarshaling)
{
    vkStream->read((VkDescriptorType*)&forUnmarshaling->type, sizeof(VkDescriptorType));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
}

void marshal_VkDescriptorPoolCreateInfo(
    VulkanStream* vkStream,
    const VkDescriptorPoolCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDescriptorPoolCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorPoolCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->maxSets, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->poolSizeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->poolSizeCount; ++i)
    {
        marshal_VkDescriptorPoolSize(vkStream, (const VkDescriptorPoolSize*)(forMarshaling->pPoolSizes + i));
    }
}

void unmarshal_VkDescriptorPoolCreateInfo(
    VulkanStream* vkStream,
    VkDescriptorPoolCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDescriptorPoolCreateFlags*)&forUnmarshaling->flags, sizeof(VkDescriptorPoolCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSets, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->poolSizeCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPoolSizes, forUnmarshaling->poolSizeCount * sizeof(const VkDescriptorPoolSize));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->poolSizeCount; ++i)
    {
        unmarshal_VkDescriptorPoolSize(vkStream, (VkDescriptorPoolSize*)(forUnmarshaling->pPoolSizes + i));
    }
}

void marshal_VkDescriptorSetAllocateInfo(
    VulkanStream* vkStream,
    const VkDescriptorSetAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDescriptorPool_u64(&forMarshaling->descriptorPool, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->descriptorSetCount, sizeof(uint32_t));
    if (forMarshaling->descriptorSetCount)
    {
        uint64_t* cgen_var_1;
        vkStream->alloc((void**)&cgen_var_1, forMarshaling->descriptorSetCount * 8);
        vkStream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(forMarshaling->pSetLayouts, cgen_var_1, forMarshaling->descriptorSetCount);
        vkStream->write((uint64_t*)cgen_var_1, forMarshaling->descriptorSetCount * 8);
    }
}

void unmarshal_VkDescriptorSetAllocateInfo(
    VulkanStream* vkStream,
    VkDescriptorSetAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_0, (VkDescriptorPool*)&forUnmarshaling->descriptorPool, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorSetCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSetLayouts, forUnmarshaling->descriptorSetCount * sizeof(const VkDescriptorSetLayout));
    if (forUnmarshaling->descriptorSetCount)
    {
        uint64_t* cgen_var_1;
        vkStream->alloc((void**)&cgen_var_1, forUnmarshaling->descriptorSetCount * 8);
        vkStream->read((uint64_t*)cgen_var_1, forUnmarshaling->descriptorSetCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(cgen_var_1, (VkDescriptorSetLayout*)forUnmarshaling->pSetLayouts, forUnmarshaling->descriptorSetCount);
    }
}

void marshal_VkDescriptorSetLayoutBinding(
    VulkanStream* vkStream,
    const VkDescriptorSetLayoutBinding* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    vkStream->write((VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->write((VkShaderStageFlags*)&forMarshaling->stageFlags, sizeof(VkShaderStageFlags));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pImmutableSamplers;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pImmutableSamplers)
    {
        if (forMarshaling->descriptorCount)
        {
            uint64_t* cgen_var_0_0;
            vkStream->alloc((void**)&cgen_var_0_0, forMarshaling->descriptorCount * 8);
            vkStream->handleMapping()->mapHandles_VkSampler_u64(forMarshaling->pImmutableSamplers, cgen_var_0_0, forMarshaling->descriptorCount);
            vkStream->write((uint64_t*)cgen_var_0_0, forMarshaling->descriptorCount * 8);
        }
    }
}

void unmarshal_VkDescriptorSetLayoutBinding(
    VulkanStream* vkStream,
    VkDescriptorSetLayoutBinding* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->binding, sizeof(uint32_t));
    vkStream->read((VkDescriptorType*)&forUnmarshaling->descriptorType, sizeof(VkDescriptorType));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->stageFlags, sizeof(VkShaderStageFlags));
    // WARNING PTR CHECK
    forUnmarshaling->pImmutableSamplers = (const VkSampler*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pImmutableSamplers)
    {
        vkStream->alloc((void**)&forUnmarshaling->pImmutableSamplers, forUnmarshaling->descriptorCount * sizeof(const VkSampler));
        if (forUnmarshaling->descriptorCount)
        {
            uint64_t* cgen_var_0_0;
            vkStream->alloc((void**)&cgen_var_0_0, forUnmarshaling->descriptorCount * 8);
            vkStream->read((uint64_t*)cgen_var_0_0, forUnmarshaling->descriptorCount * 8);
            vkStream->handleMapping()->mapHandles_u64_VkSampler(cgen_var_0_0, (VkSampler*)forUnmarshaling->pImmutableSamplers, forUnmarshaling->descriptorCount);
        }
    }
}

void marshal_VkDescriptorSetLayoutCreateInfo(
    VulkanStream* vkStream,
    const VkDescriptorSetLayoutCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDescriptorSetLayoutCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorSetLayoutCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->bindingCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindingCount; ++i)
    {
        marshal_VkDescriptorSetLayoutBinding(vkStream, (const VkDescriptorSetLayoutBinding*)(forMarshaling->pBindings + i));
    }
}

void unmarshal_VkDescriptorSetLayoutCreateInfo(
    VulkanStream* vkStream,
    VkDescriptorSetLayoutCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDescriptorSetLayoutCreateFlags*)&forUnmarshaling->flags, sizeof(VkDescriptorSetLayoutCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->bindingCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pBindings, forUnmarshaling->bindingCount * sizeof(const VkDescriptorSetLayoutBinding));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindingCount; ++i)
    {
        unmarshal_VkDescriptorSetLayoutBinding(vkStream, (VkDescriptorSetLayoutBinding*)(forUnmarshaling->pBindings + i));
    }
}

void marshal_VkWriteDescriptorSet(
    VulkanStream* vkStream,
    const VkWriteDescriptorSet* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDescriptorSet_u64(&forMarshaling->dstSet, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->write((VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pImageInfo;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pImageInfo)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_SAMPLER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_IMAGE == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT == forMarshaling->descriptorType))))
        {
            for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorCount; ++i)
            {
                marshal_VkDescriptorImageInfo(vkStream, (const VkDescriptorImageInfo*)(forMarshaling->pImageInfo + i));
            }
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pBufferInfo;
    vkStream->putBe64(cgen_var_2);
    if (forMarshaling->pBufferInfo)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC == forMarshaling->descriptorType))))
        {
            for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorCount; ++i)
            {
                marshal_VkDescriptorBufferInfo(vkStream, (const VkDescriptorBufferInfo*)(forMarshaling->pBufferInfo + i));
            }
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)forMarshaling->pTexelBufferView;
    vkStream->putBe64(cgen_var_3);
    if (forMarshaling->pTexelBufferView)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER == forMarshaling->descriptorType))))
        {
            if (forMarshaling->descriptorCount)
            {
                uint64_t* cgen_var_3_0;
                vkStream->alloc((void**)&cgen_var_3_0, forMarshaling->descriptorCount * 8);
                vkStream->handleMapping()->mapHandles_VkBufferView_u64(forMarshaling->pTexelBufferView, cgen_var_3_0, forMarshaling->descriptorCount);
                vkStream->write((uint64_t*)cgen_var_3_0, forMarshaling->descriptorCount * 8);
            }
        }
    }
}

void unmarshal_VkWriteDescriptorSet(
    VulkanStream* vkStream,
    VkWriteDescriptorSet* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_0, (VkDescriptorSet*)&forUnmarshaling->dstSet, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->dstBinding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->read((VkDescriptorType*)&forUnmarshaling->descriptorType, sizeof(VkDescriptorType));
    // WARNING PTR CHECK
    forUnmarshaling->pImageInfo = (const VkDescriptorImageInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pImageInfo)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_SAMPLER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_IMAGE == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT == forUnmarshaling->descriptorType))))
        {
            vkStream->alloc((void**)&forUnmarshaling->pImageInfo, forUnmarshaling->descriptorCount * sizeof(const VkDescriptorImageInfo));
            for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorCount; ++i)
            {
                unmarshal_VkDescriptorImageInfo(vkStream, (VkDescriptorImageInfo*)(forUnmarshaling->pImageInfo + i));
            }
        }
        else
        {
            forUnmarshaling->pImageInfo = 0;
        }
    }
    // WARNING PTR CHECK
    forUnmarshaling->pBufferInfo = (const VkDescriptorBufferInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pBufferInfo)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC == forUnmarshaling->descriptorType))))
        {
            vkStream->alloc((void**)&forUnmarshaling->pBufferInfo, forUnmarshaling->descriptorCount * sizeof(const VkDescriptorBufferInfo));
            for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorCount; ++i)
            {
                unmarshal_VkDescriptorBufferInfo(vkStream, (VkDescriptorBufferInfo*)(forUnmarshaling->pBufferInfo + i));
            }
        }
        else
        {
            forUnmarshaling->pBufferInfo = 0;
        }
    }
    // WARNING PTR CHECK
    forUnmarshaling->pTexelBufferView = (const VkBufferView*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pTexelBufferView)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER == forUnmarshaling->descriptorType))))
        {
            vkStream->alloc((void**)&forUnmarshaling->pTexelBufferView, forUnmarshaling->descriptorCount * sizeof(const VkBufferView));
            if (forUnmarshaling->descriptorCount)
            {
                uint64_t* cgen_var_3_0;
                vkStream->alloc((void**)&cgen_var_3_0, forUnmarshaling->descriptorCount * 8);
                vkStream->read((uint64_t*)cgen_var_3_0, forUnmarshaling->descriptorCount * 8);
                vkStream->handleMapping()->mapHandles_u64_VkBufferView(cgen_var_3_0, (VkBufferView*)forUnmarshaling->pTexelBufferView, forUnmarshaling->descriptorCount);
            }
        }
        else
        {
            forUnmarshaling->pTexelBufferView = 0;
        }
    }
}

void marshal_VkAttachmentDescription(
    VulkanStream* vkStream,
    const VkAttachmentDescription* forMarshaling)
{
    vkStream->write((VkAttachmentDescriptionFlags*)&forMarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkAttachmentLoadOp*)&forMarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    vkStream->write((VkAttachmentStoreOp*)&forMarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    vkStream->write((VkAttachmentLoadOp*)&forMarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    vkStream->write((VkAttachmentStoreOp*)&forMarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    vkStream->write((VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
    vkStream->write((VkImageLayout*)&forMarshaling->finalLayout, sizeof(VkImageLayout));
}

void unmarshal_VkAttachmentDescription(
    VulkanStream* vkStream,
    VkAttachmentDescription* forUnmarshaling)
{
    vkStream->read((VkAttachmentDescriptionFlags*)&forUnmarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkAttachmentLoadOp*)&forUnmarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    vkStream->read((VkAttachmentStoreOp*)&forUnmarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    vkStream->read((VkAttachmentLoadOp*)&forUnmarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    vkStream->read((VkAttachmentStoreOp*)&forUnmarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    vkStream->read((VkImageLayout*)&forUnmarshaling->initialLayout, sizeof(VkImageLayout));
    vkStream->read((VkImageLayout*)&forUnmarshaling->finalLayout, sizeof(VkImageLayout));
}

void marshal_VkAttachmentReference(
    VulkanStream* vkStream,
    const VkAttachmentReference* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->attachment, sizeof(uint32_t));
    vkStream->write((VkImageLayout*)&forMarshaling->layout, sizeof(VkImageLayout));
}

void unmarshal_VkAttachmentReference(
    VulkanStream* vkStream,
    VkAttachmentReference* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->attachment, sizeof(uint32_t));
    vkStream->read((VkImageLayout*)&forUnmarshaling->layout, sizeof(VkImageLayout));
}

void marshal_VkFramebufferCreateInfo(
    VulkanStream* vkStream,
    const VkFramebufferCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkFramebufferCreateFlags*)&forMarshaling->flags, sizeof(VkFramebufferCreateFlags));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkRenderPass_u64(&forMarshaling->renderPass, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    if (forMarshaling->attachmentCount)
    {
        uint64_t* cgen_var_1;
        vkStream->alloc((void**)&cgen_var_1, forMarshaling->attachmentCount * 8);
        vkStream->handleMapping()->mapHandles_VkImageView_u64(forMarshaling->pAttachments, cgen_var_1, forMarshaling->attachmentCount);
        vkStream->write((uint64_t*)cgen_var_1, forMarshaling->attachmentCount * 8);
    }
    vkStream->write((uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->layers, sizeof(uint32_t));
}

void unmarshal_VkFramebufferCreateInfo(
    VulkanStream* vkStream,
    VkFramebufferCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFramebufferCreateFlags*)&forUnmarshaling->flags, sizeof(VkFramebufferCreateFlags));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_0, (VkRenderPass*)&forUnmarshaling->renderPass, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkImageView));
    if (forUnmarshaling->attachmentCount)
    {
        uint64_t* cgen_var_1;
        vkStream->alloc((void**)&cgen_var_1, forUnmarshaling->attachmentCount * 8);
        vkStream->read((uint64_t*)cgen_var_1, forUnmarshaling->attachmentCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkImageView(cgen_var_1, (VkImageView*)forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount);
    }
    vkStream->read((uint32_t*)&forUnmarshaling->width, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->height, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->layers, sizeof(uint32_t));
}

void marshal_VkSubpassDescription(
    VulkanStream* vkStream,
    const VkSubpassDescription* forMarshaling)
{
    vkStream->write((VkSubpassDescriptionFlags*)&forMarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    vkStream->write((VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->write((uint32_t*)&forMarshaling->inputAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->inputAttachmentCount; ++i)
    {
        marshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pInputAttachments + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->colorAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
    {
        marshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pColorAttachments + i));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pResolveAttachments;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pResolveAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
        {
            marshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pResolveAttachments + i));
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pDepthStencilAttachment;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pDepthStencilAttachment)
    {
        marshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pDepthStencilAttachment));
    }
    vkStream->write((uint32_t*)&forMarshaling->preserveAttachmentCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pPreserveAttachments, forMarshaling->preserveAttachmentCount * sizeof(const uint32_t));
}

void unmarshal_VkSubpassDescription(
    VulkanStream* vkStream,
    VkSubpassDescription* forUnmarshaling)
{
    vkStream->read((VkSubpassDescriptionFlags*)&forUnmarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    vkStream->read((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->read((uint32_t*)&forUnmarshaling->inputAttachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pInputAttachments, forUnmarshaling->inputAttachmentCount * sizeof(const VkAttachmentReference));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->inputAttachmentCount; ++i)
    {
        unmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pInputAttachments + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->colorAttachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pColorAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
    {
        unmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pColorAttachments + i));
    }
    // WARNING PTR CHECK
    forUnmarshaling->pResolveAttachments = (const VkAttachmentReference*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pResolveAttachments)
    {
        vkStream->alloc((void**)&forUnmarshaling->pResolveAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
        {
            unmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pResolveAttachments + i));
        }
    }
    // WARNING PTR CHECK
    forUnmarshaling->pDepthStencilAttachment = (const VkAttachmentReference*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pDepthStencilAttachment)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDepthStencilAttachment, sizeof(const VkAttachmentReference));
        unmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pDepthStencilAttachment));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->preserveAttachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPreserveAttachments, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pPreserveAttachments, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
}

void marshal_VkSubpassDependency(
    VulkanStream* vkStream,
    const VkSubpassDependency* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->srcSubpass, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstSubpass, sizeof(uint32_t));
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkDependencyFlags*)&forMarshaling->dependencyFlags, sizeof(VkDependencyFlags));
}

void unmarshal_VkSubpassDependency(
    VulkanStream* vkStream,
    VkSubpassDependency* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->srcSubpass, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstSubpass, sizeof(uint32_t));
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkDependencyFlags*)&forUnmarshaling->dependencyFlags, sizeof(VkDependencyFlags));
}

void marshal_VkRenderPassCreateInfo(
    VulkanStream* vkStream,
    const VkRenderPassCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkRenderPassCreateFlags*)&forMarshaling->flags, sizeof(VkRenderPassCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        marshal_VkAttachmentDescription(vkStream, (const VkAttachmentDescription*)(forMarshaling->pAttachments + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->subpassCount; ++i)
    {
        marshal_VkSubpassDescription(vkStream, (const VkSubpassDescription*)(forMarshaling->pSubpasses + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->dependencyCount; ++i)
    {
        marshal_VkSubpassDependency(vkStream, (const VkSubpassDependency*)(forMarshaling->pDependencies + i));
    }
}

void unmarshal_VkRenderPassCreateInfo(
    VulkanStream* vkStream,
    VkRenderPassCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkRenderPassCreateFlags*)&forUnmarshaling->flags, sizeof(VkRenderPassCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkAttachmentDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        unmarshal_VkAttachmentDescription(vkStream, (VkAttachmentDescription*)(forUnmarshaling->pAttachments + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->subpassCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSubpasses, forUnmarshaling->subpassCount * sizeof(const VkSubpassDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->subpassCount; ++i)
    {
        unmarshal_VkSubpassDescription(vkStream, (VkSubpassDescription*)(forUnmarshaling->pSubpasses + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->dependencyCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDependencies, forUnmarshaling->dependencyCount * sizeof(const VkSubpassDependency));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->dependencyCount; ++i)
    {
        unmarshal_VkSubpassDependency(vkStream, (VkSubpassDependency*)(forUnmarshaling->pDependencies + i));
    }
}

void marshal_VkCommandPoolCreateInfo(
    VulkanStream* vkStream,
    const VkCommandPoolCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkCommandPoolCreateFlags*)&forMarshaling->flags, sizeof(VkCommandPoolCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
}

void unmarshal_VkCommandPoolCreateInfo(
    VulkanStream* vkStream,
    VkCommandPoolCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkCommandPoolCreateFlags*)&forUnmarshaling->flags, sizeof(VkCommandPoolCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndex, sizeof(uint32_t));
}

void marshal_VkCommandBufferAllocateInfo(
    VulkanStream* vkStream,
    const VkCommandBufferAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkCommandPool_u64(&forMarshaling->commandPool, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkCommandBufferLevel*)&forMarshaling->level, sizeof(VkCommandBufferLevel));
    vkStream->write((uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
}

void unmarshal_VkCommandBufferAllocateInfo(
    VulkanStream* vkStream,
    VkCommandBufferAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_0, (VkCommandPool*)&forUnmarshaling->commandPool, 1);
    vkStream->read((VkCommandBufferLevel*)&forUnmarshaling->level, sizeof(VkCommandBufferLevel));
    vkStream->read((uint32_t*)&forUnmarshaling->commandBufferCount, sizeof(uint32_t));
}

void marshal_VkCommandBufferInheritanceInfo(
    VulkanStream* vkStream,
    const VkCommandBufferInheritanceInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkRenderPass_u64(&forMarshaling->renderPass, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkFramebuffer_u64(&forMarshaling->framebuffer, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((VkBool32*)&forMarshaling->occlusionQueryEnable, sizeof(VkBool32));
    vkStream->write((VkQueryControlFlags*)&forMarshaling->queryFlags, sizeof(VkQueryControlFlags));
    vkStream->write((VkQueryPipelineStatisticFlags*)&forMarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
}

void unmarshal_VkCommandBufferInheritanceInfo(
    VulkanStream* vkStream,
    VkCommandBufferInheritanceInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_0, (VkRenderPass*)&forUnmarshaling->renderPass, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->subpass, sizeof(uint32_t));
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkFramebuffer(&cgen_var_1, (VkFramebuffer*)&forUnmarshaling->framebuffer, 1);
    vkStream->read((VkBool32*)&forUnmarshaling->occlusionQueryEnable, sizeof(VkBool32));
    vkStream->read((VkQueryControlFlags*)&forUnmarshaling->queryFlags, sizeof(VkQueryControlFlags));
    vkStream->read((VkQueryPipelineStatisticFlags*)&forUnmarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
}

void marshal_VkCommandBufferBeginInfo(
    VulkanStream* vkStream,
    const VkCommandBufferBeginInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkCommandBufferUsageFlags*)&forMarshaling->flags, sizeof(VkCommandBufferUsageFlags));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pInheritanceInfo;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pInheritanceInfo)
    {
        marshal_VkCommandBufferInheritanceInfo(vkStream, (const VkCommandBufferInheritanceInfo*)(forMarshaling->pInheritanceInfo));
    }
}

void unmarshal_VkCommandBufferBeginInfo(
    VulkanStream* vkStream,
    VkCommandBufferBeginInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkCommandBufferUsageFlags*)&forUnmarshaling->flags, sizeof(VkCommandBufferUsageFlags));
    // WARNING PTR CHECK
    forUnmarshaling->pInheritanceInfo = (const VkCommandBufferInheritanceInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pInheritanceInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pInheritanceInfo, sizeof(const VkCommandBufferInheritanceInfo));
        unmarshal_VkCommandBufferInheritanceInfo(vkStream, (VkCommandBufferInheritanceInfo*)(forUnmarshaling->pInheritanceInfo));
    }
}

void marshal_VkBufferCopy(
    VulkanStream* vkStream,
    const VkBufferCopy* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->srcOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->dstOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
}

void unmarshal_VkBufferCopy(
    VulkanStream* vkStream,
    VkBufferCopy* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->srcOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->dstOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
}

void marshal_VkImageSubresourceLayers(
    VulkanStream* vkStream,
    const VkImageSubresourceLayers* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->write((uint32_t*)&forMarshaling->mipLevel, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
}

void unmarshal_VkImageSubresourceLayers(
    VulkanStream* vkStream,
    VkImageSubresourceLayers* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->mipLevel, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->layerCount, sizeof(uint32_t));
}

void marshal_VkBufferImageCopy(
    VulkanStream* vkStream,
    const VkBufferImageCopy* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->bufferOffset, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->bufferRowLength, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->bufferImageHeight, sizeof(uint32_t));
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->imageSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->imageOffset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->imageExtent));
}

void unmarshal_VkBufferImageCopy(
    VulkanStream* vkStream,
    VkBufferImageCopy* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->bufferOffset, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->bufferRowLength, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->bufferImageHeight, sizeof(uint32_t));
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->imageSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->imageOffset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->imageExtent));
}

void marshal_VkClearColorValue(
    VulkanStream* vkStream,
    const VkClearColorValue* forMarshaling)
{
    vkStream->write((float*)forMarshaling->float32, 4 * sizeof(float));
}

void unmarshal_VkClearColorValue(
    VulkanStream* vkStream,
    VkClearColorValue* forUnmarshaling)
{
    vkStream->read((float*)forUnmarshaling->float32, 4 * sizeof(float));
}

void marshal_VkClearDepthStencilValue(
    VulkanStream* vkStream,
    const VkClearDepthStencilValue* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->depth, sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->stencil, sizeof(uint32_t));
}

void unmarshal_VkClearDepthStencilValue(
    VulkanStream* vkStream,
    VkClearDepthStencilValue* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->depth, sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->stencil, sizeof(uint32_t));
}

void marshal_VkClearValue(
    VulkanStream* vkStream,
    const VkClearValue* forMarshaling)
{
    marshal_VkClearColorValue(vkStream, (VkClearColorValue*)(&forMarshaling->color));
}

void unmarshal_VkClearValue(
    VulkanStream* vkStream,
    VkClearValue* forUnmarshaling)
{
    unmarshal_VkClearColorValue(vkStream, (VkClearColorValue*)(&forUnmarshaling->color));
}

void marshal_VkClearAttachment(
    VulkanStream* vkStream,
    const VkClearAttachment* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->write((uint32_t*)&forMarshaling->colorAttachment, sizeof(uint32_t));
    marshal_VkClearValue(vkStream, (VkClearValue*)(&forMarshaling->clearValue));
}

void unmarshal_VkClearAttachment(
    VulkanStream* vkStream,
    VkClearAttachment* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->colorAttachment, sizeof(uint32_t));
    unmarshal_VkClearValue(vkStream, (VkClearValue*)(&forUnmarshaling->clearValue));
}

void marshal_VkClearRect(
    VulkanStream* vkStream,
    const VkClearRect* forMarshaling)
{
    marshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->rect));
    vkStream->write((uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
}

void unmarshal_VkClearRect(
    VulkanStream* vkStream,
    VkClearRect* forUnmarshaling)
{
    unmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->rect));
    vkStream->read((uint32_t*)&forUnmarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->layerCount, sizeof(uint32_t));
}

void marshal_VkImageBlit(
    VulkanStream* vkStream,
    const VkImageBlit* forMarshaling)
{
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        marshal_VkOffset3D(vkStream, (VkOffset3D*)(forMarshaling->srcOffsets + i));
    }
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        marshal_VkOffset3D(vkStream, (VkOffset3D*)(forMarshaling->dstOffsets + i));
    }
}

void unmarshal_VkImageBlit(
    VulkanStream* vkStream,
    VkImageBlit* forUnmarshaling)
{
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(forUnmarshaling->srcOffsets + i));
    }
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(forUnmarshaling->dstOffsets + i));
    }
}

void marshal_VkImageCopy(
    VulkanStream* vkStream,
    const VkImageCopy* forMarshaling)
{
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->srcOffset));
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->dstOffset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent));
}

void unmarshal_VkImageCopy(
    VulkanStream* vkStream,
    VkImageCopy* forUnmarshaling)
{
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->srcOffset));
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->dstOffset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent));
}

void marshal_VkImageResolve(
    VulkanStream* vkStream,
    const VkImageResolve* forMarshaling)
{
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->srcOffset));
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->dstOffset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent));
}

void unmarshal_VkImageResolve(
    VulkanStream* vkStream,
    VkImageResolve* forUnmarshaling)
{
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->srcOffset));
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->dstOffset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent));
}

void marshal_VkRenderPassBeginInfo(
    VulkanStream* vkStream,
    const VkRenderPassBeginInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkRenderPass_u64(&forMarshaling->renderPass, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkFramebuffer_u64(&forMarshaling->framebuffer, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    marshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->renderArea));
    vkStream->write((uint32_t*)&forMarshaling->clearValueCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pClearValues;
    vkStream->putBe64(cgen_var_2);
    if (forMarshaling->pClearValues)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->clearValueCount; ++i)
        {
            marshal_VkClearValue(vkStream, (const VkClearValue*)(forMarshaling->pClearValues + i));
        }
    }
}

void unmarshal_VkRenderPassBeginInfo(
    VulkanStream* vkStream,
    VkRenderPassBeginInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_0, (VkRenderPass*)&forUnmarshaling->renderPass, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkFramebuffer(&cgen_var_1, (VkFramebuffer*)&forUnmarshaling->framebuffer, 1);
    unmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->renderArea));
    vkStream->read((uint32_t*)&forUnmarshaling->clearValueCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pClearValues = (const VkClearValue*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pClearValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pClearValues, forUnmarshaling->clearValueCount * sizeof(const VkClearValue));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->clearValueCount; ++i)
        {
            unmarshal_VkClearValue(vkStream, (VkClearValue*)(forUnmarshaling->pClearValues + i));
        }
    }
}

#endif
#ifdef VK_VERSION_1_1
void marshal_VkPhysicalDeviceSubgroupProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSubgroupProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->subgroupSize, sizeof(uint32_t));
    vkStream->write((VkShaderStageFlags*)&forMarshaling->supportedStages, sizeof(VkShaderStageFlags));
    vkStream->write((VkSubgroupFeatureFlags*)&forMarshaling->supportedOperations, sizeof(VkSubgroupFeatureFlags));
    vkStream->write((VkBool32*)&forMarshaling->quadOperationsInAllStages, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSubgroupProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceSubgroupProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->subgroupSize, sizeof(uint32_t));
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->supportedStages, sizeof(VkShaderStageFlags));
    vkStream->read((VkSubgroupFeatureFlags*)&forUnmarshaling->supportedOperations, sizeof(VkSubgroupFeatureFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->quadOperationsInAllStages, sizeof(VkBool32));
}

void marshal_VkBindBufferMemoryInfo(
    VulkanStream* vkStream,
    const VkBindBufferMemoryInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
}

void unmarshal_VkBindBufferMemoryInfo(
    VulkanStream* vkStream,
    VkBindBufferMemoryInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_0, (VkBuffer*)&forUnmarshaling->buffer, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_1, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->memoryOffset, sizeof(VkDeviceSize));
}

void marshal_VkBindImageMemoryInfo(
    VulkanStream* vkStream,
    const VkBindImageMemoryInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
}

void unmarshal_VkBindImageMemoryInfo(
    VulkanStream* vkStream,
    VkBindImageMemoryInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_0, (VkImage*)&forUnmarshaling->image, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_1, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->memoryOffset, sizeof(VkDeviceSize));
}

void marshal_VkPhysicalDevice16BitStorageFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDevice16BitStorageFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->storageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->uniformAndStorageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->storagePushConstant16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->storageInputOutput16, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDevice16BitStorageFeatures(
    VulkanStream* vkStream,
    VkPhysicalDevice16BitStorageFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->storageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->uniformAndStorageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->storagePushConstant16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->storageInputOutput16, sizeof(VkBool32));
}

void marshal_VkMemoryDedicatedRequirements(
    VulkanStream* vkStream,
    const VkMemoryDedicatedRequirements* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->prefersDedicatedAllocation, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->requiresDedicatedAllocation, sizeof(VkBool32));
}

void unmarshal_VkMemoryDedicatedRequirements(
    VulkanStream* vkStream,
    VkMemoryDedicatedRequirements* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->prefersDedicatedAllocation, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->requiresDedicatedAllocation, sizeof(VkBool32));
}

void marshal_VkMemoryDedicatedAllocateInfo(
    VulkanStream* vkStream,
    const VkMemoryDedicatedAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
}

void unmarshal_VkMemoryDedicatedAllocateInfo(
    VulkanStream* vkStream,
    VkMemoryDedicatedAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_0, (VkImage*)&forUnmarshaling->image, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_1, (VkBuffer*)&forUnmarshaling->buffer, 1);
}

void marshal_VkMemoryAllocateFlagsInfo(
    VulkanStream* vkStream,
    const VkMemoryAllocateFlagsInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkMemoryAllocateFlags*)&forMarshaling->flags, sizeof(VkMemoryAllocateFlags));
    vkStream->write((uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
}

void unmarshal_VkMemoryAllocateFlagsInfo(
    VulkanStream* vkStream,
    VkMemoryAllocateFlagsInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkMemoryAllocateFlags*)&forUnmarshaling->flags, sizeof(VkMemoryAllocateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceMask, sizeof(uint32_t));
}

void marshal_VkDeviceGroupRenderPassBeginInfo(
    VulkanStream* vkStream,
    const VkDeviceGroupRenderPassBeginInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->deviceRenderAreaCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->deviceRenderAreaCount; ++i)
    {
        marshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pDeviceRenderAreas + i));
    }
}

void unmarshal_VkDeviceGroupRenderPassBeginInfo(
    VulkanStream* vkStream,
    VkDeviceGroupRenderPassBeginInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->deviceMask, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceRenderAreaCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDeviceRenderAreas, forUnmarshaling->deviceRenderAreaCount * sizeof(const VkRect2D));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->deviceRenderAreaCount; ++i)
    {
        unmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pDeviceRenderAreas + i));
    }
}

void marshal_VkDeviceGroupCommandBufferBeginInfo(
    VulkanStream* vkStream,
    const VkDeviceGroupCommandBufferBeginInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
}

void unmarshal_VkDeviceGroupCommandBufferBeginInfo(
    VulkanStream* vkStream,
    VkDeviceGroupCommandBufferBeginInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->deviceMask, sizeof(uint32_t));
}

void marshal_VkDeviceGroupSubmitInfo(
    VulkanStream* vkStream,
    const VkDeviceGroupSubmitInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pWaitSemaphoreDeviceIndices, forMarshaling->waitSemaphoreCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pCommandBufferDeviceMasks, forMarshaling->commandBufferCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pSignalSemaphoreDeviceIndices, forMarshaling->signalSemaphoreCount * sizeof(const uint32_t));
}

void unmarshal_VkDeviceGroupSubmitInfo(
    VulkanStream* vkStream,
    VkDeviceGroupSubmitInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphoreDeviceIndices, forUnmarshaling->waitSemaphoreCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pWaitSemaphoreDeviceIndices, forUnmarshaling->waitSemaphoreCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->commandBufferCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pCommandBufferDeviceMasks, forUnmarshaling->commandBufferCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pCommandBufferDeviceMasks, forUnmarshaling->commandBufferCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->signalSemaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphoreDeviceIndices, forUnmarshaling->signalSemaphoreCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pSignalSemaphoreDeviceIndices, forUnmarshaling->signalSemaphoreCount * sizeof(const uint32_t));
}

void marshal_VkDeviceGroupBindSparseInfo(
    VulkanStream* vkStream,
    const VkDeviceGroupBindSparseInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->resourceDeviceIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->memoryDeviceIndex, sizeof(uint32_t));
}

void unmarshal_VkDeviceGroupBindSparseInfo(
    VulkanStream* vkStream,
    VkDeviceGroupBindSparseInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->resourceDeviceIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->memoryDeviceIndex, sizeof(uint32_t));
}

void marshal_VkBindBufferMemoryDeviceGroupInfo(
    VulkanStream* vkStream,
    const VkBindBufferMemoryDeviceGroupInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->deviceIndexCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pDeviceIndices, forMarshaling->deviceIndexCount * sizeof(const uint32_t));
}

void unmarshal_VkBindBufferMemoryDeviceGroupInfo(
    VulkanStream* vkStream,
    VkBindBufferMemoryDeviceGroupInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->deviceIndexCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
}

void marshal_VkBindImageMemoryDeviceGroupInfo(
    VulkanStream* vkStream,
    const VkBindImageMemoryDeviceGroupInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->deviceIndexCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pDeviceIndices, forMarshaling->deviceIndexCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->splitInstanceBindRegionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->splitInstanceBindRegionCount; ++i)
    {
        marshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pSplitInstanceBindRegions + i));
    }
}

void unmarshal_VkBindImageMemoryDeviceGroupInfo(
    VulkanStream* vkStream,
    VkBindImageMemoryDeviceGroupInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->deviceIndexCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->splitInstanceBindRegionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSplitInstanceBindRegions, forUnmarshaling->splitInstanceBindRegionCount * sizeof(const VkRect2D));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->splitInstanceBindRegionCount; ++i)
    {
        unmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pSplitInstanceBindRegions + i));
    }
}

void marshal_VkPhysicalDeviceGroupProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceGroupProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->physicalDeviceCount, sizeof(uint32_t));
    vkStream->write((VkPhysicalDevice*)forMarshaling->physicalDevices, VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice));
    vkStream->write((VkBool32*)&forMarshaling->subsetAllocation, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceGroupProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceGroupProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->physicalDeviceCount, sizeof(uint32_t));
    vkStream->read((VkPhysicalDevice*)forUnmarshaling->physicalDevices, VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice));
    vkStream->read((VkBool32*)&forUnmarshaling->subsetAllocation, sizeof(VkBool32));
}

void marshal_VkDeviceGroupDeviceCreateInfo(
    VulkanStream* vkStream,
    const VkDeviceGroupDeviceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->physicalDeviceCount, sizeof(uint32_t));
    if (forMarshaling->physicalDeviceCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forMarshaling->physicalDeviceCount * 8);
        vkStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(forMarshaling->pPhysicalDevices, cgen_var_0, forMarshaling->physicalDeviceCount);
        vkStream->write((uint64_t*)cgen_var_0, forMarshaling->physicalDeviceCount * 8);
    }
}

void unmarshal_VkDeviceGroupDeviceCreateInfo(
    VulkanStream* vkStream,
    VkDeviceGroupDeviceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->physicalDeviceCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPhysicalDevices, forUnmarshaling->physicalDeviceCount * sizeof(const VkPhysicalDevice));
    if (forUnmarshaling->physicalDeviceCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forUnmarshaling->physicalDeviceCount * 8);
        vkStream->read((uint64_t*)cgen_var_0, forUnmarshaling->physicalDeviceCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(cgen_var_0, (VkPhysicalDevice*)forUnmarshaling->pPhysicalDevices, forUnmarshaling->physicalDeviceCount);
    }
}

void marshal_VkBufferMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    const VkBufferMemoryRequirementsInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
}

void unmarshal_VkBufferMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    VkBufferMemoryRequirementsInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_0, (VkBuffer*)&forUnmarshaling->buffer, 1);
}

void marshal_VkImageMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    const VkImageMemoryRequirementsInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
}

void unmarshal_VkImageMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    VkImageMemoryRequirementsInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_0, (VkImage*)&forUnmarshaling->image, 1);
}

void marshal_VkImageSparseMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    const VkImageSparseMemoryRequirementsInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
}

void unmarshal_VkImageSparseMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    VkImageSparseMemoryRequirementsInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_0, (VkImage*)&forUnmarshaling->image, 1);
}

void marshal_VkMemoryRequirements2(
    VulkanStream* vkStream,
    const VkMemoryRequirements2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(&forMarshaling->memoryRequirements));
}

void unmarshal_VkMemoryRequirements2(
    VulkanStream* vkStream,
    VkMemoryRequirements2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(&forUnmarshaling->memoryRequirements));
}

void marshal_VkSparseImageMemoryRequirements2(
    VulkanStream* vkStream,
    const VkSparseImageMemoryRequirements2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(&forMarshaling->memoryRequirements));
}

void unmarshal_VkSparseImageMemoryRequirements2(
    VulkanStream* vkStream,
    VkSparseImageMemoryRequirements2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(&forUnmarshaling->memoryRequirements));
}

void marshal_VkPhysicalDeviceFeatures2(
    VulkanStream* vkStream,
    const VkPhysicalDeviceFeatures2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(&forMarshaling->features));
}

void unmarshal_VkPhysicalDeviceFeatures2(
    VulkanStream* vkStream,
    VkPhysicalDeviceFeatures2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(&forUnmarshaling->features));
}

void marshal_VkPhysicalDeviceProperties2(
    VulkanStream* vkStream,
    const VkPhysicalDeviceProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(&forMarshaling->properties));
}

void unmarshal_VkPhysicalDeviceProperties2(
    VulkanStream* vkStream,
    VkPhysicalDeviceProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(&forUnmarshaling->properties));
}

void marshal_VkFormatProperties2(
    VulkanStream* vkStream,
    const VkFormatProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkFormatProperties(vkStream, (VkFormatProperties*)(&forMarshaling->formatProperties));
}

void unmarshal_VkFormatProperties2(
    VulkanStream* vkStream,
    VkFormatProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkFormatProperties(vkStream, (VkFormatProperties*)(&forUnmarshaling->formatProperties));
}

void marshal_VkImageFormatProperties2(
    VulkanStream* vkStream,
    const VkImageFormatProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forMarshaling->imageFormatProperties));
}

void unmarshal_VkImageFormatProperties2(
    VulkanStream* vkStream,
    VkImageFormatProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forUnmarshaling->imageFormatProperties));
}

void marshal_VkPhysicalDeviceImageFormatInfo2(
    VulkanStream* vkStream,
    const VkPhysicalDeviceImageFormatInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkImageType*)&forMarshaling->type, sizeof(VkImageType));
    vkStream->write((VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->write((VkImageCreateFlags*)&forMarshaling->flags, sizeof(VkImageCreateFlags));
}

void unmarshal_VkPhysicalDeviceImageFormatInfo2(
    VulkanStream* vkStream,
    VkPhysicalDeviceImageFormatInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkImageType*)&forUnmarshaling->type, sizeof(VkImageType));
    vkStream->read((VkImageTiling*)&forUnmarshaling->tiling, sizeof(VkImageTiling));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->read((VkImageCreateFlags*)&forUnmarshaling->flags, sizeof(VkImageCreateFlags));
}

void marshal_VkQueueFamilyProperties2(
    VulkanStream* vkStream,
    const VkQueueFamilyProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(&forMarshaling->queueFamilyProperties));
}

void unmarshal_VkQueueFamilyProperties2(
    VulkanStream* vkStream,
    VkQueueFamilyProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(&forUnmarshaling->queueFamilyProperties));
}

void marshal_VkPhysicalDeviceMemoryProperties2(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMemoryProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(&forMarshaling->memoryProperties));
}

void unmarshal_VkPhysicalDeviceMemoryProperties2(
    VulkanStream* vkStream,
    VkPhysicalDeviceMemoryProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(&forUnmarshaling->memoryProperties));
}

void marshal_VkSparseImageFormatProperties2(
    VulkanStream* vkStream,
    const VkSparseImageFormatProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forMarshaling->properties));
}

void unmarshal_VkSparseImageFormatProperties2(
    VulkanStream* vkStream,
    VkSparseImageFormatProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forUnmarshaling->properties));
}

void marshal_VkPhysicalDeviceSparseImageFormatInfo2(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSparseImageFormatInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkImageType*)&forMarshaling->type, sizeof(VkImageType));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->write((VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
}

void unmarshal_VkPhysicalDeviceSparseImageFormatInfo2(
    VulkanStream* vkStream,
    VkPhysicalDeviceSparseImageFormatInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkImageType*)&forUnmarshaling->type, sizeof(VkImageType));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->read((VkImageTiling*)&forUnmarshaling->tiling, sizeof(VkImageTiling));
}

void marshal_VkPhysicalDevicePointClippingProperties(
    VulkanStream* vkStream,
    const VkPhysicalDevicePointClippingProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPointClippingBehavior*)&forMarshaling->pointClippingBehavior, sizeof(VkPointClippingBehavior));
}

void unmarshal_VkPhysicalDevicePointClippingProperties(
    VulkanStream* vkStream,
    VkPhysicalDevicePointClippingProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPointClippingBehavior*)&forUnmarshaling->pointClippingBehavior, sizeof(VkPointClippingBehavior));
}

void marshal_VkInputAttachmentAspectReference(
    VulkanStream* vkStream,
    const VkInputAttachmentAspectReference* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->inputAttachmentIndex, sizeof(uint32_t));
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
}

void unmarshal_VkInputAttachmentAspectReference(
    VulkanStream* vkStream,
    VkInputAttachmentAspectReference* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->subpass, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->inputAttachmentIndex, sizeof(uint32_t));
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
}

void marshal_VkRenderPassInputAttachmentAspectCreateInfo(
    VulkanStream* vkStream,
    const VkRenderPassInputAttachmentAspectCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->aspectReferenceCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->aspectReferenceCount; ++i)
    {
        marshal_VkInputAttachmentAspectReference(vkStream, (const VkInputAttachmentAspectReference*)(forMarshaling->pAspectReferences + i));
    }
}

void unmarshal_VkRenderPassInputAttachmentAspectCreateInfo(
    VulkanStream* vkStream,
    VkRenderPassInputAttachmentAspectCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->aspectReferenceCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAspectReferences, forUnmarshaling->aspectReferenceCount * sizeof(const VkInputAttachmentAspectReference));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->aspectReferenceCount; ++i)
    {
        unmarshal_VkInputAttachmentAspectReference(vkStream, (VkInputAttachmentAspectReference*)(forUnmarshaling->pAspectReferences + i));
    }
}

void marshal_VkImageViewUsageCreateInfo(
    VulkanStream* vkStream,
    const VkImageViewUsageCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
}

void unmarshal_VkImageViewUsageCreateInfo(
    VulkanStream* vkStream,
    VkImageViewUsageCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->usage, sizeof(VkImageUsageFlags));
}

void marshal_VkPipelineTessellationDomainOriginStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineTessellationDomainOriginStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkTessellationDomainOrigin*)&forMarshaling->domainOrigin, sizeof(VkTessellationDomainOrigin));
}

void unmarshal_VkPipelineTessellationDomainOriginStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineTessellationDomainOriginStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkTessellationDomainOrigin*)&forUnmarshaling->domainOrigin, sizeof(VkTessellationDomainOrigin));
}

void marshal_VkRenderPassMultiviewCreateInfo(
    VulkanStream* vkStream,
    const VkRenderPassMultiviewCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pViewMasks, forMarshaling->subpassCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    vkStream->write((const int32_t*)forMarshaling->pViewOffsets, forMarshaling->dependencyCount * sizeof(const int32_t));
    vkStream->write((uint32_t*)&forMarshaling->correlationMaskCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pCorrelationMasks, forMarshaling->correlationMaskCount * sizeof(const uint32_t));
}

void unmarshal_VkRenderPassMultiviewCreateInfo(
    VulkanStream* vkStream,
    VkRenderPassMultiviewCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->subpassCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pViewMasks, forUnmarshaling->subpassCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pViewMasks, forUnmarshaling->subpassCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dependencyCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pViewOffsets, forUnmarshaling->dependencyCount * sizeof(const int32_t));
    vkStream->read((int32_t*)forUnmarshaling->pViewOffsets, forUnmarshaling->dependencyCount * sizeof(const int32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->correlationMaskCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pCorrelationMasks, forUnmarshaling->correlationMaskCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pCorrelationMasks, forUnmarshaling->correlationMaskCount * sizeof(const uint32_t));
}

void marshal_VkPhysicalDeviceMultiviewFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMultiviewFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->multiview, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiviewGeometryShader, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiviewTessellationShader, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceMultiviewFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceMultiviewFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->multiview, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiviewGeometryShader, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiviewTessellationShader, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceMultiviewProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMultiviewProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->maxMultiviewViewCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxMultiviewInstanceIndex, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceMultiviewProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceMultiviewProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxMultiviewViewCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMultiviewInstanceIndex, sizeof(uint32_t));
}

void marshal_VkPhysicalDeviceVariablePointersFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceVariablePointersFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->variablePointersStorageBuffer, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->variablePointers, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceVariablePointersFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceVariablePointersFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->variablePointersStorageBuffer, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->variablePointers, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceProtectedMemoryFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceProtectedMemoryFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->protectedMemory, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceProtectedMemoryFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceProtectedMemoryFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->protectedMemory, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceProtectedMemoryProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceProtectedMemoryProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->protectedNoFault, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceProtectedMemoryProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceProtectedMemoryProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->protectedNoFault, sizeof(VkBool32));
}

void marshal_VkDeviceQueueInfo2(
    VulkanStream* vkStream,
    const VkDeviceQueueInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceQueueCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->queueIndex, sizeof(uint32_t));
}

void unmarshal_VkDeviceQueueInfo2(
    VulkanStream* vkStream,
    VkDeviceQueueInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceQueueCreateFlags*)&forUnmarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->queueIndex, sizeof(uint32_t));
}

void marshal_VkProtectedSubmitInfo(
    VulkanStream* vkStream,
    const VkProtectedSubmitInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->protectedSubmit, sizeof(VkBool32));
}

void unmarshal_VkProtectedSubmitInfo(
    VulkanStream* vkStream,
    VkProtectedSubmitInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->protectedSubmit, sizeof(VkBool32));
}

void marshal_VkSamplerYcbcrConversionCreateInfo(
    VulkanStream* vkStream,
    const VkSamplerYcbcrConversionCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkSamplerYcbcrModelConversion*)&forMarshaling->ycbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    vkStream->write((VkSamplerYcbcrRange*)&forMarshaling->ycbcrRange, sizeof(VkSamplerYcbcrRange));
    marshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forMarshaling->components));
    vkStream->write((VkChromaLocation*)&forMarshaling->xChromaOffset, sizeof(VkChromaLocation));
    vkStream->write((VkChromaLocation*)&forMarshaling->yChromaOffset, sizeof(VkChromaLocation));
    vkStream->write((VkFilter*)&forMarshaling->chromaFilter, sizeof(VkFilter));
    vkStream->write((VkBool32*)&forMarshaling->forceExplicitReconstruction, sizeof(VkBool32));
}

void unmarshal_VkSamplerYcbcrConversionCreateInfo(
    VulkanStream* vkStream,
    VkSamplerYcbcrConversionCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkSamplerYcbcrModelConversion*)&forUnmarshaling->ycbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    vkStream->read((VkSamplerYcbcrRange*)&forUnmarshaling->ycbcrRange, sizeof(VkSamplerYcbcrRange));
    unmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forUnmarshaling->components));
    vkStream->read((VkChromaLocation*)&forUnmarshaling->xChromaOffset, sizeof(VkChromaLocation));
    vkStream->read((VkChromaLocation*)&forUnmarshaling->yChromaOffset, sizeof(VkChromaLocation));
    vkStream->read((VkFilter*)&forUnmarshaling->chromaFilter, sizeof(VkFilter));
    vkStream->read((VkBool32*)&forUnmarshaling->forceExplicitReconstruction, sizeof(VkBool32));
}

void marshal_VkSamplerYcbcrConversionInfo(
    VulkanStream* vkStream,
    const VkSamplerYcbcrConversionInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(&forMarshaling->conversion, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
}

void unmarshal_VkSamplerYcbcrConversionInfo(
    VulkanStream* vkStream,
    VkSamplerYcbcrConversionInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_0, (VkSamplerYcbcrConversion*)&forUnmarshaling->conversion, 1);
}

void marshal_VkBindImagePlaneMemoryInfo(
    VulkanStream* vkStream,
    const VkBindImagePlaneMemoryInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkImageAspectFlagBits*)&forMarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
}

void unmarshal_VkBindImagePlaneMemoryInfo(
    VulkanStream* vkStream,
    VkBindImagePlaneMemoryInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageAspectFlagBits*)&forUnmarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
}

void marshal_VkImagePlaneMemoryRequirementsInfo(
    VulkanStream* vkStream,
    const VkImagePlaneMemoryRequirementsInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkImageAspectFlagBits*)&forMarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
}

void unmarshal_VkImagePlaneMemoryRequirementsInfo(
    VulkanStream* vkStream,
    VkImagePlaneMemoryRequirementsInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageAspectFlagBits*)&forUnmarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
}

void marshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->samplerYcbcrConversion, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceSamplerYcbcrConversionFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->samplerYcbcrConversion, sizeof(VkBool32));
}

void marshal_VkSamplerYcbcrConversionImageFormatProperties(
    VulkanStream* vkStream,
    const VkSamplerYcbcrConversionImageFormatProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->combinedImageSamplerDescriptorCount, sizeof(uint32_t));
}

void unmarshal_VkSamplerYcbcrConversionImageFormatProperties(
    VulkanStream* vkStream,
    VkSamplerYcbcrConversionImageFormatProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->combinedImageSamplerDescriptorCount, sizeof(uint32_t));
}

void marshal_VkDescriptorUpdateTemplateEntry(
    VulkanStream* vkStream,
    const VkDescriptorUpdateTemplateEntry* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->write((VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->offset;
    vkStream->putBe64(cgen_var_0);
    uint64_t cgen_var_1 = (uint64_t)forMarshaling->stride;
    vkStream->putBe64(cgen_var_1);
}

void unmarshal_VkDescriptorUpdateTemplateEntry(
    VulkanStream* vkStream,
    VkDescriptorUpdateTemplateEntry* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->dstBinding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->read((VkDescriptorType*)&forUnmarshaling->descriptorType, sizeof(VkDescriptorType));
    forUnmarshaling->offset = (size_t)vkStream->getBe64();
    forUnmarshaling->stride = (size_t)vkStream->getBe64();
}

void marshal_VkDescriptorUpdateTemplateCreateInfo(
    VulkanStream* vkStream,
    const VkDescriptorUpdateTemplateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDescriptorUpdateTemplateCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorUpdateTemplateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->descriptorUpdateEntryCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorUpdateEntryCount; ++i)
    {
        marshal_VkDescriptorUpdateTemplateEntry(vkStream, (const VkDescriptorUpdateTemplateEntry*)(forMarshaling->pDescriptorUpdateEntries + i));
    }
    vkStream->write((VkDescriptorUpdateTemplateType*)&forMarshaling->templateType, sizeof(VkDescriptorUpdateTemplateType));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(&forMarshaling->descriptorSetLayout, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&forMarshaling->pipelineLayout, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->set, sizeof(uint32_t));
}

void unmarshal_VkDescriptorUpdateTemplateCreateInfo(
    VulkanStream* vkStream,
    VkDescriptorUpdateTemplateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDescriptorUpdateTemplateCreateFlags*)&forUnmarshaling->flags, sizeof(VkDescriptorUpdateTemplateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorUpdateEntryCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDescriptorUpdateEntries, forUnmarshaling->descriptorUpdateEntryCount * sizeof(const VkDescriptorUpdateTemplateEntry));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorUpdateEntryCount; ++i)
    {
        unmarshal_VkDescriptorUpdateTemplateEntry(vkStream, (VkDescriptorUpdateTemplateEntry*)(forUnmarshaling->pDescriptorUpdateEntries + i));
    }
    vkStream->read((VkDescriptorUpdateTemplateType*)&forUnmarshaling->templateType, sizeof(VkDescriptorUpdateTemplateType));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(&cgen_var_0, (VkDescriptorSetLayout*)&forUnmarshaling->descriptorSetLayout, 1);
    vkStream->read((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_1, (VkPipelineLayout*)&forUnmarshaling->pipelineLayout, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->set, sizeof(uint32_t));
}

void marshal_VkExternalMemoryProperties(
    VulkanStream* vkStream,
    const VkExternalMemoryProperties* forMarshaling)
{
    vkStream->write((VkExternalMemoryFeatureFlags*)&forMarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlags));
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void unmarshal_VkExternalMemoryProperties(
    VulkanStream* vkStream,
    VkExternalMemoryProperties* forUnmarshaling)
{
    vkStream->read((VkExternalMemoryFeatureFlags*)&forUnmarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlags));
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void marshal_VkPhysicalDeviceExternalImageFormatInfo(
    VulkanStream* vkStream,
    const VkPhysicalDeviceExternalImageFormatInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void unmarshal_VkPhysicalDeviceExternalImageFormatInfo(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalImageFormatInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void marshal_VkExternalImageFormatProperties(
    VulkanStream* vkStream,
    const VkExternalImageFormatProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forMarshaling->externalMemoryProperties));
}

void unmarshal_VkExternalImageFormatProperties(
    VulkanStream* vkStream,
    VkExternalImageFormatProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forUnmarshaling->externalMemoryProperties));
}

void marshal_VkPhysicalDeviceExternalBufferInfo(
    VulkanStream* vkStream,
    const VkPhysicalDeviceExternalBufferInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBufferCreateFlags*)&forMarshaling->flags, sizeof(VkBufferCreateFlags));
    vkStream->write((VkBufferUsageFlags*)&forMarshaling->usage, sizeof(VkBufferUsageFlags));
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void unmarshal_VkPhysicalDeviceExternalBufferInfo(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalBufferInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBufferCreateFlags*)&forUnmarshaling->flags, sizeof(VkBufferCreateFlags));
    vkStream->read((VkBufferUsageFlags*)&forUnmarshaling->usage, sizeof(VkBufferUsageFlags));
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void marshal_VkExternalBufferProperties(
    VulkanStream* vkStream,
    const VkExternalBufferProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forMarshaling->externalMemoryProperties));
}

void unmarshal_VkExternalBufferProperties(
    VulkanStream* vkStream,
    VkExternalBufferProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forUnmarshaling->externalMemoryProperties));
}

void marshal_VkPhysicalDeviceIDProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceIDProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint8_t*)forMarshaling->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->write((uint8_t*)forMarshaling->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->write((uint8_t*)forMarshaling->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
    vkStream->write((uint32_t*)&forMarshaling->deviceNodeMask, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->deviceLUIDValid, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceIDProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceIDProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint8_t*)forUnmarshaling->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->read((uint8_t*)forUnmarshaling->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->read((uint8_t*)forUnmarshaling->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceNodeMask, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->deviceLUIDValid, sizeof(VkBool32));
}

void marshal_VkExternalMemoryImageCreateInfo(
    VulkanStream* vkStream,
    const VkExternalMemoryImageCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void unmarshal_VkExternalMemoryImageCreateInfo(
    VulkanStream* vkStream,
    VkExternalMemoryImageCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void marshal_VkExternalMemoryBufferCreateInfo(
    VulkanStream* vkStream,
    const VkExternalMemoryBufferCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void unmarshal_VkExternalMemoryBufferCreateInfo(
    VulkanStream* vkStream,
    VkExternalMemoryBufferCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void marshal_VkExportMemoryAllocateInfo(
    VulkanStream* vkStream,
    const VkExportMemoryAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void unmarshal_VkExportMemoryAllocateInfo(
    VulkanStream* vkStream,
    VkExportMemoryAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void marshal_VkPhysicalDeviceExternalFenceInfo(
    VulkanStream* vkStream,
    const VkPhysicalDeviceExternalFenceInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

void unmarshal_VkPhysicalDeviceExternalFenceInfo(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalFenceInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

void marshal_VkExternalFenceProperties(
    VulkanStream* vkStream,
    const VkExternalFenceProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalFenceHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    vkStream->write((VkExternalFenceHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    vkStream->write((VkExternalFenceFeatureFlags*)&forMarshaling->externalFenceFeatures, sizeof(VkExternalFenceFeatureFlags));
}

void unmarshal_VkExternalFenceProperties(
    VulkanStream* vkStream,
    VkExternalFenceProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    vkStream->read((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    vkStream->read((VkExternalFenceFeatureFlags*)&forUnmarshaling->externalFenceFeatures, sizeof(VkExternalFenceFeatureFlags));
}

void marshal_VkExportFenceCreateInfo(
    VulkanStream* vkStream,
    const VkExportFenceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalFenceHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalFenceHandleTypeFlags));
}

void unmarshal_VkExportFenceCreateInfo(
    VulkanStream* vkStream,
    VkExportFenceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalFenceHandleTypeFlags));
}

void marshal_VkExportSemaphoreCreateInfo(
    VulkanStream* vkStream,
    const VkExportSemaphoreCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
}

void unmarshal_VkExportSemaphoreCreateInfo(
    VulkanStream* vkStream,
    VkExportSemaphoreCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
}

void marshal_VkPhysicalDeviceExternalSemaphoreInfo(
    VulkanStream* vkStream,
    const VkPhysicalDeviceExternalSemaphoreInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

void unmarshal_VkPhysicalDeviceExternalSemaphoreInfo(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalSemaphoreInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

void marshal_VkExternalSemaphoreProperties(
    VulkanStream* vkStream,
    const VkExternalSemaphoreProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    vkStream->write((VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    vkStream->write((VkExternalSemaphoreFeatureFlags*)&forMarshaling->externalSemaphoreFeatures, sizeof(VkExternalSemaphoreFeatureFlags));
}

void unmarshal_VkExternalSemaphoreProperties(
    VulkanStream* vkStream,
    VkExternalSemaphoreProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    vkStream->read((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    vkStream->read((VkExternalSemaphoreFeatureFlags*)&forUnmarshaling->externalSemaphoreFeatures, sizeof(VkExternalSemaphoreFeatureFlags));
}

void marshal_VkPhysicalDeviceMaintenance3Properties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMaintenance3Properties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->maxPerSetDescriptors, sizeof(uint32_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->maxMemoryAllocationSize, sizeof(VkDeviceSize));
}

void unmarshal_VkPhysicalDeviceMaintenance3Properties(
    VulkanStream* vkStream,
    VkPhysicalDeviceMaintenance3Properties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerSetDescriptors, sizeof(uint32_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->maxMemoryAllocationSize, sizeof(VkDeviceSize));
}

void marshal_VkDescriptorSetLayoutSupport(
    VulkanStream* vkStream,
    const VkDescriptorSetLayoutSupport* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->supported, sizeof(VkBool32));
}

void unmarshal_VkDescriptorSetLayoutSupport(
    VulkanStream* vkStream,
    VkDescriptorSetLayoutSupport* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->supported, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceShaderDrawParametersFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderDrawParametersFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->shaderDrawParameters, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShaderDrawParametersFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderDrawParametersFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDrawParameters, sizeof(VkBool32));
}

#endif
#ifdef VK_VERSION_1_2
void marshal_VkPhysicalDeviceVulkan11Features(
    VulkanStream* vkStream,
    const VkPhysicalDeviceVulkan11Features* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->storageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->uniformAndStorageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->storagePushConstant16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->storageInputOutput16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiview, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiviewGeometryShader, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiviewTessellationShader, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->variablePointersStorageBuffer, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->variablePointers, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->protectedMemory, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->samplerYcbcrConversion, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderDrawParameters, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceVulkan11Features(
    VulkanStream* vkStream,
    VkPhysicalDeviceVulkan11Features* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->storageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->uniformAndStorageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->storagePushConstant16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->storageInputOutput16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiview, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiviewGeometryShader, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiviewTessellationShader, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->variablePointersStorageBuffer, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->variablePointers, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->protectedMemory, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->samplerYcbcrConversion, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDrawParameters, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceVulkan11Properties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceVulkan11Properties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint8_t*)forMarshaling->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->write((uint8_t*)forMarshaling->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->write((uint8_t*)forMarshaling->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
    vkStream->write((uint32_t*)&forMarshaling->deviceNodeMask, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->deviceLUIDValid, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->subgroupSize, sizeof(uint32_t));
    vkStream->write((VkShaderStageFlags*)&forMarshaling->subgroupSupportedStages, sizeof(VkShaderStageFlags));
    vkStream->write((VkSubgroupFeatureFlags*)&forMarshaling->subgroupSupportedOperations, sizeof(VkSubgroupFeatureFlags));
    vkStream->write((VkBool32*)&forMarshaling->subgroupQuadOperationsInAllStages, sizeof(VkBool32));
    vkStream->write((VkPointClippingBehavior*)&forMarshaling->pointClippingBehavior, sizeof(VkPointClippingBehavior));
    vkStream->write((uint32_t*)&forMarshaling->maxMultiviewViewCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxMultiviewInstanceIndex, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->protectedNoFault, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->maxPerSetDescriptors, sizeof(uint32_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->maxMemoryAllocationSize, sizeof(VkDeviceSize));
}

void unmarshal_VkPhysicalDeviceVulkan11Properties(
    VulkanStream* vkStream,
    VkPhysicalDeviceVulkan11Properties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint8_t*)forUnmarshaling->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->read((uint8_t*)forUnmarshaling->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->read((uint8_t*)forUnmarshaling->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceNodeMask, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->deviceLUIDValid, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->subgroupSize, sizeof(uint32_t));
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->subgroupSupportedStages, sizeof(VkShaderStageFlags));
    vkStream->read((VkSubgroupFeatureFlags*)&forUnmarshaling->subgroupSupportedOperations, sizeof(VkSubgroupFeatureFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->subgroupQuadOperationsInAllStages, sizeof(VkBool32));
    vkStream->read((VkPointClippingBehavior*)&forUnmarshaling->pointClippingBehavior, sizeof(VkPointClippingBehavior));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMultiviewViewCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMultiviewInstanceIndex, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->protectedNoFault, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerSetDescriptors, sizeof(uint32_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->maxMemoryAllocationSize, sizeof(VkDeviceSize));
}

void marshal_VkPhysicalDeviceVulkan12Features(
    VulkanStream* vkStream,
    const VkPhysicalDeviceVulkan12Features* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->samplerMirrorClampToEdge, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->drawIndirectCount, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->storageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->uniformAndStorageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->storagePushConstant8, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderBufferInt64Atomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSharedInt64Atomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderFloat16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInt8, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInputAttachmentArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSampledImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInputAttachmentArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingUniformBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingSampledImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingStorageImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingStorageBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingUniformTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingStorageTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingUpdateUnusedWhilePending, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingPartiallyBound, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingVariableDescriptorCount, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->runtimeDescriptorArray, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->samplerFilterMinmax, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->scalarBlockLayout, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->imagelessFramebuffer, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->uniformBufferStandardLayout, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSubgroupExtendedTypes, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->separateDepthStencilLayouts, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->hostQueryReset, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->timelineSemaphore, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->bufferDeviceAddress, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->bufferDeviceAddressCaptureReplay, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->bufferDeviceAddressMultiDevice, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->vulkanMemoryModel, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->vulkanMemoryModelDeviceScope, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->vulkanMemoryModelAvailabilityVisibilityChains, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderOutputViewportIndex, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderOutputLayer, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->subgroupBroadcastDynamicId, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceVulkan12Features(
    VulkanStream* vkStream,
    VkPhysicalDeviceVulkan12Features* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->samplerMirrorClampToEdge, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->drawIndirectCount, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->storageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->uniformAndStorageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->storagePushConstant8, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderBufferInt64Atomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSharedInt64Atomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderFloat16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInt8, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSampledImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingUniformBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingSampledImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingStorageImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingStorageBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingUniformTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingStorageTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingUpdateUnusedWhilePending, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingPartiallyBound, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingVariableDescriptorCount, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->runtimeDescriptorArray, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->samplerFilterMinmax, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->scalarBlockLayout, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->imagelessFramebuffer, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->uniformBufferStandardLayout, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSubgroupExtendedTypes, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->separateDepthStencilLayouts, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->hostQueryReset, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->timelineSemaphore, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->bufferDeviceAddress, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->bufferDeviceAddressCaptureReplay, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->bufferDeviceAddressMultiDevice, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->vulkanMemoryModel, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->vulkanMemoryModelDeviceScope, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->vulkanMemoryModelAvailabilityVisibilityChains, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderOutputViewportIndex, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderOutputLayer, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->subgroupBroadcastDynamicId, sizeof(VkBool32));
}

void marshal_VkConformanceVersion(
    VulkanStream* vkStream,
    const VkConformanceVersion* forMarshaling)
{
    vkStream->write((uint8_t*)&forMarshaling->major, sizeof(uint8_t));
    vkStream->write((uint8_t*)&forMarshaling->minor, sizeof(uint8_t));
    vkStream->write((uint8_t*)&forMarshaling->subminor, sizeof(uint8_t));
    vkStream->write((uint8_t*)&forMarshaling->patch, sizeof(uint8_t));
}

void unmarshal_VkConformanceVersion(
    VulkanStream* vkStream,
    VkConformanceVersion* forUnmarshaling)
{
    vkStream->read((uint8_t*)&forUnmarshaling->major, sizeof(uint8_t));
    vkStream->read((uint8_t*)&forUnmarshaling->minor, sizeof(uint8_t));
    vkStream->read((uint8_t*)&forUnmarshaling->subminor, sizeof(uint8_t));
    vkStream->read((uint8_t*)&forUnmarshaling->patch, sizeof(uint8_t));
}

void marshal_VkPhysicalDeviceVulkan12Properties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceVulkan12Properties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDriverId*)&forMarshaling->driverID, sizeof(VkDriverId));
    vkStream->write((char*)forMarshaling->driverName, VK_MAX_DRIVER_NAME_SIZE * sizeof(char));
    vkStream->write((char*)forMarshaling->driverInfo, VK_MAX_DRIVER_INFO_SIZE * sizeof(char));
    marshal_VkConformanceVersion(vkStream, (VkConformanceVersion*)(&forMarshaling->conformanceVersion));
    vkStream->write((VkShaderFloatControlsIndependence*)&forMarshaling->denormBehaviorIndependence, sizeof(VkShaderFloatControlsIndependence));
    vkStream->write((VkShaderFloatControlsIndependence*)&forMarshaling->roundingModeIndependence, sizeof(VkShaderFloatControlsIndependence));
    vkStream->write((VkBool32*)&forMarshaling->shaderSignedZeroInfNanPreserveFloat16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSignedZeroInfNanPreserveFloat32, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSignedZeroInfNanPreserveFloat64, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderDenormPreserveFloat16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderDenormPreserveFloat32, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderDenormPreserveFloat64, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderDenormFlushToZeroFloat16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderDenormFlushToZeroFloat32, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderDenormFlushToZeroFloat64, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderRoundingModeRTEFloat16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderRoundingModeRTEFloat32, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderRoundingModeRTEFloat64, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderRoundingModeRTZFloat16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderRoundingModeRTZFloat32, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderRoundingModeRTZFloat64, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->maxUpdateAfterBindDescriptorsInAllPools, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSampledImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInputAttachmentArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->robustBufferAccessUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->quadDivergentImplicitLod, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindInputAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageUpdateAfterBindResources, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindInputAttachments, sizeof(uint32_t));
    vkStream->write((VkResolveModeFlags*)&forMarshaling->supportedDepthResolveModes, sizeof(VkResolveModeFlags));
    vkStream->write((VkResolveModeFlags*)&forMarshaling->supportedStencilResolveModes, sizeof(VkResolveModeFlags));
    vkStream->write((VkBool32*)&forMarshaling->independentResolveNone, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->independentResolve, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->filterMinmaxSingleComponentFormats, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->filterMinmaxImageComponentMapping, sizeof(VkBool32));
    vkStream->write((uint64_t*)&forMarshaling->maxTimelineSemaphoreValueDifference, sizeof(uint64_t));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->framebufferIntegerColorSampleCounts, sizeof(VkSampleCountFlags));
}

void unmarshal_VkPhysicalDeviceVulkan12Properties(
    VulkanStream* vkStream,
    VkPhysicalDeviceVulkan12Properties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDriverId*)&forUnmarshaling->driverID, sizeof(VkDriverId));
    vkStream->read((char*)forUnmarshaling->driverName, VK_MAX_DRIVER_NAME_SIZE * sizeof(char));
    vkStream->read((char*)forUnmarshaling->driverInfo, VK_MAX_DRIVER_INFO_SIZE * sizeof(char));
    unmarshal_VkConformanceVersion(vkStream, (VkConformanceVersion*)(&forUnmarshaling->conformanceVersion));
    vkStream->read((VkShaderFloatControlsIndependence*)&forUnmarshaling->denormBehaviorIndependence, sizeof(VkShaderFloatControlsIndependence));
    vkStream->read((VkShaderFloatControlsIndependence*)&forUnmarshaling->roundingModeIndependence, sizeof(VkShaderFloatControlsIndependence));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSignedZeroInfNanPreserveFloat16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSignedZeroInfNanPreserveFloat32, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSignedZeroInfNanPreserveFloat64, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDenormPreserveFloat16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDenormPreserveFloat32, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDenormPreserveFloat64, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDenormFlushToZeroFloat16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDenormFlushToZeroFloat32, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDenormFlushToZeroFloat64, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderRoundingModeRTEFloat16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderRoundingModeRTEFloat32, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderRoundingModeRTEFloat64, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderRoundingModeRTZFloat16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderRoundingModeRTZFloat32, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderRoundingModeRTZFloat64, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->maxUpdateAfterBindDescriptorsInAllPools, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSampledImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->robustBufferAccessUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->quadDivergentImplicitLod, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindInputAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageUpdateAfterBindResources, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindInputAttachments, sizeof(uint32_t));
    vkStream->read((VkResolveModeFlags*)&forUnmarshaling->supportedDepthResolveModes, sizeof(VkResolveModeFlags));
    vkStream->read((VkResolveModeFlags*)&forUnmarshaling->supportedStencilResolveModes, sizeof(VkResolveModeFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->independentResolveNone, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->independentResolve, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->filterMinmaxSingleComponentFormats, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->filterMinmaxImageComponentMapping, sizeof(VkBool32));
    vkStream->read((uint64_t*)&forUnmarshaling->maxTimelineSemaphoreValueDifference, sizeof(uint64_t));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->framebufferIntegerColorSampleCounts, sizeof(VkSampleCountFlags));
}

void marshal_VkImageFormatListCreateInfo(
    VulkanStream* vkStream,
    const VkImageFormatListCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->viewFormatCount, sizeof(uint32_t));
    vkStream->write((const VkFormat*)forMarshaling->pViewFormats, forMarshaling->viewFormatCount * sizeof(const VkFormat));
}

void unmarshal_VkImageFormatListCreateInfo(
    VulkanStream* vkStream,
    VkImageFormatListCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->viewFormatCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pViewFormats, forUnmarshaling->viewFormatCount * sizeof(const VkFormat));
    vkStream->read((VkFormat*)forUnmarshaling->pViewFormats, forUnmarshaling->viewFormatCount * sizeof(const VkFormat));
}

void marshal_VkAttachmentDescription2(
    VulkanStream* vkStream,
    const VkAttachmentDescription2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkAttachmentDescriptionFlags*)&forMarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkAttachmentLoadOp*)&forMarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    vkStream->write((VkAttachmentStoreOp*)&forMarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    vkStream->write((VkAttachmentLoadOp*)&forMarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    vkStream->write((VkAttachmentStoreOp*)&forMarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    vkStream->write((VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
    vkStream->write((VkImageLayout*)&forMarshaling->finalLayout, sizeof(VkImageLayout));
}

void unmarshal_VkAttachmentDescription2(
    VulkanStream* vkStream,
    VkAttachmentDescription2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAttachmentDescriptionFlags*)&forUnmarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkAttachmentLoadOp*)&forUnmarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    vkStream->read((VkAttachmentStoreOp*)&forUnmarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    vkStream->read((VkAttachmentLoadOp*)&forUnmarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    vkStream->read((VkAttachmentStoreOp*)&forUnmarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    vkStream->read((VkImageLayout*)&forUnmarshaling->initialLayout, sizeof(VkImageLayout));
    vkStream->read((VkImageLayout*)&forUnmarshaling->finalLayout, sizeof(VkImageLayout));
}

void marshal_VkAttachmentReference2(
    VulkanStream* vkStream,
    const VkAttachmentReference2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->attachment, sizeof(uint32_t));
    vkStream->write((VkImageLayout*)&forMarshaling->layout, sizeof(VkImageLayout));
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
}

void unmarshal_VkAttachmentReference2(
    VulkanStream* vkStream,
    VkAttachmentReference2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->attachment, sizeof(uint32_t));
    vkStream->read((VkImageLayout*)&forUnmarshaling->layout, sizeof(VkImageLayout));
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
}

void marshal_VkSubpassDescription2(
    VulkanStream* vkStream,
    const VkSubpassDescription2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSubpassDescriptionFlags*)&forMarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    vkStream->write((VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->write((uint32_t*)&forMarshaling->viewMask, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->inputAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->inputAttachmentCount; ++i)
    {
        marshal_VkAttachmentReference2(vkStream, (const VkAttachmentReference2*)(forMarshaling->pInputAttachments + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->colorAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
    {
        marshal_VkAttachmentReference2(vkStream, (const VkAttachmentReference2*)(forMarshaling->pColorAttachments + i));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pResolveAttachments;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pResolveAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
        {
            marshal_VkAttachmentReference2(vkStream, (const VkAttachmentReference2*)(forMarshaling->pResolveAttachments + i));
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pDepthStencilAttachment;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pDepthStencilAttachment)
    {
        marshal_VkAttachmentReference2(vkStream, (const VkAttachmentReference2*)(forMarshaling->pDepthStencilAttachment));
    }
    vkStream->write((uint32_t*)&forMarshaling->preserveAttachmentCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pPreserveAttachments, forMarshaling->preserveAttachmentCount * sizeof(const uint32_t));
}

void unmarshal_VkSubpassDescription2(
    VulkanStream* vkStream,
    VkSubpassDescription2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSubpassDescriptionFlags*)&forUnmarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    vkStream->read((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->read((uint32_t*)&forUnmarshaling->viewMask, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->inputAttachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pInputAttachments, forUnmarshaling->inputAttachmentCount * sizeof(const VkAttachmentReference2));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->inputAttachmentCount; ++i)
    {
        unmarshal_VkAttachmentReference2(vkStream, (VkAttachmentReference2*)(forUnmarshaling->pInputAttachments + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->colorAttachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pColorAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference2));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
    {
        unmarshal_VkAttachmentReference2(vkStream, (VkAttachmentReference2*)(forUnmarshaling->pColorAttachments + i));
    }
    // WARNING PTR CHECK
    forUnmarshaling->pResolveAttachments = (const VkAttachmentReference2*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pResolveAttachments)
    {
        vkStream->alloc((void**)&forUnmarshaling->pResolveAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference2));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
        {
            unmarshal_VkAttachmentReference2(vkStream, (VkAttachmentReference2*)(forUnmarshaling->pResolveAttachments + i));
        }
    }
    // WARNING PTR CHECK
    forUnmarshaling->pDepthStencilAttachment = (const VkAttachmentReference2*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pDepthStencilAttachment)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDepthStencilAttachment, sizeof(const VkAttachmentReference2));
        unmarshal_VkAttachmentReference2(vkStream, (VkAttachmentReference2*)(forUnmarshaling->pDepthStencilAttachment));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->preserveAttachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPreserveAttachments, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pPreserveAttachments, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
}

void marshal_VkSubpassDependency2(
    VulkanStream* vkStream,
    const VkSubpassDependency2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->srcSubpass, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstSubpass, sizeof(uint32_t));
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkDependencyFlags*)&forMarshaling->dependencyFlags, sizeof(VkDependencyFlags));
    vkStream->write((int32_t*)&forMarshaling->viewOffset, sizeof(int32_t));
}

void unmarshal_VkSubpassDependency2(
    VulkanStream* vkStream,
    VkSubpassDependency2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->srcSubpass, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstSubpass, sizeof(uint32_t));
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkDependencyFlags*)&forUnmarshaling->dependencyFlags, sizeof(VkDependencyFlags));
    vkStream->read((int32_t*)&forUnmarshaling->viewOffset, sizeof(int32_t));
}

void marshal_VkRenderPassCreateInfo2(
    VulkanStream* vkStream,
    const VkRenderPassCreateInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkRenderPassCreateFlags*)&forMarshaling->flags, sizeof(VkRenderPassCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        marshal_VkAttachmentDescription2(vkStream, (const VkAttachmentDescription2*)(forMarshaling->pAttachments + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->subpassCount; ++i)
    {
        marshal_VkSubpassDescription2(vkStream, (const VkSubpassDescription2*)(forMarshaling->pSubpasses + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->dependencyCount; ++i)
    {
        marshal_VkSubpassDependency2(vkStream, (const VkSubpassDependency2*)(forMarshaling->pDependencies + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->correlatedViewMaskCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pCorrelatedViewMasks, forMarshaling->correlatedViewMaskCount * sizeof(const uint32_t));
}

void unmarshal_VkRenderPassCreateInfo2(
    VulkanStream* vkStream,
    VkRenderPassCreateInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkRenderPassCreateFlags*)&forUnmarshaling->flags, sizeof(VkRenderPassCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkAttachmentDescription2));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        unmarshal_VkAttachmentDescription2(vkStream, (VkAttachmentDescription2*)(forUnmarshaling->pAttachments + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->subpassCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSubpasses, forUnmarshaling->subpassCount * sizeof(const VkSubpassDescription2));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->subpassCount; ++i)
    {
        unmarshal_VkSubpassDescription2(vkStream, (VkSubpassDescription2*)(forUnmarshaling->pSubpasses + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->dependencyCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDependencies, forUnmarshaling->dependencyCount * sizeof(const VkSubpassDependency2));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->dependencyCount; ++i)
    {
        unmarshal_VkSubpassDependency2(vkStream, (VkSubpassDependency2*)(forUnmarshaling->pDependencies + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->correlatedViewMaskCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pCorrelatedViewMasks, forUnmarshaling->correlatedViewMaskCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pCorrelatedViewMasks, forUnmarshaling->correlatedViewMaskCount * sizeof(const uint32_t));
}

void marshal_VkSubpassBeginInfo(
    VulkanStream* vkStream,
    const VkSubpassBeginInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSubpassContents*)&forMarshaling->contents, sizeof(VkSubpassContents));
}

void unmarshal_VkSubpassBeginInfo(
    VulkanStream* vkStream,
    VkSubpassBeginInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSubpassContents*)&forUnmarshaling->contents, sizeof(VkSubpassContents));
}

void marshal_VkSubpassEndInfo(
    VulkanStream* vkStream,
    const VkSubpassEndInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
}

void unmarshal_VkSubpassEndInfo(
    VulkanStream* vkStream,
    VkSubpassEndInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
}

void marshal_VkPhysicalDevice8BitStorageFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDevice8BitStorageFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->storageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->uniformAndStorageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->storagePushConstant8, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDevice8BitStorageFeatures(
    VulkanStream* vkStream,
    VkPhysicalDevice8BitStorageFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->storageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->uniformAndStorageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->storagePushConstant8, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceDriverProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceDriverProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDriverId*)&forMarshaling->driverID, sizeof(VkDriverId));
    vkStream->write((char*)forMarshaling->driverName, VK_MAX_DRIVER_NAME_SIZE * sizeof(char));
    vkStream->write((char*)forMarshaling->driverInfo, VK_MAX_DRIVER_INFO_SIZE * sizeof(char));
    marshal_VkConformanceVersion(vkStream, (VkConformanceVersion*)(&forMarshaling->conformanceVersion));
}

void unmarshal_VkPhysicalDeviceDriverProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceDriverProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDriverId*)&forUnmarshaling->driverID, sizeof(VkDriverId));
    vkStream->read((char*)forUnmarshaling->driverName, VK_MAX_DRIVER_NAME_SIZE * sizeof(char));
    vkStream->read((char*)forUnmarshaling->driverInfo, VK_MAX_DRIVER_INFO_SIZE * sizeof(char));
    unmarshal_VkConformanceVersion(vkStream, (VkConformanceVersion*)(&forUnmarshaling->conformanceVersion));
}

void marshal_VkPhysicalDeviceShaderAtomicInt64Features(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderAtomicInt64Features* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->shaderBufferInt64Atomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSharedInt64Atomics, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShaderAtomicInt64Features(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderAtomicInt64Features* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shaderBufferInt64Atomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSharedInt64Atomics, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceShaderFloat16Int8Features(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderFloat16Int8Features* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->shaderFloat16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInt8, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShaderFloat16Int8Features(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderFloat16Int8Features* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shaderFloat16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInt8, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceFloatControlsProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceFloatControlsProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkShaderFloatControlsIndependence*)&forMarshaling->denormBehaviorIndependence, sizeof(VkShaderFloatControlsIndependence));
    vkStream->write((VkShaderFloatControlsIndependence*)&forMarshaling->roundingModeIndependence, sizeof(VkShaderFloatControlsIndependence));
    vkStream->write((VkBool32*)&forMarshaling->shaderSignedZeroInfNanPreserveFloat16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSignedZeroInfNanPreserveFloat32, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSignedZeroInfNanPreserveFloat64, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderDenormPreserveFloat16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderDenormPreserveFloat32, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderDenormPreserveFloat64, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderDenormFlushToZeroFloat16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderDenormFlushToZeroFloat32, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderDenormFlushToZeroFloat64, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderRoundingModeRTEFloat16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderRoundingModeRTEFloat32, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderRoundingModeRTEFloat64, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderRoundingModeRTZFloat16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderRoundingModeRTZFloat32, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderRoundingModeRTZFloat64, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceFloatControlsProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceFloatControlsProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkShaderFloatControlsIndependence*)&forUnmarshaling->denormBehaviorIndependence, sizeof(VkShaderFloatControlsIndependence));
    vkStream->read((VkShaderFloatControlsIndependence*)&forUnmarshaling->roundingModeIndependence, sizeof(VkShaderFloatControlsIndependence));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSignedZeroInfNanPreserveFloat16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSignedZeroInfNanPreserveFloat32, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSignedZeroInfNanPreserveFloat64, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDenormPreserveFloat16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDenormPreserveFloat32, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDenormPreserveFloat64, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDenormFlushToZeroFloat16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDenormFlushToZeroFloat32, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDenormFlushToZeroFloat64, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderRoundingModeRTEFloat16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderRoundingModeRTEFloat32, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderRoundingModeRTEFloat64, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderRoundingModeRTZFloat16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderRoundingModeRTZFloat32, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderRoundingModeRTZFloat64, sizeof(VkBool32));
}

void marshal_VkDescriptorSetLayoutBindingFlagsCreateInfo(
    VulkanStream* vkStream,
    const VkDescriptorSetLayoutBindingFlagsCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->bindingCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pBindingFlags;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pBindingFlags)
    {
        vkStream->write((const VkDescriptorBindingFlags*)forMarshaling->pBindingFlags, forMarshaling->bindingCount * sizeof(const VkDescriptorBindingFlags));
    }
}

void unmarshal_VkDescriptorSetLayoutBindingFlagsCreateInfo(
    VulkanStream* vkStream,
    VkDescriptorSetLayoutBindingFlagsCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->bindingCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pBindingFlags = (const VkDescriptorBindingFlags*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pBindingFlags)
    {
        vkStream->alloc((void**)&forUnmarshaling->pBindingFlags, forUnmarshaling->bindingCount * sizeof(const VkDescriptorBindingFlags));
        vkStream->read((VkDescriptorBindingFlags*)forUnmarshaling->pBindingFlags, forUnmarshaling->bindingCount * sizeof(const VkDescriptorBindingFlags));
    }
}

void marshal_VkPhysicalDeviceDescriptorIndexingFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceDescriptorIndexingFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->shaderInputAttachmentArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSampledImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInputAttachmentArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingUniformBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingSampledImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingStorageImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingStorageBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingUniformTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingStorageTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingUpdateUnusedWhilePending, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingPartiallyBound, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingVariableDescriptorCount, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->runtimeDescriptorArray, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceDescriptorIndexingFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceDescriptorIndexingFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSampledImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingUniformBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingSampledImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingStorageImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingStorageBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingUniformTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingStorageTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingUpdateUnusedWhilePending, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingPartiallyBound, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingVariableDescriptorCount, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->runtimeDescriptorArray, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceDescriptorIndexingProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceDescriptorIndexingProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->maxUpdateAfterBindDescriptorsInAllPools, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSampledImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInputAttachmentArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->robustBufferAccessUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->quadDivergentImplicitLod, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindInputAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageUpdateAfterBindResources, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindInputAttachments, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceDescriptorIndexingProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceDescriptorIndexingProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxUpdateAfterBindDescriptorsInAllPools, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSampledImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->robustBufferAccessUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->quadDivergentImplicitLod, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindInputAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageUpdateAfterBindResources, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindInputAttachments, sizeof(uint32_t));
}

void marshal_VkDescriptorSetVariableDescriptorCountAllocateInfo(
    VulkanStream* vkStream,
    const VkDescriptorSetVariableDescriptorCountAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->descriptorSetCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pDescriptorCounts, forMarshaling->descriptorSetCount * sizeof(const uint32_t));
}

void unmarshal_VkDescriptorSetVariableDescriptorCountAllocateInfo(
    VulkanStream* vkStream,
    VkDescriptorSetVariableDescriptorCountAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorSetCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDescriptorCounts, forUnmarshaling->descriptorSetCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pDescriptorCounts, forUnmarshaling->descriptorSetCount * sizeof(const uint32_t));
}

void marshal_VkDescriptorSetVariableDescriptorCountLayoutSupport(
    VulkanStream* vkStream,
    const VkDescriptorSetVariableDescriptorCountLayoutSupport* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->maxVariableDescriptorCount, sizeof(uint32_t));
}

void unmarshal_VkDescriptorSetVariableDescriptorCountLayoutSupport(
    VulkanStream* vkStream,
    VkDescriptorSetVariableDescriptorCountLayoutSupport* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxVariableDescriptorCount, sizeof(uint32_t));
}

void marshal_VkSubpassDescriptionDepthStencilResolve(
    VulkanStream* vkStream,
    const VkSubpassDescriptionDepthStencilResolve* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkResolveModeFlagBits*)&forMarshaling->depthResolveMode, sizeof(VkResolveModeFlagBits));
    vkStream->write((VkResolveModeFlagBits*)&forMarshaling->stencilResolveMode, sizeof(VkResolveModeFlagBits));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pDepthStencilResolveAttachment;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pDepthStencilResolveAttachment)
    {
        marshal_VkAttachmentReference2(vkStream, (const VkAttachmentReference2*)(forMarshaling->pDepthStencilResolveAttachment));
    }
}

void unmarshal_VkSubpassDescriptionDepthStencilResolve(
    VulkanStream* vkStream,
    VkSubpassDescriptionDepthStencilResolve* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkResolveModeFlagBits*)&forUnmarshaling->depthResolveMode, sizeof(VkResolveModeFlagBits));
    vkStream->read((VkResolveModeFlagBits*)&forUnmarshaling->stencilResolveMode, sizeof(VkResolveModeFlagBits));
    // WARNING PTR CHECK
    forUnmarshaling->pDepthStencilResolveAttachment = (const VkAttachmentReference2*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pDepthStencilResolveAttachment)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDepthStencilResolveAttachment, sizeof(const VkAttachmentReference2));
        unmarshal_VkAttachmentReference2(vkStream, (VkAttachmentReference2*)(forUnmarshaling->pDepthStencilResolveAttachment));
    }
}

void marshal_VkPhysicalDeviceDepthStencilResolveProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceDepthStencilResolveProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkResolveModeFlags*)&forMarshaling->supportedDepthResolveModes, sizeof(VkResolveModeFlags));
    vkStream->write((VkResolveModeFlags*)&forMarshaling->supportedStencilResolveModes, sizeof(VkResolveModeFlags));
    vkStream->write((VkBool32*)&forMarshaling->independentResolveNone, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->independentResolve, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceDepthStencilResolveProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceDepthStencilResolveProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkResolveModeFlags*)&forUnmarshaling->supportedDepthResolveModes, sizeof(VkResolveModeFlags));
    vkStream->read((VkResolveModeFlags*)&forUnmarshaling->supportedStencilResolveModes, sizeof(VkResolveModeFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->independentResolveNone, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->independentResolve, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceScalarBlockLayoutFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceScalarBlockLayoutFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->scalarBlockLayout, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceScalarBlockLayoutFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceScalarBlockLayoutFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->scalarBlockLayout, sizeof(VkBool32));
}

void marshal_VkImageStencilUsageCreateInfo(
    VulkanStream* vkStream,
    const VkImageStencilUsageCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkImageUsageFlags*)&forMarshaling->stencilUsage, sizeof(VkImageUsageFlags));
}

void unmarshal_VkImageStencilUsageCreateInfo(
    VulkanStream* vkStream,
    VkImageStencilUsageCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->stencilUsage, sizeof(VkImageUsageFlags));
}

void marshal_VkSamplerReductionModeCreateInfo(
    VulkanStream* vkStream,
    const VkSamplerReductionModeCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSamplerReductionMode*)&forMarshaling->reductionMode, sizeof(VkSamplerReductionMode));
}

void unmarshal_VkSamplerReductionModeCreateInfo(
    VulkanStream* vkStream,
    VkSamplerReductionModeCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSamplerReductionMode*)&forUnmarshaling->reductionMode, sizeof(VkSamplerReductionMode));
}

void marshal_VkPhysicalDeviceSamplerFilterMinmaxProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSamplerFilterMinmaxProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->filterMinmaxSingleComponentFormats, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->filterMinmaxImageComponentMapping, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSamplerFilterMinmaxProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceSamplerFilterMinmaxProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->filterMinmaxSingleComponentFormats, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->filterMinmaxImageComponentMapping, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceVulkanMemoryModelFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceVulkanMemoryModelFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->vulkanMemoryModel, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->vulkanMemoryModelDeviceScope, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->vulkanMemoryModelAvailabilityVisibilityChains, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceVulkanMemoryModelFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceVulkanMemoryModelFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->vulkanMemoryModel, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->vulkanMemoryModelDeviceScope, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->vulkanMemoryModelAvailabilityVisibilityChains, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceImagelessFramebufferFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceImagelessFramebufferFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->imagelessFramebuffer, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceImagelessFramebufferFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceImagelessFramebufferFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->imagelessFramebuffer, sizeof(VkBool32));
}

void marshal_VkFramebufferAttachmentImageInfo(
    VulkanStream* vkStream,
    const VkFramebufferAttachmentImageInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkImageCreateFlags*)&forMarshaling->flags, sizeof(VkImageCreateFlags));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->write((uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->viewFormatCount, sizeof(uint32_t));
    vkStream->write((const VkFormat*)forMarshaling->pViewFormats, forMarshaling->viewFormatCount * sizeof(const VkFormat));
}

void unmarshal_VkFramebufferAttachmentImageInfo(
    VulkanStream* vkStream,
    VkFramebufferAttachmentImageInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageCreateFlags*)&forUnmarshaling->flags, sizeof(VkImageCreateFlags));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->width, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->height, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->layerCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->viewFormatCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pViewFormats, forUnmarshaling->viewFormatCount * sizeof(const VkFormat));
    vkStream->read((VkFormat*)forUnmarshaling->pViewFormats, forUnmarshaling->viewFormatCount * sizeof(const VkFormat));
}

void marshal_VkFramebufferAttachmentsCreateInfo(
    VulkanStream* vkStream,
    const VkFramebufferAttachmentsCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->attachmentImageInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentImageInfoCount; ++i)
    {
        marshal_VkFramebufferAttachmentImageInfo(vkStream, (const VkFramebufferAttachmentImageInfo*)(forMarshaling->pAttachmentImageInfos + i));
    }
}

void unmarshal_VkFramebufferAttachmentsCreateInfo(
    VulkanStream* vkStream,
    VkFramebufferAttachmentsCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentImageInfoCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAttachmentImageInfos, forUnmarshaling->attachmentImageInfoCount * sizeof(const VkFramebufferAttachmentImageInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentImageInfoCount; ++i)
    {
        unmarshal_VkFramebufferAttachmentImageInfo(vkStream, (VkFramebufferAttachmentImageInfo*)(forUnmarshaling->pAttachmentImageInfos + i));
    }
}

void marshal_VkRenderPassAttachmentBeginInfo(
    VulkanStream* vkStream,
    const VkRenderPassAttachmentBeginInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    if (forMarshaling->attachmentCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forMarshaling->attachmentCount * 8);
        vkStream->handleMapping()->mapHandles_VkImageView_u64(forMarshaling->pAttachments, cgen_var_0, forMarshaling->attachmentCount);
        vkStream->write((uint64_t*)cgen_var_0, forMarshaling->attachmentCount * 8);
    }
}

void unmarshal_VkRenderPassAttachmentBeginInfo(
    VulkanStream* vkStream,
    VkRenderPassAttachmentBeginInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkImageView));
    if (forUnmarshaling->attachmentCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forUnmarshaling->attachmentCount * 8);
        vkStream->read((uint64_t*)cgen_var_0, forUnmarshaling->attachmentCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkImageView(cgen_var_0, (VkImageView*)forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount);
    }
}

void marshal_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceUniformBufferStandardLayoutFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->uniformBufferStandardLayout, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceUniformBufferStandardLayoutFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->uniformBufferStandardLayout, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->shaderSubgroupExtendedTypes, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSubgroupExtendedTypes, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->separateDepthStencilLayouts, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->separateDepthStencilLayouts, sizeof(VkBool32));
}

void marshal_VkAttachmentReferenceStencilLayout(
    VulkanStream* vkStream,
    const VkAttachmentReferenceStencilLayout* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkImageLayout*)&forMarshaling->stencilLayout, sizeof(VkImageLayout));
}

void unmarshal_VkAttachmentReferenceStencilLayout(
    VulkanStream* vkStream,
    VkAttachmentReferenceStencilLayout* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageLayout*)&forUnmarshaling->stencilLayout, sizeof(VkImageLayout));
}

void marshal_VkAttachmentDescriptionStencilLayout(
    VulkanStream* vkStream,
    const VkAttachmentDescriptionStencilLayout* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkImageLayout*)&forMarshaling->stencilInitialLayout, sizeof(VkImageLayout));
    vkStream->write((VkImageLayout*)&forMarshaling->stencilFinalLayout, sizeof(VkImageLayout));
}

void unmarshal_VkAttachmentDescriptionStencilLayout(
    VulkanStream* vkStream,
    VkAttachmentDescriptionStencilLayout* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageLayout*)&forUnmarshaling->stencilInitialLayout, sizeof(VkImageLayout));
    vkStream->read((VkImageLayout*)&forUnmarshaling->stencilFinalLayout, sizeof(VkImageLayout));
}

void marshal_VkPhysicalDeviceHostQueryResetFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceHostQueryResetFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->hostQueryReset, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceHostQueryResetFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceHostQueryResetFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->hostQueryReset, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceTimelineSemaphoreFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceTimelineSemaphoreFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->timelineSemaphore, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceTimelineSemaphoreFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceTimelineSemaphoreFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->timelineSemaphore, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceTimelineSemaphoreProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceTimelineSemaphoreProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint64_t*)&forMarshaling->maxTimelineSemaphoreValueDifference, sizeof(uint64_t));
}

void unmarshal_VkPhysicalDeviceTimelineSemaphoreProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceTimelineSemaphoreProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint64_t*)&forUnmarshaling->maxTimelineSemaphoreValueDifference, sizeof(uint64_t));
}

void marshal_VkSemaphoreTypeCreateInfo(
    VulkanStream* vkStream,
    const VkSemaphoreTypeCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSemaphoreType*)&forMarshaling->semaphoreType, sizeof(VkSemaphoreType));
    vkStream->write((uint64_t*)&forMarshaling->initialValue, sizeof(uint64_t));
}

void unmarshal_VkSemaphoreTypeCreateInfo(
    VulkanStream* vkStream,
    VkSemaphoreTypeCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSemaphoreType*)&forUnmarshaling->semaphoreType, sizeof(VkSemaphoreType));
    vkStream->read((uint64_t*)&forUnmarshaling->initialValue, sizeof(uint64_t));
}

void marshal_VkTimelineSemaphoreSubmitInfo(
    VulkanStream* vkStream,
    const VkTimelineSemaphoreSubmitInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreValueCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pWaitSemaphoreValues;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pWaitSemaphoreValues)
    {
        vkStream->write((const uint64_t*)forMarshaling->pWaitSemaphoreValues, forMarshaling->waitSemaphoreValueCount * sizeof(const uint64_t));
    }
    vkStream->write((uint32_t*)&forMarshaling->signalSemaphoreValueCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pSignalSemaphoreValues;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pSignalSemaphoreValues)
    {
        vkStream->write((const uint64_t*)forMarshaling->pSignalSemaphoreValues, forMarshaling->signalSemaphoreValueCount * sizeof(const uint64_t));
    }
}

void unmarshal_VkTimelineSemaphoreSubmitInfo(
    VulkanStream* vkStream,
    VkTimelineSemaphoreSubmitInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreValueCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pWaitSemaphoreValues = (const uint64_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pWaitSemaphoreValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphoreValues, forUnmarshaling->waitSemaphoreValueCount * sizeof(const uint64_t));
        vkStream->read((uint64_t*)forUnmarshaling->pWaitSemaphoreValues, forUnmarshaling->waitSemaphoreValueCount * sizeof(const uint64_t));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->signalSemaphoreValueCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pSignalSemaphoreValues = (const uint64_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pSignalSemaphoreValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphoreValues, forUnmarshaling->signalSemaphoreValueCount * sizeof(const uint64_t));
        vkStream->read((uint64_t*)forUnmarshaling->pSignalSemaphoreValues, forUnmarshaling->signalSemaphoreValueCount * sizeof(const uint64_t));
    }
}

void marshal_VkSemaphoreWaitInfo(
    VulkanStream* vkStream,
    const VkSemaphoreWaitInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSemaphoreWaitFlags*)&forMarshaling->flags, sizeof(VkSemaphoreWaitFlags));
    vkStream->write((uint32_t*)&forMarshaling->semaphoreCount, sizeof(uint32_t));
    if (forMarshaling->semaphoreCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forMarshaling->semaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_VkSemaphore_u64(forMarshaling->pSemaphores, cgen_var_0, forMarshaling->semaphoreCount);
        vkStream->write((uint64_t*)cgen_var_0, forMarshaling->semaphoreCount * 8);
    }
    vkStream->write((const uint64_t*)forMarshaling->pValues, forMarshaling->semaphoreCount * sizeof(const uint64_t));
}

void unmarshal_VkSemaphoreWaitInfo(
    VulkanStream* vkStream,
    VkSemaphoreWaitInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSemaphoreWaitFlags*)&forUnmarshaling->flags, sizeof(VkSemaphoreWaitFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->semaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSemaphores, forUnmarshaling->semaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->semaphoreCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forUnmarshaling->semaphoreCount * 8);
        vkStream->read((uint64_t*)cgen_var_0, forUnmarshaling->semaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkSemaphore(cgen_var_0, (VkSemaphore*)forUnmarshaling->pSemaphores, forUnmarshaling->semaphoreCount);
    }
    vkStream->alloc((void**)&forUnmarshaling->pValues, forUnmarshaling->semaphoreCount * sizeof(const uint64_t));
    vkStream->read((uint64_t*)forUnmarshaling->pValues, forUnmarshaling->semaphoreCount * sizeof(const uint64_t));
}

void marshal_VkSemaphoreSignalInfo(
    VulkanStream* vkStream,
    const VkSemaphoreSignalInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkSemaphore_u64(&forMarshaling->semaphore, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint64_t*)&forMarshaling->value, sizeof(uint64_t));
}

void unmarshal_VkSemaphoreSignalInfo(
    VulkanStream* vkStream,
    VkSemaphoreSignalInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_0, (VkSemaphore*)&forUnmarshaling->semaphore, 1);
    vkStream->read((uint64_t*)&forUnmarshaling->value, sizeof(uint64_t));
}

void marshal_VkPhysicalDeviceBufferDeviceAddressFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceBufferDeviceAddressFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->bufferDeviceAddress, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->bufferDeviceAddressCaptureReplay, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->bufferDeviceAddressMultiDevice, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceBufferDeviceAddressFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceBufferDeviceAddressFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->bufferDeviceAddress, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->bufferDeviceAddressCaptureReplay, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->bufferDeviceAddressMultiDevice, sizeof(VkBool32));
}

void marshal_VkBufferDeviceAddressInfo(
    VulkanStream* vkStream,
    const VkBufferDeviceAddressInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
}

void unmarshal_VkBufferDeviceAddressInfo(
    VulkanStream* vkStream,
    VkBufferDeviceAddressInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_0, (VkBuffer*)&forUnmarshaling->buffer, 1);
}

void marshal_VkBufferOpaqueCaptureAddressCreateInfo(
    VulkanStream* vkStream,
    const VkBufferOpaqueCaptureAddressCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint64_t*)&forMarshaling->opaqueCaptureAddress, sizeof(uint64_t));
}

void unmarshal_VkBufferOpaqueCaptureAddressCreateInfo(
    VulkanStream* vkStream,
    VkBufferOpaqueCaptureAddressCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint64_t*)&forUnmarshaling->opaqueCaptureAddress, sizeof(uint64_t));
}

void marshal_VkMemoryOpaqueCaptureAddressAllocateInfo(
    VulkanStream* vkStream,
    const VkMemoryOpaqueCaptureAddressAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint64_t*)&forMarshaling->opaqueCaptureAddress, sizeof(uint64_t));
}

void unmarshal_VkMemoryOpaqueCaptureAddressAllocateInfo(
    VulkanStream* vkStream,
    VkMemoryOpaqueCaptureAddressAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint64_t*)&forUnmarshaling->opaqueCaptureAddress, sizeof(uint64_t));
}

void marshal_VkDeviceMemoryOpaqueCaptureAddressInfo(
    VulkanStream* vkStream,
    const VkDeviceMemoryOpaqueCaptureAddressInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
}

void unmarshal_VkDeviceMemoryOpaqueCaptureAddressInfo(
    VulkanStream* vkStream,
    VkDeviceMemoryOpaqueCaptureAddressInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_0, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
}

#endif
#ifdef VK_KHR_surface
void marshal_VkSurfaceCapabilitiesKHR(
    VulkanStream* vkStream,
    const VkSurfaceCapabilitiesKHR* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageCount, sizeof(uint32_t));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->currentExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minImageExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxImageExtent));
    vkStream->write((uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->write((VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->write((VkCompositeAlphaFlagsKHR*)&forMarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
}

void unmarshal_VkSurfaceCapabilitiesKHR(
    VulkanStream* vkStream,
    VkSurfaceCapabilitiesKHR* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->minImageCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageCount, sizeof(uint32_t));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->currentExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minImageExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxImageExtent));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->read((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->read((VkCompositeAlphaFlagsKHR*)&forUnmarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
}

void marshal_VkSurfaceFormatKHR(
    VulkanStream* vkStream,
    const VkSurfaceFormatKHR* forMarshaling)
{
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkColorSpaceKHR*)&forMarshaling->colorSpace, sizeof(VkColorSpaceKHR));
}

void unmarshal_VkSurfaceFormatKHR(
    VulkanStream* vkStream,
    VkSurfaceFormatKHR* forUnmarshaling)
{
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkColorSpaceKHR*)&forUnmarshaling->colorSpace, sizeof(VkColorSpaceKHR));
}

#endif
#ifdef VK_KHR_swapchain
void marshal_VkSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    const VkSwapchainCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSwapchainCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkSwapchainCreateFlagsKHR));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&forMarshaling->surface, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    vkStream->write((VkFormat*)&forMarshaling->imageFormat, sizeof(VkFormat));
    vkStream->write((VkColorSpaceKHR*)&forMarshaling->imageColorSpace, sizeof(VkColorSpaceKHR));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->imageExtent));
    vkStream->write((uint32_t*)&forMarshaling->imageArrayLayers, sizeof(uint32_t));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->imageUsage, sizeof(VkImageUsageFlags));
    vkStream->write((VkSharingMode*)&forMarshaling->imageSharingMode, sizeof(VkSharingMode));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pQueueFamilyIndices;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pQueueFamilyIndices)
    {
        vkStream->write((const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->preTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->write((VkCompositeAlphaFlagBitsKHR*)&forMarshaling->compositeAlpha, sizeof(VkCompositeAlphaFlagBitsKHR));
    vkStream->write((VkPresentModeKHR*)&forMarshaling->presentMode, sizeof(VkPresentModeKHR));
    vkStream->write((VkBool32*)&forMarshaling->clipped, sizeof(VkBool32));
    uint64_t cgen_var_2;
    vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&forMarshaling->oldSwapchain, &cgen_var_2, 1);
    vkStream->write((uint64_t*)&cgen_var_2, 1 * 8);
}

void unmarshal_VkSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    VkSwapchainCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSwapchainCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkSwapchainCreateFlagsKHR));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_0, (VkSurfaceKHR*)&forUnmarshaling->surface, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->minImageCount, sizeof(uint32_t));
    vkStream->read((VkFormat*)&forUnmarshaling->imageFormat, sizeof(VkFormat));
    vkStream->read((VkColorSpaceKHR*)&forUnmarshaling->imageColorSpace, sizeof(VkColorSpaceKHR));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->imageExtent));
    vkStream->read((uint32_t*)&forUnmarshaling->imageArrayLayers, sizeof(uint32_t));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->imageUsage, sizeof(VkImageUsageFlags));
    vkStream->read((VkSharingMode*)&forUnmarshaling->imageSharingMode, sizeof(VkSharingMode));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pQueueFamilyIndices = (const uint32_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        vkStream->read((uint32_t*)forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->preTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->read((VkCompositeAlphaFlagBitsKHR*)&forUnmarshaling->compositeAlpha, sizeof(VkCompositeAlphaFlagBitsKHR));
    vkStream->read((VkPresentModeKHR*)&forUnmarshaling->presentMode, sizeof(VkPresentModeKHR));
    vkStream->read((VkBool32*)&forUnmarshaling->clipped, sizeof(VkBool32));
    uint64_t cgen_var_2;
    vkStream->read((uint64_t*)&cgen_var_2, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_2, (VkSwapchainKHR*)&forUnmarshaling->oldSwapchain, 1);
}

void marshal_VkPresentInfoKHR(
    VulkanStream* vkStream,
    const VkPresentInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    if (forMarshaling->waitSemaphoreCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forMarshaling->waitSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_VkSemaphore_u64(forMarshaling->pWaitSemaphores, cgen_var_0, forMarshaling->waitSemaphoreCount);
        vkStream->write((uint64_t*)cgen_var_0, forMarshaling->waitSemaphoreCount * 8);
    }
    vkStream->write((uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    if (forMarshaling->swapchainCount)
    {
        uint64_t* cgen_var_1;
        vkStream->alloc((void**)&cgen_var_1, forMarshaling->swapchainCount * 8);
        vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(forMarshaling->pSwapchains, cgen_var_1, forMarshaling->swapchainCount);
        vkStream->write((uint64_t*)cgen_var_1, forMarshaling->swapchainCount * 8);
    }
    vkStream->write((const uint32_t*)forMarshaling->pImageIndices, forMarshaling->swapchainCount * sizeof(const uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pResults;
    vkStream->putBe64(cgen_var_2);
    if (forMarshaling->pResults)
    {
        vkStream->write((VkResult*)forMarshaling->pResults, forMarshaling->swapchainCount * sizeof(VkResult));
    }
}

void unmarshal_VkPresentInfoKHR(
    VulkanStream* vkStream,
    VkPresentInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->waitSemaphoreCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forUnmarshaling->waitSemaphoreCount * 8);
        vkStream->read((uint64_t*)cgen_var_0, forUnmarshaling->waitSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkSemaphore(cgen_var_0, (VkSemaphore*)forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount);
    }
    vkStream->read((uint32_t*)&forUnmarshaling->swapchainCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSwapchains, forUnmarshaling->swapchainCount * sizeof(const VkSwapchainKHR));
    if (forUnmarshaling->swapchainCount)
    {
        uint64_t* cgen_var_1;
        vkStream->alloc((void**)&cgen_var_1, forUnmarshaling->swapchainCount * 8);
        vkStream->read((uint64_t*)cgen_var_1, forUnmarshaling->swapchainCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(cgen_var_1, (VkSwapchainKHR*)forUnmarshaling->pSwapchains, forUnmarshaling->swapchainCount);
    }
    vkStream->alloc((void**)&forUnmarshaling->pImageIndices, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pImageIndices, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pResults = (VkResult*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pResults)
    {
        vkStream->alloc((void**)&forUnmarshaling->pResults, forUnmarshaling->swapchainCount * sizeof(VkResult));
        vkStream->read((VkResult*)forUnmarshaling->pResults, forUnmarshaling->swapchainCount * sizeof(VkResult));
    }
}

void marshal_VkImageSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    const VkImageSwapchainCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&forMarshaling->swapchain, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
}

void unmarshal_VkImageSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    VkImageSwapchainCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_0, (VkSwapchainKHR*)&forUnmarshaling->swapchain, 1);
}

void marshal_VkBindImageMemorySwapchainInfoKHR(
    VulkanStream* vkStream,
    const VkBindImageMemorySwapchainInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&forMarshaling->swapchain, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->imageIndex, sizeof(uint32_t));
}

void unmarshal_VkBindImageMemorySwapchainInfoKHR(
    VulkanStream* vkStream,
    VkBindImageMemorySwapchainInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_0, (VkSwapchainKHR*)&forUnmarshaling->swapchain, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->imageIndex, sizeof(uint32_t));
}

void marshal_VkAcquireNextImageInfoKHR(
    VulkanStream* vkStream,
    const VkAcquireNextImageInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&forMarshaling->swapchain, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint64_t*)&forMarshaling->timeout, sizeof(uint64_t));
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkSemaphore_u64(&forMarshaling->semaphore, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    uint64_t cgen_var_2;
    vkStream->handleMapping()->mapHandles_VkFence_u64(&forMarshaling->fence, &cgen_var_2, 1);
    vkStream->write((uint64_t*)&cgen_var_2, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
}

void unmarshal_VkAcquireNextImageInfoKHR(
    VulkanStream* vkStream,
    VkAcquireNextImageInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_0, (VkSwapchainKHR*)&forUnmarshaling->swapchain, 1);
    vkStream->read((uint64_t*)&forUnmarshaling->timeout, sizeof(uint64_t));
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_1, (VkSemaphore*)&forUnmarshaling->semaphore, 1);
    uint64_t cgen_var_2;
    vkStream->read((uint64_t*)&cgen_var_2, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_2, (VkFence*)&forUnmarshaling->fence, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->deviceMask, sizeof(uint32_t));
}

void marshal_VkDeviceGroupPresentCapabilitiesKHR(
    VulkanStream* vkStream,
    const VkDeviceGroupPresentCapabilitiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)forMarshaling->presentMask, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t));
    vkStream->write((VkDeviceGroupPresentModeFlagsKHR*)&forMarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
}

void unmarshal_VkDeviceGroupPresentCapabilitiesKHR(
    VulkanStream* vkStream,
    VkDeviceGroupPresentCapabilitiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)forUnmarshaling->presentMask, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t));
    vkStream->read((VkDeviceGroupPresentModeFlagsKHR*)&forUnmarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
}

void marshal_VkDeviceGroupPresentInfoKHR(
    VulkanStream* vkStream,
    const VkDeviceGroupPresentInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pDeviceMasks, forMarshaling->swapchainCount * sizeof(const uint32_t));
    vkStream->write((VkDeviceGroupPresentModeFlagBitsKHR*)&forMarshaling->mode, sizeof(VkDeviceGroupPresentModeFlagBitsKHR));
}

void unmarshal_VkDeviceGroupPresentInfoKHR(
    VulkanStream* vkStream,
    VkDeviceGroupPresentInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->swapchainCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDeviceMasks, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pDeviceMasks, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    vkStream->read((VkDeviceGroupPresentModeFlagBitsKHR*)&forUnmarshaling->mode, sizeof(VkDeviceGroupPresentModeFlagBitsKHR));
}

void marshal_VkDeviceGroupSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    const VkDeviceGroupSwapchainCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceGroupPresentModeFlagsKHR*)&forMarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
}

void unmarshal_VkDeviceGroupSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    VkDeviceGroupSwapchainCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceGroupPresentModeFlagsKHR*)&forUnmarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
}

#endif
#ifdef VK_KHR_display
void marshal_VkDisplayModeParametersKHR(
    VulkanStream* vkStream,
    const VkDisplayModeParametersKHR* forMarshaling)
{
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->visibleRegion));
    vkStream->write((uint32_t*)&forMarshaling->refreshRate, sizeof(uint32_t));
}

void unmarshal_VkDisplayModeParametersKHR(
    VulkanStream* vkStream,
    VkDisplayModeParametersKHR* forUnmarshaling)
{
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->visibleRegion));
    vkStream->read((uint32_t*)&forUnmarshaling->refreshRate, sizeof(uint32_t));
}

void marshal_VkDisplayModeCreateInfoKHR(
    VulkanStream* vkStream,
    const VkDisplayModeCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDisplayModeCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkDisplayModeCreateFlagsKHR));
    marshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forMarshaling->parameters));
}

void unmarshal_VkDisplayModeCreateInfoKHR(
    VulkanStream* vkStream,
    VkDisplayModeCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDisplayModeCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkDisplayModeCreateFlagsKHR));
    unmarshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forUnmarshaling->parameters));
}

void marshal_VkDisplayModePropertiesKHR(
    VulkanStream* vkStream,
    const VkDisplayModePropertiesKHR* forMarshaling)
{
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(&forMarshaling->displayMode, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    marshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forMarshaling->parameters));
}

void unmarshal_VkDisplayModePropertiesKHR(
    VulkanStream* vkStream,
    VkDisplayModePropertiesKHR* forUnmarshaling)
{
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_0, (VkDisplayModeKHR*)&forUnmarshaling->displayMode, 1);
    unmarshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forUnmarshaling->parameters));
}

void marshal_VkDisplayPlaneCapabilitiesKHR(
    VulkanStream* vkStream,
    const VkDisplayPlaneCapabilitiesKHR* forMarshaling)
{
    vkStream->write((VkDisplayPlaneAlphaFlagsKHR*)&forMarshaling->supportedAlpha, sizeof(VkDisplayPlaneAlphaFlagsKHR));
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->minSrcPosition));
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->maxSrcPosition));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minSrcExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxSrcExtent));
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->minDstPosition));
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->maxDstPosition));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minDstExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxDstExtent));
}

void unmarshal_VkDisplayPlaneCapabilitiesKHR(
    VulkanStream* vkStream,
    VkDisplayPlaneCapabilitiesKHR* forUnmarshaling)
{
    vkStream->read((VkDisplayPlaneAlphaFlagsKHR*)&forUnmarshaling->supportedAlpha, sizeof(VkDisplayPlaneAlphaFlagsKHR));
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->minSrcPosition));
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->maxSrcPosition));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minSrcExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxSrcExtent));
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->minDstPosition));
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->maxDstPosition));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minDstExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxDstExtent));
}

void marshal_VkDisplayPlanePropertiesKHR(
    VulkanStream* vkStream,
    const VkDisplayPlanePropertiesKHR* forMarshaling)
{
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&forMarshaling->currentDisplay, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->currentStackIndex, sizeof(uint32_t));
}

void unmarshal_VkDisplayPlanePropertiesKHR(
    VulkanStream* vkStream,
    VkDisplayPlanePropertiesKHR* forUnmarshaling)
{
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_0, (VkDisplayKHR*)&forUnmarshaling->currentDisplay, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->currentStackIndex, sizeof(uint32_t));
}

void marshal_VkDisplayPropertiesKHR(
    VulkanStream* vkStream,
    const VkDisplayPropertiesKHR* forMarshaling)
{
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&forMarshaling->display, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->putString(forMarshaling->displayName);
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->physicalDimensions));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->physicalResolution));
    vkStream->write((VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->write((VkBool32*)&forMarshaling->planeReorderPossible, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->persistentContent, sizeof(VkBool32));
}

void unmarshal_VkDisplayPropertiesKHR(
    VulkanStream* vkStream,
    VkDisplayPropertiesKHR* forUnmarshaling)
{
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_0, (VkDisplayKHR*)&forUnmarshaling->display, 1);
    vkStream->loadStringInPlace((char**)&forUnmarshaling->displayName);
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->physicalDimensions));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->physicalResolution));
    vkStream->read((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->read((VkBool32*)&forUnmarshaling->planeReorderPossible, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->persistentContent, sizeof(VkBool32));
}

void marshal_VkDisplaySurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkDisplaySurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDisplaySurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkDisplaySurfaceCreateFlagsKHR));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(&forMarshaling->displayMode, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->planeIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->planeStackIndex, sizeof(uint32_t));
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->write((float*)&forMarshaling->globalAlpha, sizeof(float));
    vkStream->write((VkDisplayPlaneAlphaFlagBitsKHR*)&forMarshaling->alphaMode, sizeof(VkDisplayPlaneAlphaFlagBitsKHR));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->imageExtent));
}

void unmarshal_VkDisplaySurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkDisplaySurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDisplaySurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkDisplaySurfaceCreateFlagsKHR));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_0, (VkDisplayModeKHR*)&forUnmarshaling->displayMode, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->planeIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->planeStackIndex, sizeof(uint32_t));
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->read((float*)&forUnmarshaling->globalAlpha, sizeof(float));
    vkStream->read((VkDisplayPlaneAlphaFlagBitsKHR*)&forUnmarshaling->alphaMode, sizeof(VkDisplayPlaneAlphaFlagBitsKHR));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->imageExtent));
}

#endif
#ifdef VK_KHR_display_swapchain
void marshal_VkDisplayPresentInfoKHR(
    VulkanStream* vkStream,
    const VkDisplayPresentInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->srcRect));
    marshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->dstRect));
    vkStream->write((VkBool32*)&forMarshaling->persistent, sizeof(VkBool32));
}

void unmarshal_VkDisplayPresentInfoKHR(
    VulkanStream* vkStream,
    VkDisplayPresentInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->srcRect));
    unmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->dstRect));
    vkStream->read((VkBool32*)&forUnmarshaling->persistent, sizeof(VkBool32));
}

#endif
#ifdef VK_KHR_xlib_surface
void marshal_VkXlibSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkXlibSurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkXlibSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkXlibSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->dpy;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->dpy)
    {
        vkStream->write((Display*)forMarshaling->dpy, sizeof(Display));
    }
    vkStream->write((Window*)&forMarshaling->window, sizeof(Window));
}

void unmarshal_VkXlibSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkXlibSurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkXlibSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkXlibSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    forUnmarshaling->dpy = (Display*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->dpy)
    {
        vkStream->alloc((void**)&forUnmarshaling->dpy, sizeof(Display));
        vkStream->read((Display*)forUnmarshaling->dpy, sizeof(Display));
    }
    vkStream->read((Window*)&forUnmarshaling->window, sizeof(Window));
}

#endif
#ifdef VK_KHR_xcb_surface
void marshal_VkXcbSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkXcbSurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkXcbSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkXcbSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->connection;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->connection)
    {
        vkStream->write((xcb_connection_t*)forMarshaling->connection, sizeof(xcb_connection_t));
    }
    vkStream->write((xcb_window_t*)&forMarshaling->window, sizeof(xcb_window_t));
}

void unmarshal_VkXcbSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkXcbSurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkXcbSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkXcbSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    forUnmarshaling->connection = (xcb_connection_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->connection)
    {
        vkStream->alloc((void**)&forUnmarshaling->connection, sizeof(xcb_connection_t));
        vkStream->read((xcb_connection_t*)forUnmarshaling->connection, sizeof(xcb_connection_t));
    }
    vkStream->read((xcb_window_t*)&forUnmarshaling->window, sizeof(xcb_window_t));
}

#endif
#ifdef VK_KHR_wayland_surface
void marshal_VkWaylandSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkWaylandSurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkWaylandSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkWaylandSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->display;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->display)
    {
        vkStream->write((wl_display*)forMarshaling->display, sizeof(wl_display));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->surface;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->surface)
    {
        vkStream->write((wl_surface*)forMarshaling->surface, sizeof(wl_surface));
    }
}

void unmarshal_VkWaylandSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkWaylandSurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkWaylandSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkWaylandSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    forUnmarshaling->display = (wl_display*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->display)
    {
        vkStream->alloc((void**)&forUnmarshaling->display, sizeof(wl_display));
        vkStream->read((wl_display*)forUnmarshaling->display, sizeof(wl_display));
    }
    // WARNING PTR CHECK
    forUnmarshaling->surface = (wl_surface*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->surface)
    {
        vkStream->alloc((void**)&forUnmarshaling->surface, sizeof(wl_surface));
        vkStream->read((wl_surface*)forUnmarshaling->surface, sizeof(wl_surface));
    }
}

#endif
#ifdef VK_KHR_android_surface
void marshal_VkAndroidSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkAndroidSurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkAndroidSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkAndroidSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->window;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->window)
    {
        vkStream->write((ANativeWindow*)forMarshaling->window, sizeof(ANativeWindow));
    }
}

void unmarshal_VkAndroidSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkAndroidSurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAndroidSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkAndroidSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    forUnmarshaling->window = (ANativeWindow*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->window)
    {
        vkStream->alloc((void**)&forUnmarshaling->window, sizeof(ANativeWindow));
        vkStream->read((ANativeWindow*)forUnmarshaling->window, sizeof(ANativeWindow));
    }
}

#endif
#ifdef VK_KHR_win32_surface
void marshal_VkWin32SurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkWin32SurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkWin32SurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkWin32SurfaceCreateFlagsKHR));
    vkStream->write((HINSTANCE*)&forMarshaling->hinstance, sizeof(HINSTANCE));
    vkStream->write((HWND*)&forMarshaling->hwnd, sizeof(HWND));
}

void unmarshal_VkWin32SurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkWin32SurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkWin32SurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkWin32SurfaceCreateFlagsKHR));
    vkStream->read((HINSTANCE*)&forUnmarshaling->hinstance, sizeof(HINSTANCE));
    vkStream->read((HWND*)&forUnmarshaling->hwnd, sizeof(HWND));
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_device_group
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_device_group_creation
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void marshal_VkImportMemoryWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkImportMemoryWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->write((HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkImportMemoryWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkImportMemoryWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->read((HANDLE*)&forUnmarshaling->handle, sizeof(HANDLE));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkExportMemoryWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkExportMemoryWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pAttributes)
    {
        vkStream->write((const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->write((DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkExportMemoryWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkExportMemoryWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    // WARNING PTR CHECK
    forUnmarshaling->pAttributes = (const SECURITY_ATTRIBUTES*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        vkStream->read((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->read((DWORD*)&forUnmarshaling->dwAccess, sizeof(DWORD));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkMemoryWin32HandlePropertiesKHR(
    VulkanStream* vkStream,
    const VkMemoryWin32HandlePropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkMemoryWin32HandlePropertiesKHR(
    VulkanStream* vkStream,
    VkMemoryWin32HandlePropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_VkMemoryGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkMemoryGetWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void unmarshal_VkMemoryGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkMemoryGetWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_0, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

#endif
#ifdef VK_KHR_external_memory_fd
void marshal_VkImportMemoryFdInfoKHR(
    VulkanStream* vkStream,
    const VkImportMemoryFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->write((int*)&forMarshaling->fd, sizeof(int));
}

void unmarshal_VkImportMemoryFdInfoKHR(
    VulkanStream* vkStream,
    VkImportMemoryFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->read((int*)&forUnmarshaling->fd, sizeof(int));
}

void marshal_VkMemoryFdPropertiesKHR(
    VulkanStream* vkStream,
    const VkMemoryFdPropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkMemoryFdPropertiesKHR(
    VulkanStream* vkStream,
    VkMemoryFdPropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_VkMemoryGetFdInfoKHR(
    VulkanStream* vkStream,
    const VkMemoryGetFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void unmarshal_VkMemoryGetFdInfoKHR(
    VulkanStream* vkStream,
    VkMemoryGetFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_0, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void marshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    VulkanStream* vkStream,
    const VkWin32KeyedMutexAcquireReleaseInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->acquireCount, sizeof(uint32_t));
    if (forMarshaling->acquireCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forMarshaling->acquireCount * 8);
        vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(forMarshaling->pAcquireSyncs, cgen_var_0, forMarshaling->acquireCount);
        vkStream->write((uint64_t*)cgen_var_0, forMarshaling->acquireCount * 8);
    }
    vkStream->write((const uint64_t*)forMarshaling->pAcquireKeys, forMarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->write((const uint32_t*)forMarshaling->pAcquireTimeouts, forMarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->releaseCount, sizeof(uint32_t));
    if (forMarshaling->releaseCount)
    {
        uint64_t* cgen_var_1;
        vkStream->alloc((void**)&cgen_var_1, forMarshaling->releaseCount * 8);
        vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(forMarshaling->pReleaseSyncs, cgen_var_1, forMarshaling->releaseCount);
        vkStream->write((uint64_t*)cgen_var_1, forMarshaling->releaseCount * 8);
    }
    vkStream->write((const uint64_t*)forMarshaling->pReleaseKeys, forMarshaling->releaseCount * sizeof(const uint64_t));
}

void unmarshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    VulkanStream* vkStream,
    VkWin32KeyedMutexAcquireReleaseInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->acquireCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAcquireSyncs, forUnmarshaling->acquireCount * sizeof(const VkDeviceMemory));
    if (forUnmarshaling->acquireCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forUnmarshaling->acquireCount * 8);
        vkStream->read((uint64_t*)cgen_var_0, forUnmarshaling->acquireCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(cgen_var_0, (VkDeviceMemory*)forUnmarshaling->pAcquireSyncs, forUnmarshaling->acquireCount);
    }
    vkStream->alloc((void**)&forUnmarshaling->pAcquireKeys, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->read((uint64_t*)forUnmarshaling->pAcquireKeys, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->alloc((void**)&forUnmarshaling->pAcquireTimeouts, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pAcquireTimeouts, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->releaseCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pReleaseSyncs, forUnmarshaling->releaseCount * sizeof(const VkDeviceMemory));
    if (forUnmarshaling->releaseCount)
    {
        uint64_t* cgen_var_1;
        vkStream->alloc((void**)&cgen_var_1, forUnmarshaling->releaseCount * 8);
        vkStream->read((uint64_t*)cgen_var_1, forUnmarshaling->releaseCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(cgen_var_1, (VkDeviceMemory*)forUnmarshaling->pReleaseSyncs, forUnmarshaling->releaseCount);
    }
    vkStream->alloc((void**)&forUnmarshaling->pReleaseKeys, forUnmarshaling->releaseCount * sizeof(const uint64_t));
    vkStream->read((uint64_t*)forUnmarshaling->pReleaseKeys, forUnmarshaling->releaseCount * sizeof(const uint64_t));
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void marshal_VkImportSemaphoreWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkImportSemaphoreWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkSemaphore_u64(&forMarshaling->semaphore, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkSemaphoreImportFlags*)&forMarshaling->flags, sizeof(VkSemaphoreImportFlags));
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    vkStream->write((HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkImportSemaphoreWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkImportSemaphoreWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_0, (VkSemaphore*)&forUnmarshaling->semaphore, 1);
    vkStream->read((VkSemaphoreImportFlags*)&forUnmarshaling->flags, sizeof(VkSemaphoreImportFlags));
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    vkStream->read((HANDLE*)&forUnmarshaling->handle, sizeof(HANDLE));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkExportSemaphoreWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkExportSemaphoreWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pAttributes)
    {
        vkStream->write((const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->write((DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkExportSemaphoreWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkExportSemaphoreWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    // WARNING PTR CHECK
    forUnmarshaling->pAttributes = (const SECURITY_ATTRIBUTES*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        vkStream->read((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->read((DWORD*)&forUnmarshaling->dwAccess, sizeof(DWORD));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkD3D12FenceSubmitInfoKHR(
    VulkanStream* vkStream,
    const VkD3D12FenceSubmitInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreValuesCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pWaitSemaphoreValues;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pWaitSemaphoreValues)
    {
        vkStream->write((const uint64_t*)forMarshaling->pWaitSemaphoreValues, forMarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t));
    }
    vkStream->write((uint32_t*)&forMarshaling->signalSemaphoreValuesCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pSignalSemaphoreValues;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pSignalSemaphoreValues)
    {
        vkStream->write((const uint64_t*)forMarshaling->pSignalSemaphoreValues, forMarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t));
    }
}

void unmarshal_VkD3D12FenceSubmitInfoKHR(
    VulkanStream* vkStream,
    VkD3D12FenceSubmitInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreValuesCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pWaitSemaphoreValues = (const uint64_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pWaitSemaphoreValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphoreValues, forUnmarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t));
        vkStream->read((uint64_t*)forUnmarshaling->pWaitSemaphoreValues, forUnmarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->signalSemaphoreValuesCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pSignalSemaphoreValues = (const uint64_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pSignalSemaphoreValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphoreValues, forUnmarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t));
        vkStream->read((uint64_t*)forUnmarshaling->pSignalSemaphoreValues, forUnmarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t));
    }
}

void marshal_VkSemaphoreGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkSemaphoreGetWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkSemaphore_u64(&forMarshaling->semaphore, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

void unmarshal_VkSemaphoreGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkSemaphoreGetWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_0, (VkSemaphore*)&forUnmarshaling->semaphore, 1);
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void marshal_VkImportSemaphoreFdInfoKHR(
    VulkanStream* vkStream,
    const VkImportSemaphoreFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkSemaphore_u64(&forMarshaling->semaphore, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkSemaphoreImportFlags*)&forMarshaling->flags, sizeof(VkSemaphoreImportFlags));
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    vkStream->write((int*)&forMarshaling->fd, sizeof(int));
}

void unmarshal_VkImportSemaphoreFdInfoKHR(
    VulkanStream* vkStream,
    VkImportSemaphoreFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_0, (VkSemaphore*)&forUnmarshaling->semaphore, 1);
    vkStream->read((VkSemaphoreImportFlags*)&forUnmarshaling->flags, sizeof(VkSemaphoreImportFlags));
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    vkStream->read((int*)&forUnmarshaling->fd, sizeof(int));
}

void marshal_VkSemaphoreGetFdInfoKHR(
    VulkanStream* vkStream,
    const VkSemaphoreGetFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkSemaphore_u64(&forMarshaling->semaphore, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

void unmarshal_VkSemaphoreGetFdInfoKHR(
    VulkanStream* vkStream,
    VkSemaphoreGetFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_0, (VkSemaphore*)&forUnmarshaling->semaphore, 1);
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

#endif
#ifdef VK_KHR_push_descriptor
void marshal_VkPhysicalDevicePushDescriptorPropertiesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDevicePushDescriptorPropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->maxPushDescriptors, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDevicePushDescriptorPropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevicePushDescriptorPropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxPushDescriptors, sizeof(uint32_t));
}

#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void marshal_VkRectLayerKHR(
    VulkanStream* vkStream,
    const VkRectLayerKHR* forMarshaling)
{
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->offset));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->extent));
    vkStream->write((uint32_t*)&forMarshaling->layer, sizeof(uint32_t));
}

void unmarshal_VkRectLayerKHR(
    VulkanStream* vkStream,
    VkRectLayerKHR* forUnmarshaling)
{
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->offset));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->extent));
    vkStream->read((uint32_t*)&forUnmarshaling->layer, sizeof(uint32_t));
}

void marshal_VkPresentRegionKHR(
    VulkanStream* vkStream,
    const VkPresentRegionKHR* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->rectangleCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pRectangles;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->rectangleCount; ++i)
        {
            marshal_VkRectLayerKHR(vkStream, (const VkRectLayerKHR*)(forMarshaling->pRectangles + i));
        }
    }
}

void unmarshal_VkPresentRegionKHR(
    VulkanStream* vkStream,
    VkPresentRegionKHR* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->rectangleCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pRectangles = (const VkRectLayerKHR*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pRectangles)
    {
        vkStream->alloc((void**)&forUnmarshaling->pRectangles, forUnmarshaling->rectangleCount * sizeof(const VkRectLayerKHR));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->rectangleCount; ++i)
        {
            unmarshal_VkRectLayerKHR(vkStream, (VkRectLayerKHR*)(forUnmarshaling->pRectangles + i));
        }
    }
}

void marshal_VkPresentRegionsKHR(
    VulkanStream* vkStream,
    const VkPresentRegionsKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pRegions;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->swapchainCount; ++i)
        {
            marshal_VkPresentRegionKHR(vkStream, (const VkPresentRegionKHR*)(forMarshaling->pRegions + i));
        }
    }
}

void unmarshal_VkPresentRegionsKHR(
    VulkanStream* vkStream,
    VkPresentRegionsKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->swapchainCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pRegions = (const VkPresentRegionKHR*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pRegions)
    {
        vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->swapchainCount * sizeof(const VkPresentRegionKHR));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->swapchainCount; ++i)
        {
            unmarshal_VkPresentRegionKHR(vkStream, (VkPresentRegionKHR*)(forUnmarshaling->pRegions + i));
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_imageless_framebuffer
#endif
#ifdef VK_KHR_create_renderpass2
#endif
#ifdef VK_KHR_shared_presentable_image
void marshal_VkSharedPresentSurfaceCapabilitiesKHR(
    VulkanStream* vkStream,
    const VkSharedPresentSurfaceCapabilitiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkImageUsageFlags*)&forMarshaling->sharedPresentSupportedUsageFlags, sizeof(VkImageUsageFlags));
}

void unmarshal_VkSharedPresentSurfaceCapabilitiesKHR(
    VulkanStream* vkStream,
    VkSharedPresentSurfaceCapabilitiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->sharedPresentSupportedUsageFlags, sizeof(VkImageUsageFlags));
}

#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void marshal_VkImportFenceWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkImportFenceWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkFence_u64(&forMarshaling->fence, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkFenceImportFlags*)&forMarshaling->flags, sizeof(VkFenceImportFlags));
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    vkStream->write((HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkImportFenceWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkImportFenceWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_0, (VkFence*)&forUnmarshaling->fence, 1);
    vkStream->read((VkFenceImportFlags*)&forUnmarshaling->flags, sizeof(VkFenceImportFlags));
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    vkStream->read((HANDLE*)&forUnmarshaling->handle, sizeof(HANDLE));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkExportFenceWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkExportFenceWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pAttributes)
    {
        vkStream->write((const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->write((DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkExportFenceWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkExportFenceWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    // WARNING PTR CHECK
    forUnmarshaling->pAttributes = (const SECURITY_ATTRIBUTES*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        vkStream->read((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->read((DWORD*)&forUnmarshaling->dwAccess, sizeof(DWORD));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkFenceGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkFenceGetWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkFence_u64(&forMarshaling->fence, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

void unmarshal_VkFenceGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkFenceGetWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_0, (VkFence*)&forUnmarshaling->fence, 1);
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

#endif
#ifdef VK_KHR_external_fence_fd
void marshal_VkImportFenceFdInfoKHR(
    VulkanStream* vkStream,
    const VkImportFenceFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkFence_u64(&forMarshaling->fence, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkFenceImportFlags*)&forMarshaling->flags, sizeof(VkFenceImportFlags));
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    vkStream->write((int*)&forMarshaling->fd, sizeof(int));
}

void unmarshal_VkImportFenceFdInfoKHR(
    VulkanStream* vkStream,
    VkImportFenceFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_0, (VkFence*)&forUnmarshaling->fence, 1);
    vkStream->read((VkFenceImportFlags*)&forUnmarshaling->flags, sizeof(VkFenceImportFlags));
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    vkStream->read((int*)&forUnmarshaling->fd, sizeof(int));
}

void marshal_VkFenceGetFdInfoKHR(
    VulkanStream* vkStream,
    const VkFenceGetFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkFence_u64(&forMarshaling->fence, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

void unmarshal_VkFenceGetFdInfoKHR(
    VulkanStream* vkStream,
    VkFenceGetFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_0, (VkFence*)&forUnmarshaling->fence, 1);
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

#endif
#ifdef VK_KHR_performance_query
void marshal_VkPhysicalDevicePerformanceQueryFeaturesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDevicePerformanceQueryFeaturesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->performanceCounterQueryPools, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->performanceCounterMultipleQueryPools, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDevicePerformanceQueryFeaturesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevicePerformanceQueryFeaturesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->performanceCounterQueryPools, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->performanceCounterMultipleQueryPools, sizeof(VkBool32));
}

void marshal_VkPhysicalDevicePerformanceQueryPropertiesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDevicePerformanceQueryPropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->allowCommandBufferQueryCopies, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDevicePerformanceQueryPropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevicePerformanceQueryPropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->allowCommandBufferQueryCopies, sizeof(VkBool32));
}

void marshal_VkPerformanceCounterKHR(
    VulkanStream* vkStream,
    const VkPerformanceCounterKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPerformanceCounterUnitKHR*)&forMarshaling->unit, sizeof(VkPerformanceCounterUnitKHR));
    vkStream->write((VkPerformanceCounterScopeKHR*)&forMarshaling->scope, sizeof(VkPerformanceCounterScopeKHR));
    vkStream->write((VkPerformanceCounterStorageKHR*)&forMarshaling->storage, sizeof(VkPerformanceCounterStorageKHR));
    vkStream->write((uint8_t*)forMarshaling->uuid, VK_UUID_SIZE * sizeof(uint8_t));
}

void unmarshal_VkPerformanceCounterKHR(
    VulkanStream* vkStream,
    VkPerformanceCounterKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPerformanceCounterUnitKHR*)&forUnmarshaling->unit, sizeof(VkPerformanceCounterUnitKHR));
    vkStream->read((VkPerformanceCounterScopeKHR*)&forUnmarshaling->scope, sizeof(VkPerformanceCounterScopeKHR));
    vkStream->read((VkPerformanceCounterStorageKHR*)&forUnmarshaling->storage, sizeof(VkPerformanceCounterStorageKHR));
    vkStream->read((uint8_t*)forUnmarshaling->uuid, VK_UUID_SIZE * sizeof(uint8_t));
}

void marshal_VkPerformanceCounterDescriptionKHR(
    VulkanStream* vkStream,
    const VkPerformanceCounterDescriptionKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPerformanceCounterDescriptionFlagsKHR*)&forMarshaling->flags, sizeof(VkPerformanceCounterDescriptionFlagsKHR));
    vkStream->write((char*)forMarshaling->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->write((char*)forMarshaling->category, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->write((char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
}

void unmarshal_VkPerformanceCounterDescriptionKHR(
    VulkanStream* vkStream,
    VkPerformanceCounterDescriptionKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPerformanceCounterDescriptionFlagsKHR*)&forUnmarshaling->flags, sizeof(VkPerformanceCounterDescriptionFlagsKHR));
    vkStream->read((char*)forUnmarshaling->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->read((char*)forUnmarshaling->category, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->read((char*)forUnmarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
}

void marshal_VkQueryPoolPerformanceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkQueryPoolPerformanceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->counterIndexCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pCounterIndices, forMarshaling->counterIndexCount * sizeof(const uint32_t));
}

void unmarshal_VkQueryPoolPerformanceCreateInfoKHR(
    VulkanStream* vkStream,
    VkQueryPoolPerformanceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->counterIndexCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pCounterIndices, forUnmarshaling->counterIndexCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pCounterIndices, forUnmarshaling->counterIndexCount * sizeof(const uint32_t));
}

void marshal_VkPerformanceCounterResultKHR(
    VulkanStream* vkStream,
    const VkPerformanceCounterResultKHR* forMarshaling)
{
    vkStream->write((int32_t*)&forMarshaling->int32, sizeof(int32_t));
}

void unmarshal_VkPerformanceCounterResultKHR(
    VulkanStream* vkStream,
    VkPerformanceCounterResultKHR* forUnmarshaling)
{
    vkStream->read((int32_t*)&forUnmarshaling->int32, sizeof(int32_t));
}

void marshal_VkAcquireProfilingLockInfoKHR(
    VulkanStream* vkStream,
    const VkAcquireProfilingLockInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkAcquireProfilingLockFlagsKHR*)&forMarshaling->flags, sizeof(VkAcquireProfilingLockFlagsKHR));
    vkStream->write((uint64_t*)&forMarshaling->timeout, sizeof(uint64_t));
}

void unmarshal_VkAcquireProfilingLockInfoKHR(
    VulkanStream* vkStream,
    VkAcquireProfilingLockInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAcquireProfilingLockFlagsKHR*)&forUnmarshaling->flags, sizeof(VkAcquireProfilingLockFlagsKHR));
    vkStream->read((uint64_t*)&forUnmarshaling->timeout, sizeof(uint64_t));
}

void marshal_VkPerformanceQuerySubmitInfoKHR(
    VulkanStream* vkStream,
    const VkPerformanceQuerySubmitInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->counterPassIndex, sizeof(uint32_t));
}

void unmarshal_VkPerformanceQuerySubmitInfoKHR(
    VulkanStream* vkStream,
    VkPerformanceQuerySubmitInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->counterPassIndex, sizeof(uint32_t));
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void marshal_VkPhysicalDeviceSurfaceInfo2KHR(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSurfaceInfo2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&forMarshaling->surface, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
}

void unmarshal_VkPhysicalDeviceSurfaceInfo2KHR(
    VulkanStream* vkStream,
    VkPhysicalDeviceSurfaceInfo2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_0, (VkSurfaceKHR*)&forUnmarshaling->surface, 1);
}

void marshal_VkSurfaceCapabilities2KHR(
    VulkanStream* vkStream,
    const VkSurfaceCapabilities2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(&forMarshaling->surfaceCapabilities));
}

void unmarshal_VkSurfaceCapabilities2KHR(
    VulkanStream* vkStream,
    VkSurfaceCapabilities2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(&forUnmarshaling->surfaceCapabilities));
}

void marshal_VkSurfaceFormat2KHR(
    VulkanStream* vkStream,
    const VkSurfaceFormat2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(&forMarshaling->surfaceFormat));
}

void unmarshal_VkSurfaceFormat2KHR(
    VulkanStream* vkStream,
    VkSurfaceFormat2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(&forUnmarshaling->surfaceFormat));
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void marshal_VkDisplayProperties2KHR(
    VulkanStream* vkStream,
    const VkDisplayProperties2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(&forMarshaling->displayProperties));
}

void unmarshal_VkDisplayProperties2KHR(
    VulkanStream* vkStream,
    VkDisplayProperties2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(&forUnmarshaling->displayProperties));
}

void marshal_VkDisplayPlaneProperties2KHR(
    VulkanStream* vkStream,
    const VkDisplayPlaneProperties2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(&forMarshaling->displayPlaneProperties));
}

void unmarshal_VkDisplayPlaneProperties2KHR(
    VulkanStream* vkStream,
    VkDisplayPlaneProperties2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(&forUnmarshaling->displayPlaneProperties));
}

void marshal_VkDisplayModeProperties2KHR(
    VulkanStream* vkStream,
    const VkDisplayModeProperties2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(&forMarshaling->displayModeProperties));
}

void unmarshal_VkDisplayModeProperties2KHR(
    VulkanStream* vkStream,
    VkDisplayModeProperties2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(&forUnmarshaling->displayModeProperties));
}

void marshal_VkDisplayPlaneInfo2KHR(
    VulkanStream* vkStream,
    const VkDisplayPlaneInfo2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(&forMarshaling->mode, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->planeIndex, sizeof(uint32_t));
}

void unmarshal_VkDisplayPlaneInfo2KHR(
    VulkanStream* vkStream,
    VkDisplayPlaneInfo2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_0, (VkDisplayModeKHR*)&forUnmarshaling->mode, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->planeIndex, sizeof(uint32_t));
}

void marshal_VkDisplayPlaneCapabilities2KHR(
    VulkanStream* vkStream,
    const VkDisplayPlaneCapabilities2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(&forMarshaling->capabilities));
}

void unmarshal_VkDisplayPlaneCapabilities2KHR(
    VulkanStream* vkStream,
    VkDisplayPlaneCapabilities2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(&forUnmarshaling->capabilities));
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_portability_subset
void marshal_VkPhysicalDevicePortabilitySubsetFeaturesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDevicePortabilitySubsetFeaturesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->constantAlphaColorBlendFactors, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->events, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->imageViewFormatReinterpretation, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->imageViewFormatSwizzle, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->imageView2DOn3DImage, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multisampleArrayImage, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->mutableComparisonSamplers, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->pointPolygons, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->samplerMipLodBias, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->separateStencilMaskRef, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSampleRateInterpolationFunctions, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->tessellationIsolines, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->tessellationPointMode, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->triangleFans, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->vertexAttributeAccessBeyondStride, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDevicePortabilitySubsetFeaturesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevicePortabilitySubsetFeaturesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->constantAlphaColorBlendFactors, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->events, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->imageViewFormatReinterpretation, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->imageViewFormatSwizzle, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->imageView2DOn3DImage, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multisampleArrayImage, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->mutableComparisonSamplers, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->pointPolygons, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->samplerMipLodBias, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->separateStencilMaskRef, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSampleRateInterpolationFunctions, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->tessellationIsolines, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->tessellationPointMode, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->triangleFans, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->vertexAttributeAccessBeyondStride, sizeof(VkBool32));
}

void marshal_VkPhysicalDevicePortabilitySubsetPropertiesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDevicePortabilitySubsetPropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->minVertexInputBindingStrideAlignment, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDevicePortabilitySubsetPropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevicePortabilitySubsetPropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->minVertexInputBindingStrideAlignment, sizeof(uint32_t));
}

#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_draw_indirect_count
#endif
#ifdef VK_KHR_shader_subgroup_extended_types
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_KHR_shader_atomic_int64
#endif
#ifdef VK_KHR_shader_clock
void marshal_VkPhysicalDeviceShaderClockFeaturesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderClockFeaturesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->shaderSubgroupClock, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderDeviceClock, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShaderClockFeaturesKHR(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderClockFeaturesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSubgroupClock, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDeviceClock, sizeof(VkBool32));
}

#endif
#ifdef VK_KHR_driver_properties
#endif
#ifdef VK_KHR_shader_float_controls
#endif
#ifdef VK_KHR_depth_stencil_resolve
#endif
#ifdef VK_KHR_swapchain_mutable_format
#endif
#ifdef VK_KHR_timeline_semaphore
#endif
#ifdef VK_KHR_vulkan_memory_model
#endif
#ifdef VK_KHR_shader_terminate_invocation
void marshal_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->shaderTerminateInvocation, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shaderTerminateInvocation, sizeof(VkBool32));
}

#endif
#ifdef VK_KHR_fragment_shading_rate
void marshal_VkFragmentShadingRateAttachmentInfoKHR(
    VulkanStream* vkStream,
    const VkFragmentShadingRateAttachmentInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkAttachmentReference2(vkStream, (const VkAttachmentReference2*)(forMarshaling->pFragmentShadingRateAttachment));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->shadingRateAttachmentTexelSize));
}

void unmarshal_VkFragmentShadingRateAttachmentInfoKHR(
    VulkanStream* vkStream,
    VkFragmentShadingRateAttachmentInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->alloc((void**)&forUnmarshaling->pFragmentShadingRateAttachment, sizeof(const VkAttachmentReference2));
    unmarshal_VkAttachmentReference2(vkStream, (VkAttachmentReference2*)(forUnmarshaling->pFragmentShadingRateAttachment));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->shadingRateAttachmentTexelSize));
}

void marshal_VkPipelineFragmentShadingRateStateCreateInfoKHR(
    VulkanStream* vkStream,
    const VkPipelineFragmentShadingRateStateCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->fragmentSize));
    vkStream->write((VkFragmentShadingRateCombinerOpKHR*)forMarshaling->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
}

void unmarshal_VkPipelineFragmentShadingRateStateCreateInfoKHR(
    VulkanStream* vkStream,
    VkPipelineFragmentShadingRateStateCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->fragmentSize));
    vkStream->read((VkFragmentShadingRateCombinerOpKHR*)forUnmarshaling->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
}

void marshal_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDeviceFragmentShadingRateFeaturesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->pipelineFragmentShadingRate, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->primitiveFragmentShadingRate, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->attachmentFragmentShadingRate, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(
    VulkanStream* vkStream,
    VkPhysicalDeviceFragmentShadingRateFeaturesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->pipelineFragmentShadingRate, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->primitiveFragmentShadingRate, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->attachmentFragmentShadingRate, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDeviceFragmentShadingRatePropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minFragmentShadingRateAttachmentTexelSize));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxFragmentShadingRateAttachmentTexelSize));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentShadingRateAttachmentTexelSizeAspectRatio, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->primitiveFragmentShadingRateWithMultipleViewports, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->layeredShadingRateAttachments, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fragmentShadingRateNonTrivialCombinerOps, sizeof(VkBool32));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxFragmentSize));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentSizeAspectRatio, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentShadingRateCoverageSamples, sizeof(uint32_t));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->maxFragmentShadingRateRasterizationSamples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkBool32*)&forMarshaling->fragmentShadingRateWithShaderDepthStencilWrites, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fragmentShadingRateWithSampleMask, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fragmentShadingRateWithShaderSampleMask, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fragmentShadingRateWithConservativeRasterization, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fragmentShadingRateWithFragmentShaderInterlock, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fragmentShadingRateWithCustomSampleLocations, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fragmentShadingRateStrictMultiplyCombiner, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDeviceFragmentShadingRatePropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minFragmentShadingRateAttachmentTexelSize));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxFragmentShadingRateAttachmentTexelSize));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentShadingRateAttachmentTexelSizeAspectRatio, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->primitiveFragmentShadingRateWithMultipleViewports, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->layeredShadingRateAttachments, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentShadingRateNonTrivialCombinerOps, sizeof(VkBool32));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxFragmentSize));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentSizeAspectRatio, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentShadingRateCoverageSamples, sizeof(uint32_t));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->maxFragmentShadingRateRasterizationSamples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentShadingRateWithShaderDepthStencilWrites, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentShadingRateWithSampleMask, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentShadingRateWithShaderSampleMask, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentShadingRateWithConservativeRasterization, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentShadingRateWithFragmentShaderInterlock, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentShadingRateWithCustomSampleLocations, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentShadingRateStrictMultiplyCombiner, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceFragmentShadingRateKHR(
    VulkanStream* vkStream,
    const VkPhysicalDeviceFragmentShadingRateKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampleCounts, sizeof(VkSampleCountFlags));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->fragmentSize));
}

void unmarshal_VkPhysicalDeviceFragmentShadingRateKHR(
    VulkanStream* vkStream,
    VkPhysicalDeviceFragmentShadingRateKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampleCounts, sizeof(VkSampleCountFlags));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->fragmentSize));
}

#endif
#ifdef VK_KHR_spirv_1_4
#endif
#ifdef VK_KHR_surface_protected_capabilities
void marshal_VkSurfaceProtectedCapabilitiesKHR(
    VulkanStream* vkStream,
    const VkSurfaceProtectedCapabilitiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->supportsProtected, sizeof(VkBool32));
}

void unmarshal_VkSurfaceProtectedCapabilitiesKHR(
    VulkanStream* vkStream,
    VkSurfaceProtectedCapabilitiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->supportsProtected, sizeof(VkBool32));
}

#endif
#ifdef VK_KHR_separate_depth_stencil_layouts
#endif
#ifdef VK_KHR_uniform_buffer_standard_layout
#endif
#ifdef VK_KHR_buffer_device_address
#endif
#ifdef VK_KHR_deferred_host_operations
#endif
#ifdef VK_KHR_pipeline_executable_properties
void marshal_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->pipelineExecutableInfo, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->pipelineExecutableInfo, sizeof(VkBool32));
}

void marshal_VkPipelineInfoKHR(
    VulkanStream* vkStream,
    const VkPipelineInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkPipeline_u64(&forMarshaling->pipeline, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
}

void unmarshal_VkPipelineInfoKHR(
    VulkanStream* vkStream,
    VkPipelineInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_0, (VkPipeline*)&forUnmarshaling->pipeline, 1);
}

void marshal_VkPipelineExecutablePropertiesKHR(
    VulkanStream* vkStream,
    const VkPipelineExecutablePropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkShaderStageFlags*)&forMarshaling->stages, sizeof(VkShaderStageFlags));
    vkStream->write((char*)forMarshaling->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->write((char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->write((uint32_t*)&forMarshaling->subgroupSize, sizeof(uint32_t));
}

void unmarshal_VkPipelineExecutablePropertiesKHR(
    VulkanStream* vkStream,
    VkPipelineExecutablePropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->stages, sizeof(VkShaderStageFlags));
    vkStream->read((char*)forUnmarshaling->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->read((char*)forUnmarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->read((uint32_t*)&forUnmarshaling->subgroupSize, sizeof(uint32_t));
}

void marshal_VkPipelineExecutableInfoKHR(
    VulkanStream* vkStream,
    const VkPipelineExecutableInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkPipeline_u64(&forMarshaling->pipeline, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->executableIndex, sizeof(uint32_t));
}

void unmarshal_VkPipelineExecutableInfoKHR(
    VulkanStream* vkStream,
    VkPipelineExecutableInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_0, (VkPipeline*)&forUnmarshaling->pipeline, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->executableIndex, sizeof(uint32_t));
}

void marshal_VkPipelineExecutableStatisticValueKHR(
    VulkanStream* vkStream,
    const VkPipelineExecutableStatisticValueKHR* forMarshaling)
{
    vkStream->write((VkBool32*)&forMarshaling->b32, sizeof(VkBool32));
}

void unmarshal_VkPipelineExecutableStatisticValueKHR(
    VulkanStream* vkStream,
    VkPipelineExecutableStatisticValueKHR* forUnmarshaling)
{
    vkStream->read((VkBool32*)&forUnmarshaling->b32, sizeof(VkBool32));
}

void marshal_VkPipelineExecutableStatisticKHR(
    VulkanStream* vkStream,
    const VkPipelineExecutableStatisticKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((char*)forMarshaling->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->write((char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->write((VkPipelineExecutableStatisticFormatKHR*)&forMarshaling->format, sizeof(VkPipelineExecutableStatisticFormatKHR));
    marshal_VkPipelineExecutableStatisticValueKHR(vkStream, (VkPipelineExecutableStatisticValueKHR*)(&forMarshaling->value));
}

void unmarshal_VkPipelineExecutableStatisticKHR(
    VulkanStream* vkStream,
    VkPipelineExecutableStatisticKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((char*)forUnmarshaling->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->read((char*)forUnmarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->read((VkPipelineExecutableStatisticFormatKHR*)&forUnmarshaling->format, sizeof(VkPipelineExecutableStatisticFormatKHR));
    unmarshal_VkPipelineExecutableStatisticValueKHR(vkStream, (VkPipelineExecutableStatisticValueKHR*)(&forUnmarshaling->value));
}

void marshal_VkPipelineExecutableInternalRepresentationKHR(
    VulkanStream* vkStream,
    const VkPipelineExecutableInternalRepresentationKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((char*)forMarshaling->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->write((char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->write((VkBool32*)&forMarshaling->isText, sizeof(VkBool32));
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->dataSize;
    vkStream->putBe64(cgen_var_0);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pData;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pData)
    {
        vkStream->write((void*)forMarshaling->pData, forMarshaling->dataSize * sizeof(uint8_t));
    }
}

void unmarshal_VkPipelineExecutableInternalRepresentationKHR(
    VulkanStream* vkStream,
    VkPipelineExecutableInternalRepresentationKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((char*)forUnmarshaling->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->read((char*)forUnmarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->read((VkBool32*)&forUnmarshaling->isText, sizeof(VkBool32));
    forUnmarshaling->dataSize = (size_t)vkStream->getBe64();
    // WARNING PTR CHECK
    forUnmarshaling->pData = (void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pData, forUnmarshaling->dataSize * sizeof(uint8_t));
        vkStream->read((void*)forUnmarshaling->pData, forUnmarshaling->dataSize * sizeof(uint8_t));
    }
}

#endif
#ifdef VK_KHR_pipeline_library
void marshal_VkPipelineLibraryCreateInfoKHR(
    VulkanStream* vkStream,
    const VkPipelineLibraryCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->libraryCount, sizeof(uint32_t));
    if (forMarshaling->libraryCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forMarshaling->libraryCount * 8);
        vkStream->handleMapping()->mapHandles_VkPipeline_u64(forMarshaling->pLibraries, cgen_var_0, forMarshaling->libraryCount);
        vkStream->write((uint64_t*)cgen_var_0, forMarshaling->libraryCount * 8);
    }
}

void unmarshal_VkPipelineLibraryCreateInfoKHR(
    VulkanStream* vkStream,
    VkPipelineLibraryCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->libraryCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pLibraries, forUnmarshaling->libraryCount * sizeof(const VkPipeline));
    if (forUnmarshaling->libraryCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forUnmarshaling->libraryCount * 8);
        vkStream->read((uint64_t*)cgen_var_0, forUnmarshaling->libraryCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_0, (VkPipeline*)forUnmarshaling->pLibraries, forUnmarshaling->libraryCount);
    }
}

#endif
#ifdef VK_KHR_shader_non_semantic_info
#endif
#ifdef VK_KHR_copy_commands2
void marshal_VkBufferCopy2KHR(
    VulkanStream* vkStream,
    const VkBufferCopy2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceSize*)&forMarshaling->srcOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->dstOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
}

void unmarshal_VkBufferCopy2KHR(
    VulkanStream* vkStream,
    VkBufferCopy2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceSize*)&forUnmarshaling->srcOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->dstOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
}

void marshal_VkCopyBufferInfo2KHR(
    VulkanStream* vkStream,
    const VkCopyBufferInfo2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->srcBuffer, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->dstBuffer, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->regionCount; ++i)
    {
        marshal_VkBufferCopy2KHR(vkStream, (const VkBufferCopy2KHR*)(forMarshaling->pRegions + i));
    }
}

void unmarshal_VkCopyBufferInfo2KHR(
    VulkanStream* vkStream,
    VkCopyBufferInfo2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_0, (VkBuffer*)&forUnmarshaling->srcBuffer, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_1, (VkBuffer*)&forUnmarshaling->dstBuffer, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->regionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->regionCount * sizeof(const VkBufferCopy2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->regionCount; ++i)
    {
        unmarshal_VkBufferCopy2KHR(vkStream, (VkBufferCopy2KHR*)(forUnmarshaling->pRegions + i));
    }
}

void marshal_VkImageCopy2KHR(
    VulkanStream* vkStream,
    const VkImageCopy2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->srcOffset));
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->dstOffset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent));
}

void unmarshal_VkImageCopy2KHR(
    VulkanStream* vkStream,
    VkImageCopy2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->srcOffset));
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->dstOffset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent));
}

void marshal_VkCopyImageInfo2KHR(
    VulkanStream* vkStream,
    const VkCopyImageInfo2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->srcImage, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkImageLayout*)&forMarshaling->srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->dstImage, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((VkImageLayout*)&forMarshaling->dstImageLayout, sizeof(VkImageLayout));
    vkStream->write((uint32_t*)&forMarshaling->regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->regionCount; ++i)
    {
        marshal_VkImageCopy2KHR(vkStream, (const VkImageCopy2KHR*)(forMarshaling->pRegions + i));
    }
}

void unmarshal_VkCopyImageInfo2KHR(
    VulkanStream* vkStream,
    VkCopyImageInfo2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_0, (VkImage*)&forUnmarshaling->srcImage, 1);
    vkStream->read((VkImageLayout*)&forUnmarshaling->srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_1, (VkImage*)&forUnmarshaling->dstImage, 1);
    vkStream->read((VkImageLayout*)&forUnmarshaling->dstImageLayout, sizeof(VkImageLayout));
    vkStream->read((uint32_t*)&forUnmarshaling->regionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->regionCount * sizeof(const VkImageCopy2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->regionCount; ++i)
    {
        unmarshal_VkImageCopy2KHR(vkStream, (VkImageCopy2KHR*)(forUnmarshaling->pRegions + i));
    }
}

void marshal_VkBufferImageCopy2KHR(
    VulkanStream* vkStream,
    const VkBufferImageCopy2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceSize*)&forMarshaling->bufferOffset, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->bufferRowLength, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->bufferImageHeight, sizeof(uint32_t));
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->imageSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->imageOffset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->imageExtent));
}

void unmarshal_VkBufferImageCopy2KHR(
    VulkanStream* vkStream,
    VkBufferImageCopy2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceSize*)&forUnmarshaling->bufferOffset, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->bufferRowLength, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->bufferImageHeight, sizeof(uint32_t));
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->imageSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->imageOffset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->imageExtent));
}

void marshal_VkCopyBufferToImageInfo2KHR(
    VulkanStream* vkStream,
    const VkCopyBufferToImageInfo2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->srcBuffer, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->dstImage, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((VkImageLayout*)&forMarshaling->dstImageLayout, sizeof(VkImageLayout));
    vkStream->write((uint32_t*)&forMarshaling->regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->regionCount; ++i)
    {
        marshal_VkBufferImageCopy2KHR(vkStream, (const VkBufferImageCopy2KHR*)(forMarshaling->pRegions + i));
    }
}

void unmarshal_VkCopyBufferToImageInfo2KHR(
    VulkanStream* vkStream,
    VkCopyBufferToImageInfo2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_0, (VkBuffer*)&forUnmarshaling->srcBuffer, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_1, (VkImage*)&forUnmarshaling->dstImage, 1);
    vkStream->read((VkImageLayout*)&forUnmarshaling->dstImageLayout, sizeof(VkImageLayout));
    vkStream->read((uint32_t*)&forUnmarshaling->regionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->regionCount * sizeof(const VkBufferImageCopy2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->regionCount; ++i)
    {
        unmarshal_VkBufferImageCopy2KHR(vkStream, (VkBufferImageCopy2KHR*)(forUnmarshaling->pRegions + i));
    }
}

void marshal_VkCopyImageToBufferInfo2KHR(
    VulkanStream* vkStream,
    const VkCopyImageToBufferInfo2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->srcImage, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkImageLayout*)&forMarshaling->srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->dstBuffer, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->regionCount; ++i)
    {
        marshal_VkBufferImageCopy2KHR(vkStream, (const VkBufferImageCopy2KHR*)(forMarshaling->pRegions + i));
    }
}

void unmarshal_VkCopyImageToBufferInfo2KHR(
    VulkanStream* vkStream,
    VkCopyImageToBufferInfo2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_0, (VkImage*)&forUnmarshaling->srcImage, 1);
    vkStream->read((VkImageLayout*)&forUnmarshaling->srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_1, (VkBuffer*)&forUnmarshaling->dstBuffer, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->regionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->regionCount * sizeof(const VkBufferImageCopy2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->regionCount; ++i)
    {
        unmarshal_VkBufferImageCopy2KHR(vkStream, (VkBufferImageCopy2KHR*)(forUnmarshaling->pRegions + i));
    }
}

void marshal_VkImageBlit2KHR(
    VulkanStream* vkStream,
    const VkImageBlit2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        marshal_VkOffset3D(vkStream, (VkOffset3D*)(forMarshaling->srcOffsets + i));
    }
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        marshal_VkOffset3D(vkStream, (VkOffset3D*)(forMarshaling->dstOffsets + i));
    }
}

void unmarshal_VkImageBlit2KHR(
    VulkanStream* vkStream,
    VkImageBlit2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(forUnmarshaling->srcOffsets + i));
    }
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(forUnmarshaling->dstOffsets + i));
    }
}

void marshal_VkBlitImageInfo2KHR(
    VulkanStream* vkStream,
    const VkBlitImageInfo2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->srcImage, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkImageLayout*)&forMarshaling->srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->dstImage, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((VkImageLayout*)&forMarshaling->dstImageLayout, sizeof(VkImageLayout));
    vkStream->write((uint32_t*)&forMarshaling->regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->regionCount; ++i)
    {
        marshal_VkImageBlit2KHR(vkStream, (const VkImageBlit2KHR*)(forMarshaling->pRegions + i));
    }
    vkStream->write((VkFilter*)&forMarshaling->filter, sizeof(VkFilter));
}

void unmarshal_VkBlitImageInfo2KHR(
    VulkanStream* vkStream,
    VkBlitImageInfo2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_0, (VkImage*)&forUnmarshaling->srcImage, 1);
    vkStream->read((VkImageLayout*)&forUnmarshaling->srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_1, (VkImage*)&forUnmarshaling->dstImage, 1);
    vkStream->read((VkImageLayout*)&forUnmarshaling->dstImageLayout, sizeof(VkImageLayout));
    vkStream->read((uint32_t*)&forUnmarshaling->regionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->regionCount * sizeof(const VkImageBlit2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->regionCount; ++i)
    {
        unmarshal_VkImageBlit2KHR(vkStream, (VkImageBlit2KHR*)(forUnmarshaling->pRegions + i));
    }
    vkStream->read((VkFilter*)&forUnmarshaling->filter, sizeof(VkFilter));
}

void marshal_VkImageResolve2KHR(
    VulkanStream* vkStream,
    const VkImageResolve2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->srcOffset));
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->dstOffset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent));
}

void unmarshal_VkImageResolve2KHR(
    VulkanStream* vkStream,
    VkImageResolve2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->srcOffset));
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->dstOffset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent));
}

void marshal_VkResolveImageInfo2KHR(
    VulkanStream* vkStream,
    const VkResolveImageInfo2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->srcImage, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkImageLayout*)&forMarshaling->srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->dstImage, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((VkImageLayout*)&forMarshaling->dstImageLayout, sizeof(VkImageLayout));
    vkStream->write((uint32_t*)&forMarshaling->regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->regionCount; ++i)
    {
        marshal_VkImageResolve2KHR(vkStream, (const VkImageResolve2KHR*)(forMarshaling->pRegions + i));
    }
}

void unmarshal_VkResolveImageInfo2KHR(
    VulkanStream* vkStream,
    VkResolveImageInfo2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_0, (VkImage*)&forUnmarshaling->srcImage, 1);
    vkStream->read((VkImageLayout*)&forUnmarshaling->srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_1, (VkImage*)&forUnmarshaling->dstImage, 1);
    vkStream->read((VkImageLayout*)&forUnmarshaling->dstImageLayout, sizeof(VkImageLayout));
    vkStream->read((uint32_t*)&forUnmarshaling->regionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->regionCount * sizeof(const VkImageResolve2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->regionCount; ++i)
    {
        unmarshal_VkImageResolve2KHR(vkStream, (VkImageResolve2KHR*)(forUnmarshaling->pRegions + i));
    }
}

#endif
#ifdef VK_ANDROID_native_buffer
void marshal_VkNativeBufferANDROID(
    VulkanStream* vkStream,
    const VkNativeBufferANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->handle;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->handle)
    {
        vkStream->write((const uint32_t*)forMarshaling->handle, sizeof(const uint32_t));
    }
    vkStream->write((int*)&forMarshaling->stride, sizeof(int));
    vkStream->write((int*)&forMarshaling->format, sizeof(int));
    vkStream->write((int*)&forMarshaling->usage, sizeof(int));
    vkStream->write((uint64_t*)&forMarshaling->consumer, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->producer, sizeof(uint64_t));
}

void unmarshal_VkNativeBufferANDROID(
    VulkanStream* vkStream,
    VkNativeBufferANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    // WARNING PTR CHECK
    forUnmarshaling->handle = (const uint32_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->handle)
    {
        vkStream->alloc((void**)&forUnmarshaling->handle, sizeof(const uint32_t));
        vkStream->read((uint32_t*)forUnmarshaling->handle, sizeof(const uint32_t));
    }
    vkStream->read((int*)&forUnmarshaling->stride, sizeof(int));
    vkStream->read((int*)&forUnmarshaling->format, sizeof(int));
    vkStream->read((int*)&forUnmarshaling->usage, sizeof(int));
    vkStream->read((uint64_t*)&forUnmarshaling->consumer, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->producer, sizeof(uint64_t));
}

#endif
#ifdef VK_EXT_debug_report
void marshal_VkDebugReportCallbackCreateInfoEXT(
    VulkanStream* vkStream,
    const VkDebugReportCallbackCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDebugReportFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugReportFlagsEXT));
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->pfnCallback;
    vkStream->putBe64(cgen_var_0);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pUserData;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pUserData)
    {
        vkStream->write((void*)forMarshaling->pUserData, sizeof(uint8_t));
    }
}

void unmarshal_VkDebugReportCallbackCreateInfoEXT(
    VulkanStream* vkStream,
    VkDebugReportCallbackCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDebugReportFlagsEXT*)&forUnmarshaling->flags, sizeof(VkDebugReportFlagsEXT));
    forUnmarshaling->pfnCallback = (PFN_vkDebugReportCallbackEXT)vkStream->getBe64();
    // WARNING PTR CHECK
    forUnmarshaling->pUserData = (void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pUserData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
        vkStream->read((void*)forUnmarshaling->pUserData, sizeof(uint8_t));
    }
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void marshal_VkPipelineRasterizationStateRasterizationOrderAMD(
    VulkanStream* vkStream,
    const VkPipelineRasterizationStateRasterizationOrderAMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkRasterizationOrderAMD*)&forMarshaling->rasterizationOrder, sizeof(VkRasterizationOrderAMD));
}

void unmarshal_VkPipelineRasterizationStateRasterizationOrderAMD(
    VulkanStream* vkStream,
    VkPipelineRasterizationStateRasterizationOrderAMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkRasterizationOrderAMD*)&forUnmarshaling->rasterizationOrder, sizeof(VkRasterizationOrderAMD));
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void marshal_VkDebugMarkerObjectNameInfoEXT(
    VulkanStream* vkStream,
    const VkDebugMarkerObjectNameInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDebugReportObjectTypeEXT*)&forMarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    vkStream->write((uint64_t*)&forMarshaling->object, sizeof(uint64_t));
    vkStream->putString(forMarshaling->pObjectName);
}

void unmarshal_VkDebugMarkerObjectNameInfoEXT(
    VulkanStream* vkStream,
    VkDebugMarkerObjectNameInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDebugReportObjectTypeEXT*)&forUnmarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    vkStream->read((uint64_t*)&forUnmarshaling->object, sizeof(uint64_t));
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pObjectName);
}

void marshal_VkDebugMarkerObjectTagInfoEXT(
    VulkanStream* vkStream,
    const VkDebugMarkerObjectTagInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDebugReportObjectTypeEXT*)&forMarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    vkStream->write((uint64_t*)&forMarshaling->object, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->tagName, sizeof(uint64_t));
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->tagSize;
    vkStream->putBe64(cgen_var_0);
    vkStream->write((const void*)forMarshaling->pTag, forMarshaling->tagSize * sizeof(const uint8_t));
}

void unmarshal_VkDebugMarkerObjectTagInfoEXT(
    VulkanStream* vkStream,
    VkDebugMarkerObjectTagInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDebugReportObjectTypeEXT*)&forUnmarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    vkStream->read((uint64_t*)&forUnmarshaling->object, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->tagName, sizeof(uint64_t));
    forUnmarshaling->tagSize = (size_t)vkStream->getBe64();
    vkStream->alloc((void**)&forUnmarshaling->pTag, forUnmarshaling->tagSize * sizeof(const uint8_t));
    vkStream->read((void*)forUnmarshaling->pTag, forUnmarshaling->tagSize * sizeof(const uint8_t));
}

void marshal_VkDebugMarkerMarkerInfoEXT(
    VulkanStream* vkStream,
    const VkDebugMarkerMarkerInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->putString(forMarshaling->pMarkerName);
    vkStream->write((float*)forMarshaling->color, 4 * sizeof(float));
}

void unmarshal_VkDebugMarkerMarkerInfoEXT(
    VulkanStream* vkStream,
    VkDebugMarkerMarkerInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pMarkerName);
    vkStream->read((float*)forUnmarshaling->color, 4 * sizeof(float));
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void marshal_VkDedicatedAllocationImageCreateInfoNV(
    VulkanStream* vkStream,
    const VkDedicatedAllocationImageCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->dedicatedAllocation, sizeof(VkBool32));
}

void unmarshal_VkDedicatedAllocationImageCreateInfoNV(
    VulkanStream* vkStream,
    VkDedicatedAllocationImageCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->dedicatedAllocation, sizeof(VkBool32));
}

void marshal_VkDedicatedAllocationBufferCreateInfoNV(
    VulkanStream* vkStream,
    const VkDedicatedAllocationBufferCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->dedicatedAllocation, sizeof(VkBool32));
}

void unmarshal_VkDedicatedAllocationBufferCreateInfoNV(
    VulkanStream* vkStream,
    VkDedicatedAllocationBufferCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->dedicatedAllocation, sizeof(VkBool32));
}

void marshal_VkDedicatedAllocationMemoryAllocateInfoNV(
    VulkanStream* vkStream,
    const VkDedicatedAllocationMemoryAllocateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
}

void unmarshal_VkDedicatedAllocationMemoryAllocateInfoNV(
    VulkanStream* vkStream,
    VkDedicatedAllocationMemoryAllocateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_0, (VkImage*)&forUnmarshaling->image, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_1, (VkBuffer*)&forUnmarshaling->buffer, 1);
}

#endif
#ifdef VK_EXT_transform_feedback
void marshal_VkPhysicalDeviceTransformFeedbackFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceTransformFeedbackFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->transformFeedback, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->geometryStreams, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceTransformFeedbackFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceTransformFeedbackFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->transformFeedback, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->geometryStreams, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceTransformFeedbackPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceTransformFeedbackPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->maxTransformFeedbackStreams, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTransformFeedbackBuffers, sizeof(uint32_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->maxTransformFeedbackBufferSize, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->maxTransformFeedbackStreamDataSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTransformFeedbackBufferDataSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTransformFeedbackBufferDataStride, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->transformFeedbackQueries, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->transformFeedbackStreamsLinesTriangles, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->transformFeedbackRasterizationStreamSelect, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->transformFeedbackDraw, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceTransformFeedbackPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceTransformFeedbackPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxTransformFeedbackStreams, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTransformFeedbackBuffers, sizeof(uint32_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->maxTransformFeedbackBufferSize, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTransformFeedbackStreamDataSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTransformFeedbackBufferDataSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTransformFeedbackBufferDataStride, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->transformFeedbackQueries, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->transformFeedbackStreamsLinesTriangles, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->transformFeedbackRasterizationStreamSelect, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->transformFeedbackDraw, sizeof(VkBool32));
}

void marshal_VkPipelineRasterizationStateStreamCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineRasterizationStateStreamCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineRasterizationStateStreamCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineRasterizationStateStreamCreateFlagsEXT));
    vkStream->write((uint32_t*)&forMarshaling->rasterizationStream, sizeof(uint32_t));
}

void unmarshal_VkPipelineRasterizationStateStreamCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineRasterizationStateStreamCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineRasterizationStateStreamCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkPipelineRasterizationStateStreamCreateFlagsEXT));
    vkStream->read((uint32_t*)&forUnmarshaling->rasterizationStream, sizeof(uint32_t));
}

#endif
#ifdef VK_NVX_image_view_handle
void marshal_VkImageViewHandleInfoNVX(
    VulkanStream* vkStream,
    const VkImageViewHandleInfoNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkImageView_u64(&forMarshaling->imageView, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkSampler_u64(&forMarshaling->sampler, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
}

void unmarshal_VkImageViewHandleInfoNVX(
    VulkanStream* vkStream,
    VkImageViewHandleInfoNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImageView(&cgen_var_0, (VkImageView*)&forUnmarshaling->imageView, 1);
    vkStream->read((VkDescriptorType*)&forUnmarshaling->descriptorType, sizeof(VkDescriptorType));
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSampler(&cgen_var_1, (VkSampler*)&forUnmarshaling->sampler, 1);
}

void marshal_VkImageViewAddressPropertiesNVX(
    VulkanStream* vkStream,
    const VkImageViewAddressPropertiesNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceAddress*)&forMarshaling->deviceAddress, sizeof(VkDeviceAddress));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
}

void unmarshal_VkImageViewAddressPropertiesNVX(
    VulkanStream* vkStream,
    VkImageViewAddressPropertiesNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceAddress*)&forUnmarshaling->deviceAddress, sizeof(VkDeviceAddress));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
}

#endif
#ifdef VK_AMD_draw_indirect_count
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
void marshal_VkTextureLODGatherFormatPropertiesAMD(
    VulkanStream* vkStream,
    const VkTextureLODGatherFormatPropertiesAMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->supportsTextureGatherLODBiasAMD, sizeof(VkBool32));
}

void unmarshal_VkTextureLODGatherFormatPropertiesAMD(
    VulkanStream* vkStream,
    VkTextureLODGatherFormatPropertiesAMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->supportsTextureGatherLODBiasAMD, sizeof(VkBool32));
}

#endif
#ifdef VK_AMD_shader_info
void marshal_VkShaderResourceUsageAMD(
    VulkanStream* vkStream,
    const VkShaderResourceUsageAMD* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->numUsedVgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->numUsedSgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->ldsSizePerLocalWorkGroup, sizeof(uint32_t));
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->ldsUsageSizeInBytes;
    vkStream->putBe64(cgen_var_0);
    uint64_t cgen_var_1 = (uint64_t)forMarshaling->scratchMemUsageInBytes;
    vkStream->putBe64(cgen_var_1);
}

void unmarshal_VkShaderResourceUsageAMD(
    VulkanStream* vkStream,
    VkShaderResourceUsageAMD* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->numUsedVgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->numUsedSgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->ldsSizePerLocalWorkGroup, sizeof(uint32_t));
    forUnmarshaling->ldsUsageSizeInBytes = (size_t)vkStream->getBe64();
    forUnmarshaling->scratchMemUsageInBytes = (size_t)vkStream->getBe64();
}

void marshal_VkShaderStatisticsInfoAMD(
    VulkanStream* vkStream,
    const VkShaderStatisticsInfoAMD* forMarshaling)
{
    vkStream->write((VkShaderStageFlags*)&forMarshaling->shaderStageMask, sizeof(VkShaderStageFlags));
    marshal_VkShaderResourceUsageAMD(vkStream, (VkShaderResourceUsageAMD*)(&forMarshaling->resourceUsage));
    vkStream->write((uint32_t*)&forMarshaling->numPhysicalVgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->numPhysicalSgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->numAvailableVgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->numAvailableSgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)forMarshaling->computeWorkGroupSize, 3 * sizeof(uint32_t));
}

void unmarshal_VkShaderStatisticsInfoAMD(
    VulkanStream* vkStream,
    VkShaderStatisticsInfoAMD* forUnmarshaling)
{
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->shaderStageMask, sizeof(VkShaderStageFlags));
    unmarshal_VkShaderResourceUsageAMD(vkStream, (VkShaderResourceUsageAMD*)(&forUnmarshaling->resourceUsage));
    vkStream->read((uint32_t*)&forUnmarshaling->numPhysicalVgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->numPhysicalSgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->numAvailableVgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->numAvailableSgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->computeWorkGroupSize, 3 * sizeof(uint32_t));
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_GGP_stream_descriptor_surface
void marshal_VkStreamDescriptorSurfaceCreateInfoGGP(
    VulkanStream* vkStream,
    const VkStreamDescriptorSurfaceCreateInfoGGP* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkStreamDescriptorSurfaceCreateFlagsGGP*)&forMarshaling->flags, sizeof(VkStreamDescriptorSurfaceCreateFlagsGGP));
    vkStream->write((GgpStreamDescriptor*)&forMarshaling->streamDescriptor, sizeof(GgpStreamDescriptor));
}

void unmarshal_VkStreamDescriptorSurfaceCreateInfoGGP(
    VulkanStream* vkStream,
    VkStreamDescriptorSurfaceCreateInfoGGP* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkStreamDescriptorSurfaceCreateFlagsGGP*)&forUnmarshaling->flags, sizeof(VkStreamDescriptorSurfaceCreateFlagsGGP));
    vkStream->read((GgpStreamDescriptor*)&forUnmarshaling->streamDescriptor, sizeof(GgpStreamDescriptor));
}

#endif
#ifdef VK_NV_corner_sampled_image
void marshal_VkPhysicalDeviceCornerSampledImageFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceCornerSampledImageFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->cornerSampledImage, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceCornerSampledImageFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceCornerSampledImageFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->cornerSampledImage, sizeof(VkBool32));
}

#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void marshal_VkExternalImageFormatPropertiesNV(
    VulkanStream* vkStream,
    const VkExternalImageFormatPropertiesNV* forMarshaling)
{
    marshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forMarshaling->imageFormatProperties));
    vkStream->write((VkExternalMemoryFeatureFlagsNV*)&forMarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlagsNV));
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

void unmarshal_VkExternalImageFormatPropertiesNV(
    VulkanStream* vkStream,
    VkExternalImageFormatPropertiesNV* forUnmarshaling)
{
    unmarshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forUnmarshaling->imageFormatProperties));
    vkStream->read((VkExternalMemoryFeatureFlagsNV*)&forUnmarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlagsNV));
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

#endif
#ifdef VK_NV_external_memory
void marshal_VkExternalMemoryImageCreateInfoNV(
    VulkanStream* vkStream,
    const VkExternalMemoryImageCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

void unmarshal_VkExternalMemoryImageCreateInfoNV(
    VulkanStream* vkStream,
    VkExternalMemoryImageCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

void marshal_VkExportMemoryAllocateInfoNV(
    VulkanStream* vkStream,
    const VkExportMemoryAllocateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

void unmarshal_VkExportMemoryAllocateInfoNV(
    VulkanStream* vkStream,
    VkExportMemoryAllocateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

#endif
#ifdef VK_NV_external_memory_win32
void marshal_VkImportMemoryWin32HandleInfoNV(
    VulkanStream* vkStream,
    const VkImportMemoryWin32HandleInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    vkStream->write((HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
}

void unmarshal_VkImportMemoryWin32HandleInfoNV(
    VulkanStream* vkStream,
    VkImportMemoryWin32HandleInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    vkStream->read((HANDLE*)&forUnmarshaling->handle, sizeof(HANDLE));
}

void marshal_VkExportMemoryWin32HandleInfoNV(
    VulkanStream* vkStream,
    const VkExportMemoryWin32HandleInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pAttributes)
    {
        vkStream->write((const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->write((DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
}

void unmarshal_VkExportMemoryWin32HandleInfoNV(
    VulkanStream* vkStream,
    VkExportMemoryWin32HandleInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    // WARNING PTR CHECK
    forUnmarshaling->pAttributes = (const SECURITY_ATTRIBUTES*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        vkStream->read((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->read((DWORD*)&forUnmarshaling->dwAccess, sizeof(DWORD));
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void marshal_VkWin32KeyedMutexAcquireReleaseInfoNV(
    VulkanStream* vkStream,
    const VkWin32KeyedMutexAcquireReleaseInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->acquireCount, sizeof(uint32_t));
    if (forMarshaling->acquireCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forMarshaling->acquireCount * 8);
        vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(forMarshaling->pAcquireSyncs, cgen_var_0, forMarshaling->acquireCount);
        vkStream->write((uint64_t*)cgen_var_0, forMarshaling->acquireCount * 8);
    }
    vkStream->write((const uint64_t*)forMarshaling->pAcquireKeys, forMarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->write((const uint32_t*)forMarshaling->pAcquireTimeoutMilliseconds, forMarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->releaseCount, sizeof(uint32_t));
    if (forMarshaling->releaseCount)
    {
        uint64_t* cgen_var_1;
        vkStream->alloc((void**)&cgen_var_1, forMarshaling->releaseCount * 8);
        vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(forMarshaling->pReleaseSyncs, cgen_var_1, forMarshaling->releaseCount);
        vkStream->write((uint64_t*)cgen_var_1, forMarshaling->releaseCount * 8);
    }
    vkStream->write((const uint64_t*)forMarshaling->pReleaseKeys, forMarshaling->releaseCount * sizeof(const uint64_t));
}

void unmarshal_VkWin32KeyedMutexAcquireReleaseInfoNV(
    VulkanStream* vkStream,
    VkWin32KeyedMutexAcquireReleaseInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->acquireCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAcquireSyncs, forUnmarshaling->acquireCount * sizeof(const VkDeviceMemory));
    if (forUnmarshaling->acquireCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forUnmarshaling->acquireCount * 8);
        vkStream->read((uint64_t*)cgen_var_0, forUnmarshaling->acquireCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(cgen_var_0, (VkDeviceMemory*)forUnmarshaling->pAcquireSyncs, forUnmarshaling->acquireCount);
    }
    vkStream->alloc((void**)&forUnmarshaling->pAcquireKeys, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->read((uint64_t*)forUnmarshaling->pAcquireKeys, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->alloc((void**)&forUnmarshaling->pAcquireTimeoutMilliseconds, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pAcquireTimeoutMilliseconds, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->releaseCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pReleaseSyncs, forUnmarshaling->releaseCount * sizeof(const VkDeviceMemory));
    if (forUnmarshaling->releaseCount)
    {
        uint64_t* cgen_var_1;
        vkStream->alloc((void**)&cgen_var_1, forUnmarshaling->releaseCount * 8);
        vkStream->read((uint64_t*)cgen_var_1, forUnmarshaling->releaseCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(cgen_var_1, (VkDeviceMemory*)forUnmarshaling->pReleaseSyncs, forUnmarshaling->releaseCount);
    }
    vkStream->alloc((void**)&forUnmarshaling->pReleaseKeys, forUnmarshaling->releaseCount * sizeof(const uint64_t));
    vkStream->read((uint64_t*)forUnmarshaling->pReleaseKeys, forUnmarshaling->releaseCount * sizeof(const uint64_t));
}

#endif
#ifdef VK_EXT_validation_flags
void marshal_VkValidationFlagsEXT(
    VulkanStream* vkStream,
    const VkValidationFlagsEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->disabledValidationCheckCount, sizeof(uint32_t));
    vkStream->write((const VkValidationCheckEXT*)forMarshaling->pDisabledValidationChecks, forMarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
}

void unmarshal_VkValidationFlagsEXT(
    VulkanStream* vkStream,
    VkValidationFlagsEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->disabledValidationCheckCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDisabledValidationChecks, forUnmarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
    vkStream->read((VkValidationCheckEXT*)forUnmarshaling->pDisabledValidationChecks, forUnmarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
}

#endif
#ifdef VK_NN_vi_surface
void marshal_VkViSurfaceCreateInfoNN(
    VulkanStream* vkStream,
    const VkViSurfaceCreateInfoNN* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkViSurfaceCreateFlagsNN*)&forMarshaling->flags, sizeof(VkViSurfaceCreateFlagsNN));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->window;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->window)
    {
        vkStream->write((void*)forMarshaling->window, sizeof(uint8_t));
    }
}

void unmarshal_VkViSurfaceCreateInfoNN(
    VulkanStream* vkStream,
    VkViSurfaceCreateInfoNN* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkViSurfaceCreateFlagsNN*)&forUnmarshaling->flags, sizeof(VkViSurfaceCreateFlagsNN));
    // WARNING PTR CHECK
    forUnmarshaling->window = (void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->window)
    {
        vkStream->alloc((void**)&forUnmarshaling->window, sizeof(uint8_t));
        vkStream->read((void*)forUnmarshaling->window, sizeof(uint8_t));
    }
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
void marshal_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->textureCompressionASTC_HDR, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->textureCompressionASTC_HDR, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_astc_decode_mode
void marshal_VkImageViewASTCDecodeModeEXT(
    VulkanStream* vkStream,
    const VkImageViewASTCDecodeModeEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkFormat*)&forMarshaling->decodeMode, sizeof(VkFormat));
}

void unmarshal_VkImageViewASTCDecodeModeEXT(
    VulkanStream* vkStream,
    VkImageViewASTCDecodeModeEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFormat*)&forUnmarshaling->decodeMode, sizeof(VkFormat));
}

void marshal_VkPhysicalDeviceASTCDecodeFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceASTCDecodeFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->decodeModeSharedExponent, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceASTCDecodeFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceASTCDecodeFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->decodeModeSharedExponent, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_conditional_rendering
void marshal_VkConditionalRenderingBeginInfoEXT(
    VulkanStream* vkStream,
    const VkConditionalRenderingBeginInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkConditionalRenderingFlagsEXT*)&forMarshaling->flags, sizeof(VkConditionalRenderingFlagsEXT));
}

void unmarshal_VkConditionalRenderingBeginInfoEXT(
    VulkanStream* vkStream,
    VkConditionalRenderingBeginInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_0, (VkBuffer*)&forUnmarshaling->buffer, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkConditionalRenderingFlagsEXT*)&forUnmarshaling->flags, sizeof(VkConditionalRenderingFlagsEXT));
}

void marshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->conditionalRendering, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->inheritedConditionalRendering, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceConditionalRenderingFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->conditionalRendering, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->inheritedConditionalRendering, sizeof(VkBool32));
}

void marshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    VulkanStream* vkStream,
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->conditionalRenderingEnable, sizeof(VkBool32));
}

void unmarshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    VulkanStream* vkStream,
    VkCommandBufferInheritanceConditionalRenderingInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->conditionalRenderingEnable, sizeof(VkBool32));
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void marshal_VkViewportWScalingNV(
    VulkanStream* vkStream,
    const VkViewportWScalingNV* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->xcoeff, sizeof(float));
    vkStream->write((float*)&forMarshaling->ycoeff, sizeof(float));
}

void unmarshal_VkViewportWScalingNV(
    VulkanStream* vkStream,
    VkViewportWScalingNV* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->xcoeff, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->ycoeff, sizeof(float));
}

void marshal_VkPipelineViewportWScalingStateCreateInfoNV(
    VulkanStream* vkStream,
    const VkPipelineViewportWScalingStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->viewportWScalingEnable, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pViewportWScalings;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pViewportWScalings)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            marshal_VkViewportWScalingNV(vkStream, (const VkViewportWScalingNV*)(forMarshaling->pViewportWScalings + i));
        }
    }
}

void unmarshal_VkPipelineViewportWScalingStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineViewportWScalingStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->viewportWScalingEnable, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->viewportCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pViewportWScalings = (const VkViewportWScalingNV*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pViewportWScalings)
    {
        vkStream->alloc((void**)&forUnmarshaling->pViewportWScalings, forUnmarshaling->viewportCount * sizeof(const VkViewportWScalingNV));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            unmarshal_VkViewportWScalingNV(vkStream, (VkViewportWScalingNV*)(forUnmarshaling->pViewportWScalings + i));
        }
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
#endif
#ifdef VK_EXT_acquire_xlib_display
#endif
#ifdef VK_EXT_display_surface_counter
void marshal_VkSurfaceCapabilities2EXT(
    VulkanStream* vkStream,
    const VkSurfaceCapabilities2EXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageCount, sizeof(uint32_t));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->currentExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minImageExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxImageExtent));
    vkStream->write((uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->write((VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->write((VkCompositeAlphaFlagsKHR*)&forMarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
    vkStream->write((VkSurfaceCounterFlagsEXT*)&forMarshaling->supportedSurfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
}

void unmarshal_VkSurfaceCapabilities2EXT(
    VulkanStream* vkStream,
    VkSurfaceCapabilities2EXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->minImageCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageCount, sizeof(uint32_t));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->currentExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minImageExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxImageExtent));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->read((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->read((VkCompositeAlphaFlagsKHR*)&forUnmarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
    vkStream->read((VkSurfaceCounterFlagsEXT*)&forUnmarshaling->supportedSurfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
}

#endif
#ifdef VK_EXT_display_control
void marshal_VkDisplayPowerInfoEXT(
    VulkanStream* vkStream,
    const VkDisplayPowerInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDisplayPowerStateEXT*)&forMarshaling->powerState, sizeof(VkDisplayPowerStateEXT));
}

void unmarshal_VkDisplayPowerInfoEXT(
    VulkanStream* vkStream,
    VkDisplayPowerInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDisplayPowerStateEXT*)&forUnmarshaling->powerState, sizeof(VkDisplayPowerStateEXT));
}

void marshal_VkDeviceEventInfoEXT(
    VulkanStream* vkStream,
    const VkDeviceEventInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceEventTypeEXT*)&forMarshaling->deviceEvent, sizeof(VkDeviceEventTypeEXT));
}

void unmarshal_VkDeviceEventInfoEXT(
    VulkanStream* vkStream,
    VkDeviceEventInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceEventTypeEXT*)&forUnmarshaling->deviceEvent, sizeof(VkDeviceEventTypeEXT));
}

void marshal_VkDisplayEventInfoEXT(
    VulkanStream* vkStream,
    const VkDisplayEventInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDisplayEventTypeEXT*)&forMarshaling->displayEvent, sizeof(VkDisplayEventTypeEXT));
}

void unmarshal_VkDisplayEventInfoEXT(
    VulkanStream* vkStream,
    VkDisplayEventInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDisplayEventTypeEXT*)&forUnmarshaling->displayEvent, sizeof(VkDisplayEventTypeEXT));
}

void marshal_VkSwapchainCounterCreateInfoEXT(
    VulkanStream* vkStream,
    const VkSwapchainCounterCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSurfaceCounterFlagsEXT*)&forMarshaling->surfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
}

void unmarshal_VkSwapchainCounterCreateInfoEXT(
    VulkanStream* vkStream,
    VkSwapchainCounterCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSurfaceCounterFlagsEXT*)&forUnmarshaling->surfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
}

#endif
#ifdef VK_GOOGLE_display_timing
void marshal_VkRefreshCycleDurationGOOGLE(
    VulkanStream* vkStream,
    const VkRefreshCycleDurationGOOGLE* forMarshaling)
{
    vkStream->write((uint64_t*)&forMarshaling->refreshDuration, sizeof(uint64_t));
}

void unmarshal_VkRefreshCycleDurationGOOGLE(
    VulkanStream* vkStream,
    VkRefreshCycleDurationGOOGLE* forUnmarshaling)
{
    vkStream->read((uint64_t*)&forUnmarshaling->refreshDuration, sizeof(uint64_t));
}

void marshal_VkPastPresentationTimingGOOGLE(
    VulkanStream* vkStream,
    const VkPastPresentationTimingGOOGLE* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->presentID, sizeof(uint32_t));
    vkStream->write((uint64_t*)&forMarshaling->desiredPresentTime, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->actualPresentTime, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->earliestPresentTime, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->presentMargin, sizeof(uint64_t));
}

void unmarshal_VkPastPresentationTimingGOOGLE(
    VulkanStream* vkStream,
    VkPastPresentationTimingGOOGLE* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->presentID, sizeof(uint32_t));
    vkStream->read((uint64_t*)&forUnmarshaling->desiredPresentTime, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->actualPresentTime, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->earliestPresentTime, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->presentMargin, sizeof(uint64_t));
}

void marshal_VkPresentTimeGOOGLE(
    VulkanStream* vkStream,
    const VkPresentTimeGOOGLE* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->presentID, sizeof(uint32_t));
    vkStream->write((uint64_t*)&forMarshaling->desiredPresentTime, sizeof(uint64_t));
}

void unmarshal_VkPresentTimeGOOGLE(
    VulkanStream* vkStream,
    VkPresentTimeGOOGLE* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->presentID, sizeof(uint32_t));
    vkStream->read((uint64_t*)&forUnmarshaling->desiredPresentTime, sizeof(uint64_t));
}

void marshal_VkPresentTimesInfoGOOGLE(
    VulkanStream* vkStream,
    const VkPresentTimesInfoGOOGLE* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pTimes;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pTimes)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->swapchainCount; ++i)
        {
            marshal_VkPresentTimeGOOGLE(vkStream, (const VkPresentTimeGOOGLE*)(forMarshaling->pTimes + i));
        }
    }
}

void unmarshal_VkPresentTimesInfoGOOGLE(
    VulkanStream* vkStream,
    VkPresentTimesInfoGOOGLE* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->swapchainCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pTimes = (const VkPresentTimeGOOGLE*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pTimes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pTimes, forUnmarshaling->swapchainCount * sizeof(const VkPresentTimeGOOGLE));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->swapchainCount; ++i)
        {
            unmarshal_VkPresentTimeGOOGLE(vkStream, (VkPresentTimeGOOGLE*)(forUnmarshaling->pTimes + i));
        }
    }
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void marshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->perViewPositionAllComponents, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VulkanStream* vkStream,
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->perViewPositionAllComponents, sizeof(VkBool32));
}

#endif
#ifdef VK_NV_viewport_swizzle
void marshal_VkViewportSwizzleNV(
    VulkanStream* vkStream,
    const VkViewportSwizzleNV* forMarshaling)
{
    vkStream->write((VkViewportCoordinateSwizzleNV*)&forMarshaling->x, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->write((VkViewportCoordinateSwizzleNV*)&forMarshaling->y, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->write((VkViewportCoordinateSwizzleNV*)&forMarshaling->z, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->write((VkViewportCoordinateSwizzleNV*)&forMarshaling->w, sizeof(VkViewportCoordinateSwizzleNV));
}

void unmarshal_VkViewportSwizzleNV(
    VulkanStream* vkStream,
    VkViewportSwizzleNV* forUnmarshaling)
{
    vkStream->read((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->x, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->read((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->y, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->read((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->z, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->read((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->w, sizeof(VkViewportCoordinateSwizzleNV));
}

void marshal_VkPipelineViewportSwizzleStateCreateInfoNV(
    VulkanStream* vkStream,
    const VkPipelineViewportSwizzleStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineViewportSwizzleStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV));
    vkStream->write((uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pViewportSwizzles;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pViewportSwizzles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            marshal_VkViewportSwizzleNV(vkStream, (const VkViewportSwizzleNV*)(forMarshaling->pViewportSwizzles + i));
        }
    }
}

void unmarshal_VkPipelineViewportSwizzleStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineViewportSwizzleStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineViewportSwizzleStateCreateFlagsNV*)&forUnmarshaling->flags, sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV));
    vkStream->read((uint32_t*)&forUnmarshaling->viewportCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pViewportSwizzles = (const VkViewportSwizzleNV*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pViewportSwizzles)
    {
        vkStream->alloc((void**)&forUnmarshaling->pViewportSwizzles, forUnmarshaling->viewportCount * sizeof(const VkViewportSwizzleNV));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            unmarshal_VkViewportSwizzleNV(vkStream, (VkViewportSwizzleNV*)(forUnmarshaling->pViewportSwizzles + i));
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void marshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->maxDiscardRectangles, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceDiscardRectanglePropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxDiscardRectangles, sizeof(uint32_t));
}

void marshal_VkPipelineDiscardRectangleStateCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineDiscardRectangleStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineDiscardRectangleStateCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT));
    vkStream->write((VkDiscardRectangleModeEXT*)&forMarshaling->discardRectangleMode, sizeof(VkDiscardRectangleModeEXT));
    vkStream->write((uint32_t*)&forMarshaling->discardRectangleCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pDiscardRectangles;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pDiscardRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->discardRectangleCount; ++i)
        {
            marshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pDiscardRectangles + i));
        }
    }
}

void unmarshal_VkPipelineDiscardRectangleStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineDiscardRectangleStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineDiscardRectangleStateCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT));
    vkStream->read((VkDiscardRectangleModeEXT*)&forUnmarshaling->discardRectangleMode, sizeof(VkDiscardRectangleModeEXT));
    vkStream->read((uint32_t*)&forUnmarshaling->discardRectangleCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pDiscardRectangles = (const VkRect2D*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pDiscardRectangles)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDiscardRectangles, forUnmarshaling->discardRectangleCount * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->discardRectangleCount; ++i)
        {
            unmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pDiscardRectangles + i));
        }
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void marshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((float*)&forMarshaling->primitiveOverestimationSize, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxExtraPrimitiveOverestimationSize, sizeof(float));
    vkStream->write((float*)&forMarshaling->extraPrimitiveOverestimationSizeGranularity, sizeof(float));
    vkStream->write((VkBool32*)&forMarshaling->primitiveUnderestimation, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->conservativePointAndLineRasterization, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->degenerateTrianglesRasterized, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->degenerateLinesRasterized, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fullyCoveredFragmentShaderInputVariable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->conservativeRasterizationPostDepthCoverage, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceConservativeRasterizationPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((float*)&forUnmarshaling->primitiveOverestimationSize, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxExtraPrimitiveOverestimationSize, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->extraPrimitiveOverestimationSizeGranularity, sizeof(float));
    vkStream->read((VkBool32*)&forUnmarshaling->primitiveUnderestimation, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->conservativePointAndLineRasterization, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->degenerateTrianglesRasterized, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->degenerateLinesRasterized, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fullyCoveredFragmentShaderInputVariable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->conservativeRasterizationPostDepthCoverage, sizeof(VkBool32));
}

void marshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineRasterizationConservativeStateCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT));
    vkStream->write((VkConservativeRasterizationModeEXT*)&forMarshaling->conservativeRasterizationMode, sizeof(VkConservativeRasterizationModeEXT));
    vkStream->write((float*)&forMarshaling->extraPrimitiveOverestimationSize, sizeof(float));
}

void unmarshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineRasterizationConservativeStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineRasterizationConservativeStateCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT));
    vkStream->read((VkConservativeRasterizationModeEXT*)&forUnmarshaling->conservativeRasterizationMode, sizeof(VkConservativeRasterizationModeEXT));
    vkStream->read((float*)&forUnmarshaling->extraPrimitiveOverestimationSize, sizeof(float));
}

#endif
#ifdef VK_EXT_depth_clip_enable
void marshal_VkPhysicalDeviceDepthClipEnableFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceDepthClipEnableFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->depthClipEnable, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceDepthClipEnableFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceDepthClipEnableFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->depthClipEnable, sizeof(VkBool32));
}

void marshal_VkPipelineRasterizationDepthClipStateCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineRasterizationDepthClipStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineRasterizationDepthClipStateCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineRasterizationDepthClipStateCreateFlagsEXT));
    vkStream->write((VkBool32*)&forMarshaling->depthClipEnable, sizeof(VkBool32));
}

void unmarshal_VkPipelineRasterizationDepthClipStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineRasterizationDepthClipStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineRasterizationDepthClipStateCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkPipelineRasterizationDepthClipStateCreateFlagsEXT));
    vkStream->read((VkBool32*)&forUnmarshaling->depthClipEnable, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void marshal_VkXYColorEXT(
    VulkanStream* vkStream,
    const VkXYColorEXT* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->x, sizeof(float));
    vkStream->write((float*)&forMarshaling->y, sizeof(float));
}

void unmarshal_VkXYColorEXT(
    VulkanStream* vkStream,
    VkXYColorEXT* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->x, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->y, sizeof(float));
}

void marshal_VkHdrMetadataEXT(
    VulkanStream* vkStream,
    const VkHdrMetadataEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->displayPrimaryRed));
    marshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->displayPrimaryGreen));
    marshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->displayPrimaryBlue));
    marshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->whitePoint));
    vkStream->write((float*)&forMarshaling->maxLuminance, sizeof(float));
    vkStream->write((float*)&forMarshaling->minLuminance, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxContentLightLevel, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxFrameAverageLightLevel, sizeof(float));
}

void unmarshal_VkHdrMetadataEXT(
    VulkanStream* vkStream,
    VkHdrMetadataEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryRed));
    unmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryGreen));
    unmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryBlue));
    unmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->whitePoint));
    vkStream->read((float*)&forUnmarshaling->maxLuminance, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->minLuminance, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxContentLightLevel, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxFrameAverageLightLevel, sizeof(float));
}

#endif
#ifdef VK_MVK_ios_surface
void marshal_VkIOSSurfaceCreateInfoMVK(
    VulkanStream* vkStream,
    const VkIOSSurfaceCreateInfoMVK* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkIOSSurfaceCreateFlagsMVK*)&forMarshaling->flags, sizeof(VkIOSSurfaceCreateFlagsMVK));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pView;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pView)
    {
        vkStream->write((const void*)forMarshaling->pView, sizeof(const uint8_t));
    }
}

void unmarshal_VkIOSSurfaceCreateInfoMVK(
    VulkanStream* vkStream,
    VkIOSSurfaceCreateInfoMVK* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkIOSSurfaceCreateFlagsMVK*)&forUnmarshaling->flags, sizeof(VkIOSSurfaceCreateFlagsMVK));
    // WARNING PTR CHECK
    forUnmarshaling->pView = (const void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pView)
    {
        vkStream->alloc((void**)&forUnmarshaling->pView, sizeof(const uint8_t));
        vkStream->read((void*)forUnmarshaling->pView, sizeof(const uint8_t));
    }
}

#endif
#ifdef VK_MVK_macos_surface
void marshal_VkMacOSSurfaceCreateInfoMVK(
    VulkanStream* vkStream,
    const VkMacOSSurfaceCreateInfoMVK* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkMacOSSurfaceCreateFlagsMVK*)&forMarshaling->flags, sizeof(VkMacOSSurfaceCreateFlagsMVK));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pView;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pView)
    {
        vkStream->write((const void*)forMarshaling->pView, sizeof(const uint8_t));
    }
}

void unmarshal_VkMacOSSurfaceCreateInfoMVK(
    VulkanStream* vkStream,
    VkMacOSSurfaceCreateInfoMVK* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkMacOSSurfaceCreateFlagsMVK*)&forUnmarshaling->flags, sizeof(VkMacOSSurfaceCreateFlagsMVK));
    // WARNING PTR CHECK
    forUnmarshaling->pView = (const void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pView)
    {
        vkStream->alloc((void**)&forUnmarshaling->pView, sizeof(const uint8_t));
        vkStream->read((void*)forUnmarshaling->pView, sizeof(const uint8_t));
    }
}

#endif
#ifdef VK_MVK_moltenvk
#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void marshal_VkDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    const VkDebugUtilsLabelEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->putString(forMarshaling->pLabelName);
    vkStream->write((float*)forMarshaling->color, 4 * sizeof(float));
}

void unmarshal_VkDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkDebugUtilsLabelEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pLabelName);
    vkStream->read((float*)forUnmarshaling->color, 4 * sizeof(float));
}

void marshal_VkDebugUtilsObjectNameInfoEXT(
    VulkanStream* vkStream,
    const VkDebugUtilsObjectNameInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkObjectType*)&forMarshaling->objectType, sizeof(VkObjectType));
    vkStream->write((uint64_t*)&forMarshaling->objectHandle, sizeof(uint64_t));
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pObjectName;
        vkStream->putBe64(cgen_var_0);
        if (forMarshaling->pObjectName)
        {
            vkStream->putString(forMarshaling->pObjectName);
        }
    }
    else
    {
        vkStream->putString(forMarshaling->pObjectName);
    }
}

void unmarshal_VkDebugUtilsObjectNameInfoEXT(
    VulkanStream* vkStream,
    VkDebugUtilsObjectNameInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkObjectType*)&forUnmarshaling->objectType, sizeof(VkObjectType));
    vkStream->read((uint64_t*)&forUnmarshaling->objectHandle, sizeof(uint64_t));
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        forUnmarshaling->pObjectName = (const char*)(uintptr_t)vkStream->getBe64();
        if (forUnmarshaling->pObjectName)
        {
            vkStream->loadStringInPlace((char**)&forUnmarshaling->pObjectName);
        }
    }
    else
    {
        vkStream->loadStringInPlace((char**)&forUnmarshaling->pObjectName);
    }
}

void marshal_VkDebugUtilsMessengerCallbackDataEXT(
    VulkanStream* vkStream,
    const VkDebugUtilsMessengerCallbackDataEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDebugUtilsMessengerCallbackDataFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT));
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pMessageIdName;
        vkStream->putBe64(cgen_var_0);
        if (forMarshaling->pMessageIdName)
        {
            vkStream->putString(forMarshaling->pMessageIdName);
        }
    }
    else
    {
        vkStream->putString(forMarshaling->pMessageIdName);
    }
    vkStream->write((int32_t*)&forMarshaling->messageIdNumber, sizeof(int32_t));
    vkStream->putString(forMarshaling->pMessage);
    vkStream->write((uint32_t*)&forMarshaling->queueLabelCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pQueueLabels;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pQueueLabels)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->queueLabelCount; ++i)
        {
            marshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forMarshaling->pQueueLabels + i));
        }
    }
    vkStream->write((uint32_t*)&forMarshaling->cmdBufLabelCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pCmdBufLabels;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pCmdBufLabels)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->cmdBufLabelCount; ++i)
        {
            marshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forMarshaling->pCmdBufLabels + i));
        }
    }
    vkStream->write((uint32_t*)&forMarshaling->objectCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pObjects;
    vkStream->putBe64(cgen_var_2);
    if (forMarshaling->pObjects)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->objectCount; ++i)
        {
            marshal_VkDebugUtilsObjectNameInfoEXT(vkStream, (VkDebugUtilsObjectNameInfoEXT*)(forMarshaling->pObjects + i));
        }
    }
}

void unmarshal_VkDebugUtilsMessengerCallbackDataEXT(
    VulkanStream* vkStream,
    VkDebugUtilsMessengerCallbackDataEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDebugUtilsMessengerCallbackDataFlagsEXT*)&forUnmarshaling->flags, sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT));
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        forUnmarshaling->pMessageIdName = (const char*)(uintptr_t)vkStream->getBe64();
        if (forUnmarshaling->pMessageIdName)
        {
            vkStream->loadStringInPlace((char**)&forUnmarshaling->pMessageIdName);
        }
    }
    else
    {
        vkStream->loadStringInPlace((char**)&forUnmarshaling->pMessageIdName);
    }
    vkStream->read((int32_t*)&forUnmarshaling->messageIdNumber, sizeof(int32_t));
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pMessage);
    vkStream->read((uint32_t*)&forUnmarshaling->queueLabelCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pQueueLabels = (VkDebugUtilsLabelEXT*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pQueueLabels)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueLabels, forUnmarshaling->queueLabelCount * sizeof(VkDebugUtilsLabelEXT));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->queueLabelCount; ++i)
        {
            unmarshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forUnmarshaling->pQueueLabels + i));
        }
    }
    vkStream->read((uint32_t*)&forUnmarshaling->cmdBufLabelCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pCmdBufLabels = (VkDebugUtilsLabelEXT*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pCmdBufLabels)
    {
        vkStream->alloc((void**)&forUnmarshaling->pCmdBufLabels, forUnmarshaling->cmdBufLabelCount * sizeof(VkDebugUtilsLabelEXT));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->cmdBufLabelCount; ++i)
        {
            unmarshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forUnmarshaling->pCmdBufLabels + i));
        }
    }
    vkStream->read((uint32_t*)&forUnmarshaling->objectCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pObjects = (VkDebugUtilsObjectNameInfoEXT*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pObjects)
    {
        vkStream->alloc((void**)&forUnmarshaling->pObjects, forUnmarshaling->objectCount * sizeof(VkDebugUtilsObjectNameInfoEXT));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->objectCount; ++i)
        {
            unmarshal_VkDebugUtilsObjectNameInfoEXT(vkStream, (VkDebugUtilsObjectNameInfoEXT*)(forUnmarshaling->pObjects + i));
        }
    }
}

void marshal_VkDebugUtilsMessengerCreateInfoEXT(
    VulkanStream* vkStream,
    const VkDebugUtilsMessengerCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDebugUtilsMessengerCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugUtilsMessengerCreateFlagsEXT));
    vkStream->write((VkDebugUtilsMessageSeverityFlagsEXT*)&forMarshaling->messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagsEXT));
    vkStream->write((VkDebugUtilsMessageTypeFlagsEXT*)&forMarshaling->messageType, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->pfnUserCallback;
    vkStream->putBe64(cgen_var_0);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pUserData;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pUserData)
    {
        vkStream->write((void*)forMarshaling->pUserData, sizeof(uint8_t));
    }
}

void unmarshal_VkDebugUtilsMessengerCreateInfoEXT(
    VulkanStream* vkStream,
    VkDebugUtilsMessengerCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDebugUtilsMessengerCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkDebugUtilsMessengerCreateFlagsEXT));
    vkStream->read((VkDebugUtilsMessageSeverityFlagsEXT*)&forUnmarshaling->messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagsEXT));
    vkStream->read((VkDebugUtilsMessageTypeFlagsEXT*)&forUnmarshaling->messageType, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    forUnmarshaling->pfnUserCallback = (PFN_vkDebugUtilsMessengerCallbackEXT)vkStream->getBe64();
    // WARNING PTR CHECK
    forUnmarshaling->pUserData = (void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pUserData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
        vkStream->read((void*)forUnmarshaling->pUserData, sizeof(uint8_t));
    }
}

void marshal_VkDebugUtilsObjectTagInfoEXT(
    VulkanStream* vkStream,
    const VkDebugUtilsObjectTagInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkObjectType*)&forMarshaling->objectType, sizeof(VkObjectType));
    vkStream->write((uint64_t*)&forMarshaling->objectHandle, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->tagName, sizeof(uint64_t));
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->tagSize;
    vkStream->putBe64(cgen_var_0);
    vkStream->write((const void*)forMarshaling->pTag, forMarshaling->tagSize * sizeof(const uint8_t));
}

void unmarshal_VkDebugUtilsObjectTagInfoEXT(
    VulkanStream* vkStream,
    VkDebugUtilsObjectTagInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkObjectType*)&forUnmarshaling->objectType, sizeof(VkObjectType));
    vkStream->read((uint64_t*)&forUnmarshaling->objectHandle, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->tagName, sizeof(uint64_t));
    forUnmarshaling->tagSize = (size_t)vkStream->getBe64();
    vkStream->alloc((void**)&forUnmarshaling->pTag, forUnmarshaling->tagSize * sizeof(const uint8_t));
    vkStream->read((void*)forUnmarshaling->pTag, forUnmarshaling->tagSize * sizeof(const uint8_t));
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void marshal_VkAndroidHardwareBufferUsageANDROID(
    VulkanStream* vkStream,
    const VkAndroidHardwareBufferUsageANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint64_t*)&forMarshaling->androidHardwareBufferUsage, sizeof(uint64_t));
}

void unmarshal_VkAndroidHardwareBufferUsageANDROID(
    VulkanStream* vkStream,
    VkAndroidHardwareBufferUsageANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint64_t*)&forUnmarshaling->androidHardwareBufferUsage, sizeof(uint64_t));
}

void marshal_VkAndroidHardwareBufferPropertiesANDROID(
    VulkanStream* vkStream,
    const VkAndroidHardwareBufferPropertiesANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceSize*)&forMarshaling->allocationSize, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkAndroidHardwareBufferPropertiesANDROID(
    VulkanStream* vkStream,
    VkAndroidHardwareBufferPropertiesANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceSize*)&forUnmarshaling->allocationSize, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_VkAndroidHardwareBufferFormatPropertiesANDROID(
    VulkanStream* vkStream,
    const VkAndroidHardwareBufferFormatPropertiesANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((uint64_t*)&forMarshaling->externalFormat, sizeof(uint64_t));
    vkStream->write((VkFormatFeatureFlags*)&forMarshaling->formatFeatures, sizeof(VkFormatFeatureFlags));
    marshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forMarshaling->samplerYcbcrConversionComponents));
    vkStream->write((VkSamplerYcbcrModelConversion*)&forMarshaling->suggestedYcbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    vkStream->write((VkSamplerYcbcrRange*)&forMarshaling->suggestedYcbcrRange, sizeof(VkSamplerYcbcrRange));
    vkStream->write((VkChromaLocation*)&forMarshaling->suggestedXChromaOffset, sizeof(VkChromaLocation));
    vkStream->write((VkChromaLocation*)&forMarshaling->suggestedYChromaOffset, sizeof(VkChromaLocation));
}

void unmarshal_VkAndroidHardwareBufferFormatPropertiesANDROID(
    VulkanStream* vkStream,
    VkAndroidHardwareBufferFormatPropertiesANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((uint64_t*)&forUnmarshaling->externalFormat, sizeof(uint64_t));
    vkStream->read((VkFormatFeatureFlags*)&forUnmarshaling->formatFeatures, sizeof(VkFormatFeatureFlags));
    unmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forUnmarshaling->samplerYcbcrConversionComponents));
    vkStream->read((VkSamplerYcbcrModelConversion*)&forUnmarshaling->suggestedYcbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    vkStream->read((VkSamplerYcbcrRange*)&forUnmarshaling->suggestedYcbcrRange, sizeof(VkSamplerYcbcrRange));
    vkStream->read((VkChromaLocation*)&forUnmarshaling->suggestedXChromaOffset, sizeof(VkChromaLocation));
    vkStream->read((VkChromaLocation*)&forUnmarshaling->suggestedYChromaOffset, sizeof(VkChromaLocation));
}

void marshal_VkImportAndroidHardwareBufferInfoANDROID(
    VulkanStream* vkStream,
    const VkImportAndroidHardwareBufferInfoANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((AHardwareBuffer*)forMarshaling->buffer, sizeof(AHardwareBuffer));
}

void unmarshal_VkImportAndroidHardwareBufferInfoANDROID(
    VulkanStream* vkStream,
    VkImportAndroidHardwareBufferInfoANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->alloc((void**)&forUnmarshaling->buffer, sizeof(AHardwareBuffer));
    vkStream->read((AHardwareBuffer*)forUnmarshaling->buffer, sizeof(AHardwareBuffer));
}

void marshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    VulkanStream* vkStream,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
}

void unmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    VulkanStream* vkStream,
    VkMemoryGetAndroidHardwareBufferInfoANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_0, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
}

void marshal_VkExternalFormatANDROID(
    VulkanStream* vkStream,
    const VkExternalFormatANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint64_t*)&forMarshaling->externalFormat, sizeof(uint64_t));
}

void unmarshal_VkExternalFormatANDROID(
    VulkanStream* vkStream,
    VkExternalFormatANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint64_t*)&forUnmarshaling->externalFormat, sizeof(uint64_t));
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_inline_uniform_block
void marshal_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceInlineUniformBlockFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->inlineUniformBlock, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingInlineUniformBlockUpdateAfterBind, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceInlineUniformBlockFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->inlineUniformBlock, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingInlineUniformBlockUpdateAfterBind, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceInlineUniformBlockPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->maxInlineUniformBlockSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorInlineUniformBlocks, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetInlineUniformBlocks, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindInlineUniformBlocks, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceInlineUniformBlockPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxInlineUniformBlockSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorInlineUniformBlocks, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetInlineUniformBlocks, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindInlineUniformBlocks, sizeof(uint32_t));
}

void marshal_VkWriteDescriptorSetInlineUniformBlockEXT(
    VulkanStream* vkStream,
    const VkWriteDescriptorSetInlineUniformBlockEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->dataSize, sizeof(uint32_t));
    vkStream->write((const void*)forMarshaling->pData, forMarshaling->dataSize * sizeof(const uint8_t));
}

void unmarshal_VkWriteDescriptorSetInlineUniformBlockEXT(
    VulkanStream* vkStream,
    VkWriteDescriptorSetInlineUniformBlockEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->dataSize, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pData, forUnmarshaling->dataSize * sizeof(const uint8_t));
    vkStream->read((void*)forUnmarshaling->pData, forUnmarshaling->dataSize * sizeof(const uint8_t));
}

void marshal_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(
    VulkanStream* vkStream,
    const VkDescriptorPoolInlineUniformBlockCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->maxInlineUniformBlockBindings, sizeof(uint32_t));
}

void unmarshal_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(
    VulkanStream* vkStream,
    VkDescriptorPoolInlineUniformBlockCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxInlineUniformBlockBindings, sizeof(uint32_t));
}

#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void marshal_VkSampleLocationEXT(
    VulkanStream* vkStream,
    const VkSampleLocationEXT* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->x, sizeof(float));
    vkStream->write((float*)&forMarshaling->y, sizeof(float));
}

void unmarshal_VkSampleLocationEXT(
    VulkanStream* vkStream,
    VkSampleLocationEXT* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->x, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->y, sizeof(float));
}

void marshal_VkSampleLocationsInfoEXT(
    VulkanStream* vkStream,
    const VkSampleLocationsInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->sampleLocationsPerPixel, sizeof(VkSampleCountFlagBits));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->sampleLocationGridSize));
    vkStream->write((uint32_t*)&forMarshaling->sampleLocationsCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->sampleLocationsCount; ++i)
    {
        marshal_VkSampleLocationEXT(vkStream, (const VkSampleLocationEXT*)(forMarshaling->pSampleLocations + i));
    }
}

void unmarshal_VkSampleLocationsInfoEXT(
    VulkanStream* vkStream,
    VkSampleLocationsInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->sampleLocationsPerPixel, sizeof(VkSampleCountFlagBits));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->sampleLocationGridSize));
    vkStream->read((uint32_t*)&forUnmarshaling->sampleLocationsCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSampleLocations, forUnmarshaling->sampleLocationsCount * sizeof(const VkSampleLocationEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->sampleLocationsCount; ++i)
    {
        unmarshal_VkSampleLocationEXT(vkStream, (VkSampleLocationEXT*)(forUnmarshaling->pSampleLocations + i));
    }
}

void marshal_VkAttachmentSampleLocationsEXT(
    VulkanStream* vkStream,
    const VkAttachmentSampleLocationsEXT* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->attachmentIndex, sizeof(uint32_t));
    marshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo));
}

void unmarshal_VkAttachmentSampleLocationsEXT(
    VulkanStream* vkStream,
    VkAttachmentSampleLocationsEXT* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentIndex, sizeof(uint32_t));
    unmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo));
}

void marshal_VkSubpassSampleLocationsEXT(
    VulkanStream* vkStream,
    const VkSubpassSampleLocationsEXT* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->subpassIndex, sizeof(uint32_t));
    marshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo));
}

void unmarshal_VkSubpassSampleLocationsEXT(
    VulkanStream* vkStream,
    VkSubpassSampleLocationsEXT* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->subpassIndex, sizeof(uint32_t));
    unmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo));
}

void marshal_VkRenderPassSampleLocationsBeginInfoEXT(
    VulkanStream* vkStream,
    const VkRenderPassSampleLocationsBeginInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->attachmentInitialSampleLocationsCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentInitialSampleLocationsCount; ++i)
    {
        marshal_VkAttachmentSampleLocationsEXT(vkStream, (const VkAttachmentSampleLocationsEXT*)(forMarshaling->pAttachmentInitialSampleLocations + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->postSubpassSampleLocationsCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->postSubpassSampleLocationsCount; ++i)
    {
        marshal_VkSubpassSampleLocationsEXT(vkStream, (const VkSubpassSampleLocationsEXT*)(forMarshaling->pPostSubpassSampleLocations + i));
    }
}

void unmarshal_VkRenderPassSampleLocationsBeginInfoEXT(
    VulkanStream* vkStream,
    VkRenderPassSampleLocationsBeginInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentInitialSampleLocationsCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAttachmentInitialSampleLocations, forUnmarshaling->attachmentInitialSampleLocationsCount * sizeof(const VkAttachmentSampleLocationsEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentInitialSampleLocationsCount; ++i)
    {
        unmarshal_VkAttachmentSampleLocationsEXT(vkStream, (VkAttachmentSampleLocationsEXT*)(forUnmarshaling->pAttachmentInitialSampleLocations + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->postSubpassSampleLocationsCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPostSubpassSampleLocations, forUnmarshaling->postSubpassSampleLocationsCount * sizeof(const VkSubpassSampleLocationsEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->postSubpassSampleLocationsCount; ++i)
    {
        unmarshal_VkSubpassSampleLocationsEXT(vkStream, (VkSubpassSampleLocationsEXT*)(forUnmarshaling->pPostSubpassSampleLocations + i));
    }
}

void marshal_VkPipelineSampleLocationsStateCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineSampleLocationsStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->sampleLocationsEnable, sizeof(VkBool32));
    marshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo));
}

void unmarshal_VkPipelineSampleLocationsStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineSampleLocationsStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->sampleLocationsEnable, sizeof(VkBool32));
    unmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo));
}

void marshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSampleLocationsPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampleLocationSampleCounts, sizeof(VkSampleCountFlags));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxSampleLocationGridSize));
    vkStream->write((float*)forMarshaling->sampleLocationCoordinateRange, 2 * sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->sampleLocationSubPixelBits, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->variableSampleLocations, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceSampleLocationsPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampleLocationSampleCounts, sizeof(VkSampleCountFlags));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxSampleLocationGridSize));
    vkStream->read((float*)forUnmarshaling->sampleLocationCoordinateRange, 2 * sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->sampleLocationSubPixelBits, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->variableSampleLocations, sizeof(VkBool32));
}

void marshal_VkMultisamplePropertiesEXT(
    VulkanStream* vkStream,
    const VkMultisamplePropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxSampleLocationGridSize));
}

void unmarshal_VkMultisamplePropertiesEXT(
    VulkanStream* vkStream,
    VkMultisamplePropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxSampleLocationGridSize));
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void marshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendCoherentOperations, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendCoherentOperations, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->advancedBlendMaxColorAttachments, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendIndependentBlend, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendNonPremultipliedSrcColor, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendNonPremultipliedDstColor, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendCorrelatedOverlap, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendAllOperations, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->advancedBlendMaxColorAttachments, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendIndependentBlend, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendNonPremultipliedSrcColor, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendNonPremultipliedDstColor, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendCorrelatedOverlap, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendAllOperations, sizeof(VkBool32));
}

void marshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->srcPremultiplied, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->dstPremultiplied, sizeof(VkBool32));
    vkStream->write((VkBlendOverlapEXT*)&forMarshaling->blendOverlap, sizeof(VkBlendOverlapEXT));
}

void unmarshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineColorBlendAdvancedStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->srcPremultiplied, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->dstPremultiplied, sizeof(VkBool32));
    vkStream->read((VkBlendOverlapEXT*)&forUnmarshaling->blendOverlap, sizeof(VkBlendOverlapEXT));
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void marshal_VkPipelineCoverageToColorStateCreateInfoNV(
    VulkanStream* vkStream,
    const VkPipelineCoverageToColorStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineCoverageToColorStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineCoverageToColorStateCreateFlagsNV));
    vkStream->write((VkBool32*)&forMarshaling->coverageToColorEnable, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->coverageToColorLocation, sizeof(uint32_t));
}

void unmarshal_VkPipelineCoverageToColorStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineCoverageToColorStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineCoverageToColorStateCreateFlagsNV*)&forUnmarshaling->flags, sizeof(VkPipelineCoverageToColorStateCreateFlagsNV));
    vkStream->read((VkBool32*)&forUnmarshaling->coverageToColorEnable, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->coverageToColorLocation, sizeof(uint32_t));
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void marshal_VkPipelineCoverageModulationStateCreateInfoNV(
    VulkanStream* vkStream,
    const VkPipelineCoverageModulationStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineCoverageModulationStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineCoverageModulationStateCreateFlagsNV));
    vkStream->write((VkCoverageModulationModeNV*)&forMarshaling->coverageModulationMode, sizeof(VkCoverageModulationModeNV));
    vkStream->write((VkBool32*)&forMarshaling->coverageModulationTableEnable, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->coverageModulationTableCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pCoverageModulationTable;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pCoverageModulationTable)
    {
        vkStream->write((const float*)forMarshaling->pCoverageModulationTable, forMarshaling->coverageModulationTableCount * sizeof(const float));
    }
}

void unmarshal_VkPipelineCoverageModulationStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineCoverageModulationStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineCoverageModulationStateCreateFlagsNV*)&forUnmarshaling->flags, sizeof(VkPipelineCoverageModulationStateCreateFlagsNV));
    vkStream->read((VkCoverageModulationModeNV*)&forUnmarshaling->coverageModulationMode, sizeof(VkCoverageModulationModeNV));
    vkStream->read((VkBool32*)&forUnmarshaling->coverageModulationTableEnable, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->coverageModulationTableCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pCoverageModulationTable = (const float*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pCoverageModulationTable)
    {
        vkStream->alloc((void**)&forUnmarshaling->pCoverageModulationTable, forUnmarshaling->coverageModulationTableCount * sizeof(const float));
        vkStream->read((float*)forUnmarshaling->pCoverageModulationTable, forUnmarshaling->coverageModulationTableCount * sizeof(const float));
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_NV_shader_sm_builtins
void marshal_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->shaderSMCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->shaderWarpsPerSM, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->shaderSMCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->shaderWarpsPerSM, sizeof(uint32_t));
}

void marshal_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->shaderSMBuiltins, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSMBuiltins, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_image_drm_format_modifier
void marshal_VkDrmFormatModifierPropertiesEXT(
    VulkanStream* vkStream,
    const VkDrmFormatModifierPropertiesEXT* forMarshaling)
{
    vkStream->write((uint64_t*)&forMarshaling->drmFormatModifier, sizeof(uint64_t));
    vkStream->write((uint32_t*)&forMarshaling->drmFormatModifierPlaneCount, sizeof(uint32_t));
    vkStream->write((VkFormatFeatureFlags*)&forMarshaling->drmFormatModifierTilingFeatures, sizeof(VkFormatFeatureFlags));
}

void unmarshal_VkDrmFormatModifierPropertiesEXT(
    VulkanStream* vkStream,
    VkDrmFormatModifierPropertiesEXT* forUnmarshaling)
{
    vkStream->read((uint64_t*)&forUnmarshaling->drmFormatModifier, sizeof(uint64_t));
    vkStream->read((uint32_t*)&forUnmarshaling->drmFormatModifierPlaneCount, sizeof(uint32_t));
    vkStream->read((VkFormatFeatureFlags*)&forUnmarshaling->drmFormatModifierTilingFeatures, sizeof(VkFormatFeatureFlags));
}

void marshal_VkDrmFormatModifierPropertiesListEXT(
    VulkanStream* vkStream,
    const VkDrmFormatModifierPropertiesListEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->drmFormatModifierCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pDrmFormatModifierProperties;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pDrmFormatModifierProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->drmFormatModifierCount; ++i)
        {
            marshal_VkDrmFormatModifierPropertiesEXT(vkStream, (VkDrmFormatModifierPropertiesEXT*)(forMarshaling->pDrmFormatModifierProperties + i));
        }
    }
}

void unmarshal_VkDrmFormatModifierPropertiesListEXT(
    VulkanStream* vkStream,
    VkDrmFormatModifierPropertiesListEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->drmFormatModifierCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pDrmFormatModifierProperties = (VkDrmFormatModifierPropertiesEXT*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pDrmFormatModifierProperties)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDrmFormatModifierProperties, forUnmarshaling->drmFormatModifierCount * sizeof(VkDrmFormatModifierPropertiesEXT));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->drmFormatModifierCount; ++i)
        {
            unmarshal_VkDrmFormatModifierPropertiesEXT(vkStream, (VkDrmFormatModifierPropertiesEXT*)(forUnmarshaling->pDrmFormatModifierProperties + i));
        }
    }
}

void marshal_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceImageDrmFormatModifierInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint64_t*)&forMarshaling->drmFormatModifier, sizeof(uint64_t));
    vkStream->write((VkSharingMode*)&forMarshaling->sharingMode, sizeof(VkSharingMode));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pQueueFamilyIndices;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pQueueFamilyIndices)
    {
        vkStream->write((const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
}

void unmarshal_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceImageDrmFormatModifierInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint64_t*)&forUnmarshaling->drmFormatModifier, sizeof(uint64_t));
    vkStream->read((VkSharingMode*)&forUnmarshaling->sharingMode, sizeof(VkSharingMode));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pQueueFamilyIndices = (const uint32_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        vkStream->read((uint32_t*)forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
}

void marshal_VkImageDrmFormatModifierListCreateInfoEXT(
    VulkanStream* vkStream,
    const VkImageDrmFormatModifierListCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->drmFormatModifierCount, sizeof(uint32_t));
    vkStream->write((const uint64_t*)forMarshaling->pDrmFormatModifiers, forMarshaling->drmFormatModifierCount * sizeof(const uint64_t));
}

void unmarshal_VkImageDrmFormatModifierListCreateInfoEXT(
    VulkanStream* vkStream,
    VkImageDrmFormatModifierListCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->drmFormatModifierCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDrmFormatModifiers, forUnmarshaling->drmFormatModifierCount * sizeof(const uint64_t));
    vkStream->read((uint64_t*)forUnmarshaling->pDrmFormatModifiers, forUnmarshaling->drmFormatModifierCount * sizeof(const uint64_t));
}

void marshal_VkImageDrmFormatModifierExplicitCreateInfoEXT(
    VulkanStream* vkStream,
    const VkImageDrmFormatModifierExplicitCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint64_t*)&forMarshaling->drmFormatModifier, sizeof(uint64_t));
    vkStream->write((uint32_t*)&forMarshaling->drmFormatModifierPlaneCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->drmFormatModifierPlaneCount; ++i)
    {
        marshal_VkSubresourceLayout(vkStream, (const VkSubresourceLayout*)(forMarshaling->pPlaneLayouts + i));
    }
}

void unmarshal_VkImageDrmFormatModifierExplicitCreateInfoEXT(
    VulkanStream* vkStream,
    VkImageDrmFormatModifierExplicitCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint64_t*)&forUnmarshaling->drmFormatModifier, sizeof(uint64_t));
    vkStream->read((uint32_t*)&forUnmarshaling->drmFormatModifierPlaneCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPlaneLayouts, forUnmarshaling->drmFormatModifierPlaneCount * sizeof(const VkSubresourceLayout));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->drmFormatModifierPlaneCount; ++i)
    {
        unmarshal_VkSubresourceLayout(vkStream, (VkSubresourceLayout*)(forUnmarshaling->pPlaneLayouts + i));
    }
}

void marshal_VkImageDrmFormatModifierPropertiesEXT(
    VulkanStream* vkStream,
    const VkImageDrmFormatModifierPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint64_t*)&forMarshaling->drmFormatModifier, sizeof(uint64_t));
}

void unmarshal_VkImageDrmFormatModifierPropertiesEXT(
    VulkanStream* vkStream,
    VkImageDrmFormatModifierPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint64_t*)&forUnmarshaling->drmFormatModifier, sizeof(uint64_t));
}

#endif
#ifdef VK_EXT_validation_cache
void marshal_VkValidationCacheCreateInfoEXT(
    VulkanStream* vkStream,
    const VkValidationCacheCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkValidationCacheCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkValidationCacheCreateFlagsEXT));
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->initialDataSize;
    vkStream->putBe64(cgen_var_0);
    vkStream->write((const void*)forMarshaling->pInitialData, forMarshaling->initialDataSize * sizeof(const uint8_t));
}

void unmarshal_VkValidationCacheCreateInfoEXT(
    VulkanStream* vkStream,
    VkValidationCacheCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkValidationCacheCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkValidationCacheCreateFlagsEXT));
    forUnmarshaling->initialDataSize = (size_t)vkStream->getBe64();
    vkStream->alloc((void**)&forUnmarshaling->pInitialData, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
    vkStream->read((void*)forUnmarshaling->pInitialData, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
}

void marshal_VkShaderModuleValidationCacheCreateInfoEXT(
    VulkanStream* vkStream,
    const VkShaderModuleValidationCacheCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(&forMarshaling->validationCache, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
}

void unmarshal_VkShaderModuleValidationCacheCreateInfoEXT(
    VulkanStream* vkStream,
    VkShaderModuleValidationCacheCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_0, (VkValidationCacheEXT*)&forUnmarshaling->validationCache, 1);
}

#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_NV_shading_rate_image
void marshal_VkShadingRatePaletteNV(
    VulkanStream* vkStream,
    const VkShadingRatePaletteNV* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->shadingRatePaletteEntryCount, sizeof(uint32_t));
    vkStream->write((const VkShadingRatePaletteEntryNV*)forMarshaling->pShadingRatePaletteEntries, forMarshaling->shadingRatePaletteEntryCount * sizeof(const VkShadingRatePaletteEntryNV));
}

void unmarshal_VkShadingRatePaletteNV(
    VulkanStream* vkStream,
    VkShadingRatePaletteNV* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->shadingRatePaletteEntryCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pShadingRatePaletteEntries, forUnmarshaling->shadingRatePaletteEntryCount * sizeof(const VkShadingRatePaletteEntryNV));
    vkStream->read((VkShadingRatePaletteEntryNV*)forUnmarshaling->pShadingRatePaletteEntries, forUnmarshaling->shadingRatePaletteEntryCount * sizeof(const VkShadingRatePaletteEntryNV));
}

void marshal_VkPipelineViewportShadingRateImageStateCreateInfoNV(
    VulkanStream* vkStream,
    const VkPipelineViewportShadingRateImageStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->shadingRateImageEnable, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pShadingRatePalettes;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pShadingRatePalettes)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            marshal_VkShadingRatePaletteNV(vkStream, (const VkShadingRatePaletteNV*)(forMarshaling->pShadingRatePalettes + i));
        }
    }
}

void unmarshal_VkPipelineViewportShadingRateImageStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineViewportShadingRateImageStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shadingRateImageEnable, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->viewportCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pShadingRatePalettes = (const VkShadingRatePaletteNV*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pShadingRatePalettes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pShadingRatePalettes, forUnmarshaling->viewportCount * sizeof(const VkShadingRatePaletteNV));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            unmarshal_VkShadingRatePaletteNV(vkStream, (VkShadingRatePaletteNV*)(forUnmarshaling->pShadingRatePalettes + i));
        }
    }
}

void marshal_VkPhysicalDeviceShadingRateImageFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShadingRateImageFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->shadingRateImage, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shadingRateCoarseSampleOrder, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShadingRateImageFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceShadingRateImageFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shadingRateImage, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shadingRateCoarseSampleOrder, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceShadingRateImagePropertiesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShadingRateImagePropertiesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->shadingRateTexelSize));
    vkStream->write((uint32_t*)&forMarshaling->shadingRatePaletteSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->shadingRateMaxCoarseSamples, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceShadingRateImagePropertiesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceShadingRateImagePropertiesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->shadingRateTexelSize));
    vkStream->read((uint32_t*)&forUnmarshaling->shadingRatePaletteSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->shadingRateMaxCoarseSamples, sizeof(uint32_t));
}

void marshal_VkCoarseSampleLocationNV(
    VulkanStream* vkStream,
    const VkCoarseSampleLocationNV* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->pixelX, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->pixelY, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->sample, sizeof(uint32_t));
}

void unmarshal_VkCoarseSampleLocationNV(
    VulkanStream* vkStream,
    VkCoarseSampleLocationNV* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->pixelX, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->pixelY, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->sample, sizeof(uint32_t));
}

void marshal_VkCoarseSampleOrderCustomNV(
    VulkanStream* vkStream,
    const VkCoarseSampleOrderCustomNV* forMarshaling)
{
    vkStream->write((VkShadingRatePaletteEntryNV*)&forMarshaling->shadingRate, sizeof(VkShadingRatePaletteEntryNV));
    vkStream->write((uint32_t*)&forMarshaling->sampleCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->sampleLocationCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->sampleLocationCount; ++i)
    {
        marshal_VkCoarseSampleLocationNV(vkStream, (const VkCoarseSampleLocationNV*)(forMarshaling->pSampleLocations + i));
    }
}

void unmarshal_VkCoarseSampleOrderCustomNV(
    VulkanStream* vkStream,
    VkCoarseSampleOrderCustomNV* forUnmarshaling)
{
    vkStream->read((VkShadingRatePaletteEntryNV*)&forUnmarshaling->shadingRate, sizeof(VkShadingRatePaletteEntryNV));
    vkStream->read((uint32_t*)&forUnmarshaling->sampleCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->sampleLocationCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSampleLocations, forUnmarshaling->sampleLocationCount * sizeof(const VkCoarseSampleLocationNV));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->sampleLocationCount; ++i)
    {
        unmarshal_VkCoarseSampleLocationNV(vkStream, (VkCoarseSampleLocationNV*)(forUnmarshaling->pSampleLocations + i));
    }
}

void marshal_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(
    VulkanStream* vkStream,
    const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkCoarseSampleOrderTypeNV*)&forMarshaling->sampleOrderType, sizeof(VkCoarseSampleOrderTypeNV));
    vkStream->write((uint32_t*)&forMarshaling->customSampleOrderCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->customSampleOrderCount; ++i)
    {
        marshal_VkCoarseSampleOrderCustomNV(vkStream, (const VkCoarseSampleOrderCustomNV*)(forMarshaling->pCustomSampleOrders + i));
    }
}

void unmarshal_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkCoarseSampleOrderTypeNV*)&forUnmarshaling->sampleOrderType, sizeof(VkCoarseSampleOrderTypeNV));
    vkStream->read((uint32_t*)&forUnmarshaling->customSampleOrderCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pCustomSampleOrders, forUnmarshaling->customSampleOrderCount * sizeof(const VkCoarseSampleOrderCustomNV));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->customSampleOrderCount; ++i)
    {
        unmarshal_VkCoarseSampleOrderCustomNV(vkStream, (VkCoarseSampleOrderCustomNV*)(forUnmarshaling->pCustomSampleOrders + i));
    }
}

#endif
#ifdef VK_NV_ray_tracing
void marshal_VkRayTracingShaderGroupCreateInfoNV(
    VulkanStream* vkStream,
    const VkRayTracingShaderGroupCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkRayTracingShaderGroupTypeKHR*)&forMarshaling->type, sizeof(VkRayTracingShaderGroupTypeKHR));
    vkStream->write((uint32_t*)&forMarshaling->generalShader, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->closestHitShader, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->anyHitShader, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->intersectionShader, sizeof(uint32_t));
}

void unmarshal_VkRayTracingShaderGroupCreateInfoNV(
    VulkanStream* vkStream,
    VkRayTracingShaderGroupCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkRayTracingShaderGroupTypeKHR*)&forUnmarshaling->type, sizeof(VkRayTracingShaderGroupTypeKHR));
    vkStream->read((uint32_t*)&forUnmarshaling->generalShader, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->closestHitShader, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->anyHitShader, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->intersectionShader, sizeof(uint32_t));
}

void marshal_VkRayTracingPipelineCreateInfoNV(
    VulkanStream* vkStream,
    const VkRayTracingPipelineCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->stageCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->stageCount; ++i)
    {
        marshal_VkPipelineShaderStageCreateInfo(vkStream, (const VkPipelineShaderStageCreateInfo*)(forMarshaling->pStages + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->groupCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->groupCount; ++i)
    {
        marshal_VkRayTracingShaderGroupCreateInfoNV(vkStream, (const VkRayTracingShaderGroupCreateInfoNV*)(forMarshaling->pGroups + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->maxRecursionDepth, sizeof(uint32_t));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&forMarshaling->layout, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkPipeline_u64(&forMarshaling->basePipelineHandle, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((int32_t*)&forMarshaling->basePipelineIndex, sizeof(int32_t));
}

void unmarshal_VkRayTracingPipelineCreateInfoNV(
    VulkanStream* vkStream,
    VkRayTracingPipelineCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->stageCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pStages, forUnmarshaling->stageCount * sizeof(const VkPipelineShaderStageCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->stageCount; ++i)
    {
        unmarshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(forUnmarshaling->pStages + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->groupCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pGroups, forUnmarshaling->groupCount * sizeof(const VkRayTracingShaderGroupCreateInfoNV));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->groupCount; ++i)
    {
        unmarshal_VkRayTracingShaderGroupCreateInfoNV(vkStream, (VkRayTracingShaderGroupCreateInfoNV*)(forUnmarshaling->pGroups + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxRecursionDepth, sizeof(uint32_t));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_0, (VkPipelineLayout*)&forUnmarshaling->layout, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_1, (VkPipeline*)&forUnmarshaling->basePipelineHandle, 1);
    vkStream->read((int32_t*)&forUnmarshaling->basePipelineIndex, sizeof(int32_t));
}

void marshal_VkGeometryTrianglesNV(
    VulkanStream* vkStream,
    const VkGeometryTrianglesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->vertexData, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->vertexOffset, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->vertexCount, sizeof(uint32_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->vertexStride, sizeof(VkDeviceSize));
    vkStream->write((VkFormat*)&forMarshaling->vertexFormat, sizeof(VkFormat));
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->indexData, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->indexOffset, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->indexCount, sizeof(uint32_t));
    vkStream->write((VkIndexType*)&forMarshaling->indexType, sizeof(VkIndexType));
    uint64_t cgen_var_2;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->transformData, &cgen_var_2, 1);
    vkStream->write((uint64_t*)&cgen_var_2, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->transformOffset, sizeof(VkDeviceSize));
}

void unmarshal_VkGeometryTrianglesNV(
    VulkanStream* vkStream,
    VkGeometryTrianglesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_0, (VkBuffer*)&forUnmarshaling->vertexData, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->vertexOffset, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->vertexCount, sizeof(uint32_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->vertexStride, sizeof(VkDeviceSize));
    vkStream->read((VkFormat*)&forUnmarshaling->vertexFormat, sizeof(VkFormat));
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_1, (VkBuffer*)&forUnmarshaling->indexData, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->indexOffset, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->indexCount, sizeof(uint32_t));
    vkStream->read((VkIndexType*)&forUnmarshaling->indexType, sizeof(VkIndexType));
    uint64_t cgen_var_2;
    vkStream->read((uint64_t*)&cgen_var_2, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_2, (VkBuffer*)&forUnmarshaling->transformData, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->transformOffset, sizeof(VkDeviceSize));
}

void marshal_VkGeometryAABBNV(
    VulkanStream* vkStream,
    const VkGeometryAABBNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->aabbData, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->numAABBs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->stride, sizeof(uint32_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
}

void unmarshal_VkGeometryAABBNV(
    VulkanStream* vkStream,
    VkGeometryAABBNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_0, (VkBuffer*)&forUnmarshaling->aabbData, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->numAABBs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->stride, sizeof(uint32_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
}

void marshal_VkGeometryDataNV(
    VulkanStream* vkStream,
    const VkGeometryDataNV* forMarshaling)
{
    marshal_VkGeometryTrianglesNV(vkStream, (VkGeometryTrianglesNV*)(&forMarshaling->triangles));
    marshal_VkGeometryAABBNV(vkStream, (VkGeometryAABBNV*)(&forMarshaling->aabbs));
}

void unmarshal_VkGeometryDataNV(
    VulkanStream* vkStream,
    VkGeometryDataNV* forUnmarshaling)
{
    unmarshal_VkGeometryTrianglesNV(vkStream, (VkGeometryTrianglesNV*)(&forUnmarshaling->triangles));
    unmarshal_VkGeometryAABBNV(vkStream, (VkGeometryAABBNV*)(&forUnmarshaling->aabbs));
}

void marshal_VkGeometryNV(
    VulkanStream* vkStream,
    const VkGeometryNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkGeometryTypeKHR*)&forMarshaling->geometryType, sizeof(VkGeometryTypeKHR));
    marshal_VkGeometryDataNV(vkStream, (VkGeometryDataNV*)(&forMarshaling->geometry));
    vkStream->write((VkGeometryFlagsKHR*)&forMarshaling->flags, sizeof(VkGeometryFlagsKHR));
}

void unmarshal_VkGeometryNV(
    VulkanStream* vkStream,
    VkGeometryNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkGeometryTypeKHR*)&forUnmarshaling->geometryType, sizeof(VkGeometryTypeKHR));
    unmarshal_VkGeometryDataNV(vkStream, (VkGeometryDataNV*)(&forUnmarshaling->geometry));
    vkStream->read((VkGeometryFlagsKHR*)&forUnmarshaling->flags, sizeof(VkGeometryFlagsKHR));
}

void marshal_VkAccelerationStructureInfoNV(
    VulkanStream* vkStream,
    const VkAccelerationStructureInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkAccelerationStructureTypeNV*)&forMarshaling->type, sizeof(VkAccelerationStructureTypeNV));
    vkStream->write((VkBuildAccelerationStructureFlagsNV*)&forMarshaling->flags, sizeof(VkBuildAccelerationStructureFlagsNV));
    vkStream->write((uint32_t*)&forMarshaling->instanceCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->geometryCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->geometryCount; ++i)
    {
        marshal_VkGeometryNV(vkStream, (const VkGeometryNV*)(forMarshaling->pGeometries + i));
    }
}

void unmarshal_VkAccelerationStructureInfoNV(
    VulkanStream* vkStream,
    VkAccelerationStructureInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAccelerationStructureTypeNV*)&forUnmarshaling->type, sizeof(VkAccelerationStructureTypeNV));
    vkStream->read((VkBuildAccelerationStructureFlagsNV*)&forUnmarshaling->flags, sizeof(VkBuildAccelerationStructureFlagsNV));
    vkStream->read((uint32_t*)&forUnmarshaling->instanceCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->geometryCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pGeometries, forUnmarshaling->geometryCount * sizeof(const VkGeometryNV));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->geometryCount; ++i)
    {
        unmarshal_VkGeometryNV(vkStream, (VkGeometryNV*)(forUnmarshaling->pGeometries + i));
    }
}

void marshal_VkAccelerationStructureCreateInfoNV(
    VulkanStream* vkStream,
    const VkAccelerationStructureCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceSize*)&forMarshaling->compactedSize, sizeof(VkDeviceSize));
    marshal_VkAccelerationStructureInfoNV(vkStream, (VkAccelerationStructureInfoNV*)(&forMarshaling->info));
}

void unmarshal_VkAccelerationStructureCreateInfoNV(
    VulkanStream* vkStream,
    VkAccelerationStructureCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceSize*)&forUnmarshaling->compactedSize, sizeof(VkDeviceSize));
    unmarshal_VkAccelerationStructureInfoNV(vkStream, (VkAccelerationStructureInfoNV*)(&forUnmarshaling->info));
}

void marshal_VkBindAccelerationStructureMemoryInfoNV(
    VulkanStream* vkStream,
    const VkBindAccelerationStructureMemoryInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkAccelerationStructureNV_u64(&forMarshaling->accelerationStructure, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->deviceIndexCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pDeviceIndices, forMarshaling->deviceIndexCount * sizeof(const uint32_t));
}

void unmarshal_VkBindAccelerationStructureMemoryInfoNV(
    VulkanStream* vkStream,
    VkBindAccelerationStructureMemoryInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkAccelerationStructureNV(&cgen_var_0, (VkAccelerationStructureNV*)&forUnmarshaling->accelerationStructure, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_1, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->memoryOffset, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceIndexCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
}

void marshal_VkWriteDescriptorSetAccelerationStructureNV(
    VulkanStream* vkStream,
    const VkWriteDescriptorSetAccelerationStructureNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->accelerationStructureCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pAccelerationStructures;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pAccelerationStructures)
    {
        if (forMarshaling->accelerationStructureCount)
        {
            uint64_t* cgen_var_0_0;
            vkStream->alloc((void**)&cgen_var_0_0, forMarshaling->accelerationStructureCount * 8);
            vkStream->handleMapping()->mapHandles_VkAccelerationStructureNV_u64(forMarshaling->pAccelerationStructures, cgen_var_0_0, forMarshaling->accelerationStructureCount);
            vkStream->write((uint64_t*)cgen_var_0_0, forMarshaling->accelerationStructureCount * 8);
        }
    }
}

void unmarshal_VkWriteDescriptorSetAccelerationStructureNV(
    VulkanStream* vkStream,
    VkWriteDescriptorSetAccelerationStructureNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->accelerationStructureCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pAccelerationStructures = (const VkAccelerationStructureNV*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pAccelerationStructures)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAccelerationStructures, forUnmarshaling->accelerationStructureCount * sizeof(const VkAccelerationStructureNV));
        if (forUnmarshaling->accelerationStructureCount)
        {
            uint64_t* cgen_var_0_0;
            vkStream->alloc((void**)&cgen_var_0_0, forUnmarshaling->accelerationStructureCount * 8);
            vkStream->read((uint64_t*)cgen_var_0_0, forUnmarshaling->accelerationStructureCount * 8);
            vkStream->handleMapping()->mapHandles_u64_VkAccelerationStructureNV(cgen_var_0_0, (VkAccelerationStructureNV*)forUnmarshaling->pAccelerationStructures, forUnmarshaling->accelerationStructureCount);
        }
    }
}

void marshal_VkAccelerationStructureMemoryRequirementsInfoNV(
    VulkanStream* vkStream,
    const VkAccelerationStructureMemoryRequirementsInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkAccelerationStructureMemoryRequirementsTypeNV*)&forMarshaling->type, sizeof(VkAccelerationStructureMemoryRequirementsTypeNV));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkAccelerationStructureNV_u64(&forMarshaling->accelerationStructure, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
}

void unmarshal_VkAccelerationStructureMemoryRequirementsInfoNV(
    VulkanStream* vkStream,
    VkAccelerationStructureMemoryRequirementsInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAccelerationStructureMemoryRequirementsTypeNV*)&forUnmarshaling->type, sizeof(VkAccelerationStructureMemoryRequirementsTypeNV));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkAccelerationStructureNV(&cgen_var_0, (VkAccelerationStructureNV*)&forUnmarshaling->accelerationStructure, 1);
}

void marshal_VkPhysicalDeviceRayTracingPropertiesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceRayTracingPropertiesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->shaderGroupHandleSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxRecursionDepth, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxShaderGroupStride, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->shaderGroupBaseAlignment, sizeof(uint32_t));
    vkStream->write((uint64_t*)&forMarshaling->maxGeometryCount, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->maxInstanceCount, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->maxTriangleCount, sizeof(uint64_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetAccelerationStructures, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceRayTracingPropertiesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceRayTracingPropertiesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->shaderGroupHandleSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxRecursionDepth, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxShaderGroupStride, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->shaderGroupBaseAlignment, sizeof(uint32_t));
    vkStream->read((uint64_t*)&forUnmarshaling->maxGeometryCount, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->maxInstanceCount, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->maxTriangleCount, sizeof(uint64_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetAccelerationStructures, sizeof(uint32_t));
}

void marshal_VkTransformMatrixKHR(
    VulkanStream* vkStream,
    const VkTransformMatrixKHR* forMarshaling)
{
    vkStream->write((float*)forMarshaling->matrix, ((3)*(4)) * sizeof(float));
}

void unmarshal_VkTransformMatrixKHR(
    VulkanStream* vkStream,
    VkTransformMatrixKHR* forUnmarshaling)
{
    vkStream->read((float*)forUnmarshaling->matrix, ((3)*(4)) * sizeof(float));
}

void marshal_VkAabbPositionsKHR(
    VulkanStream* vkStream,
    const VkAabbPositionsKHR* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->minX, sizeof(float));
    vkStream->write((float*)&forMarshaling->minY, sizeof(float));
    vkStream->write((float*)&forMarshaling->minZ, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxX, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxY, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxZ, sizeof(float));
}

void unmarshal_VkAabbPositionsKHR(
    VulkanStream* vkStream,
    VkAabbPositionsKHR* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->minX, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->minY, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->minZ, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxX, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxY, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxZ, sizeof(float));
}

void marshal_VkAccelerationStructureInstanceKHR(
    VulkanStream* vkStream,
    const VkAccelerationStructureInstanceKHR* forMarshaling)
{
    
    typedef struct VkAccelerationStructureInstanceKHRWithoutBitFields {
        VkTransformMatrixKHR          transform;
        uint32_t                      dwords[2];
        uint64_t                      accelerationStructureReference;
    } VkAccelerationStructureInstanceKHRWithoutBitFields;
    
    const VkAccelerationStructureInstanceKHRWithoutBitFields* forMarshaling_new = (const VkAccelerationStructureInstanceKHRWithoutBitFields*)(forMarshaling);
    marshal_VkTransformMatrixKHR(vkStream, (VkTransformMatrixKHR*)(&forMarshaling_new->transform));
    for (uint32_t i = 0; i < 2; i++) {
        vkStream->write((uint32_t*)&(forMarshaling_new->dwords[i]), sizeof(uint32_t));
    }
    vkStream->write((uint64_t*)&forMarshaling_new->accelerationStructureReference, sizeof(uint64_t));
    
}

void unmarshal_VkAccelerationStructureInstanceKHR(
    VulkanStream* vkStream,
    VkAccelerationStructureInstanceKHR* forUnmarshaling)
{
    
    typedef struct VkAccelerationStructureInstanceKHRWithoutBitFields {
        VkTransformMatrixKHR          transform;
        uint32_t                      dwords[2];
        uint64_t                      accelerationStructureReference;
    } VkAccelerationStructureInstanceKHRWithoutBitFields;
    
    VkAccelerationStructureInstanceKHRWithoutBitFields* forUnmarshaling_new = (VkAccelerationStructureInstanceKHRWithoutBitFields*)(forUnmarshaling);
    unmarshal_VkTransformMatrixKHR(vkStream, (VkTransformMatrixKHR*)(&forUnmarshaling_new->transform));
    for (uint32_t i = 0; i < 2; i++) {
        vkStream->read((uint32_t*)&(forUnmarshaling_new->dwords[i]), sizeof(uint32_t));
    }
    vkStream->read((uint64_t*)&forUnmarshaling_new->accelerationStructureReference, sizeof(uint64_t));
    
}

#endif
#ifdef VK_NV_representative_fragment_test
void marshal_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->representativeFragmentTest, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->representativeFragmentTest, sizeof(VkBool32));
}

void marshal_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(
    VulkanStream* vkStream,
    const VkPipelineRepresentativeFragmentTestStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->representativeFragmentTestEnable, sizeof(VkBool32));
}

void unmarshal_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineRepresentativeFragmentTestStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->representativeFragmentTestEnable, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_filter_cubic
void marshal_VkPhysicalDeviceImageViewImageFormatInfoEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceImageViewImageFormatInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkImageViewType*)&forMarshaling->imageViewType, sizeof(VkImageViewType));
}

void unmarshal_VkPhysicalDeviceImageViewImageFormatInfoEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceImageViewImageFormatInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageViewType*)&forUnmarshaling->imageViewType, sizeof(VkImageViewType));
}

void marshal_VkFilterCubicImageViewImageFormatPropertiesEXT(
    VulkanStream* vkStream,
    const VkFilterCubicImageViewImageFormatPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->filterCubic, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->filterCubicMinmax, sizeof(VkBool32));
}

void unmarshal_VkFilterCubicImageViewImageFormatPropertiesEXT(
    VulkanStream* vkStream,
    VkFilterCubicImageViewImageFormatPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->filterCubic, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->filterCubicMinmax, sizeof(VkBool32));
}

#endif
#ifdef VK_QCOM_render_pass_shader_resolve
#endif
#ifdef VK_EXT_global_priority
void marshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    VulkanStream* vkStream,
    const VkDeviceQueueGlobalPriorityCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkQueueGlobalPriorityEXT*)&forMarshaling->globalPriority, sizeof(VkQueueGlobalPriorityEXT));
}

void unmarshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    VulkanStream* vkStream,
    VkDeviceQueueGlobalPriorityCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkQueueGlobalPriorityEXT*)&forUnmarshaling->globalPriority, sizeof(VkQueueGlobalPriorityEXT));
}

#endif
#ifdef VK_EXT_external_memory_host
void marshal_VkImportMemoryHostPointerInfoEXT(
    VulkanStream* vkStream,
    const VkImportMemoryHostPointerInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pHostPointer;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pHostPointer)
    {
        vkStream->write((void*)forMarshaling->pHostPointer, sizeof(uint8_t));
    }
}

void unmarshal_VkImportMemoryHostPointerInfoEXT(
    VulkanStream* vkStream,
    VkImportMemoryHostPointerInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    // WARNING PTR CHECK
    forUnmarshaling->pHostPointer = (void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pHostPointer)
    {
        vkStream->alloc((void**)&forUnmarshaling->pHostPointer, sizeof(uint8_t));
        vkStream->read((void*)forUnmarshaling->pHostPointer, sizeof(uint8_t));
    }
}

void marshal_VkMemoryHostPointerPropertiesEXT(
    VulkanStream* vkStream,
    const VkMemoryHostPointerPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkMemoryHostPointerPropertiesEXT(
    VulkanStream* vkStream,
    VkMemoryHostPointerPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceSize*)&forMarshaling->minImportedHostPointerAlignment, sizeof(VkDeviceSize));
}

void unmarshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalMemoryHostPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceSize*)&forUnmarshaling->minImportedHostPointerAlignment, sizeof(VkDeviceSize));
}

#endif
#ifdef VK_AMD_buffer_marker
#endif
#ifdef VK_AMD_pipeline_compiler_control
void marshal_VkPipelineCompilerControlCreateInfoAMD(
    VulkanStream* vkStream,
    const VkPipelineCompilerControlCreateInfoAMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineCompilerControlFlagsAMD*)&forMarshaling->compilerControlFlags, sizeof(VkPipelineCompilerControlFlagsAMD));
}

void unmarshal_VkPipelineCompilerControlCreateInfoAMD(
    VulkanStream* vkStream,
    VkPipelineCompilerControlCreateInfoAMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineCompilerControlFlagsAMD*)&forUnmarshaling->compilerControlFlags, sizeof(VkPipelineCompilerControlFlagsAMD));
}

#endif
#ifdef VK_EXT_calibrated_timestamps
void marshal_VkCalibratedTimestampInfoEXT(
    VulkanStream* vkStream,
    const VkCalibratedTimestampInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkTimeDomainEXT*)&forMarshaling->timeDomain, sizeof(VkTimeDomainEXT));
}

void unmarshal_VkCalibratedTimestampInfoEXT(
    VulkanStream* vkStream,
    VkCalibratedTimestampInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkTimeDomainEXT*)&forUnmarshaling->timeDomain, sizeof(VkTimeDomainEXT));
}

#endif
#ifdef VK_AMD_shader_core_properties
void marshal_VkPhysicalDeviceShaderCorePropertiesAMD(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderCorePropertiesAMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->shaderEngineCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->shaderArraysPerEngineCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->computeUnitsPerShaderArray, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->simdPerComputeUnit, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->wavefrontsPerSimd, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->wavefrontSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->sgprsPerSimd, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minSgprAllocation, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxSgprAllocation, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->sgprAllocationGranularity, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->vgprsPerSimd, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minVgprAllocation, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVgprAllocation, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->vgprAllocationGranularity, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceShaderCorePropertiesAMD(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderCorePropertiesAMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->shaderEngineCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->shaderArraysPerEngineCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->computeUnitsPerShaderArray, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->simdPerComputeUnit, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->wavefrontsPerSimd, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->wavefrontSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->sgprsPerSimd, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minSgprAllocation, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSgprAllocation, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->sgprAllocationGranularity, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->vgprsPerSimd, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minVgprAllocation, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVgprAllocation, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->vgprAllocationGranularity, sizeof(uint32_t));
}

#endif
#ifdef VK_AMD_memory_overallocation_behavior
void marshal_VkDeviceMemoryOverallocationCreateInfoAMD(
    VulkanStream* vkStream,
    const VkDeviceMemoryOverallocationCreateInfoAMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkMemoryOverallocationBehaviorAMD*)&forMarshaling->overallocationBehavior, sizeof(VkMemoryOverallocationBehaviorAMD));
}

void unmarshal_VkDeviceMemoryOverallocationCreateInfoAMD(
    VulkanStream* vkStream,
    VkDeviceMemoryOverallocationCreateInfoAMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkMemoryOverallocationBehaviorAMD*)&forUnmarshaling->overallocationBehavior, sizeof(VkMemoryOverallocationBehaviorAMD));
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void marshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->maxVertexAttribDivisor, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexAttribDivisor, sizeof(uint32_t));
}

void marshal_VkVertexInputBindingDivisorDescriptionEXT(
    VulkanStream* vkStream,
    const VkVertexInputBindingDivisorDescriptionEXT* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->divisor, sizeof(uint32_t));
}

void unmarshal_VkVertexInputBindingDivisorDescriptionEXT(
    VulkanStream* vkStream,
    VkVertexInputBindingDivisorDescriptionEXT* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->binding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->divisor, sizeof(uint32_t));
}

void marshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineVertexInputDivisorStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->vertexBindingDivisorCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexBindingDivisorCount; ++i)
    {
        marshal_VkVertexInputBindingDivisorDescriptionEXT(vkStream, (const VkVertexInputBindingDivisorDescriptionEXT*)(forMarshaling->pVertexBindingDivisors + i));
    }
}

void unmarshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineVertexInputDivisorStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->vertexBindingDivisorCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pVertexBindingDivisors, forUnmarshaling->vertexBindingDivisorCount * sizeof(const VkVertexInputBindingDivisorDescriptionEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexBindingDivisorCount; ++i)
    {
        unmarshal_VkVertexInputBindingDivisorDescriptionEXT(vkStream, (VkVertexInputBindingDivisorDescriptionEXT*)(forUnmarshaling->pVertexBindingDivisors + i));
    }
}

void marshal_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->vertexAttributeInstanceRateDivisor, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->vertexAttributeInstanceRateZeroDivisor, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->vertexAttributeInstanceRateDivisor, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->vertexAttributeInstanceRateZeroDivisor, sizeof(VkBool32));
}

#endif
#ifdef VK_GGP_frame_token
void marshal_VkPresentFrameTokenGGP(
    VulkanStream* vkStream,
    const VkPresentFrameTokenGGP* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((GgpFrameToken*)&forMarshaling->frameToken, sizeof(GgpFrameToken));
}

void unmarshal_VkPresentFrameTokenGGP(
    VulkanStream* vkStream,
    VkPresentFrameTokenGGP* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((GgpFrameToken*)&forUnmarshaling->frameToken, sizeof(GgpFrameToken));
}

#endif
#ifdef VK_EXT_pipeline_creation_feedback
void marshal_VkPipelineCreationFeedbackEXT(
    VulkanStream* vkStream,
    const VkPipelineCreationFeedbackEXT* forMarshaling)
{
    vkStream->write((VkPipelineCreationFeedbackFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineCreationFeedbackFlagsEXT));
    vkStream->write((uint64_t*)&forMarshaling->duration, sizeof(uint64_t));
}

void unmarshal_VkPipelineCreationFeedbackEXT(
    VulkanStream* vkStream,
    VkPipelineCreationFeedbackEXT* forUnmarshaling)
{
    vkStream->read((VkPipelineCreationFeedbackFlagsEXT*)&forUnmarshaling->flags, sizeof(VkPipelineCreationFeedbackFlagsEXT));
    vkStream->read((uint64_t*)&forUnmarshaling->duration, sizeof(uint64_t));
}

void marshal_VkPipelineCreationFeedbackCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineCreationFeedbackCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkPipelineCreationFeedbackEXT(vkStream, (VkPipelineCreationFeedbackEXT*)(forMarshaling->pPipelineCreationFeedback));
    vkStream->write((uint32_t*)&forMarshaling->pipelineStageCreationFeedbackCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->pipelineStageCreationFeedbackCount; ++i)
    {
        marshal_VkPipelineCreationFeedbackEXT(vkStream, (VkPipelineCreationFeedbackEXT*)(forMarshaling->pPipelineStageCreationFeedbacks + i));
    }
}

void unmarshal_VkPipelineCreationFeedbackCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineCreationFeedbackCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->alloc((void**)&forUnmarshaling->pPipelineCreationFeedback, sizeof(VkPipelineCreationFeedbackEXT));
    unmarshal_VkPipelineCreationFeedbackEXT(vkStream, (VkPipelineCreationFeedbackEXT*)(forUnmarshaling->pPipelineCreationFeedback));
    vkStream->read((uint32_t*)&forUnmarshaling->pipelineStageCreationFeedbackCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPipelineStageCreationFeedbacks, forUnmarshaling->pipelineStageCreationFeedbackCount * sizeof(VkPipelineCreationFeedbackEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->pipelineStageCreationFeedbackCount; ++i)
    {
        unmarshal_VkPipelineCreationFeedbackEXT(vkStream, (VkPipelineCreationFeedbackEXT*)(forUnmarshaling->pPipelineStageCreationFeedbacks + i));
    }
}

#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_compute_shader_derivatives
void marshal_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->computeDerivativeGroupQuads, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->computeDerivativeGroupLinear, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->computeDerivativeGroupQuads, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->computeDerivativeGroupLinear, sizeof(VkBool32));
}

#endif
#ifdef VK_NV_mesh_shader
void marshal_VkPhysicalDeviceMeshShaderFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMeshShaderFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->taskShader, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->meshShader, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceMeshShaderFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceMeshShaderFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->taskShader, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->meshShader, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceMeshShaderPropertiesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMeshShaderPropertiesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->maxDrawMeshTasksCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTaskWorkGroupInvocations, sizeof(uint32_t));
    vkStream->write((uint32_t*)forMarshaling->maxTaskWorkGroupSize, 3 * sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTaskTotalMemorySize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTaskOutputCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxMeshWorkGroupInvocations, sizeof(uint32_t));
    vkStream->write((uint32_t*)forMarshaling->maxMeshWorkGroupSize, 3 * sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxMeshTotalMemorySize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxMeshOutputVertices, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxMeshOutputPrimitives, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxMeshMultiviewViewCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->meshOutputPerVertexGranularity, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->meshOutputPerPrimitiveGranularity, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceMeshShaderPropertiesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceMeshShaderPropertiesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxDrawMeshTasksCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTaskWorkGroupInvocations, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->maxTaskWorkGroupSize, 3 * sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTaskTotalMemorySize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTaskOutputCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMeshWorkGroupInvocations, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->maxMeshWorkGroupSize, 3 * sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMeshTotalMemorySize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMeshOutputVertices, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMeshOutputPrimitives, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMeshMultiviewViewCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->meshOutputPerVertexGranularity, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->meshOutputPerPrimitiveGranularity, sizeof(uint32_t));
}

void marshal_VkDrawMeshTasksIndirectCommandNV(
    VulkanStream* vkStream,
    const VkDrawMeshTasksIndirectCommandNV* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->taskCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->firstTask, sizeof(uint32_t));
}

void unmarshal_VkDrawMeshTasksIndirectCommandNV(
    VulkanStream* vkStream,
    VkDrawMeshTasksIndirectCommandNV* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->taskCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->firstTask, sizeof(uint32_t));
}

#endif
#ifdef VK_NV_fragment_shader_barycentric
void marshal_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->fragmentShaderBarycentric, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentShaderBarycentric, sizeof(VkBool32));
}

#endif
#ifdef VK_NV_shader_image_footprint
void marshal_VkPhysicalDeviceShaderImageFootprintFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderImageFootprintFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->imageFootprint, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShaderImageFootprintFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderImageFootprintFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->imageFootprint, sizeof(VkBool32));
}

#endif
#ifdef VK_NV_scissor_exclusive
void marshal_VkPipelineViewportExclusiveScissorStateCreateInfoNV(
    VulkanStream* vkStream,
    const VkPipelineViewportExclusiveScissorStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->exclusiveScissorCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pExclusiveScissors;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pExclusiveScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->exclusiveScissorCount; ++i)
        {
            marshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pExclusiveScissors + i));
        }
    }
}

void unmarshal_VkPipelineViewportExclusiveScissorStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineViewportExclusiveScissorStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->exclusiveScissorCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pExclusiveScissors = (const VkRect2D*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pExclusiveScissors)
    {
        vkStream->alloc((void**)&forUnmarshaling->pExclusiveScissors, forUnmarshaling->exclusiveScissorCount * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->exclusiveScissorCount; ++i)
        {
            unmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pExclusiveScissors + i));
        }
    }
}

void marshal_VkPhysicalDeviceExclusiveScissorFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceExclusiveScissorFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->exclusiveScissor, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceExclusiveScissorFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceExclusiveScissorFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->exclusiveScissor, sizeof(VkBool32));
}

#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void marshal_VkQueueFamilyCheckpointPropertiesNV(
    VulkanStream* vkStream,
    const VkQueueFamilyCheckpointPropertiesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->checkpointExecutionStageMask, sizeof(VkPipelineStageFlags));
}

void unmarshal_VkQueueFamilyCheckpointPropertiesNV(
    VulkanStream* vkStream,
    VkQueueFamilyCheckpointPropertiesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->checkpointExecutionStageMask, sizeof(VkPipelineStageFlags));
}

void marshal_VkCheckpointDataNV(
    VulkanStream* vkStream,
    const VkCheckpointDataNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineStageFlagBits*)&forMarshaling->stage, sizeof(VkPipelineStageFlagBits));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pCheckpointMarker;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pCheckpointMarker)
    {
        vkStream->write((void*)forMarshaling->pCheckpointMarker, sizeof(uint8_t));
    }
}

void unmarshal_VkCheckpointDataNV(
    VulkanStream* vkStream,
    VkCheckpointDataNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineStageFlagBits*)&forUnmarshaling->stage, sizeof(VkPipelineStageFlagBits));
    // WARNING PTR CHECK
    forUnmarshaling->pCheckpointMarker = (void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pCheckpointMarker)
    {
        vkStream->alloc((void**)&forUnmarshaling->pCheckpointMarker, sizeof(uint8_t));
        vkStream->read((void*)forUnmarshaling->pCheckpointMarker, sizeof(uint8_t));
    }
}

#endif
#ifdef VK_INTEL_shader_integer_functions2
void marshal_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->shaderIntegerFunctions2, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shaderIntegerFunctions2, sizeof(VkBool32));
}

#endif
#ifdef VK_INTEL_performance_query
void marshal_VkPerformanceValueDataINTEL(
    VulkanStream* vkStream,
    const VkPerformanceValueDataINTEL* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->value32, sizeof(uint32_t));
}

void unmarshal_VkPerformanceValueDataINTEL(
    VulkanStream* vkStream,
    VkPerformanceValueDataINTEL* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->value32, sizeof(uint32_t));
}

void marshal_VkPerformanceValueINTEL(
    VulkanStream* vkStream,
    const VkPerformanceValueINTEL* forMarshaling)
{
    vkStream->write((VkPerformanceValueTypeINTEL*)&forMarshaling->type, sizeof(VkPerformanceValueTypeINTEL));
    marshal_VkPerformanceValueDataINTEL(vkStream, (VkPerformanceValueDataINTEL*)(&forMarshaling->data));
}

void unmarshal_VkPerformanceValueINTEL(
    VulkanStream* vkStream,
    VkPerformanceValueINTEL* forUnmarshaling)
{
    vkStream->read((VkPerformanceValueTypeINTEL*)&forUnmarshaling->type, sizeof(VkPerformanceValueTypeINTEL));
    unmarshal_VkPerformanceValueDataINTEL(vkStream, (VkPerformanceValueDataINTEL*)(&forUnmarshaling->data));
}

void marshal_VkInitializePerformanceApiInfoINTEL(
    VulkanStream* vkStream,
    const VkInitializePerformanceApiInfoINTEL* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pUserData;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pUserData)
    {
        vkStream->write((void*)forMarshaling->pUserData, sizeof(uint8_t));
    }
}

void unmarshal_VkInitializePerformanceApiInfoINTEL(
    VulkanStream* vkStream,
    VkInitializePerformanceApiInfoINTEL* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    // WARNING PTR CHECK
    forUnmarshaling->pUserData = (void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pUserData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
        vkStream->read((void*)forUnmarshaling->pUserData, sizeof(uint8_t));
    }
}

void marshal_VkQueryPoolPerformanceQueryCreateInfoINTEL(
    VulkanStream* vkStream,
    const VkQueryPoolPerformanceQueryCreateInfoINTEL* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkQueryPoolSamplingModeINTEL*)&forMarshaling->performanceCountersSampling, sizeof(VkQueryPoolSamplingModeINTEL));
}

void unmarshal_VkQueryPoolPerformanceQueryCreateInfoINTEL(
    VulkanStream* vkStream,
    VkQueryPoolPerformanceQueryCreateInfoINTEL* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkQueryPoolSamplingModeINTEL*)&forUnmarshaling->performanceCountersSampling, sizeof(VkQueryPoolSamplingModeINTEL));
}

void marshal_VkPerformanceMarkerInfoINTEL(
    VulkanStream* vkStream,
    const VkPerformanceMarkerInfoINTEL* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint64_t*)&forMarshaling->marker, sizeof(uint64_t));
}

void unmarshal_VkPerformanceMarkerInfoINTEL(
    VulkanStream* vkStream,
    VkPerformanceMarkerInfoINTEL* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint64_t*)&forUnmarshaling->marker, sizeof(uint64_t));
}

void marshal_VkPerformanceStreamMarkerInfoINTEL(
    VulkanStream* vkStream,
    const VkPerformanceStreamMarkerInfoINTEL* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->marker, sizeof(uint32_t));
}

void unmarshal_VkPerformanceStreamMarkerInfoINTEL(
    VulkanStream* vkStream,
    VkPerformanceStreamMarkerInfoINTEL* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->marker, sizeof(uint32_t));
}

void marshal_VkPerformanceOverrideInfoINTEL(
    VulkanStream* vkStream,
    const VkPerformanceOverrideInfoINTEL* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPerformanceOverrideTypeINTEL*)&forMarshaling->type, sizeof(VkPerformanceOverrideTypeINTEL));
    vkStream->write((VkBool32*)&forMarshaling->enable, sizeof(VkBool32));
    vkStream->write((uint64_t*)&forMarshaling->parameter, sizeof(uint64_t));
}

void unmarshal_VkPerformanceOverrideInfoINTEL(
    VulkanStream* vkStream,
    VkPerformanceOverrideInfoINTEL* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPerformanceOverrideTypeINTEL*)&forUnmarshaling->type, sizeof(VkPerformanceOverrideTypeINTEL));
    vkStream->read((VkBool32*)&forUnmarshaling->enable, sizeof(VkBool32));
    vkStream->read((uint64_t*)&forUnmarshaling->parameter, sizeof(uint64_t));
}

void marshal_VkPerformanceConfigurationAcquireInfoINTEL(
    VulkanStream* vkStream,
    const VkPerformanceConfigurationAcquireInfoINTEL* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPerformanceConfigurationTypeINTEL*)&forMarshaling->type, sizeof(VkPerformanceConfigurationTypeINTEL));
}

void unmarshal_VkPerformanceConfigurationAcquireInfoINTEL(
    VulkanStream* vkStream,
    VkPerformanceConfigurationAcquireInfoINTEL* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPerformanceConfigurationTypeINTEL*)&forUnmarshaling->type, sizeof(VkPerformanceConfigurationTypeINTEL));
}

#endif
#ifdef VK_EXT_pci_bus_info
void marshal_VkPhysicalDevicePCIBusInfoPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDevicePCIBusInfoPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->pciDomain, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->pciBus, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->pciDevice, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->pciFunction, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDevicePCIBusInfoPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDevicePCIBusInfoPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->pciDomain, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->pciBus, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->pciDevice, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->pciFunction, sizeof(uint32_t));
}

#endif
#ifdef VK_AMD_display_native_hdr
void marshal_VkDisplayNativeHdrSurfaceCapabilitiesAMD(
    VulkanStream* vkStream,
    const VkDisplayNativeHdrSurfaceCapabilitiesAMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->localDimmingSupport, sizeof(VkBool32));
}

void unmarshal_VkDisplayNativeHdrSurfaceCapabilitiesAMD(
    VulkanStream* vkStream,
    VkDisplayNativeHdrSurfaceCapabilitiesAMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->localDimmingSupport, sizeof(VkBool32));
}

void marshal_VkSwapchainDisplayNativeHdrCreateInfoAMD(
    VulkanStream* vkStream,
    const VkSwapchainDisplayNativeHdrCreateInfoAMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->localDimmingEnable, sizeof(VkBool32));
}

void unmarshal_VkSwapchainDisplayNativeHdrCreateInfoAMD(
    VulkanStream* vkStream,
    VkSwapchainDisplayNativeHdrCreateInfoAMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->localDimmingEnable, sizeof(VkBool32));
}

#endif
#ifdef VK_FUCHSIA_imagepipe_surface
void marshal_VkImagePipeSurfaceCreateInfoFUCHSIA(
    VulkanStream* vkStream,
    const VkImagePipeSurfaceCreateInfoFUCHSIA* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkImagePipeSurfaceCreateFlagsFUCHSIA*)&forMarshaling->flags, sizeof(VkImagePipeSurfaceCreateFlagsFUCHSIA));
    vkStream->write((zx_handle_t*)&forMarshaling->imagePipeHandle, sizeof(zx_handle_t));
}

void unmarshal_VkImagePipeSurfaceCreateInfoFUCHSIA(
    VulkanStream* vkStream,
    VkImagePipeSurfaceCreateInfoFUCHSIA* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImagePipeSurfaceCreateFlagsFUCHSIA*)&forUnmarshaling->flags, sizeof(VkImagePipeSurfaceCreateFlagsFUCHSIA));
    vkStream->read((zx_handle_t*)&forUnmarshaling->imagePipeHandle, sizeof(zx_handle_t));
}

#endif
#ifdef VK_EXT_metal_surface
void marshal_VkMetalSurfaceCreateInfoEXT(
    VulkanStream* vkStream,
    const VkMetalSurfaceCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkMetalSurfaceCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkMetalSurfaceCreateFlagsEXT));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pLayer;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pLayer)
    {
        vkStream->write((const CAMetalLayer*)forMarshaling->pLayer, sizeof(const CAMetalLayer));
    }
}

void unmarshal_VkMetalSurfaceCreateInfoEXT(
    VulkanStream* vkStream,
    VkMetalSurfaceCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkMetalSurfaceCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkMetalSurfaceCreateFlagsEXT));
    // WARNING PTR CHECK
    forUnmarshaling->pLayer = (const CAMetalLayer*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pLayer)
    {
        vkStream->alloc((void**)&forUnmarshaling->pLayer, sizeof(const CAMetalLayer));
        vkStream->read((CAMetalLayer*)forUnmarshaling->pLayer, sizeof(const CAMetalLayer));
    }
}

#endif
#ifdef VK_GOOGLE_color_buffer
void marshal_VkImportColorBufferGOOGLE(
    VulkanStream* vkStream,
    const VkImportColorBufferGOOGLE* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->colorBuffer, sizeof(uint32_t));
}

void unmarshal_VkImportColorBufferGOOGLE(
    VulkanStream* vkStream,
    VkImportColorBufferGOOGLE* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->colorBuffer, sizeof(uint32_t));
}

void marshal_VkImportBufferGOOGLE(
    VulkanStream* vkStream,
    const VkImportBufferGOOGLE* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->buffer, sizeof(uint32_t));
}

void unmarshal_VkImportBufferGOOGLE(
    VulkanStream* vkStream,
    VkImportBufferGOOGLE* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->buffer, sizeof(uint32_t));
}

void marshal_VkImportPhysicalAddressGOOGLE(
    VulkanStream* vkStream,
    const VkImportPhysicalAddressGOOGLE* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint64_t*)&forMarshaling->physicalAddress, sizeof(uint64_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    vkStream->write((uint32_t*)&forMarshaling->tilingParameter, sizeof(uint32_t));
}

void unmarshal_VkImportPhysicalAddressGOOGLE(
    VulkanStream* vkStream,
    VkImportPhysicalAddressGOOGLE* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint64_t*)&forUnmarshaling->physicalAddress, sizeof(uint64_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkImageTiling*)&forUnmarshaling->tiling, sizeof(VkImageTiling));
    vkStream->read((uint32_t*)&forUnmarshaling->tilingParameter, sizeof(uint32_t));
}

#endif
#ifdef VK_EXT_scalar_block_layout
#endif
#ifdef VK_GOOGLE_hlsl_functionality1
#endif
#ifdef VK_GOOGLE_decorate_string
#endif
#ifdef VK_EXT_subgroup_size_control
void marshal_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->subgroupSizeControl, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->computeFullSubgroups, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceSubgroupSizeControlFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->subgroupSizeControl, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->computeFullSubgroups, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->minSubgroupSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxSubgroupSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxComputeWorkgroupSubgroups, sizeof(uint32_t));
    vkStream->write((VkShaderStageFlags*)&forMarshaling->requiredSubgroupSizeStages, sizeof(VkShaderStageFlags));
}

void unmarshal_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceSubgroupSizeControlPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->minSubgroupSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSubgroupSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxComputeWorkgroupSubgroups, sizeof(uint32_t));
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->requiredSubgroupSizeStages, sizeof(VkShaderStageFlags));
}

void marshal_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->requiredSubgroupSize, sizeof(uint32_t));
}

void unmarshal_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->requiredSubgroupSize, sizeof(uint32_t));
}

#endif
#ifdef VK_AMD_shader_core_properties2
void marshal_VkPhysicalDeviceShaderCoreProperties2AMD(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderCoreProperties2AMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkShaderCorePropertiesFlagsAMD*)&forMarshaling->shaderCoreFeatures, sizeof(VkShaderCorePropertiesFlagsAMD));
    vkStream->write((uint32_t*)&forMarshaling->activeComputeUnitCount, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceShaderCoreProperties2AMD(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderCoreProperties2AMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkShaderCorePropertiesFlagsAMD*)&forUnmarshaling->shaderCoreFeatures, sizeof(VkShaderCorePropertiesFlagsAMD));
    vkStream->read((uint32_t*)&forUnmarshaling->activeComputeUnitCount, sizeof(uint32_t));
}

#endif
#ifdef VK_AMD_device_coherent_memory
void marshal_VkPhysicalDeviceCoherentMemoryFeaturesAMD(
    VulkanStream* vkStream,
    const VkPhysicalDeviceCoherentMemoryFeaturesAMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->deviceCoherentMemory, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceCoherentMemoryFeaturesAMD(
    VulkanStream* vkStream,
    VkPhysicalDeviceCoherentMemoryFeaturesAMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->deviceCoherentMemory, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_shader_image_atomic_int64
void marshal_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->shaderImageInt64Atomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseImageInt64Atomics, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shaderImageInt64Atomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseImageInt64Atomics, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_memory_budget
void marshal_VkPhysicalDeviceMemoryBudgetPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMemoryBudgetPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceSize*)forMarshaling->heapBudget, VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)forMarshaling->heapUsage, VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize));
}

void unmarshal_VkPhysicalDeviceMemoryBudgetPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceMemoryBudgetPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceSize*)forUnmarshaling->heapBudget, VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)forUnmarshaling->heapUsage, VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize));
}

#endif
#ifdef VK_EXT_memory_priority
void marshal_VkPhysicalDeviceMemoryPriorityFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMemoryPriorityFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->memoryPriority, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceMemoryPriorityFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceMemoryPriorityFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->memoryPriority, sizeof(VkBool32));
}

void marshal_VkMemoryPriorityAllocateInfoEXT(
    VulkanStream* vkStream,
    const VkMemoryPriorityAllocateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((float*)&forMarshaling->priority, sizeof(float));
}

void unmarshal_VkMemoryPriorityAllocateInfoEXT(
    VulkanStream* vkStream,
    VkMemoryPriorityAllocateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((float*)&forUnmarshaling->priority, sizeof(float));
}

#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
void marshal_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->dedicatedAllocationImageAliasing, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->dedicatedAllocationImageAliasing, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_buffer_device_address
void marshal_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->bufferDeviceAddress, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->bufferDeviceAddressCaptureReplay, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->bufferDeviceAddressMultiDevice, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->bufferDeviceAddress, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->bufferDeviceAddressCaptureReplay, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->bufferDeviceAddressMultiDevice, sizeof(VkBool32));
}

void marshal_VkBufferDeviceAddressCreateInfoEXT(
    VulkanStream* vkStream,
    const VkBufferDeviceAddressCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceAddress*)&forMarshaling->deviceAddress, sizeof(VkDeviceAddress));
}

void unmarshal_VkBufferDeviceAddressCreateInfoEXT(
    VulkanStream* vkStream,
    VkBufferDeviceAddressCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceAddress*)&forUnmarshaling->deviceAddress, sizeof(VkDeviceAddress));
}

#endif
#ifdef VK_EXT_tooling_info
void marshal_VkPhysicalDeviceToolPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceToolPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((char*)forMarshaling->name, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->write((char*)forMarshaling->version, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->write((VkToolPurposeFlagsEXT*)&forMarshaling->purposes, sizeof(VkToolPurposeFlagsEXT));
    vkStream->write((char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->write((char*)forMarshaling->layer, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
}

void unmarshal_VkPhysicalDeviceToolPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceToolPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((char*)forUnmarshaling->name, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->read((char*)forUnmarshaling->version, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->read((VkToolPurposeFlagsEXT*)&forUnmarshaling->purposes, sizeof(VkToolPurposeFlagsEXT));
    vkStream->read((char*)forUnmarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    vkStream->read((char*)forUnmarshaling->layer, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
}

#endif
#ifdef VK_EXT_separate_stencil_usage
#endif
#ifdef VK_EXT_validation_features
void marshal_VkValidationFeaturesEXT(
    VulkanStream* vkStream,
    const VkValidationFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->enabledValidationFeatureCount, sizeof(uint32_t));
    vkStream->write((const VkValidationFeatureEnableEXT*)forMarshaling->pEnabledValidationFeatures, forMarshaling->enabledValidationFeatureCount * sizeof(const VkValidationFeatureEnableEXT));
    vkStream->write((uint32_t*)&forMarshaling->disabledValidationFeatureCount, sizeof(uint32_t));
    vkStream->write((const VkValidationFeatureDisableEXT*)forMarshaling->pDisabledValidationFeatures, forMarshaling->disabledValidationFeatureCount * sizeof(const VkValidationFeatureDisableEXT));
}

void unmarshal_VkValidationFeaturesEXT(
    VulkanStream* vkStream,
    VkValidationFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->enabledValidationFeatureCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pEnabledValidationFeatures, forUnmarshaling->enabledValidationFeatureCount * sizeof(const VkValidationFeatureEnableEXT));
    vkStream->read((VkValidationFeatureEnableEXT*)forUnmarshaling->pEnabledValidationFeatures, forUnmarshaling->enabledValidationFeatureCount * sizeof(const VkValidationFeatureEnableEXT));
    vkStream->read((uint32_t*)&forUnmarshaling->disabledValidationFeatureCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDisabledValidationFeatures, forUnmarshaling->disabledValidationFeatureCount * sizeof(const VkValidationFeatureDisableEXT));
    vkStream->read((VkValidationFeatureDisableEXT*)forUnmarshaling->pDisabledValidationFeatures, forUnmarshaling->disabledValidationFeatureCount * sizeof(const VkValidationFeatureDisableEXT));
}

#endif
#ifdef VK_NV_cooperative_matrix
void marshal_VkCooperativeMatrixPropertiesNV(
    VulkanStream* vkStream,
    const VkCooperativeMatrixPropertiesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->MSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->NSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->KSize, sizeof(uint32_t));
    vkStream->write((VkComponentTypeNV*)&forMarshaling->AType, sizeof(VkComponentTypeNV));
    vkStream->write((VkComponentTypeNV*)&forMarshaling->BType, sizeof(VkComponentTypeNV));
    vkStream->write((VkComponentTypeNV*)&forMarshaling->CType, sizeof(VkComponentTypeNV));
    vkStream->write((VkComponentTypeNV*)&forMarshaling->DType, sizeof(VkComponentTypeNV));
    vkStream->write((VkScopeNV*)&forMarshaling->scope, sizeof(VkScopeNV));
}

void unmarshal_VkCooperativeMatrixPropertiesNV(
    VulkanStream* vkStream,
    VkCooperativeMatrixPropertiesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->MSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->NSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->KSize, sizeof(uint32_t));
    vkStream->read((VkComponentTypeNV*)&forUnmarshaling->AType, sizeof(VkComponentTypeNV));
    vkStream->read((VkComponentTypeNV*)&forUnmarshaling->BType, sizeof(VkComponentTypeNV));
    vkStream->read((VkComponentTypeNV*)&forUnmarshaling->CType, sizeof(VkComponentTypeNV));
    vkStream->read((VkComponentTypeNV*)&forUnmarshaling->DType, sizeof(VkComponentTypeNV));
    vkStream->read((VkScopeNV*)&forUnmarshaling->scope, sizeof(VkScopeNV));
}

void marshal_VkPhysicalDeviceCooperativeMatrixFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceCooperativeMatrixFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->cooperativeMatrix, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->cooperativeMatrixRobustBufferAccess, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceCooperativeMatrixFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceCooperativeMatrixFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->cooperativeMatrix, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->cooperativeMatrixRobustBufferAccess, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceCooperativeMatrixPropertiesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceCooperativeMatrixPropertiesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkShaderStageFlags*)&forMarshaling->cooperativeMatrixSupportedStages, sizeof(VkShaderStageFlags));
}

void unmarshal_VkPhysicalDeviceCooperativeMatrixPropertiesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceCooperativeMatrixPropertiesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->cooperativeMatrixSupportedStages, sizeof(VkShaderStageFlags));
}

#endif
#ifdef VK_NV_coverage_reduction_mode
void marshal_VkPhysicalDeviceCoverageReductionModeFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceCoverageReductionModeFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->coverageReductionMode, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceCoverageReductionModeFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceCoverageReductionModeFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->coverageReductionMode, sizeof(VkBool32));
}

void marshal_VkPipelineCoverageReductionStateCreateInfoNV(
    VulkanStream* vkStream,
    const VkPipelineCoverageReductionStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineCoverageReductionStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineCoverageReductionStateCreateFlagsNV));
    vkStream->write((VkCoverageReductionModeNV*)&forMarshaling->coverageReductionMode, sizeof(VkCoverageReductionModeNV));
}

void unmarshal_VkPipelineCoverageReductionStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineCoverageReductionStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineCoverageReductionStateCreateFlagsNV*)&forUnmarshaling->flags, sizeof(VkPipelineCoverageReductionStateCreateFlagsNV));
    vkStream->read((VkCoverageReductionModeNV*)&forUnmarshaling->coverageReductionMode, sizeof(VkCoverageReductionModeNV));
}

void marshal_VkFramebufferMixedSamplesCombinationNV(
    VulkanStream* vkStream,
    const VkFramebufferMixedSamplesCombinationNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkCoverageReductionModeNV*)&forMarshaling->coverageReductionMode, sizeof(VkCoverageReductionModeNV));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->rasterizationSamples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->depthStencilSamples, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->colorSamples, sizeof(VkSampleCountFlags));
}

void unmarshal_VkFramebufferMixedSamplesCombinationNV(
    VulkanStream* vkStream,
    VkFramebufferMixedSamplesCombinationNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkCoverageReductionModeNV*)&forUnmarshaling->coverageReductionMode, sizeof(VkCoverageReductionModeNV));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->rasterizationSamples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->depthStencilSamples, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->colorSamples, sizeof(VkSampleCountFlags));
}

#endif
#ifdef VK_EXT_fragment_shader_interlock
void marshal_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->fragmentShaderSampleInterlock, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fragmentShaderPixelInterlock, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fragmentShaderShadingRateInterlock, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentShaderSampleInterlock, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentShaderPixelInterlock, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentShaderShadingRateInterlock, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_ycbcr_image_arrays
void marshal_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->ycbcrImageArrays, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->ycbcrImageArrays, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_full_screen_exclusive
void marshal_VkSurfaceFullScreenExclusiveInfoEXT(
    VulkanStream* vkStream,
    const VkSurfaceFullScreenExclusiveInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkFullScreenExclusiveEXT*)&forMarshaling->fullScreenExclusive, sizeof(VkFullScreenExclusiveEXT));
}

void unmarshal_VkSurfaceFullScreenExclusiveInfoEXT(
    VulkanStream* vkStream,
    VkSurfaceFullScreenExclusiveInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFullScreenExclusiveEXT*)&forUnmarshaling->fullScreenExclusive, sizeof(VkFullScreenExclusiveEXT));
}

void marshal_VkSurfaceCapabilitiesFullScreenExclusiveEXT(
    VulkanStream* vkStream,
    const VkSurfaceCapabilitiesFullScreenExclusiveEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->fullScreenExclusiveSupported, sizeof(VkBool32));
}

void unmarshal_VkSurfaceCapabilitiesFullScreenExclusiveEXT(
    VulkanStream* vkStream,
    VkSurfaceCapabilitiesFullScreenExclusiveEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->fullScreenExclusiveSupported, sizeof(VkBool32));
}

void marshal_VkSurfaceFullScreenExclusiveWin32InfoEXT(
    VulkanStream* vkStream,
    const VkSurfaceFullScreenExclusiveWin32InfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((HMONITOR*)&forMarshaling->hmonitor, sizeof(HMONITOR));
}

void unmarshal_VkSurfaceFullScreenExclusiveWin32InfoEXT(
    VulkanStream* vkStream,
    VkSurfaceFullScreenExclusiveWin32InfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((HMONITOR*)&forUnmarshaling->hmonitor, sizeof(HMONITOR));
}

#endif
#ifdef VK_EXT_headless_surface
void marshal_VkHeadlessSurfaceCreateInfoEXT(
    VulkanStream* vkStream,
    const VkHeadlessSurfaceCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkHeadlessSurfaceCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkHeadlessSurfaceCreateFlagsEXT));
}

void unmarshal_VkHeadlessSurfaceCreateInfoEXT(
    VulkanStream* vkStream,
    VkHeadlessSurfaceCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkHeadlessSurfaceCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkHeadlessSurfaceCreateFlagsEXT));
}

#endif
#ifdef VK_EXT_line_rasterization
void marshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceLineRasterizationFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->rectangularLines, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->bresenhamLines, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->smoothLines, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->stippledRectangularLines, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->stippledBresenhamLines, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->stippledSmoothLines, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceLineRasterizationFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->rectangularLines, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->bresenhamLines, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->smoothLines, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->stippledRectangularLines, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->stippledBresenhamLines, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->stippledSmoothLines, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceLineRasterizationPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->lineSubPixelPrecisionBits, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceLineRasterizationPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->lineSubPixelPrecisionBits, sizeof(uint32_t));
}

void marshal_VkPipelineRasterizationLineStateCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineRasterizationLineStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkLineRasterizationModeEXT*)&forMarshaling->lineRasterizationMode, sizeof(VkLineRasterizationModeEXT));
    vkStream->write((VkBool32*)&forMarshaling->stippledLineEnable, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->lineStippleFactor, sizeof(uint32_t));
    vkStream->write((uint16_t*)&forMarshaling->lineStipplePattern, sizeof(uint16_t));
}

void unmarshal_VkPipelineRasterizationLineStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineRasterizationLineStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkLineRasterizationModeEXT*)&forUnmarshaling->lineRasterizationMode, sizeof(VkLineRasterizationModeEXT));
    vkStream->read((VkBool32*)&forUnmarshaling->stippledLineEnable, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->lineStippleFactor, sizeof(uint32_t));
    vkStream->read((uint16_t*)&forUnmarshaling->lineStipplePattern, sizeof(uint16_t));
}

#endif
#ifdef VK_EXT_shader_atomic_float
void marshal_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->shaderBufferFloat32Atomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderBufferFloat32AtomicAdd, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderBufferFloat64Atomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderBufferFloat64AtomicAdd, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSharedFloat32Atomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSharedFloat32AtomicAdd, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSharedFloat64Atomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSharedFloat64AtomicAdd, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderImageFloat32Atomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderImageFloat32AtomicAdd, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseImageFloat32Atomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseImageFloat32AtomicAdd, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shaderBufferFloat32Atomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderBufferFloat32AtomicAdd, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderBufferFloat64Atomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderBufferFloat64AtomicAdd, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSharedFloat32Atomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSharedFloat32AtomicAdd, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSharedFloat64Atomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSharedFloat64AtomicAdd, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderImageFloat32Atomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderImageFloat32AtomicAdd, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseImageFloat32Atomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseImageFloat32AtomicAdd, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_host_query_reset
#endif
#ifdef VK_EXT_index_type_uint8
void marshal_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceIndexTypeUint8FeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->indexTypeUint8, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceIndexTypeUint8FeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->indexTypeUint8, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_extended_dynamic_state
void marshal_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->extendedDynamicState, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->extendedDynamicState, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
void marshal_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->shaderDemoteToHelperInvocation, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDemoteToHelperInvocation, sizeof(VkBool32));
}

#endif
#ifdef VK_NV_device_generated_commands
void marshal_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->maxGraphicsShaderGroupCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxIndirectSequenceCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxIndirectCommandsTokenCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxIndirectCommandsStreamCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxIndirectCommandsTokenOffset, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxIndirectCommandsStreamStride, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minSequencesCountBufferOffsetAlignment, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minSequencesIndexBufferOffsetAlignment, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minIndirectCommandsBufferOffsetAlignment, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxGraphicsShaderGroupCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxIndirectSequenceCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxIndirectCommandsTokenCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxIndirectCommandsStreamCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxIndirectCommandsTokenOffset, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxIndirectCommandsStreamStride, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minSequencesCountBufferOffsetAlignment, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minSequencesIndexBufferOffsetAlignment, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minIndirectCommandsBufferOffsetAlignment, sizeof(uint32_t));
}

void marshal_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->deviceGeneratedCommands, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->deviceGeneratedCommands, sizeof(VkBool32));
}

void marshal_VkGraphicsShaderGroupCreateInfoNV(
    VulkanStream* vkStream,
    const VkGraphicsShaderGroupCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->stageCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->stageCount; ++i)
    {
        marshal_VkPipelineShaderStageCreateInfo(vkStream, (const VkPipelineShaderStageCreateInfo*)(forMarshaling->pStages + i));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pVertexInputState;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pVertexInputState)
    {
        marshal_VkPipelineVertexInputStateCreateInfo(vkStream, (const VkPipelineVertexInputStateCreateInfo*)(forMarshaling->pVertexInputState));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pTessellationState;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pTessellationState)
    {
        marshal_VkPipelineTessellationStateCreateInfo(vkStream, (const VkPipelineTessellationStateCreateInfo*)(forMarshaling->pTessellationState));
    }
}

void unmarshal_VkGraphicsShaderGroupCreateInfoNV(
    VulkanStream* vkStream,
    VkGraphicsShaderGroupCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->stageCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pStages, forUnmarshaling->stageCount * sizeof(const VkPipelineShaderStageCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->stageCount; ++i)
    {
        unmarshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(forUnmarshaling->pStages + i));
    }
    // WARNING PTR CHECK
    forUnmarshaling->pVertexInputState = (const VkPipelineVertexInputStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pVertexInputState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pVertexInputState, sizeof(const VkPipelineVertexInputStateCreateInfo));
        unmarshal_VkPipelineVertexInputStateCreateInfo(vkStream, (VkPipelineVertexInputStateCreateInfo*)(forUnmarshaling->pVertexInputState));
    }
    // WARNING PTR CHECK
    forUnmarshaling->pTessellationState = (const VkPipelineTessellationStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pTessellationState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pTessellationState, sizeof(const VkPipelineTessellationStateCreateInfo));
        unmarshal_VkPipelineTessellationStateCreateInfo(vkStream, (VkPipelineTessellationStateCreateInfo*)(forUnmarshaling->pTessellationState));
    }
}

void marshal_VkGraphicsPipelineShaderGroupsCreateInfoNV(
    VulkanStream* vkStream,
    const VkGraphicsPipelineShaderGroupsCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->groupCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->groupCount; ++i)
    {
        marshal_VkGraphicsShaderGroupCreateInfoNV(vkStream, (const VkGraphicsShaderGroupCreateInfoNV*)(forMarshaling->pGroups + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->pipelineCount, sizeof(uint32_t));
    if (forMarshaling->pipelineCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forMarshaling->pipelineCount * 8);
        vkStream->handleMapping()->mapHandles_VkPipeline_u64(forMarshaling->pPipelines, cgen_var_0, forMarshaling->pipelineCount);
        vkStream->write((uint64_t*)cgen_var_0, forMarshaling->pipelineCount * 8);
    }
}

void unmarshal_VkGraphicsPipelineShaderGroupsCreateInfoNV(
    VulkanStream* vkStream,
    VkGraphicsPipelineShaderGroupsCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->groupCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pGroups, forUnmarshaling->groupCount * sizeof(const VkGraphicsShaderGroupCreateInfoNV));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->groupCount; ++i)
    {
        unmarshal_VkGraphicsShaderGroupCreateInfoNV(vkStream, (VkGraphicsShaderGroupCreateInfoNV*)(forUnmarshaling->pGroups + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->pipelineCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPipelines, forUnmarshaling->pipelineCount * sizeof(const VkPipeline));
    if (forUnmarshaling->pipelineCount)
    {
        uint64_t* cgen_var_0;
        vkStream->alloc((void**)&cgen_var_0, forUnmarshaling->pipelineCount * 8);
        vkStream->read((uint64_t*)cgen_var_0, forUnmarshaling->pipelineCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_0, (VkPipeline*)forUnmarshaling->pPipelines, forUnmarshaling->pipelineCount);
    }
}

void marshal_VkBindShaderGroupIndirectCommandNV(
    VulkanStream* vkStream,
    const VkBindShaderGroupIndirectCommandNV* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->groupIndex, sizeof(uint32_t));
}

void unmarshal_VkBindShaderGroupIndirectCommandNV(
    VulkanStream* vkStream,
    VkBindShaderGroupIndirectCommandNV* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->groupIndex, sizeof(uint32_t));
}

void marshal_VkBindIndexBufferIndirectCommandNV(
    VulkanStream* vkStream,
    const VkBindIndexBufferIndirectCommandNV* forMarshaling)
{
    vkStream->write((VkDeviceAddress*)&forMarshaling->bufferAddress, sizeof(VkDeviceAddress));
    vkStream->write((uint32_t*)&forMarshaling->size, sizeof(uint32_t));
    vkStream->write((VkIndexType*)&forMarshaling->indexType, sizeof(VkIndexType));
}

void unmarshal_VkBindIndexBufferIndirectCommandNV(
    VulkanStream* vkStream,
    VkBindIndexBufferIndirectCommandNV* forUnmarshaling)
{
    vkStream->read((VkDeviceAddress*)&forUnmarshaling->bufferAddress, sizeof(VkDeviceAddress));
    vkStream->read((uint32_t*)&forUnmarshaling->size, sizeof(uint32_t));
    vkStream->read((VkIndexType*)&forUnmarshaling->indexType, sizeof(VkIndexType));
}

void marshal_VkBindVertexBufferIndirectCommandNV(
    VulkanStream* vkStream,
    const VkBindVertexBufferIndirectCommandNV* forMarshaling)
{
    vkStream->write((VkDeviceAddress*)&forMarshaling->bufferAddress, sizeof(VkDeviceAddress));
    vkStream->write((uint32_t*)&forMarshaling->size, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->stride, sizeof(uint32_t));
}

void unmarshal_VkBindVertexBufferIndirectCommandNV(
    VulkanStream* vkStream,
    VkBindVertexBufferIndirectCommandNV* forUnmarshaling)
{
    vkStream->read((VkDeviceAddress*)&forUnmarshaling->bufferAddress, sizeof(VkDeviceAddress));
    vkStream->read((uint32_t*)&forUnmarshaling->size, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->stride, sizeof(uint32_t));
}

void marshal_VkSetStateFlagsIndirectCommandNV(
    VulkanStream* vkStream,
    const VkSetStateFlagsIndirectCommandNV* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->data, sizeof(uint32_t));
}

void unmarshal_VkSetStateFlagsIndirectCommandNV(
    VulkanStream* vkStream,
    VkSetStateFlagsIndirectCommandNV* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->data, sizeof(uint32_t));
}

void marshal_VkIndirectCommandsStreamNV(
    VulkanStream* vkStream,
    const VkIndirectCommandsStreamNV* forMarshaling)
{
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
}

void unmarshal_VkIndirectCommandsStreamNV(
    VulkanStream* vkStream,
    VkIndirectCommandsStreamNV* forUnmarshaling)
{
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_0, (VkBuffer*)&forUnmarshaling->buffer, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
}

void marshal_VkIndirectCommandsLayoutTokenNV(
    VulkanStream* vkStream,
    const VkIndirectCommandsLayoutTokenNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkIndirectCommandsTokenTypeNV*)&forMarshaling->tokenType, sizeof(VkIndirectCommandsTokenTypeNV));
    vkStream->write((uint32_t*)&forMarshaling->stream, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->vertexBindingUnit, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->vertexDynamicStride, sizeof(VkBool32));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&forMarshaling->pushconstantPipelineLayout, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkShaderStageFlags*)&forMarshaling->pushconstantShaderStageFlags, sizeof(VkShaderStageFlags));
    vkStream->write((uint32_t*)&forMarshaling->pushconstantOffset, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->pushconstantSize, sizeof(uint32_t));
    vkStream->write((VkIndirectStateFlagsNV*)&forMarshaling->indirectStateFlags, sizeof(VkIndirectStateFlagsNV));
    vkStream->write((uint32_t*)&forMarshaling->indexTypeCount, sizeof(uint32_t));
    vkStream->write((const VkIndexType*)forMarshaling->pIndexTypes, forMarshaling->indexTypeCount * sizeof(const VkIndexType));
    vkStream->write((const uint32_t*)forMarshaling->pIndexTypeValues, forMarshaling->indexTypeCount * sizeof(const uint32_t));
}

void unmarshal_VkIndirectCommandsLayoutTokenNV(
    VulkanStream* vkStream,
    VkIndirectCommandsLayoutTokenNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkIndirectCommandsTokenTypeNV*)&forUnmarshaling->tokenType, sizeof(VkIndirectCommandsTokenTypeNV));
    vkStream->read((uint32_t*)&forUnmarshaling->stream, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->offset, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->vertexBindingUnit, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->vertexDynamicStride, sizeof(VkBool32));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_0, (VkPipelineLayout*)&forUnmarshaling->pushconstantPipelineLayout, 1);
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->pushconstantShaderStageFlags, sizeof(VkShaderStageFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->pushconstantOffset, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->pushconstantSize, sizeof(uint32_t));
    vkStream->read((VkIndirectStateFlagsNV*)&forUnmarshaling->indirectStateFlags, sizeof(VkIndirectStateFlagsNV));
    vkStream->read((uint32_t*)&forUnmarshaling->indexTypeCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pIndexTypes, forUnmarshaling->indexTypeCount * sizeof(const VkIndexType));
    vkStream->read((VkIndexType*)forUnmarshaling->pIndexTypes, forUnmarshaling->indexTypeCount * sizeof(const VkIndexType));
    vkStream->alloc((void**)&forUnmarshaling->pIndexTypeValues, forUnmarshaling->indexTypeCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pIndexTypeValues, forUnmarshaling->indexTypeCount * sizeof(const uint32_t));
}

void marshal_VkIndirectCommandsLayoutCreateInfoNV(
    VulkanStream* vkStream,
    const VkIndirectCommandsLayoutCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkIndirectCommandsLayoutUsageFlagsNV*)&forMarshaling->flags, sizeof(VkIndirectCommandsLayoutUsageFlagsNV));
    vkStream->write((VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->write((uint32_t*)&forMarshaling->tokenCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->tokenCount; ++i)
    {
        marshal_VkIndirectCommandsLayoutTokenNV(vkStream, (const VkIndirectCommandsLayoutTokenNV*)(forMarshaling->pTokens + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->streamCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pStreamStrides, forMarshaling->streamCount * sizeof(const uint32_t));
}

void unmarshal_VkIndirectCommandsLayoutCreateInfoNV(
    VulkanStream* vkStream,
    VkIndirectCommandsLayoutCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkIndirectCommandsLayoutUsageFlagsNV*)&forUnmarshaling->flags, sizeof(VkIndirectCommandsLayoutUsageFlagsNV));
    vkStream->read((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->read((uint32_t*)&forUnmarshaling->tokenCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pTokens, forUnmarshaling->tokenCount * sizeof(const VkIndirectCommandsLayoutTokenNV));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->tokenCount; ++i)
    {
        unmarshal_VkIndirectCommandsLayoutTokenNV(vkStream, (VkIndirectCommandsLayoutTokenNV*)(forUnmarshaling->pTokens + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->streamCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pStreamStrides, forUnmarshaling->streamCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pStreamStrides, forUnmarshaling->streamCount * sizeof(const uint32_t));
}

void marshal_VkGeneratedCommandsInfoNV(
    VulkanStream* vkStream,
    const VkGeneratedCommandsInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkPipeline_u64(&forMarshaling->pipeline, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNV_u64(&forMarshaling->indirectCommandsLayout, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->streamCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->streamCount; ++i)
    {
        marshal_VkIndirectCommandsStreamNV(vkStream, (const VkIndirectCommandsStreamNV*)(forMarshaling->pStreams + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->sequencesCount, sizeof(uint32_t));
    uint64_t cgen_var_2;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->preprocessBuffer, &cgen_var_2, 1);
    vkStream->write((uint64_t*)&cgen_var_2, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->preprocessOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->preprocessSize, sizeof(VkDeviceSize));
    uint64_t cgen_var_3;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->sequencesCountBuffer, &cgen_var_3, 1);
    vkStream->write((uint64_t*)&cgen_var_3, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->sequencesCountOffset, sizeof(VkDeviceSize));
    uint64_t cgen_var_4;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->sequencesIndexBuffer, &cgen_var_4, 1);
    vkStream->write((uint64_t*)&cgen_var_4, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->sequencesIndexOffset, sizeof(VkDeviceSize));
}

void unmarshal_VkGeneratedCommandsInfoNV(
    VulkanStream* vkStream,
    VkGeneratedCommandsInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_0, (VkPipeline*)&forUnmarshaling->pipeline, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkIndirectCommandsLayoutNV(&cgen_var_1, (VkIndirectCommandsLayoutNV*)&forUnmarshaling->indirectCommandsLayout, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->streamCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pStreams, forUnmarshaling->streamCount * sizeof(const VkIndirectCommandsStreamNV));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->streamCount; ++i)
    {
        unmarshal_VkIndirectCommandsStreamNV(vkStream, (VkIndirectCommandsStreamNV*)(forUnmarshaling->pStreams + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->sequencesCount, sizeof(uint32_t));
    uint64_t cgen_var_2;
    vkStream->read((uint64_t*)&cgen_var_2, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_2, (VkBuffer*)&forUnmarshaling->preprocessBuffer, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->preprocessOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->preprocessSize, sizeof(VkDeviceSize));
    uint64_t cgen_var_3;
    vkStream->read((uint64_t*)&cgen_var_3, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_3, (VkBuffer*)&forUnmarshaling->sequencesCountBuffer, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->sequencesCountOffset, sizeof(VkDeviceSize));
    uint64_t cgen_var_4;
    vkStream->read((uint64_t*)&cgen_var_4, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_4, (VkBuffer*)&forUnmarshaling->sequencesIndexBuffer, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->sequencesIndexOffset, sizeof(VkDeviceSize));
}

void marshal_VkGeneratedCommandsMemoryRequirementsInfoNV(
    VulkanStream* vkStream,
    const VkGeneratedCommandsMemoryRequirementsInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkPipeline_u64(&forMarshaling->pipeline, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNV_u64(&forMarshaling->indirectCommandsLayout, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->maxSequencesCount, sizeof(uint32_t));
}

void unmarshal_VkGeneratedCommandsMemoryRequirementsInfoNV(
    VulkanStream* vkStream,
    VkGeneratedCommandsMemoryRequirementsInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_0, (VkPipeline*)&forUnmarshaling->pipeline, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkIndirectCommandsLayoutNV(&cgen_var_1, (VkIndirectCommandsLayoutNV*)&forUnmarshaling->indirectCommandsLayout, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->maxSequencesCount, sizeof(uint32_t));
}

#endif
#ifdef VK_EXT_texel_buffer_alignment
void marshal_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->texelBufferAlignment, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->texelBufferAlignment, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceSize*)&forMarshaling->storageTexelBufferOffsetAlignmentBytes, sizeof(VkDeviceSize));
    vkStream->write((VkBool32*)&forMarshaling->storageTexelBufferOffsetSingleTexelAlignment, sizeof(VkBool32));
    vkStream->write((VkDeviceSize*)&forMarshaling->uniformTexelBufferOffsetAlignmentBytes, sizeof(VkDeviceSize));
    vkStream->write((VkBool32*)&forMarshaling->uniformTexelBufferOffsetSingleTexelAlignment, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceSize*)&forUnmarshaling->storageTexelBufferOffsetAlignmentBytes, sizeof(VkDeviceSize));
    vkStream->read((VkBool32*)&forUnmarshaling->storageTexelBufferOffsetSingleTexelAlignment, sizeof(VkBool32));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->uniformTexelBufferOffsetAlignmentBytes, sizeof(VkDeviceSize));
    vkStream->read((VkBool32*)&forUnmarshaling->uniformTexelBufferOffsetSingleTexelAlignment, sizeof(VkBool32));
}

#endif
#ifdef VK_QCOM_render_pass_transform
void marshal_VkRenderPassTransformBeginInfoQCOM(
    VulkanStream* vkStream,
    const VkRenderPassTransformBeginInfoQCOM* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
}

void unmarshal_VkRenderPassTransformBeginInfoQCOM(
    VulkanStream* vkStream,
    VkRenderPassTransformBeginInfoQCOM* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
}

void marshal_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(
    VulkanStream* vkStream,
    const VkCommandBufferInheritanceRenderPassTransformInfoQCOM* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
    marshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->renderArea));
}

void unmarshal_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(
    VulkanStream* vkStream,
    VkCommandBufferInheritanceRenderPassTransformInfoQCOM* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
    unmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->renderArea));
}

#endif
#ifdef VK_EXT_device_memory_report
void marshal_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->deviceMemoryReport, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->deviceMemoryReport, sizeof(VkBool32));
}

void marshal_VkDeviceMemoryReportCallbackDataEXT(
    VulkanStream* vkStream,
    const VkDeviceMemoryReportCallbackDataEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceMemoryReportFlagsEXT*)&forMarshaling->flags, sizeof(VkDeviceMemoryReportFlagsEXT));
    vkStream->write((VkDeviceMemoryReportEventTypeEXT*)&forMarshaling->type, sizeof(VkDeviceMemoryReportEventTypeEXT));
    vkStream->write((uint64_t*)&forMarshaling->memoryObjectId, sizeof(uint64_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkObjectType*)&forMarshaling->objectType, sizeof(VkObjectType));
    vkStream->write((uint64_t*)&forMarshaling->objectHandle, sizeof(uint64_t));
    vkStream->write((uint32_t*)&forMarshaling->heapIndex, sizeof(uint32_t));
}

void unmarshal_VkDeviceMemoryReportCallbackDataEXT(
    VulkanStream* vkStream,
    VkDeviceMemoryReportCallbackDataEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceMemoryReportFlagsEXT*)&forUnmarshaling->flags, sizeof(VkDeviceMemoryReportFlagsEXT));
    vkStream->read((VkDeviceMemoryReportEventTypeEXT*)&forUnmarshaling->type, sizeof(VkDeviceMemoryReportEventTypeEXT));
    vkStream->read((uint64_t*)&forUnmarshaling->memoryObjectId, sizeof(uint64_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkObjectType*)&forUnmarshaling->objectType, sizeof(VkObjectType));
    vkStream->read((uint64_t*)&forUnmarshaling->objectHandle, sizeof(uint64_t));
    vkStream->read((uint32_t*)&forUnmarshaling->heapIndex, sizeof(uint32_t));
}

void marshal_VkDeviceDeviceMemoryReportCreateInfoEXT(
    VulkanStream* vkStream,
    const VkDeviceDeviceMemoryReportCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceMemoryReportFlagsEXT*)&forMarshaling->flags, sizeof(VkDeviceMemoryReportFlagsEXT));
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->pfnUserCallback;
    vkStream->putBe64(cgen_var_0);
    vkStream->write((void*)forMarshaling->pUserData, sizeof(uint8_t));
}

void unmarshal_VkDeviceDeviceMemoryReportCreateInfoEXT(
    VulkanStream* vkStream,
    VkDeviceDeviceMemoryReportCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceMemoryReportFlagsEXT*)&forUnmarshaling->flags, sizeof(VkDeviceMemoryReportFlagsEXT));
    forUnmarshaling->pfnUserCallback = (PFN_vkDeviceMemoryReportCallbackEXT)vkStream->getBe64();
    vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
    vkStream->read((void*)forUnmarshaling->pUserData, sizeof(uint8_t));
}

#endif
#ifdef VK_EXT_robustness2
void marshal_VkPhysicalDeviceRobustness2FeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceRobustness2FeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->robustBufferAccess2, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->robustImageAccess2, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->nullDescriptor, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceRobustness2FeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceRobustness2FeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->robustBufferAccess2, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->robustImageAccess2, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->nullDescriptor, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceRobustness2PropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceRobustness2PropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceSize*)&forMarshaling->robustStorageBufferAccessSizeAlignment, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->robustUniformBufferAccessSizeAlignment, sizeof(VkDeviceSize));
}

void unmarshal_VkPhysicalDeviceRobustness2PropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceRobustness2PropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceSize*)&forUnmarshaling->robustStorageBufferAccessSizeAlignment, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->robustUniformBufferAccessSizeAlignment, sizeof(VkDeviceSize));
}

#endif
#ifdef VK_EXT_custom_border_color
void marshal_VkSamplerCustomBorderColorCreateInfoEXT(
    VulkanStream* vkStream,
    const VkSamplerCustomBorderColorCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkClearColorValue(vkStream, (VkClearColorValue*)(&forMarshaling->customBorderColor));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
}

void unmarshal_VkSamplerCustomBorderColorCreateInfoEXT(
    VulkanStream* vkStream,
    VkSamplerCustomBorderColorCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkClearColorValue(vkStream, (VkClearColorValue*)(&forUnmarshaling->customBorderColor));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
}

void marshal_VkPhysicalDeviceCustomBorderColorPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceCustomBorderColorPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->maxCustomBorderColorSamplers, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceCustomBorderColorPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceCustomBorderColorPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxCustomBorderColorSamplers, sizeof(uint32_t));
}

void marshal_VkPhysicalDeviceCustomBorderColorFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceCustomBorderColorFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->customBorderColors, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->customBorderColorWithoutFormat, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceCustomBorderColorFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceCustomBorderColorFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->customBorderColors, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->customBorderColorWithoutFormat, sizeof(VkBool32));
}

#endif
#ifdef VK_GOOGLE_user_type
#endif
#ifdef VK_EXT_private_data
void marshal_VkPhysicalDevicePrivateDataFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDevicePrivateDataFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->privateData, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDevicePrivateDataFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDevicePrivateDataFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->privateData, sizeof(VkBool32));
}

void marshal_VkDevicePrivateDataCreateInfoEXT(
    VulkanStream* vkStream,
    const VkDevicePrivateDataCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->privateDataSlotRequestCount, sizeof(uint32_t));
}

void unmarshal_VkDevicePrivateDataCreateInfoEXT(
    VulkanStream* vkStream,
    VkDevicePrivateDataCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->privateDataSlotRequestCount, sizeof(uint32_t));
}

void marshal_VkPrivateDataSlotCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPrivateDataSlotCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPrivateDataSlotCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPrivateDataSlotCreateFlagsEXT));
}

void unmarshal_VkPrivateDataSlotCreateInfoEXT(
    VulkanStream* vkStream,
    VkPrivateDataSlotCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPrivateDataSlotCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkPrivateDataSlotCreateFlagsEXT));
}

#endif
#ifdef VK_EXT_pipeline_creation_cache_control
void marshal_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->pipelineCreationCacheControl, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->pipelineCreationCacheControl, sizeof(VkBool32));
}

#endif
#ifdef VK_NV_device_diagnostics_config
void marshal_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceDiagnosticsConfigFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->diagnosticsConfig, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceDiagnosticsConfigFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->diagnosticsConfig, sizeof(VkBool32));
}

void marshal_VkDeviceDiagnosticsConfigCreateInfoNV(
    VulkanStream* vkStream,
    const VkDeviceDiagnosticsConfigCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceDiagnosticsConfigFlagsNV*)&forMarshaling->flags, sizeof(VkDeviceDiagnosticsConfigFlagsNV));
}

void unmarshal_VkDeviceDiagnosticsConfigCreateInfoNV(
    VulkanStream* vkStream,
    VkDeviceDiagnosticsConfigCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceDiagnosticsConfigFlagsNV*)&forUnmarshaling->flags, sizeof(VkDeviceDiagnosticsConfigFlagsNV));
}

#endif
#ifdef VK_QCOM_render_pass_store_ops
#endif
#ifdef VK_NV_fragment_shading_rate_enums
void marshal_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->fragmentShadingRateEnums, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->supersampleFragmentShadingRates, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->noInvocationFragmentShadingRates, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentShadingRateEnums, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->supersampleFragmentShadingRates, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->noInvocationFragmentShadingRates, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
    VulkanStream* vkStream,
    const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->maxFragmentShadingRateInvocationCount, sizeof(VkSampleCountFlagBits));
}

void unmarshal_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
    VulkanStream* vkStream,
    VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->maxFragmentShadingRateInvocationCount, sizeof(VkSampleCountFlagBits));
}

void marshal_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(
    VulkanStream* vkStream,
    const VkPipelineFragmentShadingRateEnumStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkFragmentShadingRateTypeNV*)&forMarshaling->shadingRateType, sizeof(VkFragmentShadingRateTypeNV));
    vkStream->write((VkFragmentShadingRateNV*)&forMarshaling->shadingRate, sizeof(VkFragmentShadingRateNV));
    vkStream->write((VkFragmentShadingRateCombinerOpKHR*)forMarshaling->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
}

void unmarshal_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineFragmentShadingRateEnumStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFragmentShadingRateTypeNV*)&forUnmarshaling->shadingRateType, sizeof(VkFragmentShadingRateTypeNV));
    vkStream->read((VkFragmentShadingRateNV*)&forUnmarshaling->shadingRate, sizeof(VkFragmentShadingRateNV));
    vkStream->read((VkFragmentShadingRateCombinerOpKHR*)forUnmarshaling->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
}

#endif
#ifdef VK_EXT_fragment_density_map2
void marshal_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->fragmentDensityMapDeferred, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentDensityMapDeferred, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->subsampledLoads, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->subsampledCoarseReconstructionEarlyAccess, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->maxSubsampledArrayLayers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetSubsampledSamplers, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->subsampledLoads, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->subsampledCoarseReconstructionEarlyAccess, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSubsampledArrayLayers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetSubsampledSamplers, sizeof(uint32_t));
}

#endif
#ifdef VK_QCOM_rotated_copy_commands
void marshal_VkCopyCommandTransformInfoQCOM(
    VulkanStream* vkStream,
    const VkCopyCommandTransformInfoQCOM* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
}

void unmarshal_VkCopyCommandTransformInfoQCOM(
    VulkanStream* vkStream,
    VkCopyCommandTransformInfoQCOM* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
}

#endif
#ifdef VK_EXT_image_robustness
void marshal_VkPhysicalDeviceImageRobustnessFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceImageRobustnessFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->robustImageAccess, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceImageRobustnessFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceImageRobustnessFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->robustImageAccess, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_4444_formats
void marshal_VkPhysicalDevice4444FormatsFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDevice4444FormatsFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->formatA4R4G4B4, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->formatA4B4G4R4, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDevice4444FormatsFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDevice4444FormatsFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->formatA4R4G4B4, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->formatA4B4G4R4, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_directfb_surface
void marshal_VkDirectFBSurfaceCreateInfoEXT(
    VulkanStream* vkStream,
    const VkDirectFBSurfaceCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDirectFBSurfaceCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkDirectFBSurfaceCreateFlagsEXT));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->dfb;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->dfb)
    {
        vkStream->write((IDirectFB*)forMarshaling->dfb, sizeof(IDirectFB));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->surface;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->surface)
    {
        vkStream->write((IDirectFBSurface*)forMarshaling->surface, sizeof(IDirectFBSurface));
    }
}

void unmarshal_VkDirectFBSurfaceCreateInfoEXT(
    VulkanStream* vkStream,
    VkDirectFBSurfaceCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDirectFBSurfaceCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkDirectFBSurfaceCreateFlagsEXT));
    // WARNING PTR CHECK
    forUnmarshaling->dfb = (IDirectFB*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->dfb)
    {
        vkStream->alloc((void**)&forUnmarshaling->dfb, sizeof(IDirectFB));
        vkStream->read((IDirectFB*)forUnmarshaling->dfb, sizeof(IDirectFB));
    }
    // WARNING PTR CHECK
    forUnmarshaling->surface = (IDirectFBSurface*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->surface)
    {
        vkStream->alloc((void**)&forUnmarshaling->surface, sizeof(IDirectFBSurface));
        vkStream->read((IDirectFBSurface*)forUnmarshaling->surface, sizeof(IDirectFBSurface));
    }
}

#endif
#ifdef VK_GOOGLE_address_space
#endif
#ifdef VK_GOOGLE_sized_descriptor_update_template
#endif
#ifdef VK_GOOGLE_async_command_buffers
#endif
#ifdef VK_GOOGLE_create_resources_with_requirements
#endif
#ifdef VK_GOOGLE_address_space_info
#endif
#ifdef VK_GOOGLE_free_memory_sync
#endif
#ifdef VK_GOOGLE_async_queue_submit
#endif
#ifdef VK_GOOGLE_linear_image_layout
#endif
#ifdef VK_GOOGLE_queue_submit_with_commands
#endif
#ifdef VK_KHR_acceleration_structure
void marshal_VkDeviceOrHostAddressKHR(
    VulkanStream* vkStream,
    const VkDeviceOrHostAddressKHR* forMarshaling)
{
    vkStream->write((VkDeviceAddress*)&forMarshaling->deviceAddress, sizeof(VkDeviceAddress));
}

void unmarshal_VkDeviceOrHostAddressKHR(
    VulkanStream* vkStream,
    VkDeviceOrHostAddressKHR* forUnmarshaling)
{
    vkStream->read((VkDeviceAddress*)&forUnmarshaling->deviceAddress, sizeof(VkDeviceAddress));
}

void marshal_VkDeviceOrHostAddressConstKHR(
    VulkanStream* vkStream,
    const VkDeviceOrHostAddressConstKHR* forMarshaling)
{
    vkStream->write((VkDeviceAddress*)&forMarshaling->deviceAddress, sizeof(VkDeviceAddress));
}

void unmarshal_VkDeviceOrHostAddressConstKHR(
    VulkanStream* vkStream,
    VkDeviceOrHostAddressConstKHR* forUnmarshaling)
{
    vkStream->read((VkDeviceAddress*)&forUnmarshaling->deviceAddress, sizeof(VkDeviceAddress));
}

void marshal_VkAccelerationStructureBuildRangeInfoKHR(
    VulkanStream* vkStream,
    const VkAccelerationStructureBuildRangeInfoKHR* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->primitiveCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->primitiveOffset, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->firstVertex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->transformOffset, sizeof(uint32_t));
}

void unmarshal_VkAccelerationStructureBuildRangeInfoKHR(
    VulkanStream* vkStream,
    VkAccelerationStructureBuildRangeInfoKHR* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->primitiveCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->primitiveOffset, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->firstVertex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->transformOffset, sizeof(uint32_t));
}

void marshal_VkAccelerationStructureGeometryTrianglesDataKHR(
    VulkanStream* vkStream,
    const VkAccelerationStructureGeometryTrianglesDataKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkFormat*)&forMarshaling->vertexFormat, sizeof(VkFormat));
    marshal_VkDeviceOrHostAddressConstKHR(vkStream, (VkDeviceOrHostAddressConstKHR*)(&forMarshaling->vertexData));
    vkStream->write((VkDeviceSize*)&forMarshaling->vertexStride, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->maxVertex, sizeof(uint32_t));
    vkStream->write((VkIndexType*)&forMarshaling->indexType, sizeof(VkIndexType));
    marshal_VkDeviceOrHostAddressConstKHR(vkStream, (VkDeviceOrHostAddressConstKHR*)(&forMarshaling->indexData));
    marshal_VkDeviceOrHostAddressConstKHR(vkStream, (VkDeviceOrHostAddressConstKHR*)(&forMarshaling->transformData));
}

void unmarshal_VkAccelerationStructureGeometryTrianglesDataKHR(
    VulkanStream* vkStream,
    VkAccelerationStructureGeometryTrianglesDataKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFormat*)&forUnmarshaling->vertexFormat, sizeof(VkFormat));
    unmarshal_VkDeviceOrHostAddressConstKHR(vkStream, (VkDeviceOrHostAddressConstKHR*)(&forUnmarshaling->vertexData));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->vertexStride, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertex, sizeof(uint32_t));
    vkStream->read((VkIndexType*)&forUnmarshaling->indexType, sizeof(VkIndexType));
    unmarshal_VkDeviceOrHostAddressConstKHR(vkStream, (VkDeviceOrHostAddressConstKHR*)(&forUnmarshaling->indexData));
    unmarshal_VkDeviceOrHostAddressConstKHR(vkStream, (VkDeviceOrHostAddressConstKHR*)(&forUnmarshaling->transformData));
}

void marshal_VkAccelerationStructureGeometryAabbsDataKHR(
    VulkanStream* vkStream,
    const VkAccelerationStructureGeometryAabbsDataKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkDeviceOrHostAddressConstKHR(vkStream, (VkDeviceOrHostAddressConstKHR*)(&forMarshaling->data));
    vkStream->write((VkDeviceSize*)&forMarshaling->stride, sizeof(VkDeviceSize));
}

void unmarshal_VkAccelerationStructureGeometryAabbsDataKHR(
    VulkanStream* vkStream,
    VkAccelerationStructureGeometryAabbsDataKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkDeviceOrHostAddressConstKHR(vkStream, (VkDeviceOrHostAddressConstKHR*)(&forUnmarshaling->data));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->stride, sizeof(VkDeviceSize));
}

void marshal_VkAccelerationStructureGeometryInstancesDataKHR(
    VulkanStream* vkStream,
    const VkAccelerationStructureGeometryInstancesDataKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->arrayOfPointers, sizeof(VkBool32));
    marshal_VkDeviceOrHostAddressConstKHR(vkStream, (VkDeviceOrHostAddressConstKHR*)(&forMarshaling->data));
}

void unmarshal_VkAccelerationStructureGeometryInstancesDataKHR(
    VulkanStream* vkStream,
    VkAccelerationStructureGeometryInstancesDataKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->arrayOfPointers, sizeof(VkBool32));
    unmarshal_VkDeviceOrHostAddressConstKHR(vkStream, (VkDeviceOrHostAddressConstKHR*)(&forUnmarshaling->data));
}

void marshal_VkAccelerationStructureGeometryDataKHR(
    VulkanStream* vkStream,
    const VkAccelerationStructureGeometryDataKHR* forMarshaling)
{
    marshal_VkAccelerationStructureGeometryTrianglesDataKHR(vkStream, (VkAccelerationStructureGeometryTrianglesDataKHR*)(&forMarshaling->triangles));
}

void unmarshal_VkAccelerationStructureGeometryDataKHR(
    VulkanStream* vkStream,
    VkAccelerationStructureGeometryDataKHR* forUnmarshaling)
{
    unmarshal_VkAccelerationStructureGeometryTrianglesDataKHR(vkStream, (VkAccelerationStructureGeometryTrianglesDataKHR*)(&forUnmarshaling->triangles));
}

void marshal_VkAccelerationStructureGeometryKHR(
    VulkanStream* vkStream,
    const VkAccelerationStructureGeometryKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkGeometryTypeKHR*)&forMarshaling->geometryType, sizeof(VkGeometryTypeKHR));
    marshal_VkAccelerationStructureGeometryDataKHR(vkStream, (VkAccelerationStructureGeometryDataKHR*)(&forMarshaling->geometry));
    vkStream->write((VkGeometryFlagsKHR*)&forMarshaling->flags, sizeof(VkGeometryFlagsKHR));
}

void unmarshal_VkAccelerationStructureGeometryKHR(
    VulkanStream* vkStream,
    VkAccelerationStructureGeometryKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkGeometryTypeKHR*)&forUnmarshaling->geometryType, sizeof(VkGeometryTypeKHR));
    unmarshal_VkAccelerationStructureGeometryDataKHR(vkStream, (VkAccelerationStructureGeometryDataKHR*)(&forUnmarshaling->geometry));
    vkStream->read((VkGeometryFlagsKHR*)&forUnmarshaling->flags, sizeof(VkGeometryFlagsKHR));
}

void marshal_VkAccelerationStructureBuildGeometryInfoKHR(
    VulkanStream* vkStream,
    const VkAccelerationStructureBuildGeometryInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkAccelerationStructureTypeKHR*)&forMarshaling->type, sizeof(VkAccelerationStructureTypeKHR));
    vkStream->write((VkBuildAccelerationStructureFlagsKHR*)&forMarshaling->flags, sizeof(VkBuildAccelerationStructureFlagsKHR));
    vkStream->write((VkBuildAccelerationStructureModeKHR*)&forMarshaling->mode, sizeof(VkBuildAccelerationStructureModeKHR));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkAccelerationStructureKHR_u64(&forMarshaling->srcAccelerationStructure, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkAccelerationStructureKHR_u64(&forMarshaling->dstAccelerationStructure, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->geometryCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pGeometries;
    vkStream->putBe64(cgen_var_2);
    if (forMarshaling->pGeometries)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->geometryCount; ++i)
        {
            marshal_VkAccelerationStructureGeometryKHR(vkStream, (const VkAccelerationStructureGeometryKHR*)(forMarshaling->pGeometries + i));
        }
    }
    marshal_VkDeviceOrHostAddressKHR(vkStream, (VkDeviceOrHostAddressKHR*)(&forMarshaling->scratchData));
}

void unmarshal_VkAccelerationStructureBuildGeometryInfoKHR(
    VulkanStream* vkStream,
    VkAccelerationStructureBuildGeometryInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAccelerationStructureTypeKHR*)&forUnmarshaling->type, sizeof(VkAccelerationStructureTypeKHR));
    vkStream->read((VkBuildAccelerationStructureFlagsKHR*)&forUnmarshaling->flags, sizeof(VkBuildAccelerationStructureFlagsKHR));
    vkStream->read((VkBuildAccelerationStructureModeKHR*)&forUnmarshaling->mode, sizeof(VkBuildAccelerationStructureModeKHR));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkAccelerationStructureKHR(&cgen_var_0, (VkAccelerationStructureKHR*)&forUnmarshaling->srcAccelerationStructure, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkAccelerationStructureKHR(&cgen_var_1, (VkAccelerationStructureKHR*)&forUnmarshaling->dstAccelerationStructure, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->geometryCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pGeometries = (const VkAccelerationStructureGeometryKHR*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pGeometries)
    {
        vkStream->alloc((void**)&forUnmarshaling->pGeometries, forUnmarshaling->geometryCount * sizeof(const VkAccelerationStructureGeometryKHR));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->geometryCount; ++i)
        {
            unmarshal_VkAccelerationStructureGeometryKHR(vkStream, (VkAccelerationStructureGeometryKHR*)(forUnmarshaling->pGeometries + i));
        }
    }
    unmarshal_VkDeviceOrHostAddressKHR(vkStream, (VkDeviceOrHostAddressKHR*)(&forUnmarshaling->scratchData));
}

void marshal_VkAccelerationStructureCreateInfoKHR(
    VulkanStream* vkStream,
    const VkAccelerationStructureCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkAccelerationStructureCreateFlagsKHR*)&forMarshaling->createFlags, sizeof(VkAccelerationStructureCreateFlagsKHR));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkAccelerationStructureTypeKHR*)&forMarshaling->type, sizeof(VkAccelerationStructureTypeKHR));
    vkStream->write((VkDeviceAddress*)&forMarshaling->deviceAddress, sizeof(VkDeviceAddress));
}

void unmarshal_VkAccelerationStructureCreateInfoKHR(
    VulkanStream* vkStream,
    VkAccelerationStructureCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAccelerationStructureCreateFlagsKHR*)&forUnmarshaling->createFlags, sizeof(VkAccelerationStructureCreateFlagsKHR));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_0, (VkBuffer*)&forUnmarshaling->buffer, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkAccelerationStructureTypeKHR*)&forUnmarshaling->type, sizeof(VkAccelerationStructureTypeKHR));
    vkStream->read((VkDeviceAddress*)&forUnmarshaling->deviceAddress, sizeof(VkDeviceAddress));
}

void marshal_VkWriteDescriptorSetAccelerationStructureKHR(
    VulkanStream* vkStream,
    const VkWriteDescriptorSetAccelerationStructureKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->accelerationStructureCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pAccelerationStructures;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pAccelerationStructures)
    {
        if (forMarshaling->accelerationStructureCount)
        {
            uint64_t* cgen_var_0_0;
            vkStream->alloc((void**)&cgen_var_0_0, forMarshaling->accelerationStructureCount * 8);
            vkStream->handleMapping()->mapHandles_VkAccelerationStructureKHR_u64(forMarshaling->pAccelerationStructures, cgen_var_0_0, forMarshaling->accelerationStructureCount);
            vkStream->write((uint64_t*)cgen_var_0_0, forMarshaling->accelerationStructureCount * 8);
        }
    }
}

void unmarshal_VkWriteDescriptorSetAccelerationStructureKHR(
    VulkanStream* vkStream,
    VkWriteDescriptorSetAccelerationStructureKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->accelerationStructureCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pAccelerationStructures = (const VkAccelerationStructureKHR*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pAccelerationStructures)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAccelerationStructures, forUnmarshaling->accelerationStructureCount * sizeof(const VkAccelerationStructureKHR));
        if (forUnmarshaling->accelerationStructureCount)
        {
            uint64_t* cgen_var_0_0;
            vkStream->alloc((void**)&cgen_var_0_0, forUnmarshaling->accelerationStructureCount * 8);
            vkStream->read((uint64_t*)cgen_var_0_0, forUnmarshaling->accelerationStructureCount * 8);
            vkStream->handleMapping()->mapHandles_u64_VkAccelerationStructureKHR(cgen_var_0_0, (VkAccelerationStructureKHR*)forUnmarshaling->pAccelerationStructures, forUnmarshaling->accelerationStructureCount);
        }
    }
}

void marshal_VkPhysicalDeviceAccelerationStructureFeaturesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDeviceAccelerationStructureFeaturesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->accelerationStructure, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->accelerationStructureCaptureReplay, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->accelerationStructureIndirectBuild, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->accelerationStructureHostCommands, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingAccelerationStructureUpdateAfterBind, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceAccelerationStructureFeaturesKHR(
    VulkanStream* vkStream,
    VkPhysicalDeviceAccelerationStructureFeaturesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->accelerationStructure, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->accelerationStructureCaptureReplay, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->accelerationStructureIndirectBuild, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->accelerationStructureHostCommands, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingAccelerationStructureUpdateAfterBind, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceAccelerationStructurePropertiesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDeviceAccelerationStructurePropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint64_t*)&forMarshaling->maxGeometryCount, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->maxInstanceCount, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->maxPrimitiveCount, sizeof(uint64_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorAccelerationStructures, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindAccelerationStructures, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetAccelerationStructures, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindAccelerationStructures, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minAccelerationStructureScratchOffsetAlignment, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceAccelerationStructurePropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDeviceAccelerationStructurePropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint64_t*)&forUnmarshaling->maxGeometryCount, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->maxInstanceCount, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->maxPrimitiveCount, sizeof(uint64_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorAccelerationStructures, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindAccelerationStructures, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetAccelerationStructures, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindAccelerationStructures, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minAccelerationStructureScratchOffsetAlignment, sizeof(uint32_t));
}

void marshal_VkAccelerationStructureDeviceAddressInfoKHR(
    VulkanStream* vkStream,
    const VkAccelerationStructureDeviceAddressInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkAccelerationStructureKHR_u64(&forMarshaling->accelerationStructure, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
}

void unmarshal_VkAccelerationStructureDeviceAddressInfoKHR(
    VulkanStream* vkStream,
    VkAccelerationStructureDeviceAddressInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkAccelerationStructureKHR(&cgen_var_0, (VkAccelerationStructureKHR*)&forUnmarshaling->accelerationStructure, 1);
}

void marshal_VkAccelerationStructureVersionInfoKHR(
    VulkanStream* vkStream,
    const VkAccelerationStructureVersionInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((const uint8_t*)forMarshaling->pVersionData, 2*VK_UUID_SIZE * sizeof(const uint8_t));
}

void unmarshal_VkAccelerationStructureVersionInfoKHR(
    VulkanStream* vkStream,
    VkAccelerationStructureVersionInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->alloc((void**)&forUnmarshaling->pVersionData, 2*VK_UUID_SIZE * sizeof(const uint8_t));
    vkStream->read((uint8_t*)forUnmarshaling->pVersionData, 2*VK_UUID_SIZE * sizeof(const uint8_t));
}

void marshal_VkCopyAccelerationStructureToMemoryInfoKHR(
    VulkanStream* vkStream,
    const VkCopyAccelerationStructureToMemoryInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkAccelerationStructureKHR_u64(&forMarshaling->src, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    marshal_VkDeviceOrHostAddressKHR(vkStream, (VkDeviceOrHostAddressKHR*)(&forMarshaling->dst));
    vkStream->write((VkCopyAccelerationStructureModeKHR*)&forMarshaling->mode, sizeof(VkCopyAccelerationStructureModeKHR));
}

void unmarshal_VkCopyAccelerationStructureToMemoryInfoKHR(
    VulkanStream* vkStream,
    VkCopyAccelerationStructureToMemoryInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkAccelerationStructureKHR(&cgen_var_0, (VkAccelerationStructureKHR*)&forUnmarshaling->src, 1);
    unmarshal_VkDeviceOrHostAddressKHR(vkStream, (VkDeviceOrHostAddressKHR*)(&forUnmarshaling->dst));
    vkStream->read((VkCopyAccelerationStructureModeKHR*)&forUnmarshaling->mode, sizeof(VkCopyAccelerationStructureModeKHR));
}

void marshal_VkCopyMemoryToAccelerationStructureInfoKHR(
    VulkanStream* vkStream,
    const VkCopyMemoryToAccelerationStructureInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    marshal_VkDeviceOrHostAddressConstKHR(vkStream, (VkDeviceOrHostAddressConstKHR*)(&forMarshaling->src));
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkAccelerationStructureKHR_u64(&forMarshaling->dst, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->write((VkCopyAccelerationStructureModeKHR*)&forMarshaling->mode, sizeof(VkCopyAccelerationStructureModeKHR));
}

void unmarshal_VkCopyMemoryToAccelerationStructureInfoKHR(
    VulkanStream* vkStream,
    VkCopyMemoryToAccelerationStructureInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkDeviceOrHostAddressConstKHR(vkStream, (VkDeviceOrHostAddressConstKHR*)(&forUnmarshaling->src));
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkAccelerationStructureKHR(&cgen_var_0, (VkAccelerationStructureKHR*)&forUnmarshaling->dst, 1);
    vkStream->read((VkCopyAccelerationStructureModeKHR*)&forUnmarshaling->mode, sizeof(VkCopyAccelerationStructureModeKHR));
}

void marshal_VkCopyAccelerationStructureInfoKHR(
    VulkanStream* vkStream,
    const VkCopyAccelerationStructureInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    uint64_t cgen_var_0;
    vkStream->handleMapping()->mapHandles_VkAccelerationStructureKHR_u64(&forMarshaling->src, &cgen_var_0, 1);
    vkStream->write((uint64_t*)&cgen_var_0, 1 * 8);
    uint64_t cgen_var_1;
    vkStream->handleMapping()->mapHandles_VkAccelerationStructureKHR_u64(&forMarshaling->dst, &cgen_var_1, 1);
    vkStream->write((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->write((VkCopyAccelerationStructureModeKHR*)&forMarshaling->mode, sizeof(VkCopyAccelerationStructureModeKHR));
}

void unmarshal_VkCopyAccelerationStructureInfoKHR(
    VulkanStream* vkStream,
    VkCopyAccelerationStructureInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_0;
    vkStream->read((uint64_t*)&cgen_var_0, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkAccelerationStructureKHR(&cgen_var_0, (VkAccelerationStructureKHR*)&forUnmarshaling->src, 1);
    uint64_t cgen_var_1;
    vkStream->read((uint64_t*)&cgen_var_1, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkAccelerationStructureKHR(&cgen_var_1, (VkAccelerationStructureKHR*)&forUnmarshaling->dst, 1);
    vkStream->read((VkCopyAccelerationStructureModeKHR*)&forUnmarshaling->mode, sizeof(VkCopyAccelerationStructureModeKHR));
}

void marshal_VkAccelerationStructureBuildSizesInfoKHR(
    VulkanStream* vkStream,
    const VkAccelerationStructureBuildSizesInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkDeviceSize*)&forMarshaling->accelerationStructureSize, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->updateScratchSize, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->buildScratchSize, sizeof(VkDeviceSize));
}

void unmarshal_VkAccelerationStructureBuildSizesInfoKHR(
    VulkanStream* vkStream,
    VkAccelerationStructureBuildSizesInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceSize*)&forUnmarshaling->accelerationStructureSize, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->updateScratchSize, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->buildScratchSize, sizeof(VkDeviceSize));
}

#endif
#ifdef VK_KHR_ray_tracing_pipeline
void marshal_VkRayTracingShaderGroupCreateInfoKHR(
    VulkanStream* vkStream,
    const VkRayTracingShaderGroupCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkRayTracingShaderGroupTypeKHR*)&forMarshaling->type, sizeof(VkRayTracingShaderGroupTypeKHR));
    vkStream->write((uint32_t*)&forMarshaling->generalShader, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->closestHitShader, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->anyHitShader, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->intersectionShader, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pShaderGroupCaptureReplayHandle;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pShaderGroupCaptureReplayHandle)
    {
        vkStream->write((const void*)forMarshaling->pShaderGroupCaptureReplayHandle, sizeof(const uint8_t));
    }
}

void unmarshal_VkRayTracingShaderGroupCreateInfoKHR(
    VulkanStream* vkStream,
    VkRayTracingShaderGroupCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkRayTracingShaderGroupTypeKHR*)&forUnmarshaling->type, sizeof(VkRayTracingShaderGroupTypeKHR));
    vkStream->read((uint32_t*)&forUnmarshaling->generalShader, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->closestHitShader, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->anyHitShader, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->intersectionShader, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pShaderGroupCaptureReplayHandle = (const void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pShaderGroupCaptureReplayHandle)
    {
        vkStream->alloc((void**)&forUnmarshaling->pShaderGroupCaptureReplayHandle, sizeof(const uint8_t));
        vkStream->read((void*)forUnmarshaling->pShaderGroupCaptureReplayHandle, sizeof(const uint8_t));
    }
}

void marshal_VkRayTracingPipelineInterfaceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkRayTracingPipelineInterfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->maxPipelineRayPayloadSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPipelineRayHitAttributeSize, sizeof(uint32_t));
}

void unmarshal_VkRayTracingPipelineInterfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkRayTracingPipelineInterfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxPipelineRayPayloadSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPipelineRayHitAttributeSize, sizeof(uint32_t));
}

void marshal_VkRayTracingPipelineCreateInfoKHR(
    VulkanStream* vkStream,
    const VkRayTracingPipelineCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkPipelineCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->stageCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->stageCount; ++i)
    {
        marshal_VkPipelineShaderStageCreateInfo(vkStream, (const VkPipelineShaderStageCreateInfo*)(forMarshaling->pStages + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->groupCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->groupCount; ++i)
    {
        marshal_VkRayTracingShaderGroupCreateInfoKHR(vkStream, (const VkRayTracingShaderGroupCreateInfoKHR*)(forMarshaling->pGroups + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->maxPipelineRayRecursionDepth, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pLibraryInfo;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pLibraryInfo)
    {
        marshal_VkPipelineLibraryCreateInfoKHR(vkStream, (const VkPipelineLibraryCreateInfoKHR*)(forMarshaling->pLibraryInfo));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pLibraryInterface;
    vkStream->putBe64(cgen_var_1);
    if (forMarshaling->pLibraryInterface)
    {
        marshal_VkRayTracingPipelineInterfaceCreateInfoKHR(vkStream, (const VkRayTracingPipelineInterfaceCreateInfoKHR*)(forMarshaling->pLibraryInterface));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pDynamicState;
    vkStream->putBe64(cgen_var_2);
    if (forMarshaling->pDynamicState)
    {
        marshal_VkPipelineDynamicStateCreateInfo(vkStream, (const VkPipelineDynamicStateCreateInfo*)(forMarshaling->pDynamicState));
    }
    uint64_t cgen_var_3;
    vkStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&forMarshaling->layout, &cgen_var_3, 1);
    vkStream->write((uint64_t*)&cgen_var_3, 1 * 8);
    uint64_t cgen_var_4;
    vkStream->handleMapping()->mapHandles_VkPipeline_u64(&forMarshaling->basePipelineHandle, &cgen_var_4, 1);
    vkStream->write((uint64_t*)&cgen_var_4, 1 * 8);
    vkStream->write((int32_t*)&forMarshaling->basePipelineIndex, sizeof(int32_t));
}

void unmarshal_VkRayTracingPipelineCreateInfoKHR(
    VulkanStream* vkStream,
    VkRayTracingPipelineCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->stageCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pStages, forUnmarshaling->stageCount * sizeof(const VkPipelineShaderStageCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->stageCount; ++i)
    {
        unmarshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(forUnmarshaling->pStages + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->groupCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pGroups, forUnmarshaling->groupCount * sizeof(const VkRayTracingShaderGroupCreateInfoKHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->groupCount; ++i)
    {
        unmarshal_VkRayTracingShaderGroupCreateInfoKHR(vkStream, (VkRayTracingShaderGroupCreateInfoKHR*)(forUnmarshaling->pGroups + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxPipelineRayRecursionDepth, sizeof(uint32_t));
    // WARNING PTR CHECK
    forUnmarshaling->pLibraryInfo = (const VkPipelineLibraryCreateInfoKHR*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pLibraryInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pLibraryInfo, sizeof(const VkPipelineLibraryCreateInfoKHR));
        unmarshal_VkPipelineLibraryCreateInfoKHR(vkStream, (VkPipelineLibraryCreateInfoKHR*)(forUnmarshaling->pLibraryInfo));
    }
    // WARNING PTR CHECK
    forUnmarshaling->pLibraryInterface = (const VkRayTracingPipelineInterfaceCreateInfoKHR*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pLibraryInterface)
    {
        vkStream->alloc((void**)&forUnmarshaling->pLibraryInterface, sizeof(const VkRayTracingPipelineInterfaceCreateInfoKHR));
        unmarshal_VkRayTracingPipelineInterfaceCreateInfoKHR(vkStream, (VkRayTracingPipelineInterfaceCreateInfoKHR*)(forUnmarshaling->pLibraryInterface));
    }
    // WARNING PTR CHECK
    forUnmarshaling->pDynamicState = (const VkPipelineDynamicStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pDynamicState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDynamicState, sizeof(const VkPipelineDynamicStateCreateInfo));
        unmarshal_VkPipelineDynamicStateCreateInfo(vkStream, (VkPipelineDynamicStateCreateInfo*)(forUnmarshaling->pDynamicState));
    }
    uint64_t cgen_var_3;
    vkStream->read((uint64_t*)&cgen_var_3, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_3, (VkPipelineLayout*)&forUnmarshaling->layout, 1);
    uint64_t cgen_var_4;
    vkStream->read((uint64_t*)&cgen_var_4, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_4, (VkPipeline*)&forUnmarshaling->basePipelineHandle, 1);
    vkStream->read((int32_t*)&forUnmarshaling->basePipelineIndex, sizeof(int32_t));
}

void marshal_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDeviceRayTracingPipelineFeaturesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->rayTracingPipeline, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->rayTracingPipelineShaderGroupHandleCaptureReplay, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->rayTracingPipelineShaderGroupHandleCaptureReplayMixed, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->rayTracingPipelineTraceRaysIndirect, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->rayTraversalPrimitiveCulling, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(
    VulkanStream* vkStream,
    VkPhysicalDeviceRayTracingPipelineFeaturesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->rayTracingPipeline, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->rayTracingPipelineShaderGroupHandleCaptureReplay, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->rayTracingPipelineShaderGroupHandleCaptureReplayMixed, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->rayTracingPipelineTraceRaysIndirect, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->rayTraversalPrimitiveCulling, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDeviceRayTracingPipelinePropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((uint32_t*)&forMarshaling->shaderGroupHandleSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxRayRecursionDepth, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxShaderGroupStride, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->shaderGroupBaseAlignment, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->shaderGroupHandleCaptureReplaySize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxRayDispatchInvocationCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->shaderGroupHandleAlignment, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxRayHitAttributeSize, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDeviceRayTracingPipelinePropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->shaderGroupHandleSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxRayRecursionDepth, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxShaderGroupStride, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->shaderGroupBaseAlignment, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->shaderGroupHandleCaptureReplaySize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxRayDispatchInvocationCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->shaderGroupHandleAlignment, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxRayHitAttributeSize, sizeof(uint32_t));
}

void marshal_VkStridedDeviceAddressRegionKHR(
    VulkanStream* vkStream,
    const VkStridedDeviceAddressRegionKHR* forMarshaling)
{
    vkStream->write((VkDeviceAddress*)&forMarshaling->deviceAddress, sizeof(VkDeviceAddress));
    vkStream->write((VkDeviceSize*)&forMarshaling->stride, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
}

void unmarshal_VkStridedDeviceAddressRegionKHR(
    VulkanStream* vkStream,
    VkStridedDeviceAddressRegionKHR* forUnmarshaling)
{
    vkStream->read((VkDeviceAddress*)&forUnmarshaling->deviceAddress, sizeof(VkDeviceAddress));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->stride, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
}

void marshal_VkTraceRaysIndirectCommandKHR(
    VulkanStream* vkStream,
    const VkTraceRaysIndirectCommandKHR* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->depth, sizeof(uint32_t));
}

void unmarshal_VkTraceRaysIndirectCommandKHR(
    VulkanStream* vkStream,
    VkTraceRaysIndirectCommandKHR* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->width, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->height, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->depth, sizeof(uint32_t));
}

#endif
#ifdef VK_KHR_ray_query
void marshal_VkPhysicalDeviceRayQueryFeaturesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDeviceRayQueryFeaturesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    marshal_extension_struct(vkStream, forMarshaling->pNext);
    vkStream->write((VkBool32*)&forMarshaling->rayQuery, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceRayQueryFeaturesKHR(
    VulkanStream* vkStream,
    VkPhysicalDeviceRayQueryFeaturesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        vkStream->read((void*)forUnmarshaling->pNext, sizeof(VkStructureType));
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->rayQuery, sizeof(VkBool32));
}

#endif
void marshal_extension_struct(
    VulkanStream* vkStream,
    const void* structExtension)
{
    VkInstanceCreateInfo* structAccess = (VkInstanceCreateInfo*)(structExtension);
    size_t currExtSize = goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), structExtension);
    if (!currExtSize && structExtension)
    {
        // unknown struct extension; skip and call on its pNext field
        marshal_extension_struct(vkStream, (void*)structAccess->pNext);
        return;
    }
    else
    {
        // known or null extension struct
        vkStream->putBe32(currExtSize);
        if (!currExtSize)
        {
            // exit if this was a null extension struct (size == 0 in this branch)
            return;
        }
    }
    vkStream->write(structExtension, sizeof(VkStructureType));
    if (!structExtension)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            marshal_VkPhysicalDeviceSubgroupProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceSubgroupProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            marshal_VkPhysicalDevice16BitStorageFeatures(vkStream, reinterpret_cast<const VkPhysicalDevice16BitStorageFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            marshal_VkMemoryDedicatedRequirements(vkStream, reinterpret_cast<const VkMemoryDedicatedRequirements*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            marshal_VkMemoryDedicatedAllocateInfo(vkStream, reinterpret_cast<const VkMemoryDedicatedAllocateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            marshal_VkMemoryAllocateFlagsInfo(vkStream, reinterpret_cast<const VkMemoryAllocateFlagsInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            marshal_VkDeviceGroupRenderPassBeginInfo(vkStream, reinterpret_cast<const VkDeviceGroupRenderPassBeginInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            marshal_VkDeviceGroupCommandBufferBeginInfo(vkStream, reinterpret_cast<const VkDeviceGroupCommandBufferBeginInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            marshal_VkDeviceGroupSubmitInfo(vkStream, reinterpret_cast<const VkDeviceGroupSubmitInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            marshal_VkDeviceGroupBindSparseInfo(vkStream, reinterpret_cast<const VkDeviceGroupBindSparseInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            marshal_VkBindBufferMemoryDeviceGroupInfo(vkStream, reinterpret_cast<const VkBindBufferMemoryDeviceGroupInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            marshal_VkBindImageMemoryDeviceGroupInfo(vkStream, reinterpret_cast<const VkBindImageMemoryDeviceGroupInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            marshal_VkDeviceGroupDeviceCreateInfo(vkStream, reinterpret_cast<const VkDeviceGroupDeviceCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            marshal_VkPhysicalDeviceFeatures2(vkStream, reinterpret_cast<const VkPhysicalDeviceFeatures2*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            marshal_VkPhysicalDevicePointClippingProperties(vkStream, reinterpret_cast<const VkPhysicalDevicePointClippingProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            marshal_VkRenderPassInputAttachmentAspectCreateInfo(vkStream, reinterpret_cast<const VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            marshal_VkImageViewUsageCreateInfo(vkStream, reinterpret_cast<const VkImageViewUsageCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            marshal_VkPipelineTessellationDomainOriginStateCreateInfo(vkStream, reinterpret_cast<const VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            marshal_VkRenderPassMultiviewCreateInfo(vkStream, reinterpret_cast<const VkRenderPassMultiviewCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            marshal_VkPhysicalDeviceMultiviewFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceMultiviewFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            marshal_VkPhysicalDeviceMultiviewProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceMultiviewProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            marshal_VkPhysicalDeviceVariablePointersFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceVariablePointersFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            marshal_VkPhysicalDeviceProtectedMemoryFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            marshal_VkPhysicalDeviceProtectedMemoryProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceProtectedMemoryProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            marshal_VkProtectedSubmitInfo(vkStream, reinterpret_cast<const VkProtectedSubmitInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            marshal_VkSamplerYcbcrConversionInfo(vkStream, reinterpret_cast<const VkSamplerYcbcrConversionInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            marshal_VkBindImagePlaneMemoryInfo(vkStream, reinterpret_cast<const VkBindImagePlaneMemoryInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            marshal_VkImagePlaneMemoryRequirementsInfo(vkStream, reinterpret_cast<const VkImagePlaneMemoryRequirementsInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            marshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            marshal_VkSamplerYcbcrConversionImageFormatProperties(vkStream, reinterpret_cast<const VkSamplerYcbcrConversionImageFormatProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            marshal_VkPhysicalDeviceExternalImageFormatInfo(vkStream, reinterpret_cast<const VkPhysicalDeviceExternalImageFormatInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            marshal_VkExternalImageFormatProperties(vkStream, reinterpret_cast<const VkExternalImageFormatProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            marshal_VkPhysicalDeviceIDProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceIDProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            marshal_VkExternalMemoryImageCreateInfo(vkStream, reinterpret_cast<const VkExternalMemoryImageCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            marshal_VkExternalMemoryBufferCreateInfo(vkStream, reinterpret_cast<const VkExternalMemoryBufferCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            marshal_VkExportMemoryAllocateInfo(vkStream, reinterpret_cast<const VkExportMemoryAllocateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            marshal_VkExportFenceCreateInfo(vkStream, reinterpret_cast<const VkExportFenceCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            marshal_VkExportSemaphoreCreateInfo(vkStream, reinterpret_cast<const VkExportSemaphoreCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            marshal_VkPhysicalDeviceMaintenance3Properties(vkStream, reinterpret_cast<const VkPhysicalDeviceMaintenance3Properties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            marshal_VkPhysicalDeviceShaderDrawParametersFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderDrawParametersFeatures*>(structExtension));
            break;
        }
#endif
#ifdef VK_VERSION_1_2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            marshal_VkPhysicalDeviceVulkan11Features(vkStream, reinterpret_cast<const VkPhysicalDeviceVulkan11Features*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {
            marshal_VkPhysicalDeviceVulkan11Properties(vkStream, reinterpret_cast<const VkPhysicalDeviceVulkan11Properties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            marshal_VkPhysicalDeviceVulkan12Features(vkStream, reinterpret_cast<const VkPhysicalDeviceVulkan12Features*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {
            marshal_VkPhysicalDeviceVulkan12Properties(vkStream, reinterpret_cast<const VkPhysicalDeviceVulkan12Properties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            marshal_VkImageFormatListCreateInfo(vkStream, reinterpret_cast<const VkImageFormatListCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            marshal_VkPhysicalDevice8BitStorageFeatures(vkStream, reinterpret_cast<const VkPhysicalDevice8BitStorageFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
            marshal_VkPhysicalDeviceDriverProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceDriverProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            marshal_VkPhysicalDeviceShaderAtomicInt64Features(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderAtomicInt64Features*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            marshal_VkPhysicalDeviceShaderFloat16Int8Features(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderFloat16Int8Features*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
            marshal_VkPhysicalDeviceFloatControlsProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceFloatControlsProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
        {
            marshal_VkDescriptorSetLayoutBindingFlagsCreateInfo(vkStream, reinterpret_cast<const VkDescriptorSetLayoutBindingFlagsCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            marshal_VkPhysicalDeviceDescriptorIndexingFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
            marshal_VkPhysicalDeviceDescriptorIndexingProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
        {
            marshal_VkDescriptorSetVariableDescriptorCountAllocateInfo(vkStream, reinterpret_cast<const VkDescriptorSetVariableDescriptorCountAllocateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
            marshal_VkDescriptorSetVariableDescriptorCountLayoutSupport(vkStream, reinterpret_cast<const VkDescriptorSetVariableDescriptorCountLayoutSupport*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
        {
            marshal_VkSubpassDescriptionDepthStencilResolve(vkStream, reinterpret_cast<const VkSubpassDescriptionDepthStencilResolve*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
            marshal_VkPhysicalDeviceDepthStencilResolveProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceDepthStencilResolveProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            marshal_VkPhysicalDeviceScalarBlockLayoutFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceScalarBlockLayoutFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            marshal_VkImageStencilUsageCreateInfo(vkStream, reinterpret_cast<const VkImageStencilUsageCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
        {
            marshal_VkSamplerReductionModeCreateInfo(vkStream, reinterpret_cast<const VkSamplerReductionModeCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
            marshal_VkPhysicalDeviceSamplerFilterMinmaxProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceSamplerFilterMinmaxProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            marshal_VkPhysicalDeviceVulkanMemoryModelFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceVulkanMemoryModelFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            marshal_VkPhysicalDeviceImagelessFramebufferFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceImagelessFramebufferFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
        {
            marshal_VkFramebufferAttachmentsCreateInfo(vkStream, reinterpret_cast<const VkFramebufferAttachmentsCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
        {
            marshal_VkRenderPassAttachmentBeginInfo(vkStream, reinterpret_cast<const VkRenderPassAttachmentBeginInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            marshal_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            marshal_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            marshal_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
        {
            marshal_VkAttachmentReferenceStencilLayout(vkStream, reinterpret_cast<const VkAttachmentReferenceStencilLayout*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
        {
            marshal_VkAttachmentDescriptionStencilLayout(vkStream, reinterpret_cast<const VkAttachmentDescriptionStencilLayout*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            marshal_VkPhysicalDeviceHostQueryResetFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceHostQueryResetFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            marshal_VkPhysicalDeviceTimelineSemaphoreFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceTimelineSemaphoreFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
            marshal_VkPhysicalDeviceTimelineSemaphoreProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceTimelineSemaphoreProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
            marshal_VkSemaphoreTypeCreateInfo(vkStream, reinterpret_cast<const VkSemaphoreTypeCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            marshal_VkTimelineSemaphoreSubmitInfo(vkStream, reinterpret_cast<const VkTimelineSemaphoreSubmitInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            marshal_VkPhysicalDeviceBufferDeviceAddressFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceBufferDeviceAddressFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
            marshal_VkBufferOpaqueCaptureAddressCreateInfo(vkStream, reinterpret_cast<const VkBufferOpaqueCaptureAddressCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
            marshal_VkMemoryOpaqueCaptureAddressAllocateInfo(vkStream, reinterpret_cast<const VkMemoryOpaqueCaptureAddressAllocateInfo*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            marshal_VkImageSwapchainCreateInfoKHR(vkStream, reinterpret_cast<const VkImageSwapchainCreateInfoKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            marshal_VkBindImageMemorySwapchainInfoKHR(vkStream, reinterpret_cast<const VkBindImageMemorySwapchainInfoKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            marshal_VkDeviceGroupPresentInfoKHR(vkStream, reinterpret_cast<const VkDeviceGroupPresentInfoKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            marshal_VkDeviceGroupSwapchainCreateInfoKHR(vkStream, reinterpret_cast<const VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            marshal_VkDisplayPresentInfoKHR(vkStream, reinterpret_cast<const VkDisplayPresentInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            marshal_VkImportMemoryWin32HandleInfoKHR(vkStream, reinterpret_cast<const VkImportMemoryWin32HandleInfoKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            marshal_VkExportMemoryWin32HandleInfoKHR(vkStream, reinterpret_cast<const VkExportMemoryWin32HandleInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            marshal_VkImportMemoryFdInfoKHR(vkStream, reinterpret_cast<const VkImportMemoryFdInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            marshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(vkStream, reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            marshal_VkExportSemaphoreWin32HandleInfoKHR(vkStream, reinterpret_cast<const VkExportSemaphoreWin32HandleInfoKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            marshal_VkD3D12FenceSubmitInfoKHR(vkStream, reinterpret_cast<const VkD3D12FenceSubmitInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            marshal_VkPhysicalDevicePushDescriptorPropertiesKHR(vkStream, reinterpret_cast<const VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            marshal_VkPresentRegionsKHR(vkStream, reinterpret_cast<const VkPresentRegionsKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            marshal_VkSharedPresentSurfaceCapabilitiesKHR(vkStream, reinterpret_cast<const VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            marshal_VkExportFenceWin32HandleInfoKHR(vkStream, reinterpret_cast<const VkExportFenceWin32HandleInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_performance_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            marshal_VkPhysicalDevicePerformanceQueryFeaturesKHR(vkStream, reinterpret_cast<const VkPhysicalDevicePerformanceQueryFeaturesKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {
            marshal_VkPhysicalDevicePerformanceQueryPropertiesKHR(vkStream, reinterpret_cast<const VkPhysicalDevicePerformanceQueryPropertiesKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
        {
            marshal_VkQueryPoolPerformanceCreateInfoKHR(vkStream, reinterpret_cast<const VkQueryPoolPerformanceCreateInfoKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            marshal_VkPerformanceQuerySubmitInfoKHR(vkStream, reinterpret_cast<const VkPerformanceQuerySubmitInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_portability_subset
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR:
        {
            marshal_VkPhysicalDevicePortabilitySubsetFeaturesKHR(vkStream, reinterpret_cast<const VkPhysicalDevicePortabilitySubsetFeaturesKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR:
        {
            marshal_VkPhysicalDevicePortabilitySubsetPropertiesKHR(vkStream, reinterpret_cast<const VkPhysicalDevicePortabilitySubsetPropertiesKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_shader_clock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            marshal_VkPhysicalDeviceShaderClockFeaturesKHR(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderClockFeaturesKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_shader_terminate_invocation
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR:
        {
            marshal_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_fragment_shading_rate
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
            marshal_VkFragmentShadingRateAttachmentInfoKHR(vkStream, reinterpret_cast<const VkFragmentShadingRateAttachmentInfoKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {
            marshal_VkPipelineFragmentShadingRateStateCreateInfoKHR(vkStream, reinterpret_cast<const VkPipelineFragmentShadingRateStateCreateInfoKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            marshal_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(vkStream, reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateFeaturesKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {
            marshal_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(vkStream, reinterpret_cast<const VkPhysicalDeviceFragmentShadingRatePropertiesKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_surface_protected_capabilities
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
        {
            marshal_VkSurfaceProtectedCapabilitiesKHR(vkStream, reinterpret_cast<const VkSurfaceProtectedCapabilitiesKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_pipeline_executable_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            marshal_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(vkStream, reinterpret_cast<const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            marshal_VkNativeBufferANDROID(vkStream, reinterpret_cast<const VkNativeBufferANDROID*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            marshal_VkDebugReportCallbackCreateInfoEXT(vkStream, reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            marshal_VkPipelineRasterizationStateRasterizationOrderAMD(vkStream, reinterpret_cast<const VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            marshal_VkDedicatedAllocationImageCreateInfoNV(vkStream, reinterpret_cast<const VkDedicatedAllocationImageCreateInfoNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            marshal_VkDedicatedAllocationBufferCreateInfoNV(vkStream, reinterpret_cast<const VkDedicatedAllocationBufferCreateInfoNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            marshal_VkDedicatedAllocationMemoryAllocateInfoNV(vkStream, reinterpret_cast<const VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_transform_feedback
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceTransformFeedbackFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceTransformFeedbackPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
        {
            marshal_VkPipelineRasterizationStateStreamCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineRasterizationStateStreamCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            marshal_VkTextureLODGatherFormatPropertiesAMD(vkStream, reinterpret_cast<const VkTextureLODGatherFormatPropertiesAMD*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_corner_sampled_image
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceCornerSampledImageFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceCornerSampledImageFeaturesNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            marshal_VkExternalMemoryImageCreateInfoNV(vkStream, reinterpret_cast<const VkExternalMemoryImageCreateInfoNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            marshal_VkExportMemoryAllocateInfoNV(vkStream, reinterpret_cast<const VkExportMemoryAllocateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            marshal_VkImportMemoryWin32HandleInfoNV(vkStream, reinterpret_cast<const VkImportMemoryWin32HandleInfoNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            marshal_VkExportMemoryWin32HandleInfoNV(vkStream, reinterpret_cast<const VkExportMemoryWin32HandleInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            marshal_VkWin32KeyedMutexAcquireReleaseInfoNV(vkStream, reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            marshal_VkValidationFlagsEXT(vkStream, reinterpret_cast<const VkValidationFlagsEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_astc_decode_mode
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
        {
            marshal_VkImageViewASTCDecodeModeEXT(vkStream, reinterpret_cast<const VkImageViewASTCDecodeModeEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceASTCDecodeFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceASTCDecodeFeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            marshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(vkStream, reinterpret_cast<const VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            marshal_VkPipelineViewportWScalingStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            marshal_VkSwapchainCounterCreateInfoEXT(vkStream, reinterpret_cast<const VkSwapchainCounterCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            marshal_VkPresentTimesInfoGOOGLE(vkStream, reinterpret_cast<const VkPresentTimesInfoGOOGLE*>(structExtension));
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            marshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(vkStream, reinterpret_cast<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            marshal_VkPipelineViewportSwizzleStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            marshal_VkPipelineDiscardRectangleStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            marshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_depth_clip_enable
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceDepthClipEnableFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
        {
            marshal_VkPipelineRasterizationDepthClipStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            marshal_VkDebugUtilsMessengerCreateInfoEXT(vkStream, reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            marshal_VkAndroidHardwareBufferUsageANDROID(vkStream, reinterpret_cast<const VkAndroidHardwareBufferUsageANDROID*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            marshal_VkAndroidHardwareBufferFormatPropertiesANDROID(vkStream, reinterpret_cast<const VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            marshal_VkImportAndroidHardwareBufferInfoANDROID(vkStream, reinterpret_cast<const VkImportAndroidHardwareBufferInfoANDROID*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            marshal_VkExternalFormatANDROID(vkStream, reinterpret_cast<const VkExternalFormatANDROID*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_inline_uniform_block
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockPropertiesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
        {
            marshal_VkWriteDescriptorSetInlineUniformBlockEXT(vkStream, reinterpret_cast<const VkWriteDescriptorSetInlineUniformBlockEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
        {
            marshal_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(vkStream, reinterpret_cast<const VkDescriptorPoolInlineUniformBlockCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            marshal_VkSampleLocationsInfoEXT(vkStream, reinterpret_cast<const VkSampleLocationsInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            marshal_VkRenderPassSampleLocationsBeginInfoEXT(vkStream, reinterpret_cast<const VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            marshal_VkPipelineSampleLocationsStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            marshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            marshal_VkPipelineCoverageToColorStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            marshal_VkPipelineCoverageModulationStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_shader_sm_builtins
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {
            marshal_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_image_drm_format_modifier
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
        {
            marshal_VkDrmFormatModifierPropertiesListEXT(vkStream, reinterpret_cast<const VkDrmFormatModifierPropertiesListEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
        {
            marshal_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
        {
            marshal_VkImageDrmFormatModifierListCreateInfoEXT(vkStream, reinterpret_cast<const VkImageDrmFormatModifierListCreateInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
        {
            marshal_VkImageDrmFormatModifierExplicitCreateInfoEXT(vkStream, reinterpret_cast<const VkImageDrmFormatModifierExplicitCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            marshal_VkShaderModuleValidationCacheCreateInfoEXT(vkStream, reinterpret_cast<const VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_shading_rate_image
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
        {
            marshal_VkPipelineViewportShadingRateImageStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineViewportShadingRateImageStateCreateInfoNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceShadingRateImageFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceShadingRateImageFeaturesNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {
            marshal_VkPhysicalDeviceShadingRateImagePropertiesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceShadingRateImagePropertiesNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
        {
            marshal_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_ray_tracing
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
        {
            marshal_VkWriteDescriptorSetAccelerationStructureNV(vkStream, reinterpret_cast<const VkWriteDescriptorSetAccelerationStructureNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {
            marshal_VkPhysicalDeviceRayTracingPropertiesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceRayTracingPropertiesNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_representative_fragment_test
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {
            marshal_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_filter_cubic
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {
            marshal_VkPhysicalDeviceImageViewImageFormatInfoEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceImageViewImageFormatInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {
            marshal_VkFilterCubicImageViewImageFormatPropertiesEXT(vkStream, reinterpret_cast<const VkFilterCubicImageViewImageFormatPropertiesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            marshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(vkStream, reinterpret_cast<const VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            marshal_VkImportMemoryHostPointerInfoEXT(vkStream, reinterpret_cast<const VkImportMemoryHostPointerInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_AMD_pipeline_compiler_control
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
            marshal_VkPipelineCompilerControlCreateInfoAMD(vkStream, reinterpret_cast<const VkPipelineCompilerControlCreateInfoAMD*>(structExtension));
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            marshal_VkPhysicalDeviceShaderCorePropertiesAMD(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension));
            break;
        }
#endif
#ifdef VK_AMD_memory_overallocation_behavior
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {
            marshal_VkDeviceMemoryOverallocationCreateInfoAMD(vkStream, reinterpret_cast<const VkDeviceMemoryOverallocationCreateInfoAMD*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            marshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_GGP_frame_token
        case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
        {
            marshal_VkPresentFrameTokenGGP(vkStream, reinterpret_cast<const VkPresentFrameTokenGGP*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_pipeline_creation_feedback
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
        {
            marshal_VkPipelineCreationFeedbackCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineCreationFeedbackCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_compute_shader_derivatives
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_mesh_shader
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceMeshShaderFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceMeshShaderFeaturesNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {
            marshal_VkPhysicalDeviceMeshShaderPropertiesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceMeshShaderPropertiesNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_fragment_shader_barycentric
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_shader_image_footprint
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceShaderImageFootprintFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_scissor_exclusive
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
        {
            marshal_VkPipelineViewportExclusiveScissorStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceExclusiveScissorFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceExclusiveScissorFeaturesNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            marshal_VkQueueFamilyCheckpointPropertiesNV(vkStream, reinterpret_cast<const VkQueueFamilyCheckpointPropertiesNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_INTEL_shader_integer_functions2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            marshal_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(structExtension));
            break;
        }
#endif
#ifdef VK_INTEL_performance_query
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
        {
            marshal_VkQueryPoolPerformanceQueryCreateInfoINTEL(vkStream, reinterpret_cast<const VkQueryPoolPerformanceQueryCreateInfoINTEL*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_pci_bus_info
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDevicePCIBusInfoPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDevicePCIBusInfoPropertiesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_AMD_display_native_hdr
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
        {
            marshal_VkDisplayNativeHdrSurfaceCapabilitiesAMD(vkStream, reinterpret_cast<const VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
        {
            marshal_VkSwapchainDisplayNativeHdrCreateInfoAMD(vkStream, reinterpret_cast<const VkSwapchainDisplayNativeHdrCreateInfoAMD*>(structExtension));
            break;
        }
#endif
#ifdef VK_GOOGLE_color_buffer
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE:
        {
            marshal_VkImportColorBufferGOOGLE(vkStream, reinterpret_cast<const VkImportColorBufferGOOGLE*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_BUFFER_GOOGLE:
        {
            marshal_VkImportBufferGOOGLE(vkStream, reinterpret_cast<const VkImportBufferGOOGLE*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE:
        {
            marshal_VkImportPhysicalAddressGOOGLE(vkStream, reinterpret_cast<const VkImportPhysicalAddressGOOGLE*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_subgroup_size_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT:
        {
            marshal_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {
            marshal_VkPhysicalDeviceShaderCoreProperties2AMD(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderCoreProperties2AMD*>(structExtension));
            break;
        }
#endif
#ifdef VK_AMD_device_coherent_memory
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            marshal_VkPhysicalDeviceCoherentMemoryFeaturesAMD(vkStream, reinterpret_cast<const VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_shader_image_atomic_int64
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_memory_budget
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceMemoryBudgetPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_memory_priority
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceMemoryPriorityFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {
            marshal_VkMemoryPriorityAllocateInfoEXT(vkStream, reinterpret_cast<const VkMemoryPriorityAllocateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_buffer_device_address
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {
            marshal_VkBufferDeviceAddressCreateInfoEXT(vkStream, reinterpret_cast<const VkBufferDeviceAddressCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_validation_features
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
            marshal_VkValidationFeaturesEXT(vkStream, reinterpret_cast<const VkValidationFeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_cooperative_matrix
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceCooperativeMatrixFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
            marshal_VkPhysicalDeviceCooperativeMatrixPropertiesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_coverage_reduction_mode
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceCoverageReductionModeFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
        {
            marshal_VkPipelineCoverageReductionStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineCoverageReductionStateCreateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_fragment_shader_interlock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_ycbcr_image_arrays
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_full_screen_exclusive
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
        {
            marshal_VkSurfaceFullScreenExclusiveInfoEXT(vkStream, reinterpret_cast<const VkSurfaceFullScreenExclusiveInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
        {
            marshal_VkSurfaceCapabilitiesFullScreenExclusiveEXT(vkStream, reinterpret_cast<const VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
        {
            marshal_VkSurfaceFullScreenExclusiveWin32InfoEXT(vkStream, reinterpret_cast<const VkSurfaceFullScreenExclusiveWin32InfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_line_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceLineRasterizationFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceLineRasterizationPropertiesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
        {
            marshal_VkPipelineRasterizationLineStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineRasterizationLineStateCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_shader_atomic_float
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_index_type_uint8
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceIndexTypeUint8FeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_device_generated_commands
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {
            marshal_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {
            marshal_VkGraphicsPipelineShaderGroupsCreateInfoNV(vkStream, reinterpret_cast<const VkGraphicsPipelineShaderGroupsCreateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_texel_buffer_alignment
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_QCOM_render_pass_transform
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
        {
            marshal_VkRenderPassTransformBeginInfoQCOM(vkStream, reinterpret_cast<const VkRenderPassTransformBeginInfoQCOM*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
        {
            marshal_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(vkStream, reinterpret_cast<const VkCommandBufferInheritanceRenderPassTransformInfoQCOM*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_device_memory_report
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
        {
            marshal_VkDeviceDeviceMemoryReportCreateInfoEXT(vkStream, reinterpret_cast<const VkDeviceDeviceMemoryReportCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_robustness2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceRobustness2FeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceRobustness2FeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceRobustness2PropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceRobustness2PropertiesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_custom_border_color
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
        {
            marshal_VkSamplerCustomBorderColorCreateInfoEXT(vkStream, reinterpret_cast<const VkSamplerCustomBorderColorCreateInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceCustomBorderColorPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceCustomBorderColorPropertiesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceCustomBorderColorFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_private_data
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT:
        {
            marshal_VkPhysicalDevicePrivateDataFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDevicePrivateDataFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT:
        {
            marshal_VkDevicePrivateDataCreateInfoEXT(vkStream, reinterpret_cast<const VkDevicePrivateDataCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_pipeline_creation_cache_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT:
        {
            marshal_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_device_diagnostics_config
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceDiagnosticsConfigFeaturesNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {
            marshal_VkDeviceDiagnosticsConfigCreateInfoNV(vkStream, reinterpret_cast<const VkDeviceDiagnosticsConfigCreateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_fragment_shading_rate_enums
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            marshal_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {
            marshal_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(vkStream, reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {
            marshal_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineFragmentShadingRateEnumStateCreateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_fragment_density_map2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_QCOM_rotated_copy_commands
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {
            marshal_VkCopyCommandTransformInfoQCOM(vkStream, reinterpret_cast<const VkCopyCommandTransformInfoQCOM*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_image_robustness
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceImageRobustnessFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceImageRobustnessFeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_4444_formats
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            marshal_VkPhysicalDevice4444FormatsFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDevice4444FormatsFeaturesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
        {
            marshal_VkWriteDescriptorSetAccelerationStructureKHR(vkStream, reinterpret_cast<const VkWriteDescriptorSetAccelerationStructureKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            marshal_VkPhysicalDeviceAccelerationStructureFeaturesKHR(vkStream, reinterpret_cast<const VkPhysicalDeviceAccelerationStructureFeaturesKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {
            marshal_VkPhysicalDeviceAccelerationStructurePropertiesKHR(vkStream, reinterpret_cast<const VkPhysicalDeviceAccelerationStructurePropertiesKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            marshal_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(vkStream, reinterpret_cast<const VkPhysicalDeviceRayTracingPipelineFeaturesKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {
            marshal_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(vkStream, reinterpret_cast<const VkPhysicalDeviceRayTracingPipelinePropertiesKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_ray_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            marshal_VkPhysicalDeviceRayQueryFeaturesKHR(vkStream, reinterpret_cast<const VkPhysicalDeviceRayQueryFeaturesKHR*>(structExtension));
            break;
        }
#endif
        default:
        {
            // fatal; the switch is only taken if the extension struct is known
            abort();
        }
    }
}

void unmarshal_extension_struct(
    VulkanStream* vkStream,
    void* structExtension_out)
{
    VkInstanceCreateInfo* structAccess = (VkInstanceCreateInfo*)(structExtension_out);
    size_t currExtSize = goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), structExtension_out);
    if (!currExtSize && structExtension_out)
    {
        // unknown struct extension; skip and call on its pNext field
        unmarshal_extension_struct(vkStream, (void*)structAccess->pNext);
        return;
    }
    else
    {
        // known or null extension struct
        if (!currExtSize)
        {
            // exit if this was a null extension struct (size == 0 in this branch)
            return;
        }
    }
    if (!structExtension_out)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension_out);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceSubgroupProperties(vkStream, reinterpret_cast<VkPhysicalDeviceSubgroupProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            unmarshal_VkPhysicalDevice16BitStorageFeatures(vkStream, reinterpret_cast<VkPhysicalDevice16BitStorageFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            unmarshal_VkMemoryDedicatedRequirements(vkStream, reinterpret_cast<VkMemoryDedicatedRequirements*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            unmarshal_VkMemoryDedicatedAllocateInfo(vkStream, reinterpret_cast<VkMemoryDedicatedAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            unmarshal_VkMemoryAllocateFlagsInfo(vkStream, reinterpret_cast<VkMemoryAllocateFlagsInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            unmarshal_VkDeviceGroupRenderPassBeginInfo(vkStream, reinterpret_cast<VkDeviceGroupRenderPassBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            unmarshal_VkDeviceGroupCommandBufferBeginInfo(vkStream, reinterpret_cast<VkDeviceGroupCommandBufferBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            unmarshal_VkDeviceGroupSubmitInfo(vkStream, reinterpret_cast<VkDeviceGroupSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            unmarshal_VkDeviceGroupBindSparseInfo(vkStream, reinterpret_cast<VkDeviceGroupBindSparseInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            unmarshal_VkBindBufferMemoryDeviceGroupInfo(vkStream, reinterpret_cast<VkBindBufferMemoryDeviceGroupInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            unmarshal_VkBindImageMemoryDeviceGroupInfo(vkStream, reinterpret_cast<VkBindImageMemoryDeviceGroupInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            unmarshal_VkDeviceGroupDeviceCreateInfo(vkStream, reinterpret_cast<VkDeviceGroupDeviceCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            unmarshal_VkPhysicalDeviceFeatures2(vkStream, reinterpret_cast<VkPhysicalDeviceFeatures2*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            unmarshal_VkPhysicalDevicePointClippingProperties(vkStream, reinterpret_cast<VkPhysicalDevicePointClippingProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            unmarshal_VkRenderPassInputAttachmentAspectCreateInfo(vkStream, reinterpret_cast<VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            unmarshal_VkImageViewUsageCreateInfo(vkStream, reinterpret_cast<VkImageViewUsageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            unmarshal_VkPipelineTessellationDomainOriginStateCreateInfo(vkStream, reinterpret_cast<VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            unmarshal_VkRenderPassMultiviewCreateInfo(vkStream, reinterpret_cast<VkRenderPassMultiviewCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            unmarshal_VkPhysicalDeviceMultiviewFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceMultiviewFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceMultiviewProperties(vkStream, reinterpret_cast<VkPhysicalDeviceMultiviewProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            unmarshal_VkPhysicalDeviceVariablePointersFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceVariablePointersFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            unmarshal_VkPhysicalDeviceProtectedMemoryFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceProtectedMemoryProperties(vkStream, reinterpret_cast<VkPhysicalDeviceProtectedMemoryProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            unmarshal_VkProtectedSubmitInfo(vkStream, reinterpret_cast<VkProtectedSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            unmarshal_VkSamplerYcbcrConversionInfo(vkStream, reinterpret_cast<VkSamplerYcbcrConversionInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            unmarshal_VkBindImagePlaneMemoryInfo(vkStream, reinterpret_cast<VkBindImagePlaneMemoryInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            unmarshal_VkImagePlaneMemoryRequirementsInfo(vkStream, reinterpret_cast<VkImagePlaneMemoryRequirementsInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            unmarshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            unmarshal_VkSamplerYcbcrConversionImageFormatProperties(vkStream, reinterpret_cast<VkSamplerYcbcrConversionImageFormatProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            unmarshal_VkPhysicalDeviceExternalImageFormatInfo(vkStream, reinterpret_cast<VkPhysicalDeviceExternalImageFormatInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            unmarshal_VkExternalImageFormatProperties(vkStream, reinterpret_cast<VkExternalImageFormatProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceIDProperties(vkStream, reinterpret_cast<VkPhysicalDeviceIDProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            unmarshal_VkExternalMemoryImageCreateInfo(vkStream, reinterpret_cast<VkExternalMemoryImageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            unmarshal_VkExternalMemoryBufferCreateInfo(vkStream, reinterpret_cast<VkExternalMemoryBufferCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            unmarshal_VkExportMemoryAllocateInfo(vkStream, reinterpret_cast<VkExportMemoryAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            unmarshal_VkExportFenceCreateInfo(vkStream, reinterpret_cast<VkExportFenceCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            unmarshal_VkExportSemaphoreCreateInfo(vkStream, reinterpret_cast<VkExportSemaphoreCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceMaintenance3Properties(vkStream, reinterpret_cast<VkPhysicalDeviceMaintenance3Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            unmarshal_VkPhysicalDeviceShaderDrawParametersFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceShaderDrawParametersFeatures*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_VERSION_1_2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            unmarshal_VkPhysicalDeviceVulkan11Features(vkStream, reinterpret_cast<VkPhysicalDeviceVulkan11Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceVulkan11Properties(vkStream, reinterpret_cast<VkPhysicalDeviceVulkan11Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            unmarshal_VkPhysicalDeviceVulkan12Features(vkStream, reinterpret_cast<VkPhysicalDeviceVulkan12Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceVulkan12Properties(vkStream, reinterpret_cast<VkPhysicalDeviceVulkan12Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            unmarshal_VkImageFormatListCreateInfo(vkStream, reinterpret_cast<VkImageFormatListCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            unmarshal_VkPhysicalDevice8BitStorageFeatures(vkStream, reinterpret_cast<VkPhysicalDevice8BitStorageFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceDriverProperties(vkStream, reinterpret_cast<VkPhysicalDeviceDriverProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            unmarshal_VkPhysicalDeviceShaderAtomicInt64Features(vkStream, reinterpret_cast<VkPhysicalDeviceShaderAtomicInt64Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            unmarshal_VkPhysicalDeviceShaderFloat16Int8Features(vkStream, reinterpret_cast<VkPhysicalDeviceShaderFloat16Int8Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceFloatControlsProperties(vkStream, reinterpret_cast<VkPhysicalDeviceFloatControlsProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
        {
            unmarshal_VkDescriptorSetLayoutBindingFlagsCreateInfo(vkStream, reinterpret_cast<VkDescriptorSetLayoutBindingFlagsCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            unmarshal_VkPhysicalDeviceDescriptorIndexingFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceDescriptorIndexingFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceDescriptorIndexingProperties(vkStream, reinterpret_cast<VkPhysicalDeviceDescriptorIndexingProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
        {
            unmarshal_VkDescriptorSetVariableDescriptorCountAllocateInfo(vkStream, reinterpret_cast<VkDescriptorSetVariableDescriptorCountAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
            unmarshal_VkDescriptorSetVariableDescriptorCountLayoutSupport(vkStream, reinterpret_cast<VkDescriptorSetVariableDescriptorCountLayoutSupport*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
        {
            unmarshal_VkSubpassDescriptionDepthStencilResolve(vkStream, reinterpret_cast<VkSubpassDescriptionDepthStencilResolve*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceDepthStencilResolveProperties(vkStream, reinterpret_cast<VkPhysicalDeviceDepthStencilResolveProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            unmarshal_VkPhysicalDeviceScalarBlockLayoutFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceScalarBlockLayoutFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            unmarshal_VkImageStencilUsageCreateInfo(vkStream, reinterpret_cast<VkImageStencilUsageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
        {
            unmarshal_VkSamplerReductionModeCreateInfo(vkStream, reinterpret_cast<VkSamplerReductionModeCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceSamplerFilterMinmaxProperties(vkStream, reinterpret_cast<VkPhysicalDeviceSamplerFilterMinmaxProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            unmarshal_VkPhysicalDeviceVulkanMemoryModelFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceVulkanMemoryModelFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            unmarshal_VkPhysicalDeviceImagelessFramebufferFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceImagelessFramebufferFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
        {
            unmarshal_VkFramebufferAttachmentsCreateInfo(vkStream, reinterpret_cast<VkFramebufferAttachmentsCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
        {
            unmarshal_VkRenderPassAttachmentBeginInfo(vkStream, reinterpret_cast<VkRenderPassAttachmentBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            unmarshal_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            unmarshal_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            unmarshal_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
        {
            unmarshal_VkAttachmentReferenceStencilLayout(vkStream, reinterpret_cast<VkAttachmentReferenceStencilLayout*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
        {
            unmarshal_VkAttachmentDescriptionStencilLayout(vkStream, reinterpret_cast<VkAttachmentDescriptionStencilLayout*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            unmarshal_VkPhysicalDeviceHostQueryResetFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceHostQueryResetFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            unmarshal_VkPhysicalDeviceTimelineSemaphoreFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceTimelineSemaphoreProperties(vkStream, reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
            unmarshal_VkSemaphoreTypeCreateInfo(vkStream, reinterpret_cast<VkSemaphoreTypeCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            unmarshal_VkTimelineSemaphoreSubmitInfo(vkStream, reinterpret_cast<VkTimelineSemaphoreSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            unmarshal_VkPhysicalDeviceBufferDeviceAddressFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceBufferDeviceAddressFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
            unmarshal_VkBufferOpaqueCaptureAddressCreateInfo(vkStream, reinterpret_cast<VkBufferOpaqueCaptureAddressCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
            unmarshal_VkMemoryOpaqueCaptureAddressAllocateInfo(vkStream, reinterpret_cast<VkMemoryOpaqueCaptureAddressAllocateInfo*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            unmarshal_VkImageSwapchainCreateInfoKHR(vkStream, reinterpret_cast<VkImageSwapchainCreateInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            unmarshal_VkBindImageMemorySwapchainInfoKHR(vkStream, reinterpret_cast<VkBindImageMemorySwapchainInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            unmarshal_VkDeviceGroupPresentInfoKHR(vkStream, reinterpret_cast<VkDeviceGroupPresentInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            unmarshal_VkDeviceGroupSwapchainCreateInfoKHR(vkStream, reinterpret_cast<VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            unmarshal_VkDisplayPresentInfoKHR(vkStream, reinterpret_cast<VkDisplayPresentInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            unmarshal_VkImportMemoryWin32HandleInfoKHR(vkStream, reinterpret_cast<VkImportMemoryWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            unmarshal_VkExportMemoryWin32HandleInfoKHR(vkStream, reinterpret_cast<VkExportMemoryWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            unmarshal_VkImportMemoryFdInfoKHR(vkStream, reinterpret_cast<VkImportMemoryFdInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            unmarshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(vkStream, reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            unmarshal_VkExportSemaphoreWin32HandleInfoKHR(vkStream, reinterpret_cast<VkExportSemaphoreWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            unmarshal_VkD3D12FenceSubmitInfoKHR(vkStream, reinterpret_cast<VkD3D12FenceSubmitInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            unmarshal_VkPhysicalDevicePushDescriptorPropertiesKHR(vkStream, reinterpret_cast<VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            unmarshal_VkPresentRegionsKHR(vkStream, reinterpret_cast<VkPresentRegionsKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            unmarshal_VkSharedPresentSurfaceCapabilitiesKHR(vkStream, reinterpret_cast<VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            unmarshal_VkExportFenceWin32HandleInfoKHR(vkStream, reinterpret_cast<VkExportFenceWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_performance_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            unmarshal_VkPhysicalDevicePerformanceQueryFeaturesKHR(vkStream, reinterpret_cast<VkPhysicalDevicePerformanceQueryFeaturesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {
            unmarshal_VkPhysicalDevicePerformanceQueryPropertiesKHR(vkStream, reinterpret_cast<VkPhysicalDevicePerformanceQueryPropertiesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
        {
            unmarshal_VkQueryPoolPerformanceCreateInfoKHR(vkStream, reinterpret_cast<VkQueryPoolPerformanceCreateInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            unmarshal_VkPerformanceQuerySubmitInfoKHR(vkStream, reinterpret_cast<VkPerformanceQuerySubmitInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_portability_subset
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR:
        {
            unmarshal_VkPhysicalDevicePortabilitySubsetFeaturesKHR(vkStream, reinterpret_cast<VkPhysicalDevicePortabilitySubsetFeaturesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR:
        {
            unmarshal_VkPhysicalDevicePortabilitySubsetPropertiesKHR(vkStream, reinterpret_cast<VkPhysicalDevicePortabilitySubsetPropertiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_shader_clock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            unmarshal_VkPhysicalDeviceShaderClockFeaturesKHR(vkStream, reinterpret_cast<VkPhysicalDeviceShaderClockFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_shader_terminate_invocation
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR:
        {
            unmarshal_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(vkStream, reinterpret_cast<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_fragment_shading_rate
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
            unmarshal_VkFragmentShadingRateAttachmentInfoKHR(vkStream, reinterpret_cast<VkFragmentShadingRateAttachmentInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {
            unmarshal_VkPipelineFragmentShadingRateStateCreateInfoKHR(vkStream, reinterpret_cast<VkPipelineFragmentShadingRateStateCreateInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            unmarshal_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(vkStream, reinterpret_cast<VkPhysicalDeviceFragmentShadingRateFeaturesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {
            unmarshal_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(vkStream, reinterpret_cast<VkPhysicalDeviceFragmentShadingRatePropertiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_surface_protected_capabilities
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
        {
            unmarshal_VkSurfaceProtectedCapabilitiesKHR(vkStream, reinterpret_cast<VkSurfaceProtectedCapabilitiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_pipeline_executable_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            unmarshal_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(vkStream, reinterpret_cast<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            unmarshal_VkNativeBufferANDROID(vkStream, reinterpret_cast<VkNativeBufferANDROID*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            unmarshal_VkDebugReportCallbackCreateInfoEXT(vkStream, reinterpret_cast<VkDebugReportCallbackCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            unmarshal_VkPipelineRasterizationStateRasterizationOrderAMD(vkStream, reinterpret_cast<VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            unmarshal_VkDedicatedAllocationImageCreateInfoNV(vkStream, reinterpret_cast<VkDedicatedAllocationImageCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            unmarshal_VkDedicatedAllocationBufferCreateInfoNV(vkStream, reinterpret_cast<VkDedicatedAllocationBufferCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            unmarshal_VkDedicatedAllocationMemoryAllocateInfoNV(vkStream, reinterpret_cast<VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_transform_feedback
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceTransformFeedbackFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceTransformFeedbackPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineRasterizationStateStreamCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineRasterizationStateStreamCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            unmarshal_VkTextureLODGatherFormatPropertiesAMD(vkStream, reinterpret_cast<VkTextureLODGatherFormatPropertiesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_corner_sampled_image
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceCornerSampledImageFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceCornerSampledImageFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            unmarshal_VkExternalMemoryImageCreateInfoNV(vkStream, reinterpret_cast<VkExternalMemoryImageCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            unmarshal_VkExportMemoryAllocateInfoNV(vkStream, reinterpret_cast<VkExportMemoryAllocateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            unmarshal_VkImportMemoryWin32HandleInfoNV(vkStream, reinterpret_cast<VkImportMemoryWin32HandleInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            unmarshal_VkExportMemoryWin32HandleInfoNV(vkStream, reinterpret_cast<VkExportMemoryWin32HandleInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            unmarshal_VkWin32KeyedMutexAcquireReleaseInfoNV(vkStream, reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            unmarshal_VkValidationFlagsEXT(vkStream, reinterpret_cast<VkValidationFlagsEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_astc_decode_mode
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
        {
            unmarshal_VkImageViewASTCDecodeModeEXT(vkStream, reinterpret_cast<VkImageViewASTCDecodeModeEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceASTCDecodeFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceASTCDecodeFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            unmarshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(vkStream, reinterpret_cast<VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            unmarshal_VkPipelineViewportWScalingStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            unmarshal_VkSwapchainCounterCreateInfoEXT(vkStream, reinterpret_cast<VkSwapchainCounterCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            unmarshal_VkPresentTimesInfoGOOGLE(vkStream, reinterpret_cast<VkPresentTimesInfoGOOGLE*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            unmarshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(vkStream, reinterpret_cast<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            unmarshal_VkPipelineViewportSwizzleStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineDiscardRectangleStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_depth_clip_enable
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceDepthClipEnableFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineRasterizationDepthClipStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            unmarshal_VkDebugUtilsMessengerCreateInfoEXT(vkStream, reinterpret_cast<VkDebugUtilsMessengerCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            unmarshal_VkAndroidHardwareBufferUsageANDROID(vkStream, reinterpret_cast<VkAndroidHardwareBufferUsageANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            unmarshal_VkAndroidHardwareBufferFormatPropertiesANDROID(vkStream, reinterpret_cast<VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            unmarshal_VkImportAndroidHardwareBufferInfoANDROID(vkStream, reinterpret_cast<VkImportAndroidHardwareBufferInfoANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            unmarshal_VkExternalFormatANDROID(vkStream, reinterpret_cast<VkExternalFormatANDROID*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_inline_uniform_block
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceInlineUniformBlockFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceInlineUniformBlockPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
        {
            unmarshal_VkWriteDescriptorSetInlineUniformBlockEXT(vkStream, reinterpret_cast<VkWriteDescriptorSetInlineUniformBlockEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
        {
            unmarshal_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(vkStream, reinterpret_cast<VkDescriptorPoolInlineUniformBlockCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            unmarshal_VkSampleLocationsInfoEXT(vkStream, reinterpret_cast<VkSampleLocationsInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            unmarshal_VkRenderPassSampleLocationsBeginInfoEXT(vkStream, reinterpret_cast<VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineSampleLocationsStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            unmarshal_VkPipelineCoverageToColorStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            unmarshal_VkPipelineCoverageModulationStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_shader_sm_builtins
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {
            unmarshal_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(vkStream, reinterpret_cast<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_image_drm_format_modifier
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
        {
            unmarshal_VkDrmFormatModifierPropertiesListEXT(vkStream, reinterpret_cast<VkDrmFormatModifierPropertiesListEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
        {
            unmarshal_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(vkStream, reinterpret_cast<VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
        {
            unmarshal_VkImageDrmFormatModifierListCreateInfoEXT(vkStream, reinterpret_cast<VkImageDrmFormatModifierListCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
        {
            unmarshal_VkImageDrmFormatModifierExplicitCreateInfoEXT(vkStream, reinterpret_cast<VkImageDrmFormatModifierExplicitCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            unmarshal_VkShaderModuleValidationCacheCreateInfoEXT(vkStream, reinterpret_cast<VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_shading_rate_image
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
        {
            unmarshal_VkPipelineViewportShadingRateImageStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineViewportShadingRateImageStateCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceShadingRateImageFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceShadingRateImageFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {
            unmarshal_VkPhysicalDeviceShadingRateImagePropertiesNV(vkStream, reinterpret_cast<VkPhysicalDeviceShadingRateImagePropertiesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
        {
            unmarshal_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_ray_tracing
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
        {
            unmarshal_VkWriteDescriptorSetAccelerationStructureNV(vkStream, reinterpret_cast<VkWriteDescriptorSetAccelerationStructureNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {
            unmarshal_VkPhysicalDeviceRayTracingPropertiesNV(vkStream, reinterpret_cast<VkPhysicalDeviceRayTracingPropertiesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_representative_fragment_test
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {
            unmarshal_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_filter_cubic
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {
            unmarshal_VkPhysicalDeviceImageViewImageFormatInfoEXT(vkStream, reinterpret_cast<VkPhysicalDeviceImageViewImageFormatInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {
            unmarshal_VkFilterCubicImageViewImageFormatPropertiesEXT(vkStream, reinterpret_cast<VkFilterCubicImageViewImageFormatPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            unmarshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(vkStream, reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            unmarshal_VkImportMemoryHostPointerInfoEXT(vkStream, reinterpret_cast<VkImportMemoryHostPointerInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_pipeline_compiler_control
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
            unmarshal_VkPipelineCompilerControlCreateInfoAMD(vkStream, reinterpret_cast<VkPipelineCompilerControlCreateInfoAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            unmarshal_VkPhysicalDeviceShaderCorePropertiesAMD(vkStream, reinterpret_cast<VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_memory_overallocation_behavior
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {
            unmarshal_VkDeviceMemoryOverallocationCreateInfoAMD(vkStream, reinterpret_cast<VkDeviceMemoryOverallocationCreateInfoAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_GGP_frame_token
        case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
        {
            unmarshal_VkPresentFrameTokenGGP(vkStream, reinterpret_cast<VkPresentFrameTokenGGP*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_pipeline_creation_feedback
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineCreationFeedbackCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineCreationFeedbackCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_compute_shader_derivatives
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_mesh_shader
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceMeshShaderFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceMeshShaderFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {
            unmarshal_VkPhysicalDeviceMeshShaderPropertiesNV(vkStream, reinterpret_cast<VkPhysicalDeviceMeshShaderPropertiesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_fragment_shader_barycentric
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_shader_image_footprint
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceShaderImageFootprintFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_scissor_exclusive
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
        {
            unmarshal_VkPipelineViewportExclusiveScissorStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceExclusiveScissorFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceExclusiveScissorFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            unmarshal_VkQueueFamilyCheckpointPropertiesNV(vkStream, reinterpret_cast<VkQueueFamilyCheckpointPropertiesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_INTEL_shader_integer_functions2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            unmarshal_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(vkStream, reinterpret_cast<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_INTEL_performance_query
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
        {
            unmarshal_VkQueryPoolPerformanceQueryCreateInfoINTEL(vkStream, reinterpret_cast<VkQueryPoolPerformanceQueryCreateInfoINTEL*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_pci_bus_info
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDevicePCIBusInfoPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDevicePCIBusInfoPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_display_native_hdr
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
        {
            unmarshal_VkDisplayNativeHdrSurfaceCapabilitiesAMD(vkStream, reinterpret_cast<VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
        {
            unmarshal_VkSwapchainDisplayNativeHdrCreateInfoAMD(vkStream, reinterpret_cast<VkSwapchainDisplayNativeHdrCreateInfoAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_GOOGLE_color_buffer
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE:
        {
            unmarshal_VkImportColorBufferGOOGLE(vkStream, reinterpret_cast<VkImportColorBufferGOOGLE*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_BUFFER_GOOGLE:
        {
            unmarshal_VkImportBufferGOOGLE(vkStream, reinterpret_cast<VkImportBufferGOOGLE*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE:
        {
            unmarshal_VkImportPhysicalAddressGOOGLE(vkStream, reinterpret_cast<VkImportPhysicalAddressGOOGLE*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_subgroup_size_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {
            unmarshal_VkPhysicalDeviceShaderCoreProperties2AMD(vkStream, reinterpret_cast<VkPhysicalDeviceShaderCoreProperties2AMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_device_coherent_memory
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            unmarshal_VkPhysicalDeviceCoherentMemoryFeaturesAMD(vkStream, reinterpret_cast<VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_shader_image_atomic_int64
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_memory_budget
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceMemoryBudgetPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_memory_priority
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceMemoryPriorityFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {
            unmarshal_VkMemoryPriorityAllocateInfoEXT(vkStream, reinterpret_cast<VkMemoryPriorityAllocateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_buffer_device_address
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {
            unmarshal_VkBufferDeviceAddressCreateInfoEXT(vkStream, reinterpret_cast<VkBufferDeviceAddressCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_features
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
            unmarshal_VkValidationFeaturesEXT(vkStream, reinterpret_cast<VkValidationFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_cooperative_matrix
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceCooperativeMatrixFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
            unmarshal_VkPhysicalDeviceCooperativeMatrixPropertiesNV(vkStream, reinterpret_cast<VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_coverage_reduction_mode
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceCoverageReductionModeFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
        {
            unmarshal_VkPipelineCoverageReductionStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineCoverageReductionStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_fragment_shader_interlock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_ycbcr_image_arrays
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_full_screen_exclusive
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
        {
            unmarshal_VkSurfaceFullScreenExclusiveInfoEXT(vkStream, reinterpret_cast<VkSurfaceFullScreenExclusiveInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
        {
            unmarshal_VkSurfaceCapabilitiesFullScreenExclusiveEXT(vkStream, reinterpret_cast<VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
        {
            unmarshal_VkSurfaceFullScreenExclusiveWin32InfoEXT(vkStream, reinterpret_cast<VkSurfaceFullScreenExclusiveWin32InfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_line_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineRasterizationLineStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_shader_atomic_float
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_index_type_uint8
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceIndexTypeUint8FeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_device_generated_commands
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {
            unmarshal_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(vkStream, reinterpret_cast<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {
            unmarshal_VkGraphicsPipelineShaderGroupsCreateInfoNV(vkStream, reinterpret_cast<VkGraphicsPipelineShaderGroupsCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_texel_buffer_alignment
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_QCOM_render_pass_transform
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
        {
            unmarshal_VkRenderPassTransformBeginInfoQCOM(vkStream, reinterpret_cast<VkRenderPassTransformBeginInfoQCOM*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
        {
            unmarshal_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(vkStream, reinterpret_cast<VkCommandBufferInheritanceRenderPassTransformInfoQCOM*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_device_memory_report
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
        {
            unmarshal_VkDeviceDeviceMemoryReportCreateInfoEXT(vkStream, reinterpret_cast<VkDeviceDeviceMemoryReportCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_robustness2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceRobustness2FeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceRobustness2FeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceRobustness2PropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceRobustness2PropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_custom_border_color
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
        {
            unmarshal_VkSamplerCustomBorderColorCreateInfoEXT(vkStream, reinterpret_cast<VkSamplerCustomBorderColorCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceCustomBorderColorPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceCustomBorderColorPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceCustomBorderColorFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_private_data
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDevicePrivateDataFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDevicePrivateDataFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT:
        {
            unmarshal_VkDevicePrivateDataCreateInfoEXT(vkStream, reinterpret_cast<VkDevicePrivateDataCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_pipeline_creation_cache_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_device_diagnostics_config
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceDiagnosticsConfigFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {
            unmarshal_VkDeviceDiagnosticsConfigCreateInfoNV(vkStream, reinterpret_cast<VkDeviceDiagnosticsConfigCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_fragment_shading_rate_enums
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            unmarshal_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(vkStream, reinterpret_cast<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {
            unmarshal_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(vkStream, reinterpret_cast<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {
            unmarshal_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineFragmentShadingRateEnumStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_fragment_density_map2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_QCOM_rotated_copy_commands
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {
            unmarshal_VkCopyCommandTransformInfoQCOM(vkStream, reinterpret_cast<VkCopyCommandTransformInfoQCOM*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_image_robustness
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceImageRobustnessFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceImageRobustnessFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_4444_formats
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDevice4444FormatsFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDevice4444FormatsFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
        {
            unmarshal_VkWriteDescriptorSetAccelerationStructureKHR(vkStream, reinterpret_cast<VkWriteDescriptorSetAccelerationStructureKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            unmarshal_VkPhysicalDeviceAccelerationStructureFeaturesKHR(vkStream, reinterpret_cast<VkPhysicalDeviceAccelerationStructureFeaturesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {
            unmarshal_VkPhysicalDeviceAccelerationStructurePropertiesKHR(vkStream, reinterpret_cast<VkPhysicalDeviceAccelerationStructurePropertiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            unmarshal_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(vkStream, reinterpret_cast<VkPhysicalDeviceRayTracingPipelineFeaturesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {
            unmarshal_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(vkStream, reinterpret_cast<VkPhysicalDeviceRayTracingPipelinePropertiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_ray_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            unmarshal_VkPhysicalDeviceRayQueryFeaturesKHR(vkStream, reinterpret_cast<VkPhysicalDeviceRayQueryFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
        default:
        {
            // fatal; the switch is only taken if the extension struct is known
            abort();
        }
    }
}

const char* api_opcode_to_string(
    const uint32_t opcode)
{
    switch(opcode)
    {
#ifdef VK_VERSION_1_0
        case OP_vkCreateInstance:
        {
            return "OP_vkCreateInstance";
        }
        case OP_vkDestroyInstance:
        {
            return "OP_vkDestroyInstance";
        }
        case OP_vkEnumeratePhysicalDevices:
        {
            return "OP_vkEnumeratePhysicalDevices";
        }
        case OP_vkGetPhysicalDeviceFeatures:
        {
            return "OP_vkGetPhysicalDeviceFeatures";
        }
        case OP_vkGetPhysicalDeviceFormatProperties:
        {
            return "OP_vkGetPhysicalDeviceFormatProperties";
        }
        case OP_vkGetPhysicalDeviceImageFormatProperties:
        {
            return "OP_vkGetPhysicalDeviceImageFormatProperties";
        }
        case OP_vkGetPhysicalDeviceProperties:
        {
            return "OP_vkGetPhysicalDeviceProperties";
        }
        case OP_vkGetPhysicalDeviceQueueFamilyProperties:
        {
            return "OP_vkGetPhysicalDeviceQueueFamilyProperties";
        }
        case OP_vkGetPhysicalDeviceMemoryProperties:
        {
            return "OP_vkGetPhysicalDeviceMemoryProperties";
        }
        case OP_vkGetInstanceProcAddr:
        {
            return "OP_vkGetInstanceProcAddr";
        }
        case OP_vkGetDeviceProcAddr:
        {
            return "OP_vkGetDeviceProcAddr";
        }
        case OP_vkCreateDevice:
        {
            return "OP_vkCreateDevice";
        }
        case OP_vkDestroyDevice:
        {
            return "OP_vkDestroyDevice";
        }
        case OP_vkEnumerateInstanceExtensionProperties:
        {
            return "OP_vkEnumerateInstanceExtensionProperties";
        }
        case OP_vkEnumerateDeviceExtensionProperties:
        {
            return "OP_vkEnumerateDeviceExtensionProperties";
        }
        case OP_vkEnumerateInstanceLayerProperties:
        {
            return "OP_vkEnumerateInstanceLayerProperties";
        }
        case OP_vkEnumerateDeviceLayerProperties:
        {
            return "OP_vkEnumerateDeviceLayerProperties";
        }
        case OP_vkGetDeviceQueue:
        {
            return "OP_vkGetDeviceQueue";
        }
        case OP_vkQueueSubmit:
        {
            return "OP_vkQueueSubmit";
        }
        case OP_vkQueueWaitIdle:
        {
            return "OP_vkQueueWaitIdle";
        }
        case OP_vkDeviceWaitIdle:
        {
            return "OP_vkDeviceWaitIdle";
        }
        case OP_vkAllocateMemory:
        {
            return "OP_vkAllocateMemory";
        }
        case OP_vkFreeMemory:
        {
            return "OP_vkFreeMemory";
        }
        case OP_vkMapMemory:
        {
            return "OP_vkMapMemory";
        }
        case OP_vkUnmapMemory:
        {
            return "OP_vkUnmapMemory";
        }
        case OP_vkFlushMappedMemoryRanges:
        {
            return "OP_vkFlushMappedMemoryRanges";
        }
        case OP_vkInvalidateMappedMemoryRanges:
        {
            return "OP_vkInvalidateMappedMemoryRanges";
        }
        case OP_vkGetDeviceMemoryCommitment:
        {
            return "OP_vkGetDeviceMemoryCommitment";
        }
        case OP_vkBindBufferMemory:
        {
            return "OP_vkBindBufferMemory";
        }
        case OP_vkBindImageMemory:
        {
            return "OP_vkBindImageMemory";
        }
        case OP_vkGetBufferMemoryRequirements:
        {
            return "OP_vkGetBufferMemoryRequirements";
        }
        case OP_vkGetImageMemoryRequirements:
        {
            return "OP_vkGetImageMemoryRequirements";
        }
        case OP_vkGetImageSparseMemoryRequirements:
        {
            return "OP_vkGetImageSparseMemoryRequirements";
        }
        case OP_vkGetPhysicalDeviceSparseImageFormatProperties:
        {
            return "OP_vkGetPhysicalDeviceSparseImageFormatProperties";
        }
        case OP_vkQueueBindSparse:
        {
            return "OP_vkQueueBindSparse";
        }
        case OP_vkCreateFence:
        {
            return "OP_vkCreateFence";
        }
        case OP_vkDestroyFence:
        {
            return "OP_vkDestroyFence";
        }
        case OP_vkResetFences:
        {
            return "OP_vkResetFences";
        }
        case OP_vkGetFenceStatus:
        {
            return "OP_vkGetFenceStatus";
        }
        case OP_vkWaitForFences:
        {
            return "OP_vkWaitForFences";
        }
        case OP_vkCreateSemaphore:
        {
            return "OP_vkCreateSemaphore";
        }
        case OP_vkDestroySemaphore:
        {
            return "OP_vkDestroySemaphore";
        }
        case OP_vkCreateEvent:
        {
            return "OP_vkCreateEvent";
        }
        case OP_vkDestroyEvent:
        {
            return "OP_vkDestroyEvent";
        }
        case OP_vkGetEventStatus:
        {
            return "OP_vkGetEventStatus";
        }
        case OP_vkSetEvent:
        {
            return "OP_vkSetEvent";
        }
        case OP_vkResetEvent:
        {
            return "OP_vkResetEvent";
        }
        case OP_vkCreateQueryPool:
        {
            return "OP_vkCreateQueryPool";
        }
        case OP_vkDestroyQueryPool:
        {
            return "OP_vkDestroyQueryPool";
        }
        case OP_vkGetQueryPoolResults:
        {
            return "OP_vkGetQueryPoolResults";
        }
        case OP_vkCreateBuffer:
        {
            return "OP_vkCreateBuffer";
        }
        case OP_vkDestroyBuffer:
        {
            return "OP_vkDestroyBuffer";
        }
        case OP_vkCreateBufferView:
        {
            return "OP_vkCreateBufferView";
        }
        case OP_vkDestroyBufferView:
        {
            return "OP_vkDestroyBufferView";
        }
        case OP_vkCreateImage:
        {
            return "OP_vkCreateImage";
        }
        case OP_vkDestroyImage:
        {
            return "OP_vkDestroyImage";
        }
        case OP_vkGetImageSubresourceLayout:
        {
            return "OP_vkGetImageSubresourceLayout";
        }
        case OP_vkCreateImageView:
        {
            return "OP_vkCreateImageView";
        }
        case OP_vkDestroyImageView:
        {
            return "OP_vkDestroyImageView";
        }
        case OP_vkCreateShaderModule:
        {
            return "OP_vkCreateShaderModule";
        }
        case OP_vkDestroyShaderModule:
        {
            return "OP_vkDestroyShaderModule";
        }
        case OP_vkCreatePipelineCache:
        {
            return "OP_vkCreatePipelineCache";
        }
        case OP_vkDestroyPipelineCache:
        {
            return "OP_vkDestroyPipelineCache";
        }
        case OP_vkGetPipelineCacheData:
        {
            return "OP_vkGetPipelineCacheData";
        }
        case OP_vkMergePipelineCaches:
        {
            return "OP_vkMergePipelineCaches";
        }
        case OP_vkCreateGraphicsPipelines:
        {
            return "OP_vkCreateGraphicsPipelines";
        }
        case OP_vkCreateComputePipelines:
        {
            return "OP_vkCreateComputePipelines";
        }
        case OP_vkDestroyPipeline:
        {
            return "OP_vkDestroyPipeline";
        }
        case OP_vkCreatePipelineLayout:
        {
            return "OP_vkCreatePipelineLayout";
        }
        case OP_vkDestroyPipelineLayout:
        {
            return "OP_vkDestroyPipelineLayout";
        }
        case OP_vkCreateSampler:
        {
            return "OP_vkCreateSampler";
        }
        case OP_vkDestroySampler:
        {
            return "OP_vkDestroySampler";
        }
        case OP_vkCreateDescriptorSetLayout:
        {
            return "OP_vkCreateDescriptorSetLayout";
        }
        case OP_vkDestroyDescriptorSetLayout:
        {
            return "OP_vkDestroyDescriptorSetLayout";
        }
        case OP_vkCreateDescriptorPool:
        {
            return "OP_vkCreateDescriptorPool";
        }
        case OP_vkDestroyDescriptorPool:
        {
            return "OP_vkDestroyDescriptorPool";
        }
        case OP_vkResetDescriptorPool:
        {
            return "OP_vkResetDescriptorPool";
        }
        case OP_vkAllocateDescriptorSets:
        {
            return "OP_vkAllocateDescriptorSets";
        }
        case OP_vkFreeDescriptorSets:
        {
            return "OP_vkFreeDescriptorSets";
        }
        case OP_vkUpdateDescriptorSets:
        {
            return "OP_vkUpdateDescriptorSets";
        }
        case OP_vkCreateFramebuffer:
        {
            return "OP_vkCreateFramebuffer";
        }
        case OP_vkDestroyFramebuffer:
        {
            return "OP_vkDestroyFramebuffer";
        }
        case OP_vkCreateRenderPass:
        {
            return "OP_vkCreateRenderPass";
        }
        case OP_vkDestroyRenderPass:
        {
            return "OP_vkDestroyRenderPass";
        }
        case OP_vkGetRenderAreaGranularity:
        {
            return "OP_vkGetRenderAreaGranularity";
        }
        case OP_vkCreateCommandPool:
        {
            return "OP_vkCreateCommandPool";
        }
        case OP_vkDestroyCommandPool:
        {
            return "OP_vkDestroyCommandPool";
        }
        case OP_vkResetCommandPool:
        {
            return "OP_vkResetCommandPool";
        }
        case OP_vkAllocateCommandBuffers:
        {
            return "OP_vkAllocateCommandBuffers";
        }
        case OP_vkFreeCommandBuffers:
        {
            return "OP_vkFreeCommandBuffers";
        }
        case OP_vkBeginCommandBuffer:
        {
            return "OP_vkBeginCommandBuffer";
        }
        case OP_vkEndCommandBuffer:
        {
            return "OP_vkEndCommandBuffer";
        }
        case OP_vkResetCommandBuffer:
        {
            return "OP_vkResetCommandBuffer";
        }
        case OP_vkCmdBindPipeline:
        {
            return "OP_vkCmdBindPipeline";
        }
        case OP_vkCmdSetViewport:
        {
            return "OP_vkCmdSetViewport";
        }
        case OP_vkCmdSetScissor:
        {
            return "OP_vkCmdSetScissor";
        }
        case OP_vkCmdSetLineWidth:
        {
            return "OP_vkCmdSetLineWidth";
        }
        case OP_vkCmdSetDepthBias:
        {
            return "OP_vkCmdSetDepthBias";
        }
        case OP_vkCmdSetBlendConstants:
        {
            return "OP_vkCmdSetBlendConstants";
        }
        case OP_vkCmdSetDepthBounds:
        {
            return "OP_vkCmdSetDepthBounds";
        }
        case OP_vkCmdSetStencilCompareMask:
        {
            return "OP_vkCmdSetStencilCompareMask";
        }
        case OP_vkCmdSetStencilWriteMask:
        {
            return "OP_vkCmdSetStencilWriteMask";
        }
        case OP_vkCmdSetStencilReference:
        {
            return "OP_vkCmdSetStencilReference";
        }
        case OP_vkCmdBindDescriptorSets:
        {
            return "OP_vkCmdBindDescriptorSets";
        }
        case OP_vkCmdBindIndexBuffer:
        {
            return "OP_vkCmdBindIndexBuffer";
        }
        case OP_vkCmdBindVertexBuffers:
        {
            return "OP_vkCmdBindVertexBuffers";
        }
        case OP_vkCmdDraw:
        {
            return "OP_vkCmdDraw";
        }
        case OP_vkCmdDrawIndexed:
        {
            return "OP_vkCmdDrawIndexed";
        }
        case OP_vkCmdDrawIndirect:
        {
            return "OP_vkCmdDrawIndirect";
        }
        case OP_vkCmdDrawIndexedIndirect:
        {
            return "OP_vkCmdDrawIndexedIndirect";
        }
        case OP_vkCmdDispatch:
        {
            return "OP_vkCmdDispatch";
        }
        case OP_vkCmdDispatchIndirect:
        {
            return "OP_vkCmdDispatchIndirect";
        }
        case OP_vkCmdCopyBuffer:
        {
            return "OP_vkCmdCopyBuffer";
        }
        case OP_vkCmdCopyImage:
        {
            return "OP_vkCmdCopyImage";
        }
        case OP_vkCmdBlitImage:
        {
            return "OP_vkCmdBlitImage";
        }
        case OP_vkCmdCopyBufferToImage:
        {
            return "OP_vkCmdCopyBufferToImage";
        }
        case OP_vkCmdCopyImageToBuffer:
        {
            return "OP_vkCmdCopyImageToBuffer";
        }
        case OP_vkCmdUpdateBuffer:
        {
            return "OP_vkCmdUpdateBuffer";
        }
        case OP_vkCmdFillBuffer:
        {
            return "OP_vkCmdFillBuffer";
        }
        case OP_vkCmdClearColorImage:
        {
            return "OP_vkCmdClearColorImage";
        }
        case OP_vkCmdClearDepthStencilImage:
        {
            return "OP_vkCmdClearDepthStencilImage";
        }
        case OP_vkCmdClearAttachments:
        {
            return "OP_vkCmdClearAttachments";
        }
        case OP_vkCmdResolveImage:
        {
            return "OP_vkCmdResolveImage";
        }
        case OP_vkCmdSetEvent:
        {
            return "OP_vkCmdSetEvent";
        }
        case OP_vkCmdResetEvent:
        {
            return "OP_vkCmdResetEvent";
        }
        case OP_vkCmdWaitEvents:
        {
            return "OP_vkCmdWaitEvents";
        }
        case OP_vkCmdPipelineBarrier:
        {
            return "OP_vkCmdPipelineBarrier";
        }
        case OP_vkCmdBeginQuery:
        {
            return "OP_vkCmdBeginQuery";
        }
        case OP_vkCmdEndQuery:
        {
            return "OP_vkCmdEndQuery";
        }
        case OP_vkCmdResetQueryPool:
        {
            return "OP_vkCmdResetQueryPool";
        }
        case OP_vkCmdWriteTimestamp:
        {
            return "OP_vkCmdWriteTimestamp";
        }
        case OP_vkCmdCopyQueryPoolResults:
        {
            return "OP_vkCmdCopyQueryPoolResults";
        }
        case OP_vkCmdPushConstants:
        {
            return "OP_vkCmdPushConstants";
        }
        case OP_vkCmdBeginRenderPass:
        {
            return "OP_vkCmdBeginRenderPass";
        }
        case OP_vkCmdNextSubpass:
        {
            return "OP_vkCmdNextSubpass";
        }
        case OP_vkCmdEndRenderPass:
        {
            return "OP_vkCmdEndRenderPass";
        }
        case OP_vkCmdExecuteCommands:
        {
            return "OP_vkCmdExecuteCommands";
        }
#endif
#ifdef VK_VERSION_1_1
        case OP_vkEnumerateInstanceVersion:
        {
            return "OP_vkEnumerateInstanceVersion";
        }
        case OP_vkBindBufferMemory2:
        {
            return "OP_vkBindBufferMemory2";
        }
        case OP_vkBindImageMemory2:
        {
            return "OP_vkBindImageMemory2";
        }
        case OP_vkGetDeviceGroupPeerMemoryFeatures:
        {
            return "OP_vkGetDeviceGroupPeerMemoryFeatures";
        }
        case OP_vkCmdSetDeviceMask:
        {
            return "OP_vkCmdSetDeviceMask";
        }
        case OP_vkCmdDispatchBase:
        {
            return "OP_vkCmdDispatchBase";
        }
        case OP_vkEnumeratePhysicalDeviceGroups:
        {
            return "OP_vkEnumeratePhysicalDeviceGroups";
        }
        case OP_vkGetImageMemoryRequirements2:
        {
            return "OP_vkGetImageMemoryRequirements2";
        }
        case OP_vkGetBufferMemoryRequirements2:
        {
            return "OP_vkGetBufferMemoryRequirements2";
        }
        case OP_vkGetImageSparseMemoryRequirements2:
        {
            return "OP_vkGetImageSparseMemoryRequirements2";
        }
        case OP_vkGetPhysicalDeviceFeatures2:
        {
            return "OP_vkGetPhysicalDeviceFeatures2";
        }
        case OP_vkGetPhysicalDeviceProperties2:
        {
            return "OP_vkGetPhysicalDeviceProperties2";
        }
        case OP_vkGetPhysicalDeviceFormatProperties2:
        {
            return "OP_vkGetPhysicalDeviceFormatProperties2";
        }
        case OP_vkGetPhysicalDeviceImageFormatProperties2:
        {
            return "OP_vkGetPhysicalDeviceImageFormatProperties2";
        }
        case OP_vkGetPhysicalDeviceQueueFamilyProperties2:
        {
            return "OP_vkGetPhysicalDeviceQueueFamilyProperties2";
        }
        case OP_vkGetPhysicalDeviceMemoryProperties2:
        {
            return "OP_vkGetPhysicalDeviceMemoryProperties2";
        }
        case OP_vkGetPhysicalDeviceSparseImageFormatProperties2:
        {
            return "OP_vkGetPhysicalDeviceSparseImageFormatProperties2";
        }
        case OP_vkTrimCommandPool:
        {
            return "OP_vkTrimCommandPool";
        }
        case OP_vkGetDeviceQueue2:
        {
            return "OP_vkGetDeviceQueue2";
        }
        case OP_vkCreateSamplerYcbcrConversion:
        {
            return "OP_vkCreateSamplerYcbcrConversion";
        }
        case OP_vkDestroySamplerYcbcrConversion:
        {
            return "OP_vkDestroySamplerYcbcrConversion";
        }
        case OP_vkCreateDescriptorUpdateTemplate:
        {
            return "OP_vkCreateDescriptorUpdateTemplate";
        }
        case OP_vkDestroyDescriptorUpdateTemplate:
        {
            return "OP_vkDestroyDescriptorUpdateTemplate";
        }
        case OP_vkUpdateDescriptorSetWithTemplate:
        {
            return "OP_vkUpdateDescriptorSetWithTemplate";
        }
        case OP_vkGetPhysicalDeviceExternalBufferProperties:
        {
            return "OP_vkGetPhysicalDeviceExternalBufferProperties";
        }
        case OP_vkGetPhysicalDeviceExternalFenceProperties:
        {
            return "OP_vkGetPhysicalDeviceExternalFenceProperties";
        }
        case OP_vkGetPhysicalDeviceExternalSemaphoreProperties:
        {
            return "OP_vkGetPhysicalDeviceExternalSemaphoreProperties";
        }
        case OP_vkGetDescriptorSetLayoutSupport:
        {
            return "OP_vkGetDescriptorSetLayoutSupport";
        }
#endif
#ifdef VK_KHR_surface
        case OP_vkDestroySurfaceKHR:
        {
            return "OP_vkDestroySurfaceKHR";
        }
        case OP_vkGetPhysicalDeviceSurfaceSupportKHR:
        {
            return "OP_vkGetPhysicalDeviceSurfaceSupportKHR";
        }
        case OP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR:
        {
            return "OP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR";
        }
        case OP_vkGetPhysicalDeviceSurfaceFormatsKHR:
        {
            return "OP_vkGetPhysicalDeviceSurfaceFormatsKHR";
        }
        case OP_vkGetPhysicalDeviceSurfacePresentModesKHR:
        {
            return "OP_vkGetPhysicalDeviceSurfacePresentModesKHR";
        }
#endif
#ifdef VK_KHR_swapchain
        case OP_vkCreateSwapchainKHR:
        {
            return "OP_vkCreateSwapchainKHR";
        }
        case OP_vkDestroySwapchainKHR:
        {
            return "OP_vkDestroySwapchainKHR";
        }
        case OP_vkGetSwapchainImagesKHR:
        {
            return "OP_vkGetSwapchainImagesKHR";
        }
        case OP_vkAcquireNextImageKHR:
        {
            return "OP_vkAcquireNextImageKHR";
        }
        case OP_vkQueuePresentKHR:
        {
            return "OP_vkQueuePresentKHR";
        }
        case OP_vkGetDeviceGroupPresentCapabilitiesKHR:
        {
            return "OP_vkGetDeviceGroupPresentCapabilitiesKHR";
        }
        case OP_vkGetDeviceGroupSurfacePresentModesKHR:
        {
            return "OP_vkGetDeviceGroupSurfacePresentModesKHR";
        }
        case OP_vkGetPhysicalDevicePresentRectanglesKHR:
        {
            return "OP_vkGetPhysicalDevicePresentRectanglesKHR";
        }
        case OP_vkAcquireNextImage2KHR:
        {
            return "OP_vkAcquireNextImage2KHR";
        }
#endif
#ifdef VK_KHR_display
        case OP_vkGetPhysicalDeviceDisplayPropertiesKHR:
        {
            return "OP_vkGetPhysicalDeviceDisplayPropertiesKHR";
        }
        case OP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR:
        {
            return "OP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR";
        }
        case OP_vkGetDisplayPlaneSupportedDisplaysKHR:
        {
            return "OP_vkGetDisplayPlaneSupportedDisplaysKHR";
        }
        case OP_vkGetDisplayModePropertiesKHR:
        {
            return "OP_vkGetDisplayModePropertiesKHR";
        }
        case OP_vkCreateDisplayModeKHR:
        {
            return "OP_vkCreateDisplayModeKHR";
        }
        case OP_vkGetDisplayPlaneCapabilitiesKHR:
        {
            return "OP_vkGetDisplayPlaneCapabilitiesKHR";
        }
        case OP_vkCreateDisplayPlaneSurfaceKHR:
        {
            return "OP_vkCreateDisplayPlaneSurfaceKHR";
        }
#endif
#ifdef VK_KHR_display_swapchain
        case OP_vkCreateSharedSwapchainsKHR:
        {
            return "OP_vkCreateSharedSwapchainsKHR";
        }
#endif
#ifdef VK_KHR_xlib_surface
        case OP_vkCreateXlibSurfaceKHR:
        {
            return "OP_vkCreateXlibSurfaceKHR";
        }
        case OP_vkGetPhysicalDeviceXlibPresentationSupportKHR:
        {
            return "OP_vkGetPhysicalDeviceXlibPresentationSupportKHR";
        }
#endif
#ifdef VK_KHR_xcb_surface
        case OP_vkCreateXcbSurfaceKHR:
        {
            return "OP_vkCreateXcbSurfaceKHR";
        }
        case OP_vkGetPhysicalDeviceXcbPresentationSupportKHR:
        {
            return "OP_vkGetPhysicalDeviceXcbPresentationSupportKHR";
        }
#endif
#ifdef VK_KHR_wayland_surface
        case OP_vkCreateWaylandSurfaceKHR:
        {
            return "OP_vkCreateWaylandSurfaceKHR";
        }
        case OP_vkGetPhysicalDeviceWaylandPresentationSupportKHR:
        {
            return "OP_vkGetPhysicalDeviceWaylandPresentationSupportKHR";
        }
#endif
#ifdef VK_KHR_android_surface
        case OP_vkCreateAndroidSurfaceKHR:
        {
            return "OP_vkCreateAndroidSurfaceKHR";
        }
#endif
#ifdef VK_KHR_win32_surface
        case OP_vkCreateWin32SurfaceKHR:
        {
            return "OP_vkCreateWin32SurfaceKHR";
        }
        case OP_vkGetPhysicalDeviceWin32PresentationSupportKHR:
        {
            return "OP_vkGetPhysicalDeviceWin32PresentationSupportKHR";
        }
#endif
#ifdef VK_KHR_get_physical_device_properties2
        case OP_vkGetPhysicalDeviceFeatures2KHR:
        {
            return "OP_vkGetPhysicalDeviceFeatures2KHR";
        }
        case OP_vkGetPhysicalDeviceProperties2KHR:
        {
            return "OP_vkGetPhysicalDeviceProperties2KHR";
        }
        case OP_vkGetPhysicalDeviceFormatProperties2KHR:
        {
            return "OP_vkGetPhysicalDeviceFormatProperties2KHR";
        }
        case OP_vkGetPhysicalDeviceImageFormatProperties2KHR:
        {
            return "OP_vkGetPhysicalDeviceImageFormatProperties2KHR";
        }
        case OP_vkGetPhysicalDeviceQueueFamilyProperties2KHR:
        {
            return "OP_vkGetPhysicalDeviceQueueFamilyProperties2KHR";
        }
        case OP_vkGetPhysicalDeviceMemoryProperties2KHR:
        {
            return "OP_vkGetPhysicalDeviceMemoryProperties2KHR";
        }
        case OP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR:
        {
            return "OP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR";
        }
#endif
#ifdef VK_KHR_device_group
        case OP_vkGetDeviceGroupPeerMemoryFeaturesKHR:
        {
            return "OP_vkGetDeviceGroupPeerMemoryFeaturesKHR";
        }
        case OP_vkCmdSetDeviceMaskKHR:
        {
            return "OP_vkCmdSetDeviceMaskKHR";
        }
        case OP_vkCmdDispatchBaseKHR:
        {
            return "OP_vkCmdDispatchBaseKHR";
        }
#endif
#ifdef VK_KHR_maintenance1
        case OP_vkTrimCommandPoolKHR:
        {
            return "OP_vkTrimCommandPoolKHR";
        }
#endif
#ifdef VK_KHR_device_group_creation
        case OP_vkEnumeratePhysicalDeviceGroupsKHR:
        {
            return "OP_vkEnumeratePhysicalDeviceGroupsKHR";
        }
#endif
#ifdef VK_KHR_external_memory_capabilities
        case OP_vkGetPhysicalDeviceExternalBufferPropertiesKHR:
        {
            return "OP_vkGetPhysicalDeviceExternalBufferPropertiesKHR";
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case OP_vkGetMemoryWin32HandleKHR:
        {
            return "OP_vkGetMemoryWin32HandleKHR";
        }
        case OP_vkGetMemoryWin32HandlePropertiesKHR:
        {
            return "OP_vkGetMemoryWin32HandlePropertiesKHR";
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case OP_vkGetMemoryFdKHR:
        {
            return "OP_vkGetMemoryFdKHR";
        }
        case OP_vkGetMemoryFdPropertiesKHR:
        {
            return "OP_vkGetMemoryFdPropertiesKHR";
        }
#endif
#ifdef VK_KHR_external_semaphore_capabilities
        case OP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR:
        {
            return "OP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR";
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case OP_vkImportSemaphoreWin32HandleKHR:
        {
            return "OP_vkImportSemaphoreWin32HandleKHR";
        }
        case OP_vkGetSemaphoreWin32HandleKHR:
        {
            return "OP_vkGetSemaphoreWin32HandleKHR";
        }
#endif
#ifdef VK_KHR_external_semaphore_fd
        case OP_vkImportSemaphoreFdKHR:
        {
            return "OP_vkImportSemaphoreFdKHR";
        }
        case OP_vkGetSemaphoreFdKHR:
        {
            return "OP_vkGetSemaphoreFdKHR";
        }
#endif
#ifdef VK_KHR_push_descriptor
        case OP_vkCmdPushDescriptorSetKHR:
        {
            return "OP_vkCmdPushDescriptorSetKHR";
        }
        case OP_vkCmdPushDescriptorSetWithTemplateKHR:
        {
            return "OP_vkCmdPushDescriptorSetWithTemplateKHR";
        }
#endif
#ifdef VK_KHR_descriptor_update_template
        case OP_vkCreateDescriptorUpdateTemplateKHR:
        {
            return "OP_vkCreateDescriptorUpdateTemplateKHR";
        }
        case OP_vkDestroyDescriptorUpdateTemplateKHR:
        {
            return "OP_vkDestroyDescriptorUpdateTemplateKHR";
        }
        case OP_vkUpdateDescriptorSetWithTemplateKHR:
        {
            return "OP_vkUpdateDescriptorSetWithTemplateKHR";
        }
#endif
#ifdef VK_KHR_create_renderpass2
        case OP_vkCreateRenderPass2KHR:
        {
            return "OP_vkCreateRenderPass2KHR";
        }
        case OP_vkCmdBeginRenderPass2KHR:
        {
            return "OP_vkCmdBeginRenderPass2KHR";
        }
        case OP_vkCmdNextSubpass2KHR:
        {
            return "OP_vkCmdNextSubpass2KHR";
        }
        case OP_vkCmdEndRenderPass2KHR:
        {
            return "OP_vkCmdEndRenderPass2KHR";
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case OP_vkGetSwapchainStatusKHR:
        {
            return "OP_vkGetSwapchainStatusKHR";
        }
#endif
#ifdef VK_KHR_external_fence_capabilities
        case OP_vkGetPhysicalDeviceExternalFencePropertiesKHR:
        {
            return "OP_vkGetPhysicalDeviceExternalFencePropertiesKHR";
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case OP_vkImportFenceWin32HandleKHR:
        {
            return "OP_vkImportFenceWin32HandleKHR";
        }
        case OP_vkGetFenceWin32HandleKHR:
        {
            return "OP_vkGetFenceWin32HandleKHR";
        }
#endif
#ifdef VK_KHR_external_fence_fd
        case OP_vkImportFenceFdKHR:
        {
            return "OP_vkImportFenceFdKHR";
        }
        case OP_vkGetFenceFdKHR:
        {
            return "OP_vkGetFenceFdKHR";
        }
#endif
#ifdef VK_KHR_get_surface_capabilities2
        case OP_vkGetPhysicalDeviceSurfaceCapabilities2KHR:
        {
            return "OP_vkGetPhysicalDeviceSurfaceCapabilities2KHR";
        }
        case OP_vkGetPhysicalDeviceSurfaceFormats2KHR:
        {
            return "OP_vkGetPhysicalDeviceSurfaceFormats2KHR";
        }
#endif
#ifdef VK_KHR_get_display_properties2
        case OP_vkGetPhysicalDeviceDisplayProperties2KHR:
        {
            return "OP_vkGetPhysicalDeviceDisplayProperties2KHR";
        }
        case OP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR:
        {
            return "OP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR";
        }
        case OP_vkGetDisplayModeProperties2KHR:
        {
            return "OP_vkGetDisplayModeProperties2KHR";
        }
        case OP_vkGetDisplayPlaneCapabilities2KHR:
        {
            return "OP_vkGetDisplayPlaneCapabilities2KHR";
        }
#endif
#ifdef VK_KHR_get_memory_requirements2
        case OP_vkGetImageMemoryRequirements2KHR:
        {
            return "OP_vkGetImageMemoryRequirements2KHR";
        }
        case OP_vkGetBufferMemoryRequirements2KHR:
        {
            return "OP_vkGetBufferMemoryRequirements2KHR";
        }
        case OP_vkGetImageSparseMemoryRequirements2KHR:
        {
            return "OP_vkGetImageSparseMemoryRequirements2KHR";
        }
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
        case OP_vkCreateSamplerYcbcrConversionKHR:
        {
            return "OP_vkCreateSamplerYcbcrConversionKHR";
        }
        case OP_vkDestroySamplerYcbcrConversionKHR:
        {
            return "OP_vkDestroySamplerYcbcrConversionKHR";
        }
#endif
#ifdef VK_KHR_bind_memory2
        case OP_vkBindBufferMemory2KHR:
        {
            return "OP_vkBindBufferMemory2KHR";
        }
        case OP_vkBindImageMemory2KHR:
        {
            return "OP_vkBindImageMemory2KHR";
        }
#endif
#ifdef VK_KHR_maintenance3
        case OP_vkGetDescriptorSetLayoutSupportKHR:
        {
            return "OP_vkGetDescriptorSetLayoutSupportKHR";
        }
#endif
#ifdef VK_KHR_draw_indirect_count
        case OP_vkCmdDrawIndirectCountKHR:
        {
            return "OP_vkCmdDrawIndirectCountKHR";
        }
        case OP_vkCmdDrawIndexedIndirectCountKHR:
        {
            return "OP_vkCmdDrawIndexedIndirectCountKHR";
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case OP_vkGetSwapchainGrallocUsageANDROID:
        {
            return "OP_vkGetSwapchainGrallocUsageANDROID";
        }
        case OP_vkAcquireImageANDROID:
        {
            return "OP_vkAcquireImageANDROID";
        }
        case OP_vkQueueSignalReleaseImageANDROID:
        {
            return "OP_vkQueueSignalReleaseImageANDROID";
        }
#endif
#ifdef VK_EXT_debug_report
        case OP_vkCreateDebugReportCallbackEXT:
        {
            return "OP_vkCreateDebugReportCallbackEXT";
        }
        case OP_vkDestroyDebugReportCallbackEXT:
        {
            return "OP_vkDestroyDebugReportCallbackEXT";
        }
        case OP_vkDebugReportMessageEXT:
        {
            return "OP_vkDebugReportMessageEXT";
        }
#endif
#ifdef VK_EXT_debug_marker
        case OP_vkDebugMarkerSetObjectTagEXT:
        {
            return "OP_vkDebugMarkerSetObjectTagEXT";
        }
        case OP_vkDebugMarkerSetObjectNameEXT:
        {
            return "OP_vkDebugMarkerSetObjectNameEXT";
        }
        case OP_vkCmdDebugMarkerBeginEXT:
        {
            return "OP_vkCmdDebugMarkerBeginEXT";
        }
        case OP_vkCmdDebugMarkerEndEXT:
        {
            return "OP_vkCmdDebugMarkerEndEXT";
        }
        case OP_vkCmdDebugMarkerInsertEXT:
        {
            return "OP_vkCmdDebugMarkerInsertEXT";
        }
#endif
#ifdef VK_AMD_draw_indirect_count
        case OP_vkCmdDrawIndirectCountAMD:
        {
            return "OP_vkCmdDrawIndirectCountAMD";
        }
        case OP_vkCmdDrawIndexedIndirectCountAMD:
        {
            return "OP_vkCmdDrawIndexedIndirectCountAMD";
        }
#endif
#ifdef VK_AMD_shader_info
        case OP_vkGetShaderInfoAMD:
        {
            return "OP_vkGetShaderInfoAMD";
        }
#endif
#ifdef VK_NV_external_memory_capabilities
        case OP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV:
        {
            return "OP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV";
        }
#endif
#ifdef VK_NV_external_memory_win32
        case OP_vkGetMemoryWin32HandleNV:
        {
            return "OP_vkGetMemoryWin32HandleNV";
        }
#endif
#ifdef VK_NN_vi_surface
        case OP_vkCreateViSurfaceNN:
        {
            return "OP_vkCreateViSurfaceNN";
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case OP_vkCmdBeginConditionalRenderingEXT:
        {
            return "OP_vkCmdBeginConditionalRenderingEXT";
        }
        case OP_vkCmdEndConditionalRenderingEXT:
        {
            return "OP_vkCmdEndConditionalRenderingEXT";
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case OP_vkCmdSetViewportWScalingNV:
        {
            return "OP_vkCmdSetViewportWScalingNV";
        }
#endif
#ifdef VK_EXT_direct_mode_display
        case OP_vkReleaseDisplayEXT:
        {
            return "OP_vkReleaseDisplayEXT";
        }
#endif
#ifdef VK_EXT_acquire_xlib_display
        case OP_vkAcquireXlibDisplayEXT:
        {
            return "OP_vkAcquireXlibDisplayEXT";
        }
        case OP_vkGetRandROutputDisplayEXT:
        {
            return "OP_vkGetRandROutputDisplayEXT";
        }
#endif
#ifdef VK_EXT_display_surface_counter
        case OP_vkGetPhysicalDeviceSurfaceCapabilities2EXT:
        {
            return "OP_vkGetPhysicalDeviceSurfaceCapabilities2EXT";
        }
#endif
#ifdef VK_EXT_display_control
        case OP_vkDisplayPowerControlEXT:
        {
            return "OP_vkDisplayPowerControlEXT";
        }
        case OP_vkRegisterDeviceEventEXT:
        {
            return "OP_vkRegisterDeviceEventEXT";
        }
        case OP_vkRegisterDisplayEventEXT:
        {
            return "OP_vkRegisterDisplayEventEXT";
        }
        case OP_vkGetSwapchainCounterEXT:
        {
            return "OP_vkGetSwapchainCounterEXT";
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case OP_vkGetRefreshCycleDurationGOOGLE:
        {
            return "OP_vkGetRefreshCycleDurationGOOGLE";
        }
        case OP_vkGetPastPresentationTimingGOOGLE:
        {
            return "OP_vkGetPastPresentationTimingGOOGLE";
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case OP_vkCmdSetDiscardRectangleEXT:
        {
            return "OP_vkCmdSetDiscardRectangleEXT";
        }
#endif
#ifdef VK_EXT_hdr_metadata
        case OP_vkSetHdrMetadataEXT:
        {
            return "OP_vkSetHdrMetadataEXT";
        }
#endif
#ifdef VK_MVK_ios_surface
        case OP_vkCreateIOSSurfaceMVK:
        {
            return "OP_vkCreateIOSSurfaceMVK";
        }
#endif
#ifdef VK_MVK_macos_surface
        case OP_vkCreateMacOSSurfaceMVK:
        {
            return "OP_vkCreateMacOSSurfaceMVK";
        }
#endif
#ifdef VK_EXT_debug_utils
        case OP_vkSetDebugUtilsObjectNameEXT:
        {
            return "OP_vkSetDebugUtilsObjectNameEXT";
        }
        case OP_vkSetDebugUtilsObjectTagEXT:
        {
            return "OP_vkSetDebugUtilsObjectTagEXT";
        }
        case OP_vkQueueBeginDebugUtilsLabelEXT:
        {
            return "OP_vkQueueBeginDebugUtilsLabelEXT";
        }
        case OP_vkQueueEndDebugUtilsLabelEXT:
        {
            return "OP_vkQueueEndDebugUtilsLabelEXT";
        }
        case OP_vkQueueInsertDebugUtilsLabelEXT:
        {
            return "OP_vkQueueInsertDebugUtilsLabelEXT";
        }
        case OP_vkCmdBeginDebugUtilsLabelEXT:
        {
            return "OP_vkCmdBeginDebugUtilsLabelEXT";
        }
        case OP_vkCmdEndDebugUtilsLabelEXT:
        {
            return "OP_vkCmdEndDebugUtilsLabelEXT";
        }
        case OP_vkCmdInsertDebugUtilsLabelEXT:
        {
            return "OP_vkCmdInsertDebugUtilsLabelEXT";
        }
        case OP_vkCreateDebugUtilsMessengerEXT:
        {
            return "OP_vkCreateDebugUtilsMessengerEXT";
        }
        case OP_vkDestroyDebugUtilsMessengerEXT:
        {
            return "OP_vkDestroyDebugUtilsMessengerEXT";
        }
        case OP_vkSubmitDebugUtilsMessageEXT:
        {
            return "OP_vkSubmitDebugUtilsMessageEXT";
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case OP_vkGetAndroidHardwareBufferPropertiesANDROID:
        {
            return "OP_vkGetAndroidHardwareBufferPropertiesANDROID";
        }
        case OP_vkGetMemoryAndroidHardwareBufferANDROID:
        {
            return "OP_vkGetMemoryAndroidHardwareBufferANDROID";
        }
#endif
#ifdef VK_EXT_sample_locations
        case OP_vkCmdSetSampleLocationsEXT:
        {
            return "OP_vkCmdSetSampleLocationsEXT";
        }
        case OP_vkGetPhysicalDeviceMultisamplePropertiesEXT:
        {
            return "OP_vkGetPhysicalDeviceMultisamplePropertiesEXT";
        }
#endif
#ifdef VK_EXT_validation_cache
        case OP_vkCreateValidationCacheEXT:
        {
            return "OP_vkCreateValidationCacheEXT";
        }
        case OP_vkDestroyValidationCacheEXT:
        {
            return "OP_vkDestroyValidationCacheEXT";
        }
        case OP_vkMergeValidationCachesEXT:
        {
            return "OP_vkMergeValidationCachesEXT";
        }
        case OP_vkGetValidationCacheDataEXT:
        {
            return "OP_vkGetValidationCacheDataEXT";
        }
#endif
#ifdef VK_EXT_external_memory_host
        case OP_vkGetMemoryHostPointerPropertiesEXT:
        {
            return "OP_vkGetMemoryHostPointerPropertiesEXT";
        }
#endif
#ifdef VK_AMD_buffer_marker
        case OP_vkCmdWriteBufferMarkerAMD:
        {
            return "OP_vkCmdWriteBufferMarkerAMD";
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case OP_vkCmdSetCheckpointNV:
        {
            return "OP_vkCmdSetCheckpointNV";
        }
        case OP_vkGetQueueCheckpointDataNV:
        {
            return "OP_vkGetQueueCheckpointDataNV";
        }
#endif
#ifdef VK_GOOGLE_address_space
        case OP_vkMapMemoryIntoAddressSpaceGOOGLE:
        {
            return "OP_vkMapMemoryIntoAddressSpaceGOOGLE";
        }
#endif
#ifdef VK_GOOGLE_color_buffer
        case OP_vkRegisterImageColorBufferGOOGLE:
        {
            return "OP_vkRegisterImageColorBufferGOOGLE";
        }
        case OP_vkRegisterBufferColorBufferGOOGLE:
        {
            return "OP_vkRegisterBufferColorBufferGOOGLE";
        }
#endif
#ifdef VK_GOOGLE_sized_descriptor_update_template
        case OP_vkUpdateDescriptorSetWithTemplateSizedGOOGLE:
        {
            return "OP_vkUpdateDescriptorSetWithTemplateSizedGOOGLE";
        }
#endif
#ifdef VK_GOOGLE_async_command_buffers
        case OP_vkBeginCommandBufferAsyncGOOGLE:
        {
            return "OP_vkBeginCommandBufferAsyncGOOGLE";
        }
        case OP_vkEndCommandBufferAsyncGOOGLE:
        {
            return "OP_vkEndCommandBufferAsyncGOOGLE";
        }
        case OP_vkResetCommandBufferAsyncGOOGLE:
        {
            return "OP_vkResetCommandBufferAsyncGOOGLE";
        }
        case OP_vkCommandBufferHostSyncGOOGLE:
        {
            return "OP_vkCommandBufferHostSyncGOOGLE";
        }
#endif
#ifdef VK_GOOGLE_create_resources_with_requirements
        case OP_vkCreateImageWithRequirementsGOOGLE:
        {
            return "OP_vkCreateImageWithRequirementsGOOGLE";
        }
        case OP_vkCreateBufferWithRequirementsGOOGLE:
        {
            return "OP_vkCreateBufferWithRequirementsGOOGLE";
        }
#endif
#ifdef VK_GOOGLE_address_space_info
        case OP_vkGetMemoryHostAddressInfoGOOGLE:
        {
            return "OP_vkGetMemoryHostAddressInfoGOOGLE";
        }
#endif
#ifdef VK_GOOGLE_free_memory_sync
        case OP_vkFreeMemorySyncGOOGLE:
        {
            return "OP_vkFreeMemorySyncGOOGLE";
        }
#endif
#ifdef VK_GOOGLE_async_queue_submit
        case OP_vkQueueHostSyncGOOGLE:
        {
            return "OP_vkQueueHostSyncGOOGLE";
        }
        case OP_vkQueueSubmitAsyncGOOGLE:
        {
            return "OP_vkQueueSubmitAsyncGOOGLE";
        }
        case OP_vkQueueWaitIdleAsyncGOOGLE:
        {
            return "OP_vkQueueWaitIdleAsyncGOOGLE";
        }
        case OP_vkQueueBindSparseAsyncGOOGLE:
        {
            return "OP_vkQueueBindSparseAsyncGOOGLE";
        }
#endif
#ifdef VK_GOOGLE_linear_image_layout
        case OP_vkGetLinearImageLayoutGOOGLE:
        {
            return "OP_vkGetLinearImageLayoutGOOGLE";
        }
#endif
#ifdef VK_MVK_moltenvk
        case OP_vkGetMTLDeviceMVK:
        {
            return "OP_vkGetMTLDeviceMVK";
        }
        case OP_vkSetMTLTextureMVK:
        {
            return "OP_vkSetMTLTextureMVK";
        }
        case OP_vkGetMTLTextureMVK:
        {
            return "OP_vkGetMTLTextureMVK";
        }
        case OP_vkGetMTLBufferMVK:
        {
            return "OP_vkGetMTLBufferMVK";
        }
        case OP_vkUseIOSurfaceMVK:
        {
            return "OP_vkUseIOSurfaceMVK";
        }
        case OP_vkGetIOSurfaceMVK:
        {
            return "OP_vkGetIOSurfaceMVK";
        }
#endif
#ifdef VK_GOOGLE_queue_submit_with_commands
        case OP_vkQueueFlushCommandsGOOGLE:
        {
            return "OP_vkQueueFlushCommandsGOOGLE";
        }
#endif
#ifdef VK_EXT_full_screen_exclusive
        case OP_vkAcquireFullScreenExclusiveModeEXT:
        {
            return "OP_vkAcquireFullScreenExclusiveModeEXT";
        }
#endif
#ifdef VK_NV_ray_tracing
        case OP_vkBindAccelerationStructureMemoryNV:
        {
            return "OP_vkBindAccelerationStructureMemoryNV";
        }
#endif
#ifdef VK_INTEL_performance_query
        case OP_vkInitializePerformanceApiINTEL:
        {
            return "OP_vkInitializePerformanceApiINTEL";
        }
#endif
#ifdef VK_KHR_deferred_host_operations
        case OP_vkGetDeferredOperationMaxConcurrencyKHR:
        {
            return "OP_vkGetDeferredOperationMaxConcurrencyKHR";
        }
#endif
#ifdef VK_EXT_calibrated_timestamps
        case OP_vkGetCalibratedTimestampsEXT:
        {
            return "OP_vkGetCalibratedTimestampsEXT";
        }
#endif
#ifdef VK_NV_ray_tracing
        case OP_vkCreateRayTracingPipelinesNV:
        {
            return "OP_vkCreateRayTracingPipelinesNV";
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case OP_vkCmdCopyMemoryToAccelerationStructureKHR:
        {
            return "OP_vkCmdCopyMemoryToAccelerationStructureKHR";
        }
#endif
#ifdef VK_KHR_fragment_shading_rate
        case OP_vkCmdSetFragmentShadingRateKHR:
        {
            return "OP_vkCmdSetFragmentShadingRateKHR";
        }
#endif
#ifdef VK_NVX_image_view_handle
        case OP_vkGetImageViewHandleNVX:
        {
            return "OP_vkGetImageViewHandleNVX";
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case OP_vkCmdSetScissorWithCountEXT:
        {
            return "OP_vkCmdSetScissorWithCountEXT";
        }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
        case OP_vkGetRayTracingShaderGroupStackSizeKHR:
        {
            return "OP_vkGetRayTracingShaderGroupStackSizeKHR";
        }
#endif
#ifdef VK_EXT_full_screen_exclusive
        case OP_vkGetDeviceGroupSurfacePresentModes2EXT:
        {
            return "OP_vkGetDeviceGroupSurfacePresentModes2EXT";
        }
#endif
#ifdef VK_NV_mesh_shader
        case OP_vkCmdDrawMeshTasksNV:
        {
            return "OP_vkCmdDrawMeshTasksNV";
        }
#endif
#ifdef VK_NV_ray_tracing
        case OP_vkCmdWriteAccelerationStructuresPropertiesNV:
        {
            return "OP_vkCmdWriteAccelerationStructuresPropertiesNV";
        }
#endif
#ifdef VK_EXT_private_data
        case OP_vkDestroyPrivateDataSlotEXT:
        {
            return "OP_vkDestroyPrivateDataSlotEXT";
        }
#endif
#ifdef VK_NV_ray_tracing
        case OP_vkCmdTraceRaysNV:
        {
            return "OP_vkCmdTraceRaysNV";
        }
#endif
#ifdef VK_NVX_image_view_handle
        case OP_vkGetImageViewAddressNVX:
        {
            return "OP_vkGetImageViewAddressNVX";
        }
#endif
#ifdef VK_NV_ray_tracing
        case OP_vkCmdCopyAccelerationStructureNV:
        {
            return "OP_vkCmdCopyAccelerationStructureNV";
        }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
        case OP_vkCmdTraceRaysIndirectKHR:
        {
            return "OP_vkCmdTraceRaysIndirectKHR";
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case OP_vkCmdSetFrontFaceEXT:
        {
            return "OP_vkCmdSetFrontFaceEXT";
        }
#endif
#ifdef VK_INTEL_performance_query
        case OP_vkGetPerformanceParameterINTEL:
        {
            return "OP_vkGetPerformanceParameterINTEL";
        }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
        case OP_vkCmdTraceRaysKHR:
        {
            return "OP_vkCmdTraceRaysKHR";
        }
#endif
#ifdef VK_NV_shading_rate_image
        case OP_vkCmdSetViewportShadingRatePaletteNV:
        {
            return "OP_vkCmdSetViewportShadingRatePaletteNV";
        }
#endif
#ifdef VK_KHR_deferred_host_operations
        case OP_vkDestroyDeferredOperationKHR:
        {
            return "OP_vkDestroyDeferredOperationKHR";
        }
        case OP_vkDeferredOperationJoinKHR:
        {
            return "OP_vkDeferredOperationJoinKHR";
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case OP_vkCmdSetDepthWriteEnableEXT:
        {
            return "OP_vkCmdSetDepthWriteEnableEXT";
        }
#endif
#ifdef VK_KHR_buffer_device_address
        case OP_vkGetBufferDeviceAddressKHR:
        {
            return "OP_vkGetBufferDeviceAddressKHR";
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case OP_vkGetAccelerationStructureBuildSizesKHR:
        {
            return "OP_vkGetAccelerationStructureBuildSizesKHR";
        }
#endif
#ifdef VK_NV_ray_tracing
        case OP_vkGetAccelerationStructureMemoryRequirementsNV:
        {
            return "OP_vkGetAccelerationStructureMemoryRequirementsNV";
        }
#endif
#ifdef VK_EXT_directfb_surface
        case OP_vkCreateDirectFBSurfaceEXT:
        {
            return "OP_vkCreateDirectFBSurfaceEXT";
        }
#endif
#ifdef VK_VERSION_1_2
        case OP_vkCmdEndRenderPass2:
        {
            return "OP_vkCmdEndRenderPass2";
        }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
        case OP_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR:
        {
            return "OP_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR";
        }
#endif
#ifdef VK_VERSION_1_2
        case OP_vkGetBufferDeviceAddress:
        {
            return "OP_vkGetBufferDeviceAddress";
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case OP_vkCmdSetDepthBoundsTestEnableEXT:
        {
            return "OP_vkCmdSetDepthBoundsTestEnableEXT";
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case OP_vkGetAccelerationStructureDeviceAddressKHR:
        {
            return "OP_vkGetAccelerationStructureDeviceAddressKHR";
        }
        case OP_vkCmdCopyAccelerationStructureToMemoryKHR:
        {
            return "OP_vkCmdCopyAccelerationStructureToMemoryKHR";
        }
#endif
#ifdef VK_NV_mesh_shader
        case OP_vkCmdDrawMeshTasksIndirectCountNV:
        {
            return "OP_vkCmdDrawMeshTasksIndirectCountNV";
        }
#endif
#ifdef VK_KHR_performance_query
        case OP_vkReleaseProfilingLockKHR:
        {
            return "OP_vkReleaseProfilingLockKHR";
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case OP_vkDestroyAccelerationStructureKHR:
        {
            return "OP_vkDestroyAccelerationStructureKHR";
        }
#endif
#ifdef VK_EXT_buffer_device_address
        case OP_vkGetBufferDeviceAddressEXT:
        {
            return "OP_vkGetBufferDeviceAddressEXT";
        }
#endif
#ifdef VK_VERSION_1_2
        case OP_vkWaitSemaphores:
        {
            return "OP_vkWaitSemaphores";
        }
#endif
#ifdef VK_EXT_private_data
        case OP_vkSetPrivateDataEXT:
        {
            return "OP_vkSetPrivateDataEXT";
        }
#endif
#ifdef VK_NV_scissor_exclusive
        case OP_vkCmdSetExclusiveScissorNV:
        {
            return "OP_vkCmdSetExclusiveScissorNV";
        }
#endif
#ifdef VK_KHR_copy_commands2
        case OP_vkCmdCopyImage2KHR:
        {
            return "OP_vkCmdCopyImage2KHR";
        }
#endif
#ifdef VK_KHR_timeline_semaphore
        case OP_vkGetSemaphoreCounterValueKHR:
        {
            return "OP_vkGetSemaphoreCounterValueKHR";
        }
#endif
#ifdef VK_NV_ray_tracing
        case OP_vkGetRayTracingShaderGroupHandlesNV:
        {
            return "OP_vkGetRayTracingShaderGroupHandlesNV";
        }
#endif
#ifdef VK_VERSION_1_2
        case OP_vkGetBufferOpaqueCaptureAddress:
        {
            return "OP_vkGetBufferOpaqueCaptureAddress";
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case OP_vkCmdSetDepthTestEnableEXT:
        {
            return "OP_vkCmdSetDepthTestEnableEXT";
        }
#endif
#ifdef VK_NV_device_generated_commands
        case OP_vkCmdExecuteGeneratedCommandsNV:
        {
            return "OP_vkCmdExecuteGeneratedCommandsNV";
        }
#endif
#ifdef VK_VERSION_1_2
        case OP_vkCmdBeginRenderPass2:
        {
            return "OP_vkCmdBeginRenderPass2";
        }
#endif
#ifdef VK_EXT_private_data
        case OP_vkCreatePrivateDataSlotEXT:
        {
            return "OP_vkCreatePrivateDataSlotEXT";
        }
#endif
#ifdef VK_NV_shading_rate_image
        case OP_vkCmdSetCoarseSampleOrderNV:
        {
            return "OP_vkCmdSetCoarseSampleOrderNV";
        }
        case OP_vkCmdBindShadingRateImageNV:
        {
            return "OP_vkCmdBindShadingRateImageNV";
        }
#endif
#ifdef VK_KHR_performance_query
        case OP_vkAcquireProfilingLockKHR:
        {
            return "OP_vkAcquireProfilingLockKHR";
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case OP_vkCopyAccelerationStructureKHR:
        {
            return "OP_vkCopyAccelerationStructureKHR";
        }
#endif
#ifdef VK_GGP_stream_descriptor_surface
        case OP_vkCreateStreamDescriptorSurfaceGGP:
        {
            return "OP_vkCreateStreamDescriptorSurfaceGGP";
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case OP_vkBuildAccelerationStructuresKHR:
        {
            return "OP_vkBuildAccelerationStructuresKHR";
        }
#endif
#ifdef VK_EXT_host_query_reset
        case OP_vkResetQueryPoolEXT:
        {
            return "OP_vkResetQueryPoolEXT";
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case OP_vkCmdBindVertexBuffers2EXT:
        {
            return "OP_vkCmdBindVertexBuffers2EXT";
        }
#endif
#ifdef VK_VERSION_1_2
        case OP_vkCmdNextSubpass2:
        {
            return "OP_vkCmdNextSubpass2";
        }
        case OP_vkCmdDrawIndexedIndirectCount:
        {
            return "OP_vkCmdDrawIndexedIndirectCount";
        }
#endif
#ifdef VK_INTEL_performance_query
        case OP_vkAcquirePerformanceConfigurationINTEL:
        {
            return "OP_vkAcquirePerformanceConfigurationINTEL";
        }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
        case OP_vkCreateRayTracingPipelinesKHR:
        {
            return "OP_vkCreateRayTracingPipelinesKHR";
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case OP_vkCmdSetDepthCompareOpEXT:
        {
            return "OP_vkCmdSetDepthCompareOpEXT";
        }
#endif
#ifdef VK_KHR_copy_commands2
        case OP_vkCmdCopyBuffer2KHR:
        {
            return "OP_vkCmdCopyBuffer2KHR";
        }
        case OP_vkCmdCopyBufferToImage2KHR:
        {
            return "OP_vkCmdCopyBufferToImage2KHR";
        }
#endif
#ifdef VK_NV_device_generated_commands
        case OP_vkGetGeneratedCommandsMemoryRequirementsNV:
        {
            return "OP_vkGetGeneratedCommandsMemoryRequirementsNV";
        }
#endif
#ifdef VK_EXT_image_drm_format_modifier
        case OP_vkGetImageDrmFormatModifierPropertiesEXT:
        {
            return "OP_vkGetImageDrmFormatModifierPropertiesEXT";
        }
#endif
#ifdef VK_INTEL_performance_query
        case OP_vkCmdSetPerformanceOverrideINTEL:
        {
            return "OP_vkCmdSetPerformanceOverrideINTEL";
        }
#endif
#ifdef VK_VERSION_1_2
        case OP_vkResetQueryPool:
        {
            return "OP_vkResetQueryPool";
        }
#endif
#ifdef VK_KHR_copy_commands2
        case OP_vkCmdCopyImageToBuffer2KHR:
        {
            return "OP_vkCmdCopyImageToBuffer2KHR";
        }
#endif
#ifdef VK_NV_ray_tracing
        case OP_vkDestroyAccelerationStructureNV:
        {
            return "OP_vkDestroyAccelerationStructureNV";
        }
#endif
#ifdef VK_INTEL_performance_query
        case OP_vkReleasePerformanceConfigurationINTEL:
        {
            return "OP_vkReleasePerformanceConfigurationINTEL";
        }
#endif
#ifdef VK_KHR_copy_commands2
        case OP_vkCmdResolveImage2KHR:
        {
            return "OP_vkCmdResolveImage2KHR";
        }
#endif
#ifdef VK_EXT_metal_surface
        case OP_vkCreateMetalSurfaceEXT:
        {
            return "OP_vkCreateMetalSurfaceEXT";
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case OP_vkCopyAccelerationStructureToMemoryKHR:
        {
            return "OP_vkCopyAccelerationStructureToMemoryKHR";
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case OP_vkCmdSetViewportWithCountEXT:
        {
            return "OP_vkCmdSetViewportWithCountEXT";
        }
#endif
#ifdef VK_EXT_full_screen_exclusive
        case OP_vkReleaseFullScreenExclusiveModeEXT:
        {
            return "OP_vkReleaseFullScreenExclusiveModeEXT";
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case OP_vkCmdBuildAccelerationStructuresIndirectKHR:
        {
            return "OP_vkCmdBuildAccelerationStructuresIndirectKHR";
        }
        case OP_vkCreateAccelerationStructureKHR:
        {
            return "OP_vkCreateAccelerationStructureKHR";
        }
#endif
#ifdef VK_NV_ray_tracing
        case OP_vkCreateAccelerationStructureNV:
        {
            return "OP_vkCreateAccelerationStructureNV";
        }
#endif
#ifdef VK_KHR_copy_commands2
        case OP_vkCmdBlitImage2KHR:
        {
            return "OP_vkCmdBlitImage2KHR";
        }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
        case OP_vkCmdSetRayTracingPipelineStackSizeKHR:
        {
            return "OP_vkCmdSetRayTracingPipelineStackSizeKHR";
        }
#endif
#ifdef VK_VERSION_1_2
        case OP_vkGetDeviceMemoryOpaqueCaptureAddress:
        {
            return "OP_vkGetDeviceMemoryOpaqueCaptureAddress";
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case OP_vkCmdSetPrimitiveTopologyEXT:
        {
            return "OP_vkCmdSetPrimitiveTopologyEXT";
        }
#endif
#ifdef VK_INTEL_performance_query
        case OP_vkCmdSetPerformanceStreamMarkerINTEL:
        {
            return "OP_vkCmdSetPerformanceStreamMarkerINTEL";
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case OP_vkCopyMemoryToAccelerationStructureKHR:
        {
            return "OP_vkCopyMemoryToAccelerationStructureKHR";
        }
#endif
#ifdef VK_FUCHSIA_imagepipe_surface
        case OP_vkCreateImagePipeSurfaceFUCHSIA:
        {
            return "OP_vkCreateImagePipeSurfaceFUCHSIA";
        }
#endif
#ifdef VK_KHR_deferred_host_operations
        case OP_vkGetDeferredOperationResultKHR:
        {
            return "OP_vkGetDeferredOperationResultKHR";
        }
#endif
#ifdef VK_EXT_line_rasterization
        case OP_vkCmdSetLineStippleEXT:
        {
            return "OP_vkCmdSetLineStippleEXT";
        }
#endif
#ifdef VK_KHR_timeline_semaphore
        case OP_vkWaitSemaphoresKHR:
        {
            return "OP_vkWaitSemaphoresKHR";
        }
#endif
#ifdef VK_NV_fragment_shading_rate_enums
        case OP_vkCmdSetFragmentShadingRateEnumNV:
        {
            return "OP_vkCmdSetFragmentShadingRateEnumNV";
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case OP_vkCmdSetCullModeEXT:
        {
            return "OP_vkCmdSetCullModeEXT";
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case OP_vkGetDeviceAccelerationStructureCompatibilityKHR:
        {
            return "OP_vkGetDeviceAccelerationStructureCompatibilityKHR";
        }
#endif
#ifdef VK_VERSION_1_2
        case OP_vkGetSemaphoreCounterValue:
        {
            return "OP_vkGetSemaphoreCounterValue";
        }
#endif
#ifdef VK_AMD_display_native_hdr
        case OP_vkSetLocalDimmingAMD:
        {
            return "OP_vkSetLocalDimmingAMD";
        }
#endif
#ifdef VK_EXT_transform_feedback
        case OP_vkCmdBindTransformFeedbackBuffersEXT:
        {
            return "OP_vkCmdBindTransformFeedbackBuffersEXT";
        }
#endif
#ifdef VK_EXT_full_screen_exclusive
        case OP_vkGetPhysicalDeviceSurfacePresentModes2EXT:
        {
            return "OP_vkGetPhysicalDeviceSurfacePresentModes2EXT";
        }
#endif
#ifdef VK_NV_ray_tracing
        case OP_vkCmdBuildAccelerationStructureNV:
        {
            return "OP_vkCmdBuildAccelerationStructureNV";
        }
#endif
#ifdef VK_KHR_pipeline_executable_properties
        case OP_vkGetPipelineExecutablePropertiesKHR:
        {
            return "OP_vkGetPipelineExecutablePropertiesKHR";
        }
#endif
#ifdef VK_NV_ray_tracing
        case OP_vkGetAccelerationStructureHandleNV:
        {
            return "OP_vkGetAccelerationStructureHandleNV";
        }
#endif
#ifdef VK_KHR_timeline_semaphore
        case OP_vkSignalSemaphoreKHR:
        {
            return "OP_vkSignalSemaphoreKHR";
        }
#endif
#ifdef VK_INTEL_performance_query
        case OP_vkCmdSetPerformanceMarkerINTEL:
        {
            return "OP_vkCmdSetPerformanceMarkerINTEL";
        }
#endif
#ifdef VK_NV_device_generated_commands
        case OP_vkCmdBindPipelineShaderGroupNV:
        {
            return "OP_vkCmdBindPipelineShaderGroupNV";
        }
#endif
#ifdef VK_VERSION_1_2
        case OP_vkSignalSemaphore:
        {
            return "OP_vkSignalSemaphore";
        }
#endif
#ifdef VK_KHR_pipeline_executable_properties
        case OP_vkGetPipelineExecutableStatisticsKHR:
        {
            return "OP_vkGetPipelineExecutableStatisticsKHR";
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case OP_vkCmdWriteAccelerationStructuresPropertiesKHR:
        {
            return "OP_vkCmdWriteAccelerationStructuresPropertiesKHR";
        }
#endif
#ifdef VK_NV_ray_tracing
        case OP_vkGetRayTracingShaderGroupHandlesKHR:
        {
            return "OP_vkGetRayTracingShaderGroupHandlesKHR";
        }
#endif
#ifdef VK_EXT_transform_feedback
        case OP_vkCmdEndTransformFeedbackEXT:
        {
            return "OP_vkCmdEndTransformFeedbackEXT";
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case OP_vkCmdBuildAccelerationStructuresKHR:
        {
            return "OP_vkCmdBuildAccelerationStructuresKHR";
        }
#endif
#ifdef VK_KHR_fragment_shading_rate
        case OP_vkGetPhysicalDeviceFragmentShadingRatesKHR:
        {
            return "OP_vkGetPhysicalDeviceFragmentShadingRatesKHR";
        }
#endif
#ifdef VK_NV_mesh_shader
        case OP_vkCmdDrawMeshTasksIndirectNV:
        {
            return "OP_vkCmdDrawMeshTasksIndirectNV";
        }
#endif
#ifdef VK_KHR_pipeline_executable_properties
        case OP_vkGetPipelineExecutableInternalRepresentationsKHR:
        {
            return "OP_vkGetPipelineExecutableInternalRepresentationsKHR";
        }
#endif
#ifdef VK_KHR_deferred_host_operations
        case OP_vkCreateDeferredOperationKHR:
        {
            return "OP_vkCreateDeferredOperationKHR";
        }
#endif
#ifdef VK_EXT_transform_feedback
        case OP_vkCmdBeginQueryIndexedEXT:
        {
            return "OP_vkCmdBeginQueryIndexedEXT";
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case OP_vkCmdSetStencilOpEXT:
        {
            return "OP_vkCmdSetStencilOpEXT";
        }
#endif
#ifdef VK_NV_ray_tracing
        case OP_vkCompileDeferredNV:
        {
            return "OP_vkCompileDeferredNV";
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case OP_vkCmdCopyAccelerationStructureKHR:
        {
            return "OP_vkCmdCopyAccelerationStructureKHR";
        }
#endif
#ifdef VK_VERSION_1_2
        case OP_vkCreateRenderPass2:
        {
            return "OP_vkCreateRenderPass2";
        }
#endif
#ifdef VK_EXT_transform_feedback
        case OP_vkCmdEndQueryIndexedEXT:
        {
            return "OP_vkCmdEndQueryIndexedEXT";
        }
#endif
#ifdef VK_KHR_performance_query
        case OP_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR:
        {
            return "OP_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR";
        }
#endif
#ifdef VK_EXT_tooling_info
        case OP_vkGetPhysicalDeviceToolPropertiesEXT:
        {
            return "OP_vkGetPhysicalDeviceToolPropertiesEXT";
        }
#endif
#ifdef VK_VERSION_1_2
        case OP_vkCmdDrawIndirectCount:
        {
            return "OP_vkCmdDrawIndirectCount";
        }
#endif
#ifdef VK_EXT_transform_feedback
        case OP_vkCmdDrawIndirectByteCountEXT:
        {
            return "OP_vkCmdDrawIndirectByteCountEXT";
        }
#endif
#ifdef VK_NV_device_generated_commands
        case OP_vkCreateIndirectCommandsLayoutNV:
        {
            return "OP_vkCreateIndirectCommandsLayoutNV";
        }
#endif
#ifdef VK_EXT_directfb_surface
        case OP_vkGetPhysicalDeviceDirectFBPresentationSupportEXT:
        {
            return "OP_vkGetPhysicalDeviceDirectFBPresentationSupportEXT";
        }
#endif
#ifdef VK_KHR_buffer_device_address
        case OP_vkGetBufferOpaqueCaptureAddressKHR:
        {
            return "OP_vkGetBufferOpaqueCaptureAddressKHR";
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case OP_vkCmdSetStencilTestEnableEXT:
        {
            return "OP_vkCmdSetStencilTestEnableEXT";
        }
#endif
#ifdef VK_NV_cooperative_matrix
        case OP_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV:
        {
            return "OP_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV";
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case OP_vkWriteAccelerationStructuresPropertiesKHR:
        {
            return "OP_vkWriteAccelerationStructuresPropertiesKHR";
        }
#endif
#ifdef VK_EXT_private_data
        case OP_vkGetPrivateDataEXT:
        {
            return "OP_vkGetPrivateDataEXT";
        }
#endif
#ifdef VK_NV_coverage_reduction_mode
        case OP_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV:
        {
            return "OP_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV";
        }
#endif
#ifdef VK_NV_device_generated_commands
        case OP_vkDestroyIndirectCommandsLayoutNV:
        {
            return "OP_vkDestroyIndirectCommandsLayoutNV";
        }
#endif
#ifdef VK_EXT_transform_feedback
        case OP_vkCmdBeginTransformFeedbackEXT:
        {
            return "OP_vkCmdBeginTransformFeedbackEXT";
        }
#endif
#ifdef VK_KHR_buffer_device_address
        case OP_vkGetDeviceMemoryOpaqueCaptureAddressKHR:
        {
            return "OP_vkGetDeviceMemoryOpaqueCaptureAddressKHR";
        }
#endif
#ifdef VK_INTEL_performance_query
        case OP_vkQueueSetPerformanceConfigurationINTEL:
        {
            return "OP_vkQueueSetPerformanceConfigurationINTEL";
        }
#endif
#ifdef VK_EXT_calibrated_timestamps
        case OP_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT:
        {
            return "OP_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT";
        }
#endif
#ifdef VK_INTEL_performance_query
        case OP_vkUninitializePerformanceApiINTEL:
        {
            return "OP_vkUninitializePerformanceApiINTEL";
        }
#endif
#ifdef VK_NV_device_generated_commands
        case OP_vkCmdPreprocessGeneratedCommandsNV:
        {
            return "OP_vkCmdPreprocessGeneratedCommandsNV";
        }
#endif
#ifdef VK_EXT_headless_surface
        case OP_vkCreateHeadlessSurfaceEXT:
        {
            return "OP_vkCreateHeadlessSurfaceEXT";
        }
#endif
#ifdef VK_KHR_performance_query
        case OP_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR:
        {
            return "OP_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR";
        }
#endif
        default:
        {
            return "OP_UNKNOWN_API_CALL";
        }
    }
}


} // namespace goldfish_vk
