// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_baseprotoconversion
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "goldfish_vk_baseprotoconversion.h"


#include <vector>
#include <string.h>


namespace goldfish_vk {

VkStructureType extension_proto_to_struct_type(
    const goldfish_vk_proto::VkExtensionStruct* input);

void to_proto_extension_struct(
    VulkanHandleMapping* handleMapping,
    const void* structExtension,
    void* output);

void from_proto_extension_struct(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    void* input,
    void* structExtension_out);

#ifdef VK_VERSION_1_0
void to_proto_VkApplicationInfo(
    VulkanHandleMapping* handleMapping,
    const VkApplicationInfo* input,
    goldfish_vk_proto::VkApplicationInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_papplicationname(input->pApplicationName);
    output->set_applicationversion((uint32_t)input->applicationVersion);
    output->set_penginename(input->pEngineName);
    output->set_engineversion((uint32_t)input->engineVersion);
    output->set_apiversion((uint32_t)input->apiVersion);
}

void from_proto_VkApplicationInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkApplicationInfo* input,
    VkApplicationInfo* output)
{
    memset(output, 0x0, sizeof(VkApplicationInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    *(const char**)(&output->pApplicationName) = input->papplicationname().c_str();
    output->applicationVersion = (uint32_t)input->applicationversion();
    *(const char**)(&output->pEngineName) = input->penginename().c_str();
    output->engineVersion = (uint32_t)input->engineversion();
    output->apiVersion = (uint32_t)input->apiversion();
}

void to_proto_VkInstanceCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkInstanceCreateInfo* input,
    goldfish_vk_proto::VkInstanceCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    // WARNING PTR CHECK
    if (input->pApplicationInfo)
    {
        to_proto_VkApplicationInfo(handleMapping, input->pApplicationInfo, output->mutable_papplicationinfo());
    }
    output->set_enabledlayercount((uint32_t)input->enabledLayerCount);
    for (uint32_t i = 0; i < (uint32_t)input->enabledLayerCount; ++i)
    {
        *(output->add_ppenabledlayernames()) = input->ppEnabledLayerNames[i];
    }
    output->set_enabledextensioncount((uint32_t)input->enabledExtensionCount);
    for (uint32_t i = 0; i < (uint32_t)input->enabledExtensionCount; ++i)
    {
        *(output->add_ppenabledextensionnames()) = input->ppEnabledExtensionNames[i];
    }
}

void from_proto_VkInstanceCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkInstanceCreateInfo* input,
    VkInstanceCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkInstanceCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkInstanceCreateFlags)input->flags();
    // WARNING PTR CHECK
    if (input->has_papplicationinfo())
    {
        *(void**)&output->pApplicationInfo = pool->alloc(sizeof(const VkApplicationInfo));
        from_proto_VkApplicationInfo(pool, handleMapping, input->mutable_papplicationinfo(), (VkApplicationInfo*)(output->pApplicationInfo));
    }
    output->enabledLayerCount = (uint32_t)input->enabledlayercount();
    if (output->enabledLayerCount)
    {
        *(void**)&output->ppEnabledLayerNames = pool->alloc(output->enabledLayerCount * sizeof(char*));
    }
    for (uint32_t i = 0; i < (uint32_t)output->enabledLayerCount; ++i)
    {
        *(const char**)(&output->ppEnabledLayerNames[i]) = input->ppenabledlayernames(i).c_str();
    }
    output->enabledExtensionCount = (uint32_t)input->enabledextensioncount();
    if (output->enabledExtensionCount)
    {
        *(void**)&output->ppEnabledExtensionNames = pool->alloc(output->enabledExtensionCount * sizeof(char*));
    }
    for (uint32_t i = 0; i < (uint32_t)output->enabledExtensionCount; ++i)
    {
        *(const char**)(&output->ppEnabledExtensionNames[i]) = input->ppenabledextensionnames(i).c_str();
    }
}

void to_proto_VkAllocationCallbacks(
    VulkanHandleMapping* handleMapping,
    const VkAllocationCallbacks* input,
    goldfish_vk_proto::VkAllocationCallbacks* output)
{
    // WARNING PTR CHECK
    if (input->pUserData)
    {
        output->set_puserdata((uint64_t)(uintptr_t)input->pUserData);
    }
    output->set_pfnallocation((uint64_t)input->pfnAllocation);
    output->set_pfnreallocation((uint64_t)input->pfnReallocation);
    output->set_pfnfree((uint64_t)input->pfnFree);
    output->set_pfninternalallocation((uint64_t)input->pfnInternalAllocation);
    output->set_pfninternalfree((uint64_t)input->pfnInternalFree);
}

void from_proto_VkAllocationCallbacks(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkAllocationCallbacks* input,
    VkAllocationCallbacks* output)
{
    memset(output, 0x0, sizeof(VkAllocationCallbacks));
    // WARNING PTR CHECK
    if (input->has_puserdata())
    {
        output->pUserData = (void*)(uintptr_t)input->puserdata();
    }
    output->pfnAllocation = (PFN_vkAllocationFunction)input->pfnallocation();
    output->pfnReallocation = (PFN_vkReallocationFunction)input->pfnreallocation();
    output->pfnFree = (PFN_vkFreeFunction)input->pfnfree();
    output->pfnInternalAllocation = (PFN_vkInternalAllocationNotification)input->pfninternalallocation();
    output->pfnInternalFree = (PFN_vkInternalFreeNotification)input->pfninternalfree();
}

void to_proto_VkPhysicalDeviceFeatures(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceFeatures* input,
    goldfish_vk_proto::VkPhysicalDeviceFeatures* output)
{
    output->set_robustbufferaccess((uint32_t)input->robustBufferAccess);
    output->set_fulldrawindexuint32((uint32_t)input->fullDrawIndexUint32);
    output->set_imagecubearray((uint32_t)input->imageCubeArray);
    output->set_independentblend((uint32_t)input->independentBlend);
    output->set_geometryshader((uint32_t)input->geometryShader);
    output->set_tessellationshader((uint32_t)input->tessellationShader);
    output->set_samplerateshading((uint32_t)input->sampleRateShading);
    output->set_dualsrcblend((uint32_t)input->dualSrcBlend);
    output->set_logicop((uint32_t)input->logicOp);
    output->set_multidrawindirect((uint32_t)input->multiDrawIndirect);
    output->set_drawindirectfirstinstance((uint32_t)input->drawIndirectFirstInstance);
    output->set_depthclamp((uint32_t)input->depthClamp);
    output->set_depthbiasclamp((uint32_t)input->depthBiasClamp);
    output->set_fillmodenonsolid((uint32_t)input->fillModeNonSolid);
    output->set_depthbounds((uint32_t)input->depthBounds);
    output->set_widelines((uint32_t)input->wideLines);
    output->set_largepoints((uint32_t)input->largePoints);
    output->set_alphatoone((uint32_t)input->alphaToOne);
    output->set_multiviewport((uint32_t)input->multiViewport);
    output->set_sampleranisotropy((uint32_t)input->samplerAnisotropy);
    output->set_texturecompressionetc2((uint32_t)input->textureCompressionETC2);
    output->set_texturecompressionastc_ldr((uint32_t)input->textureCompressionASTC_LDR);
    output->set_texturecompressionbc((uint32_t)input->textureCompressionBC);
    output->set_occlusionqueryprecise((uint32_t)input->occlusionQueryPrecise);
    output->set_pipelinestatisticsquery((uint32_t)input->pipelineStatisticsQuery);
    output->set_vertexpipelinestoresandatomics((uint32_t)input->vertexPipelineStoresAndAtomics);
    output->set_fragmentstoresandatomics((uint32_t)input->fragmentStoresAndAtomics);
    output->set_shadertessellationandgeometrypointsize((uint32_t)input->shaderTessellationAndGeometryPointSize);
    output->set_shaderimagegatherextended((uint32_t)input->shaderImageGatherExtended);
    output->set_shaderstorageimageextendedformats((uint32_t)input->shaderStorageImageExtendedFormats);
    output->set_shaderstorageimagemultisample((uint32_t)input->shaderStorageImageMultisample);
    output->set_shaderstorageimagereadwithoutformat((uint32_t)input->shaderStorageImageReadWithoutFormat);
    output->set_shaderstorageimagewritewithoutformat((uint32_t)input->shaderStorageImageWriteWithoutFormat);
    output->set_shaderuniformbufferarraydynamicindexing((uint32_t)input->shaderUniformBufferArrayDynamicIndexing);
    output->set_shadersampledimagearraydynamicindexing((uint32_t)input->shaderSampledImageArrayDynamicIndexing);
    output->set_shaderstoragebufferarraydynamicindexing((uint32_t)input->shaderStorageBufferArrayDynamicIndexing);
    output->set_shaderstorageimagearraydynamicindexing((uint32_t)input->shaderStorageImageArrayDynamicIndexing);
    output->set_shaderclipdistance((uint32_t)input->shaderClipDistance);
    output->set_shaderculldistance((uint32_t)input->shaderCullDistance);
    output->set_shaderfloat64((uint32_t)input->shaderFloat64);
    output->set_shaderint64((uint32_t)input->shaderInt64);
    output->set_shaderint16((uint32_t)input->shaderInt16);
    output->set_shaderresourceresidency((uint32_t)input->shaderResourceResidency);
    output->set_shaderresourceminlod((uint32_t)input->shaderResourceMinLod);
    output->set_sparsebinding((uint32_t)input->sparseBinding);
    output->set_sparseresidencybuffer((uint32_t)input->sparseResidencyBuffer);
    output->set_sparseresidencyimage2d((uint32_t)input->sparseResidencyImage2D);
    output->set_sparseresidencyimage3d((uint32_t)input->sparseResidencyImage3D);
    output->set_sparseresidency2samples((uint32_t)input->sparseResidency2Samples);
    output->set_sparseresidency4samples((uint32_t)input->sparseResidency4Samples);
    output->set_sparseresidency8samples((uint32_t)input->sparseResidency8Samples);
    output->set_sparseresidency16samples((uint32_t)input->sparseResidency16Samples);
    output->set_sparseresidencyaliased((uint32_t)input->sparseResidencyAliased);
    output->set_variablemultisamplerate((uint32_t)input->variableMultisampleRate);
    output->set_inheritedqueries((uint32_t)input->inheritedQueries);
}

void from_proto_VkPhysicalDeviceFeatures(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceFeatures* input,
    VkPhysicalDeviceFeatures* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceFeatures));
    output->robustBufferAccess = (VkBool32)input->robustbufferaccess();
    output->fullDrawIndexUint32 = (VkBool32)input->fulldrawindexuint32();
    output->imageCubeArray = (VkBool32)input->imagecubearray();
    output->independentBlend = (VkBool32)input->independentblend();
    output->geometryShader = (VkBool32)input->geometryshader();
    output->tessellationShader = (VkBool32)input->tessellationshader();
    output->sampleRateShading = (VkBool32)input->samplerateshading();
    output->dualSrcBlend = (VkBool32)input->dualsrcblend();
    output->logicOp = (VkBool32)input->logicop();
    output->multiDrawIndirect = (VkBool32)input->multidrawindirect();
    output->drawIndirectFirstInstance = (VkBool32)input->drawindirectfirstinstance();
    output->depthClamp = (VkBool32)input->depthclamp();
    output->depthBiasClamp = (VkBool32)input->depthbiasclamp();
    output->fillModeNonSolid = (VkBool32)input->fillmodenonsolid();
    output->depthBounds = (VkBool32)input->depthbounds();
    output->wideLines = (VkBool32)input->widelines();
    output->largePoints = (VkBool32)input->largepoints();
    output->alphaToOne = (VkBool32)input->alphatoone();
    output->multiViewport = (VkBool32)input->multiviewport();
    output->samplerAnisotropy = (VkBool32)input->sampleranisotropy();
    output->textureCompressionETC2 = (VkBool32)input->texturecompressionetc2();
    output->textureCompressionASTC_LDR = (VkBool32)input->texturecompressionastc_ldr();
    output->textureCompressionBC = (VkBool32)input->texturecompressionbc();
    output->occlusionQueryPrecise = (VkBool32)input->occlusionqueryprecise();
    output->pipelineStatisticsQuery = (VkBool32)input->pipelinestatisticsquery();
    output->vertexPipelineStoresAndAtomics = (VkBool32)input->vertexpipelinestoresandatomics();
    output->fragmentStoresAndAtomics = (VkBool32)input->fragmentstoresandatomics();
    output->shaderTessellationAndGeometryPointSize = (VkBool32)input->shadertessellationandgeometrypointsize();
    output->shaderImageGatherExtended = (VkBool32)input->shaderimagegatherextended();
    output->shaderStorageImageExtendedFormats = (VkBool32)input->shaderstorageimageextendedformats();
    output->shaderStorageImageMultisample = (VkBool32)input->shaderstorageimagemultisample();
    output->shaderStorageImageReadWithoutFormat = (VkBool32)input->shaderstorageimagereadwithoutformat();
    output->shaderStorageImageWriteWithoutFormat = (VkBool32)input->shaderstorageimagewritewithoutformat();
    output->shaderUniformBufferArrayDynamicIndexing = (VkBool32)input->shaderuniformbufferarraydynamicindexing();
    output->shaderSampledImageArrayDynamicIndexing = (VkBool32)input->shadersampledimagearraydynamicindexing();
    output->shaderStorageBufferArrayDynamicIndexing = (VkBool32)input->shaderstoragebufferarraydynamicindexing();
    output->shaderStorageImageArrayDynamicIndexing = (VkBool32)input->shaderstorageimagearraydynamicindexing();
    output->shaderClipDistance = (VkBool32)input->shaderclipdistance();
    output->shaderCullDistance = (VkBool32)input->shaderculldistance();
    output->shaderFloat64 = (VkBool32)input->shaderfloat64();
    output->shaderInt64 = (VkBool32)input->shaderint64();
    output->shaderInt16 = (VkBool32)input->shaderint16();
    output->shaderResourceResidency = (VkBool32)input->shaderresourceresidency();
    output->shaderResourceMinLod = (VkBool32)input->shaderresourceminlod();
    output->sparseBinding = (VkBool32)input->sparsebinding();
    output->sparseResidencyBuffer = (VkBool32)input->sparseresidencybuffer();
    output->sparseResidencyImage2D = (VkBool32)input->sparseresidencyimage2d();
    output->sparseResidencyImage3D = (VkBool32)input->sparseresidencyimage3d();
    output->sparseResidency2Samples = (VkBool32)input->sparseresidency2samples();
    output->sparseResidency4Samples = (VkBool32)input->sparseresidency4samples();
    output->sparseResidency8Samples = (VkBool32)input->sparseresidency8samples();
    output->sparseResidency16Samples = (VkBool32)input->sparseresidency16samples();
    output->sparseResidencyAliased = (VkBool32)input->sparseresidencyaliased();
    output->variableMultisampleRate = (VkBool32)input->variablemultisamplerate();
    output->inheritedQueries = (VkBool32)input->inheritedqueries();
}

void to_proto_VkFormatProperties(
    VulkanHandleMapping* handleMapping,
    const VkFormatProperties* input,
    goldfish_vk_proto::VkFormatProperties* output)
{
    output->set_lineartilingfeatures((uint32_t)input->linearTilingFeatures);
    output->set_optimaltilingfeatures((uint32_t)input->optimalTilingFeatures);
    output->set_bufferfeatures((uint32_t)input->bufferFeatures);
}

void from_proto_VkFormatProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkFormatProperties* input,
    VkFormatProperties* output)
{
    memset(output, 0x0, sizeof(VkFormatProperties));
    output->linearTilingFeatures = (VkFormatFeatureFlags)input->lineartilingfeatures();
    output->optimalTilingFeatures = (VkFormatFeatureFlags)input->optimaltilingfeatures();
    output->bufferFeatures = (VkFormatFeatureFlags)input->bufferfeatures();
}

void to_proto_VkExtent3D(
    VulkanHandleMapping* handleMapping,
    const VkExtent3D* input,
    goldfish_vk_proto::VkExtent3D* output)
{
    output->set_width((uint32_t)input->width);
    output->set_height((uint32_t)input->height);
    output->set_depth((uint32_t)input->depth);
}

void from_proto_VkExtent3D(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExtent3D* input,
    VkExtent3D* output)
{
    memset(output, 0x0, sizeof(VkExtent3D));
    output->width = (uint32_t)input->width();
    output->height = (uint32_t)input->height();
    output->depth = (uint32_t)input->depth();
}

void to_proto_VkImageFormatProperties(
    VulkanHandleMapping* handleMapping,
    const VkImageFormatProperties* input,
    goldfish_vk_proto::VkImageFormatProperties* output)
{
    to_proto_VkExtent3D(handleMapping, &input->maxExtent, output->mutable_maxextent());
    output->set_maxmiplevels((uint32_t)input->maxMipLevels);
    output->set_maxarraylayers((uint32_t)input->maxArrayLayers);
    output->set_samplecounts((uint32_t)input->sampleCounts);
    output->set_maxresourcesize((uint64_t)input->maxResourceSize);
}

void from_proto_VkImageFormatProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageFormatProperties* input,
    VkImageFormatProperties* output)
{
    memset(output, 0x0, sizeof(VkImageFormatProperties));
    from_proto_VkExtent3D(pool, handleMapping, input->mutable_maxextent(), (VkExtent3D*)(&output->maxExtent));
    output->maxMipLevels = (uint32_t)input->maxmiplevels();
    output->maxArrayLayers = (uint32_t)input->maxarraylayers();
    output->sampleCounts = (VkSampleCountFlags)input->samplecounts();
    output->maxResourceSize = (VkDeviceSize)input->maxresourcesize();
}

void to_proto_VkPhysicalDeviceLimits(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceLimits* input,
    goldfish_vk_proto::VkPhysicalDeviceLimits* output)
{
    output->set_maximagedimension1d((uint32_t)input->maxImageDimension1D);
    output->set_maximagedimension2d((uint32_t)input->maxImageDimension2D);
    output->set_maximagedimension3d((uint32_t)input->maxImageDimension3D);
    output->set_maximagedimensioncube((uint32_t)input->maxImageDimensionCube);
    output->set_maximagearraylayers((uint32_t)input->maxImageArrayLayers);
    output->set_maxtexelbufferelements((uint32_t)input->maxTexelBufferElements);
    output->set_maxuniformbufferrange((uint32_t)input->maxUniformBufferRange);
    output->set_maxstoragebufferrange((uint32_t)input->maxStorageBufferRange);
    output->set_maxpushconstantssize((uint32_t)input->maxPushConstantsSize);
    output->set_maxmemoryallocationcount((uint32_t)input->maxMemoryAllocationCount);
    output->set_maxsamplerallocationcount((uint32_t)input->maxSamplerAllocationCount);
    output->set_bufferimagegranularity((uint64_t)input->bufferImageGranularity);
    output->set_sparseaddressspacesize((uint64_t)input->sparseAddressSpaceSize);
    output->set_maxbounddescriptorsets((uint32_t)input->maxBoundDescriptorSets);
    output->set_maxperstagedescriptorsamplers((uint32_t)input->maxPerStageDescriptorSamplers);
    output->set_maxperstagedescriptoruniformbuffers((uint32_t)input->maxPerStageDescriptorUniformBuffers);
    output->set_maxperstagedescriptorstoragebuffers((uint32_t)input->maxPerStageDescriptorStorageBuffers);
    output->set_maxperstagedescriptorsampledimages((uint32_t)input->maxPerStageDescriptorSampledImages);
    output->set_maxperstagedescriptorstorageimages((uint32_t)input->maxPerStageDescriptorStorageImages);
    output->set_maxperstagedescriptorinputattachments((uint32_t)input->maxPerStageDescriptorInputAttachments);
    output->set_maxperstageresources((uint32_t)input->maxPerStageResources);
    output->set_maxdescriptorsetsamplers((uint32_t)input->maxDescriptorSetSamplers);
    output->set_maxdescriptorsetuniformbuffers((uint32_t)input->maxDescriptorSetUniformBuffers);
    output->set_maxdescriptorsetuniformbuffersdynamic((uint32_t)input->maxDescriptorSetUniformBuffersDynamic);
    output->set_maxdescriptorsetstoragebuffers((uint32_t)input->maxDescriptorSetStorageBuffers);
    output->set_maxdescriptorsetstoragebuffersdynamic((uint32_t)input->maxDescriptorSetStorageBuffersDynamic);
    output->set_maxdescriptorsetsampledimages((uint32_t)input->maxDescriptorSetSampledImages);
    output->set_maxdescriptorsetstorageimages((uint32_t)input->maxDescriptorSetStorageImages);
    output->set_maxdescriptorsetinputattachments((uint32_t)input->maxDescriptorSetInputAttachments);
    output->set_maxvertexinputattributes((uint32_t)input->maxVertexInputAttributes);
    output->set_maxvertexinputbindings((uint32_t)input->maxVertexInputBindings);
    output->set_maxvertexinputattributeoffset((uint32_t)input->maxVertexInputAttributeOffset);
    output->set_maxvertexinputbindingstride((uint32_t)input->maxVertexInputBindingStride);
    output->set_maxvertexoutputcomponents((uint32_t)input->maxVertexOutputComponents);
    output->set_maxtessellationgenerationlevel((uint32_t)input->maxTessellationGenerationLevel);
    output->set_maxtessellationpatchsize((uint32_t)input->maxTessellationPatchSize);
    output->set_maxtessellationcontrolpervertexinputcomponents((uint32_t)input->maxTessellationControlPerVertexInputComponents);
    output->set_maxtessellationcontrolpervertexoutputcomponents((uint32_t)input->maxTessellationControlPerVertexOutputComponents);
    output->set_maxtessellationcontrolperpatchoutputcomponents((uint32_t)input->maxTessellationControlPerPatchOutputComponents);
    output->set_maxtessellationcontroltotaloutputcomponents((uint32_t)input->maxTessellationControlTotalOutputComponents);
    output->set_maxtessellationevaluationinputcomponents((uint32_t)input->maxTessellationEvaluationInputComponents);
    output->set_maxtessellationevaluationoutputcomponents((uint32_t)input->maxTessellationEvaluationOutputComponents);
    output->set_maxgeometryshaderinvocations((uint32_t)input->maxGeometryShaderInvocations);
    output->set_maxgeometryinputcomponents((uint32_t)input->maxGeometryInputComponents);
    output->set_maxgeometryoutputcomponents((uint32_t)input->maxGeometryOutputComponents);
    output->set_maxgeometryoutputvertices((uint32_t)input->maxGeometryOutputVertices);
    output->set_maxgeometrytotaloutputcomponents((uint32_t)input->maxGeometryTotalOutputComponents);
    output->set_maxfragmentinputcomponents((uint32_t)input->maxFragmentInputComponents);
    output->set_maxfragmentoutputattachments((uint32_t)input->maxFragmentOutputAttachments);
    output->set_maxfragmentdualsrcattachments((uint32_t)input->maxFragmentDualSrcAttachments);
    output->set_maxfragmentcombinedoutputresources((uint32_t)input->maxFragmentCombinedOutputResources);
    output->set_maxcomputesharedmemorysize((uint32_t)input->maxComputeSharedMemorySize);
    for (uint32_t i = 0; i < (uint32_t)3; ++i)
    {
        output->add_maxcomputeworkgroupcount(input->maxComputeWorkGroupCount[i]);
    }
    output->set_maxcomputeworkgroupinvocations((uint32_t)input->maxComputeWorkGroupInvocations);
    for (uint32_t i = 0; i < (uint32_t)3; ++i)
    {
        output->add_maxcomputeworkgroupsize(input->maxComputeWorkGroupSize[i]);
    }
    output->set_subpixelprecisionbits((uint32_t)input->subPixelPrecisionBits);
    output->set_subtexelprecisionbits((uint32_t)input->subTexelPrecisionBits);
    output->set_mipmapprecisionbits((uint32_t)input->mipmapPrecisionBits);
    output->set_maxdrawindexedindexvalue((uint32_t)input->maxDrawIndexedIndexValue);
    output->set_maxdrawindirectcount((uint32_t)input->maxDrawIndirectCount);
    output->set_maxsamplerlodbias((float)input->maxSamplerLodBias);
    output->set_maxsampleranisotropy((float)input->maxSamplerAnisotropy);
    output->set_maxviewports((uint32_t)input->maxViewports);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        output->add_maxviewportdimensions(input->maxViewportDimensions[i]);
    }
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        output->add_viewportboundsrange(input->viewportBoundsRange[i]);
    }
    output->set_viewportsubpixelbits((uint32_t)input->viewportSubPixelBits);
    output->set_minmemorymapalignment((uint64_t)input->minMemoryMapAlignment);
    output->set_mintexelbufferoffsetalignment((uint64_t)input->minTexelBufferOffsetAlignment);
    output->set_minuniformbufferoffsetalignment((uint64_t)input->minUniformBufferOffsetAlignment);
    output->set_minstoragebufferoffsetalignment((uint64_t)input->minStorageBufferOffsetAlignment);
    output->set_mintexeloffset((int32_t)input->minTexelOffset);
    output->set_maxtexeloffset((uint32_t)input->maxTexelOffset);
    output->set_mintexelgatheroffset((int32_t)input->minTexelGatherOffset);
    output->set_maxtexelgatheroffset((uint32_t)input->maxTexelGatherOffset);
    output->set_mininterpolationoffset((float)input->minInterpolationOffset);
    output->set_maxinterpolationoffset((float)input->maxInterpolationOffset);
    output->set_subpixelinterpolationoffsetbits((uint32_t)input->subPixelInterpolationOffsetBits);
    output->set_maxframebufferwidth((uint32_t)input->maxFramebufferWidth);
    output->set_maxframebufferheight((uint32_t)input->maxFramebufferHeight);
    output->set_maxframebufferlayers((uint32_t)input->maxFramebufferLayers);
    output->set_framebuffercolorsamplecounts((uint32_t)input->framebufferColorSampleCounts);
    output->set_framebufferdepthsamplecounts((uint32_t)input->framebufferDepthSampleCounts);
    output->set_framebufferstencilsamplecounts((uint32_t)input->framebufferStencilSampleCounts);
    output->set_framebuffernoattachmentssamplecounts((uint32_t)input->framebufferNoAttachmentsSampleCounts);
    output->set_maxcolorattachments((uint32_t)input->maxColorAttachments);
    output->set_sampledimagecolorsamplecounts((uint32_t)input->sampledImageColorSampleCounts);
    output->set_sampledimageintegersamplecounts((uint32_t)input->sampledImageIntegerSampleCounts);
    output->set_sampledimagedepthsamplecounts((uint32_t)input->sampledImageDepthSampleCounts);
    output->set_sampledimagestencilsamplecounts((uint32_t)input->sampledImageStencilSampleCounts);
    output->set_storageimagesamplecounts((uint32_t)input->storageImageSampleCounts);
    output->set_maxsamplemaskwords((uint32_t)input->maxSampleMaskWords);
    output->set_timestampcomputeandgraphics((uint32_t)input->timestampComputeAndGraphics);
    output->set_timestampperiod((float)input->timestampPeriod);
    output->set_maxclipdistances((uint32_t)input->maxClipDistances);
    output->set_maxculldistances((uint32_t)input->maxCullDistances);
    output->set_maxcombinedclipandculldistances((uint32_t)input->maxCombinedClipAndCullDistances);
    output->set_discretequeuepriorities((uint32_t)input->discreteQueuePriorities);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        output->add_pointsizerange(input->pointSizeRange[i]);
    }
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        output->add_linewidthrange(input->lineWidthRange[i]);
    }
    output->set_pointsizegranularity((float)input->pointSizeGranularity);
    output->set_linewidthgranularity((float)input->lineWidthGranularity);
    output->set_strictlines((uint32_t)input->strictLines);
    output->set_standardsamplelocations((uint32_t)input->standardSampleLocations);
    output->set_optimalbuffercopyoffsetalignment((uint64_t)input->optimalBufferCopyOffsetAlignment);
    output->set_optimalbuffercopyrowpitchalignment((uint64_t)input->optimalBufferCopyRowPitchAlignment);
    output->set_noncoherentatomsize((uint64_t)input->nonCoherentAtomSize);
}

void from_proto_VkPhysicalDeviceLimits(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceLimits* input,
    VkPhysicalDeviceLimits* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceLimits));
    output->maxImageDimension1D = (uint32_t)input->maximagedimension1d();
    output->maxImageDimension2D = (uint32_t)input->maximagedimension2d();
    output->maxImageDimension3D = (uint32_t)input->maximagedimension3d();
    output->maxImageDimensionCube = (uint32_t)input->maximagedimensioncube();
    output->maxImageArrayLayers = (uint32_t)input->maximagearraylayers();
    output->maxTexelBufferElements = (uint32_t)input->maxtexelbufferelements();
    output->maxUniformBufferRange = (uint32_t)input->maxuniformbufferrange();
    output->maxStorageBufferRange = (uint32_t)input->maxstoragebufferrange();
    output->maxPushConstantsSize = (uint32_t)input->maxpushconstantssize();
    output->maxMemoryAllocationCount = (uint32_t)input->maxmemoryallocationcount();
    output->maxSamplerAllocationCount = (uint32_t)input->maxsamplerallocationcount();
    output->bufferImageGranularity = (VkDeviceSize)input->bufferimagegranularity();
    output->sparseAddressSpaceSize = (VkDeviceSize)input->sparseaddressspacesize();
    output->maxBoundDescriptorSets = (uint32_t)input->maxbounddescriptorsets();
    output->maxPerStageDescriptorSamplers = (uint32_t)input->maxperstagedescriptorsamplers();
    output->maxPerStageDescriptorUniformBuffers = (uint32_t)input->maxperstagedescriptoruniformbuffers();
    output->maxPerStageDescriptorStorageBuffers = (uint32_t)input->maxperstagedescriptorstoragebuffers();
    output->maxPerStageDescriptorSampledImages = (uint32_t)input->maxperstagedescriptorsampledimages();
    output->maxPerStageDescriptorStorageImages = (uint32_t)input->maxperstagedescriptorstorageimages();
    output->maxPerStageDescriptorInputAttachments = (uint32_t)input->maxperstagedescriptorinputattachments();
    output->maxPerStageResources = (uint32_t)input->maxperstageresources();
    output->maxDescriptorSetSamplers = (uint32_t)input->maxdescriptorsetsamplers();
    output->maxDescriptorSetUniformBuffers = (uint32_t)input->maxdescriptorsetuniformbuffers();
    output->maxDescriptorSetUniformBuffersDynamic = (uint32_t)input->maxdescriptorsetuniformbuffersdynamic();
    output->maxDescriptorSetStorageBuffers = (uint32_t)input->maxdescriptorsetstoragebuffers();
    output->maxDescriptorSetStorageBuffersDynamic = (uint32_t)input->maxdescriptorsetstoragebuffersdynamic();
    output->maxDescriptorSetSampledImages = (uint32_t)input->maxdescriptorsetsampledimages();
    output->maxDescriptorSetStorageImages = (uint32_t)input->maxdescriptorsetstorageimages();
    output->maxDescriptorSetInputAttachments = (uint32_t)input->maxdescriptorsetinputattachments();
    output->maxVertexInputAttributes = (uint32_t)input->maxvertexinputattributes();
    output->maxVertexInputBindings = (uint32_t)input->maxvertexinputbindings();
    output->maxVertexInputAttributeOffset = (uint32_t)input->maxvertexinputattributeoffset();
    output->maxVertexInputBindingStride = (uint32_t)input->maxvertexinputbindingstride();
    output->maxVertexOutputComponents = (uint32_t)input->maxvertexoutputcomponents();
    output->maxTessellationGenerationLevel = (uint32_t)input->maxtessellationgenerationlevel();
    output->maxTessellationPatchSize = (uint32_t)input->maxtessellationpatchsize();
    output->maxTessellationControlPerVertexInputComponents = (uint32_t)input->maxtessellationcontrolpervertexinputcomponents();
    output->maxTessellationControlPerVertexOutputComponents = (uint32_t)input->maxtessellationcontrolpervertexoutputcomponents();
    output->maxTessellationControlPerPatchOutputComponents = (uint32_t)input->maxtessellationcontrolperpatchoutputcomponents();
    output->maxTessellationControlTotalOutputComponents = (uint32_t)input->maxtessellationcontroltotaloutputcomponents();
    output->maxTessellationEvaluationInputComponents = (uint32_t)input->maxtessellationevaluationinputcomponents();
    output->maxTessellationEvaluationOutputComponents = (uint32_t)input->maxtessellationevaluationoutputcomponents();
    output->maxGeometryShaderInvocations = (uint32_t)input->maxgeometryshaderinvocations();
    output->maxGeometryInputComponents = (uint32_t)input->maxgeometryinputcomponents();
    output->maxGeometryOutputComponents = (uint32_t)input->maxgeometryoutputcomponents();
    output->maxGeometryOutputVertices = (uint32_t)input->maxgeometryoutputvertices();
    output->maxGeometryTotalOutputComponents = (uint32_t)input->maxgeometrytotaloutputcomponents();
    output->maxFragmentInputComponents = (uint32_t)input->maxfragmentinputcomponents();
    output->maxFragmentOutputAttachments = (uint32_t)input->maxfragmentoutputattachments();
    output->maxFragmentDualSrcAttachments = (uint32_t)input->maxfragmentdualsrcattachments();
    output->maxFragmentCombinedOutputResources = (uint32_t)input->maxfragmentcombinedoutputresources();
    output->maxComputeSharedMemorySize = (uint32_t)input->maxcomputesharedmemorysize();
    for (uint32_t i = 0; i < (uint32_t)3; ++i)
    {
        output->maxComputeWorkGroupCount[i] = (uint32_t)input->maxcomputeworkgroupcount(i);
    }
    output->maxComputeWorkGroupInvocations = (uint32_t)input->maxcomputeworkgroupinvocations();
    for (uint32_t i = 0; i < (uint32_t)3; ++i)
    {
        output->maxComputeWorkGroupSize[i] = (uint32_t)input->maxcomputeworkgroupsize(i);
    }
    output->subPixelPrecisionBits = (uint32_t)input->subpixelprecisionbits();
    output->subTexelPrecisionBits = (uint32_t)input->subtexelprecisionbits();
    output->mipmapPrecisionBits = (uint32_t)input->mipmapprecisionbits();
    output->maxDrawIndexedIndexValue = (uint32_t)input->maxdrawindexedindexvalue();
    output->maxDrawIndirectCount = (uint32_t)input->maxdrawindirectcount();
    output->maxSamplerLodBias = (float)input->maxsamplerlodbias();
    output->maxSamplerAnisotropy = (float)input->maxsampleranisotropy();
    output->maxViewports = (uint32_t)input->maxviewports();
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        output->maxViewportDimensions[i] = (uint32_t)input->maxviewportdimensions(i);
    }
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        output->viewportBoundsRange[i] = (float)input->viewportboundsrange(i);
    }
    output->viewportSubPixelBits = (uint32_t)input->viewportsubpixelbits();
    output->minMemoryMapAlignment = (size_t)input->minmemorymapalignment();
    output->minTexelBufferOffsetAlignment = (VkDeviceSize)input->mintexelbufferoffsetalignment();
    output->minUniformBufferOffsetAlignment = (VkDeviceSize)input->minuniformbufferoffsetalignment();
    output->minStorageBufferOffsetAlignment = (VkDeviceSize)input->minstoragebufferoffsetalignment();
    output->minTexelOffset = (int32_t)input->mintexeloffset();
    output->maxTexelOffset = (uint32_t)input->maxtexeloffset();
    output->minTexelGatherOffset = (int32_t)input->mintexelgatheroffset();
    output->maxTexelGatherOffset = (uint32_t)input->maxtexelgatheroffset();
    output->minInterpolationOffset = (float)input->mininterpolationoffset();
    output->maxInterpolationOffset = (float)input->maxinterpolationoffset();
    output->subPixelInterpolationOffsetBits = (uint32_t)input->subpixelinterpolationoffsetbits();
    output->maxFramebufferWidth = (uint32_t)input->maxframebufferwidth();
    output->maxFramebufferHeight = (uint32_t)input->maxframebufferheight();
    output->maxFramebufferLayers = (uint32_t)input->maxframebufferlayers();
    output->framebufferColorSampleCounts = (VkSampleCountFlags)input->framebuffercolorsamplecounts();
    output->framebufferDepthSampleCounts = (VkSampleCountFlags)input->framebufferdepthsamplecounts();
    output->framebufferStencilSampleCounts = (VkSampleCountFlags)input->framebufferstencilsamplecounts();
    output->framebufferNoAttachmentsSampleCounts = (VkSampleCountFlags)input->framebuffernoattachmentssamplecounts();
    output->maxColorAttachments = (uint32_t)input->maxcolorattachments();
    output->sampledImageColorSampleCounts = (VkSampleCountFlags)input->sampledimagecolorsamplecounts();
    output->sampledImageIntegerSampleCounts = (VkSampleCountFlags)input->sampledimageintegersamplecounts();
    output->sampledImageDepthSampleCounts = (VkSampleCountFlags)input->sampledimagedepthsamplecounts();
    output->sampledImageStencilSampleCounts = (VkSampleCountFlags)input->sampledimagestencilsamplecounts();
    output->storageImageSampleCounts = (VkSampleCountFlags)input->storageimagesamplecounts();
    output->maxSampleMaskWords = (uint32_t)input->maxsamplemaskwords();
    output->timestampComputeAndGraphics = (VkBool32)input->timestampcomputeandgraphics();
    output->timestampPeriod = (float)input->timestampperiod();
    output->maxClipDistances = (uint32_t)input->maxclipdistances();
    output->maxCullDistances = (uint32_t)input->maxculldistances();
    output->maxCombinedClipAndCullDistances = (uint32_t)input->maxcombinedclipandculldistances();
    output->discreteQueuePriorities = (uint32_t)input->discretequeuepriorities();
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        output->pointSizeRange[i] = (float)input->pointsizerange(i);
    }
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        output->lineWidthRange[i] = (float)input->linewidthrange(i);
    }
    output->pointSizeGranularity = (float)input->pointsizegranularity();
    output->lineWidthGranularity = (float)input->linewidthgranularity();
    output->strictLines = (VkBool32)input->strictlines();
    output->standardSampleLocations = (VkBool32)input->standardsamplelocations();
    output->optimalBufferCopyOffsetAlignment = (VkDeviceSize)input->optimalbuffercopyoffsetalignment();
    output->optimalBufferCopyRowPitchAlignment = (VkDeviceSize)input->optimalbuffercopyrowpitchalignment();
    output->nonCoherentAtomSize = (VkDeviceSize)input->noncoherentatomsize();
}

void to_proto_VkPhysicalDeviceSparseProperties(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceSparseProperties* input,
    goldfish_vk_proto::VkPhysicalDeviceSparseProperties* output)
{
    output->set_residencystandard2dblockshape((uint32_t)input->residencyStandard2DBlockShape);
    output->set_residencystandard2dmultisampleblockshape((uint32_t)input->residencyStandard2DMultisampleBlockShape);
    output->set_residencystandard3dblockshape((uint32_t)input->residencyStandard3DBlockShape);
    output->set_residencyalignedmipsize((uint32_t)input->residencyAlignedMipSize);
    output->set_residencynonresidentstrict((uint32_t)input->residencyNonResidentStrict);
}

void from_proto_VkPhysicalDeviceSparseProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceSparseProperties* input,
    VkPhysicalDeviceSparseProperties* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceSparseProperties));
    output->residencyStandard2DBlockShape = (VkBool32)input->residencystandard2dblockshape();
    output->residencyStandard2DMultisampleBlockShape = (VkBool32)input->residencystandard2dmultisampleblockshape();
    output->residencyStandard3DBlockShape = (VkBool32)input->residencystandard3dblockshape();
    output->residencyAlignedMipSize = (VkBool32)input->residencyalignedmipsize();
    output->residencyNonResidentStrict = (VkBool32)input->residencynonresidentstrict();
}

void to_proto_VkPhysicalDeviceProperties(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceProperties* input,
    goldfish_vk_proto::VkPhysicalDeviceProperties* output)
{
    output->set_apiversion((uint32_t)input->apiVersion);
    output->set_driverversion((uint32_t)input->driverVersion);
    output->set_vendorid((uint32_t)input->vendorID);
    output->set_deviceid((uint32_t)input->deviceID);
    output->set_devicetype((uint32_t)input->deviceType);
    output->set_devicename(input->deviceName);
    for (uint32_t i = 0; i < (uint32_t)VK_UUID_SIZE; ++i)
    {
        output->add_pipelinecacheuuid(input->pipelineCacheUUID[i]);
    }
    to_proto_VkPhysicalDeviceLimits(handleMapping, &input->limits, output->mutable_limits());
    to_proto_VkPhysicalDeviceSparseProperties(handleMapping, &input->sparseProperties, output->mutable_sparseproperties());
}

void from_proto_VkPhysicalDeviceProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceProperties* input,
    VkPhysicalDeviceProperties* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceProperties));
    output->apiVersion = (uint32_t)input->apiversion();
    output->driverVersion = (uint32_t)input->driverversion();
    output->vendorID = (uint32_t)input->vendorid();
    output->deviceID = (uint32_t)input->deviceid();
    output->deviceType = (VkPhysicalDeviceType)input->devicetype();
    memset(output->deviceName, 0x0, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE);
    strncpy(output->deviceName, input->devicename().c_str(), strlen(input->devicename().c_str()));
    for (uint32_t i = 0; i < (uint32_t)VK_UUID_SIZE; ++i)
    {
        output->pipelineCacheUUID[i] = (uint8_t)input->pipelinecacheuuid(i);
    }
    from_proto_VkPhysicalDeviceLimits(pool, handleMapping, input->mutable_limits(), (VkPhysicalDeviceLimits*)(&output->limits));
    from_proto_VkPhysicalDeviceSparseProperties(pool, handleMapping, input->mutable_sparseproperties(), (VkPhysicalDeviceSparseProperties*)(&output->sparseProperties));
}

void to_proto_VkQueueFamilyProperties(
    VulkanHandleMapping* handleMapping,
    const VkQueueFamilyProperties* input,
    goldfish_vk_proto::VkQueueFamilyProperties* output)
{
    output->set_queueflags((uint32_t)input->queueFlags);
    output->set_queuecount((uint32_t)input->queueCount);
    output->set_timestampvalidbits((uint32_t)input->timestampValidBits);
    to_proto_VkExtent3D(handleMapping, &input->minImageTransferGranularity, output->mutable_minimagetransfergranularity());
}

void from_proto_VkQueueFamilyProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkQueueFamilyProperties* input,
    VkQueueFamilyProperties* output)
{
    memset(output, 0x0, sizeof(VkQueueFamilyProperties));
    output->queueFlags = (VkQueueFlags)input->queueflags();
    output->queueCount = (uint32_t)input->queuecount();
    output->timestampValidBits = (uint32_t)input->timestampvalidbits();
    from_proto_VkExtent3D(pool, handleMapping, input->mutable_minimagetransfergranularity(), (VkExtent3D*)(&output->minImageTransferGranularity));
}

void to_proto_VkMemoryType(
    VulkanHandleMapping* handleMapping,
    const VkMemoryType* input,
    goldfish_vk_proto::VkMemoryType* output)
{
    output->set_propertyflags((uint32_t)input->propertyFlags);
    output->set_heapindex((uint32_t)input->heapIndex);
}

void from_proto_VkMemoryType(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryType* input,
    VkMemoryType* output)
{
    memset(output, 0x0, sizeof(VkMemoryType));
    output->propertyFlags = (VkMemoryPropertyFlags)input->propertyflags();
    output->heapIndex = (uint32_t)input->heapindex();
}

void to_proto_VkMemoryHeap(
    VulkanHandleMapping* handleMapping,
    const VkMemoryHeap* input,
    goldfish_vk_proto::VkMemoryHeap* output)
{
    output->set_size((uint64_t)input->size);
    output->set_flags((uint32_t)input->flags);
}

void from_proto_VkMemoryHeap(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryHeap* input,
    VkMemoryHeap* output)
{
    memset(output, 0x0, sizeof(VkMemoryHeap));
    output->size = (VkDeviceSize)input->size();
    output->flags = (VkMemoryHeapFlags)input->flags();
}

void to_proto_VkPhysicalDeviceMemoryProperties(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceMemoryProperties* input,
    goldfish_vk_proto::VkPhysicalDeviceMemoryProperties* output)
{
    output->set_memorytypecount((uint32_t)input->memoryTypeCount);
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        to_proto_VkMemoryType(handleMapping, input->memoryTypes + i, output->add_memorytypes());
    }
    output->set_memoryheapcount((uint32_t)input->memoryHeapCount);
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        to_proto_VkMemoryHeap(handleMapping, input->memoryHeaps + i, output->add_memoryheaps());
    }
}

void from_proto_VkPhysicalDeviceMemoryProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceMemoryProperties* input,
    VkPhysicalDeviceMemoryProperties* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceMemoryProperties));
    output->memoryTypeCount = (uint32_t)input->memorytypecount();
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        from_proto_VkMemoryType(pool, handleMapping, input->mutable_memorytypes(i), (VkMemoryType*)(output->memoryTypes + i));
    }
    output->memoryHeapCount = (uint32_t)input->memoryheapcount();
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        from_proto_VkMemoryHeap(pool, handleMapping, input->mutable_memoryheaps(i), (VkMemoryHeap*)(output->memoryHeaps + i));
    }
}

void to_proto_VkDeviceQueueCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkDeviceQueueCreateInfo* input,
    goldfish_vk_proto::VkDeviceQueueCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_queuefamilyindex((uint32_t)input->queueFamilyIndex);
    output->set_queuecount((uint32_t)input->queueCount);
    for (uint32_t i = 0; i < (uint32_t)input->queueCount; ++i)
    {
        output->add_pqueuepriorities(input->pQueuePriorities[i]);
    }
}

void from_proto_VkDeviceQueueCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceQueueCreateInfo* input,
    VkDeviceQueueCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkDeviceQueueCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkDeviceQueueCreateFlags)input->flags();
    output->queueFamilyIndex = (uint32_t)input->queuefamilyindex();
    output->queueCount = (uint32_t)input->queuecount();
    for (uint32_t i = 0; i < (uint32_t)output->queueCount; ++i)
    {
        *((float*)(&output->pQueuePriorities) + i) = (float)input->pqueuepriorities(i);
    }
}

void to_proto_VkDeviceCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkDeviceCreateInfo* input,
    goldfish_vk_proto::VkDeviceCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_queuecreateinfocount((uint32_t)input->queueCreateInfoCount);
    for (uint32_t i = 0; i < (uint32_t)input->queueCreateInfoCount; ++i)
    {
        to_proto_VkDeviceQueueCreateInfo(handleMapping, input->pQueueCreateInfos + i, output->add_pqueuecreateinfos());
    }
    output->set_enabledlayercount((uint32_t)input->enabledLayerCount);
    for (uint32_t i = 0; i < (uint32_t)input->enabledLayerCount; ++i)
    {
        *(output->add_ppenabledlayernames()) = input->ppEnabledLayerNames[i];
    }
    output->set_enabledextensioncount((uint32_t)input->enabledExtensionCount);
    for (uint32_t i = 0; i < (uint32_t)input->enabledExtensionCount; ++i)
    {
        *(output->add_ppenabledextensionnames()) = input->ppEnabledExtensionNames[i];
    }
    // WARNING PTR CHECK
    if (input->pEnabledFeatures)
    {
        to_proto_VkPhysicalDeviceFeatures(handleMapping, input->pEnabledFeatures, output->mutable_penabledfeatures());
    }
}

void from_proto_VkDeviceCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceCreateInfo* input,
    VkDeviceCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkDeviceCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkDeviceCreateFlags)input->flags();
    output->queueCreateInfoCount = (uint32_t)input->queuecreateinfocount();
    *(void**)&output->pQueueCreateInfos = pool->alloc(output->queueCreateInfoCount * sizeof(const VkDeviceQueueCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)output->queueCreateInfoCount; ++i)
    {
        from_proto_VkDeviceQueueCreateInfo(pool, handleMapping, input->mutable_pqueuecreateinfos(i), (VkDeviceQueueCreateInfo*)(output->pQueueCreateInfos + i));
    }
    output->enabledLayerCount = (uint32_t)input->enabledlayercount();
    if (output->enabledLayerCount)
    {
        *(void**)&output->ppEnabledLayerNames = pool->alloc(output->enabledLayerCount * sizeof(char*));
    }
    for (uint32_t i = 0; i < (uint32_t)output->enabledLayerCount; ++i)
    {
        *(const char**)(&output->ppEnabledLayerNames[i]) = input->ppenabledlayernames(i).c_str();
    }
    output->enabledExtensionCount = (uint32_t)input->enabledextensioncount();
    if (output->enabledExtensionCount)
    {
        *(void**)&output->ppEnabledExtensionNames = pool->alloc(output->enabledExtensionCount * sizeof(char*));
    }
    for (uint32_t i = 0; i < (uint32_t)output->enabledExtensionCount; ++i)
    {
        *(const char**)(&output->ppEnabledExtensionNames[i]) = input->ppenabledextensionnames(i).c_str();
    }
    // WARNING PTR CHECK
    if (input->has_penabledfeatures())
    {
        *(void**)&output->pEnabledFeatures = pool->alloc(sizeof(const VkPhysicalDeviceFeatures));
        from_proto_VkPhysicalDeviceFeatures(pool, handleMapping, input->mutable_penabledfeatures(), (VkPhysicalDeviceFeatures*)(output->pEnabledFeatures));
    }
}

void to_proto_VkExtensionProperties(
    VulkanHandleMapping* handleMapping,
    const VkExtensionProperties* input,
    goldfish_vk_proto::VkExtensionProperties* output)
{
    output->set_extensionname(input->extensionName);
    output->set_specversion((uint32_t)input->specVersion);
}

void from_proto_VkExtensionProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExtensionProperties* input,
    VkExtensionProperties* output)
{
    memset(output, 0x0, sizeof(VkExtensionProperties));
    memset(output->extensionName, 0x0, VK_MAX_EXTENSION_NAME_SIZE);
    strncpy(output->extensionName, input->extensionname().c_str(), strlen(input->extensionname().c_str()));
    output->specVersion = (uint32_t)input->specversion();
}

void to_proto_VkLayerProperties(
    VulkanHandleMapping* handleMapping,
    const VkLayerProperties* input,
    goldfish_vk_proto::VkLayerProperties* output)
{
    output->set_layername(input->layerName);
    output->set_specversion((uint32_t)input->specVersion);
    output->set_implementationversion((uint32_t)input->implementationVersion);
    output->set_description(input->description);
}

void from_proto_VkLayerProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkLayerProperties* input,
    VkLayerProperties* output)
{
    memset(output, 0x0, sizeof(VkLayerProperties));
    memset(output->layerName, 0x0, VK_MAX_EXTENSION_NAME_SIZE);
    strncpy(output->layerName, input->layername().c_str(), strlen(input->layername().c_str()));
    output->specVersion = (uint32_t)input->specversion();
    output->implementationVersion = (uint32_t)input->implementationversion();
    memset(output->description, 0x0, VK_MAX_DESCRIPTION_SIZE);
    strncpy(output->description, input->description().c_str(), strlen(input->description().c_str()));
}

void to_proto_VkSubmitInfo(
    VulkanHandleMapping* handleMapping,
    const VkSubmitInfo* input,
    goldfish_vk_proto::VkSubmitInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_waitsemaphorecount((uint32_t)input->waitSemaphoreCount);
    if (input->waitSemaphoreCount)
    {
        std::vector<uint64_t> cgen_var_0(input->waitSemaphoreCount);
        handleMapping->mapHandles_VkSemaphore_u64(input->pWaitSemaphores, cgen_var_0.data(), input->waitSemaphoreCount);
        for (uint32_t i = 0; i < input->waitSemaphoreCount; ++i)
        {
            output->add_pwaitsemaphores(cgen_var_0[i]);
        }
    }
    for (uint32_t i = 0; i < (uint32_t)input->waitSemaphoreCount; ++i)
    {
        output->add_pwaitdststagemask(input->pWaitDstStageMask[i]);
    }
    output->set_commandbuffercount((uint32_t)input->commandBufferCount);
    if (input->commandBufferCount)
    {
        std::vector<uint64_t> cgen_var_1(input->commandBufferCount);
        handleMapping->mapHandles_VkCommandBuffer_u64(input->pCommandBuffers, cgen_var_1.data(), input->commandBufferCount);
        for (uint32_t i = 0; i < input->commandBufferCount; ++i)
        {
            output->add_pcommandbuffers(cgen_var_1[i]);
        }
    }
    output->set_signalsemaphorecount((uint32_t)input->signalSemaphoreCount);
    if (input->signalSemaphoreCount)
    {
        std::vector<uint64_t> cgen_var_2(input->signalSemaphoreCount);
        handleMapping->mapHandles_VkSemaphore_u64(input->pSignalSemaphores, cgen_var_2.data(), input->signalSemaphoreCount);
        for (uint32_t i = 0; i < input->signalSemaphoreCount; ++i)
        {
            output->add_psignalsemaphores(cgen_var_2[i]);
        }
    }
}

void from_proto_VkSubmitInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSubmitInfo* input,
    VkSubmitInfo* output)
{
    memset(output, 0x0, sizeof(VkSubmitInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->waitSemaphoreCount = (uint32_t)input->waitsemaphorecount();
    if (output->waitSemaphoreCount)
    {
        for (uint32_t i = 0; i < output->waitSemaphoreCount; ++i)
        {
            uint64_t current = input->pwaitsemaphores(i);
            handleMapping->mapHandles_u64_VkSemaphore(&current, (VkSemaphore*)&output->pWaitSemaphores[i], 1);
        }
    }
    for (uint32_t i = 0; i < (uint32_t)output->waitSemaphoreCount; ++i)
    {
        *((VkPipelineStageFlags*)(&output->pWaitDstStageMask) + i) = (VkPipelineStageFlags)input->pwaitdststagemask(i);
    }
    output->commandBufferCount = (uint32_t)input->commandbuffercount();
    if (output->commandBufferCount)
    {
        for (uint32_t i = 0; i < output->commandBufferCount; ++i)
        {
            uint64_t current = input->pcommandbuffers(i);
            handleMapping->mapHandles_u64_VkCommandBuffer(&current, (VkCommandBuffer*)&output->pCommandBuffers[i], 1);
        }
    }
    output->signalSemaphoreCount = (uint32_t)input->signalsemaphorecount();
    if (output->signalSemaphoreCount)
    {
        for (uint32_t i = 0; i < output->signalSemaphoreCount; ++i)
        {
            uint64_t current = input->psignalsemaphores(i);
            handleMapping->mapHandles_u64_VkSemaphore(&current, (VkSemaphore*)&output->pSignalSemaphores[i], 1);
        }
    }
}

void to_proto_VkMemoryAllocateInfo(
    VulkanHandleMapping* handleMapping,
    const VkMemoryAllocateInfo* input,
    goldfish_vk_proto::VkMemoryAllocateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_allocationsize((uint64_t)input->allocationSize);
    output->set_memorytypeindex((uint32_t)input->memoryTypeIndex);
}

void from_proto_VkMemoryAllocateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryAllocateInfo* input,
    VkMemoryAllocateInfo* output)
{
    memset(output, 0x0, sizeof(VkMemoryAllocateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->allocationSize = (VkDeviceSize)input->allocationsize();
    output->memoryTypeIndex = (uint32_t)input->memorytypeindex();
}

void to_proto_VkMappedMemoryRange(
    VulkanHandleMapping* handleMapping,
    const VkMappedMemoryRange* input,
    goldfish_vk_proto::VkMappedMemoryRange* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_3;
    handleMapping->mapHandles_VkDeviceMemory_u64(&input->memory, &cgen_var_3, 1);
    output->set_memory(cgen_var_3);
    output->set_offset((uint64_t)input->offset);
    output->set_size((uint64_t)input->size);
}

void from_proto_VkMappedMemoryRange(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMappedMemoryRange* input,
    VkMappedMemoryRange* output)
{
    memset(output, 0x0, sizeof(VkMappedMemoryRange));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->memory();
        handleMapping->mapHandles_u64_VkDeviceMemory(&current, (VkDeviceMemory*)&output->memory, 1);
    }
    output->offset = (VkDeviceSize)input->offset();
    output->size = (VkDeviceSize)input->size();
}

void to_proto_VkMemoryRequirements(
    VulkanHandleMapping* handleMapping,
    const VkMemoryRequirements* input,
    goldfish_vk_proto::VkMemoryRequirements* output)
{
    output->set_size((uint64_t)input->size);
    output->set_alignment((uint64_t)input->alignment);
    output->set_memorytypebits((uint32_t)input->memoryTypeBits);
}

void from_proto_VkMemoryRequirements(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryRequirements* input,
    VkMemoryRequirements* output)
{
    memset(output, 0x0, sizeof(VkMemoryRequirements));
    output->size = (VkDeviceSize)input->size();
    output->alignment = (VkDeviceSize)input->alignment();
    output->memoryTypeBits = (uint32_t)input->memorytypebits();
}

void to_proto_VkSparseImageFormatProperties(
    VulkanHandleMapping* handleMapping,
    const VkSparseImageFormatProperties* input,
    goldfish_vk_proto::VkSparseImageFormatProperties* output)
{
    output->set_aspectmask((uint32_t)input->aspectMask);
    to_proto_VkExtent3D(handleMapping, &input->imageGranularity, output->mutable_imagegranularity());
    output->set_flags((uint32_t)input->flags);
}

void from_proto_VkSparseImageFormatProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSparseImageFormatProperties* input,
    VkSparseImageFormatProperties* output)
{
    memset(output, 0x0, sizeof(VkSparseImageFormatProperties));
    output->aspectMask = (VkImageAspectFlags)input->aspectmask();
    from_proto_VkExtent3D(pool, handleMapping, input->mutable_imagegranularity(), (VkExtent3D*)(&output->imageGranularity));
    output->flags = (VkSparseImageFormatFlags)input->flags();
}

void to_proto_VkSparseImageMemoryRequirements(
    VulkanHandleMapping* handleMapping,
    const VkSparseImageMemoryRequirements* input,
    goldfish_vk_proto::VkSparseImageMemoryRequirements* output)
{
    to_proto_VkSparseImageFormatProperties(handleMapping, &input->formatProperties, output->mutable_formatproperties());
    output->set_imagemiptailfirstlod((uint32_t)input->imageMipTailFirstLod);
    output->set_imagemiptailsize((uint64_t)input->imageMipTailSize);
    output->set_imagemiptailoffset((uint64_t)input->imageMipTailOffset);
    output->set_imagemiptailstride((uint64_t)input->imageMipTailStride);
}

void from_proto_VkSparseImageMemoryRequirements(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSparseImageMemoryRequirements* input,
    VkSparseImageMemoryRequirements* output)
{
    memset(output, 0x0, sizeof(VkSparseImageMemoryRequirements));
    from_proto_VkSparseImageFormatProperties(pool, handleMapping, input->mutable_formatproperties(), (VkSparseImageFormatProperties*)(&output->formatProperties));
    output->imageMipTailFirstLod = (uint32_t)input->imagemiptailfirstlod();
    output->imageMipTailSize = (VkDeviceSize)input->imagemiptailsize();
    output->imageMipTailOffset = (VkDeviceSize)input->imagemiptailoffset();
    output->imageMipTailStride = (VkDeviceSize)input->imagemiptailstride();
}

void to_proto_VkSparseMemoryBind(
    VulkanHandleMapping* handleMapping,
    const VkSparseMemoryBind* input,
    goldfish_vk_proto::VkSparseMemoryBind* output)
{
    output->set_resourceoffset((uint64_t)input->resourceOffset);
    output->set_size((uint64_t)input->size);
    uint64_t cgen_var_4;
    handleMapping->mapHandles_VkDeviceMemory_u64(&input->memory, &cgen_var_4, 1);
    output->set_memory(cgen_var_4);
    output->set_memoryoffset((uint64_t)input->memoryOffset);
    output->set_flags((uint32_t)input->flags);
}

void from_proto_VkSparseMemoryBind(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSparseMemoryBind* input,
    VkSparseMemoryBind* output)
{
    memset(output, 0x0, sizeof(VkSparseMemoryBind));
    output->resourceOffset = (VkDeviceSize)input->resourceoffset();
    output->size = (VkDeviceSize)input->size();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->memory();
        handleMapping->mapHandles_u64_VkDeviceMemory(&current, (VkDeviceMemory*)&output->memory, 1);
    }
    output->memoryOffset = (VkDeviceSize)input->memoryoffset();
    output->flags = (VkSparseMemoryBindFlags)input->flags();
}

void to_proto_VkSparseBufferMemoryBindInfo(
    VulkanHandleMapping* handleMapping,
    const VkSparseBufferMemoryBindInfo* input,
    goldfish_vk_proto::VkSparseBufferMemoryBindInfo* output)
{
    uint64_t cgen_var_5;
    handleMapping->mapHandles_VkBuffer_u64(&input->buffer, &cgen_var_5, 1);
    output->set_buffer(cgen_var_5);
    output->set_bindcount((uint32_t)input->bindCount);
    for (uint32_t i = 0; i < (uint32_t)input->bindCount; ++i)
    {
        to_proto_VkSparseMemoryBind(handleMapping, input->pBinds + i, output->add_pbinds());
    }
}

void from_proto_VkSparseBufferMemoryBindInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSparseBufferMemoryBindInfo* input,
    VkSparseBufferMemoryBindInfo* output)
{
    memset(output, 0x0, sizeof(VkSparseBufferMemoryBindInfo));
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->buffer();
        handleMapping->mapHandles_u64_VkBuffer(&current, (VkBuffer*)&output->buffer, 1);
    }
    output->bindCount = (uint32_t)input->bindcount();
    *(void**)&output->pBinds = pool->alloc(output->bindCount * sizeof(const VkSparseMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)output->bindCount; ++i)
    {
        from_proto_VkSparseMemoryBind(pool, handleMapping, input->mutable_pbinds(i), (VkSparseMemoryBind*)(output->pBinds + i));
    }
}

void to_proto_VkSparseImageOpaqueMemoryBindInfo(
    VulkanHandleMapping* handleMapping,
    const VkSparseImageOpaqueMemoryBindInfo* input,
    goldfish_vk_proto::VkSparseImageOpaqueMemoryBindInfo* output)
{
    uint64_t cgen_var_6;
    handleMapping->mapHandles_VkImage_u64(&input->image, &cgen_var_6, 1);
    output->set_image(cgen_var_6);
    output->set_bindcount((uint32_t)input->bindCount);
    for (uint32_t i = 0; i < (uint32_t)input->bindCount; ++i)
    {
        to_proto_VkSparseMemoryBind(handleMapping, input->pBinds + i, output->add_pbinds());
    }
}

void from_proto_VkSparseImageOpaqueMemoryBindInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSparseImageOpaqueMemoryBindInfo* input,
    VkSparseImageOpaqueMemoryBindInfo* output)
{
    memset(output, 0x0, sizeof(VkSparseImageOpaqueMemoryBindInfo));
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->image();
        handleMapping->mapHandles_u64_VkImage(&current, (VkImage*)&output->image, 1);
    }
    output->bindCount = (uint32_t)input->bindcount();
    *(void**)&output->pBinds = pool->alloc(output->bindCount * sizeof(const VkSparseMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)output->bindCount; ++i)
    {
        from_proto_VkSparseMemoryBind(pool, handleMapping, input->mutable_pbinds(i), (VkSparseMemoryBind*)(output->pBinds + i));
    }
}

void to_proto_VkImageSubresource(
    VulkanHandleMapping* handleMapping,
    const VkImageSubresource* input,
    goldfish_vk_proto::VkImageSubresource* output)
{
    output->set_aspectmask((uint32_t)input->aspectMask);
    output->set_miplevel((uint32_t)input->mipLevel);
    output->set_arraylayer((uint32_t)input->arrayLayer);
}

void from_proto_VkImageSubresource(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageSubresource* input,
    VkImageSubresource* output)
{
    memset(output, 0x0, sizeof(VkImageSubresource));
    output->aspectMask = (VkImageAspectFlags)input->aspectmask();
    output->mipLevel = (uint32_t)input->miplevel();
    output->arrayLayer = (uint32_t)input->arraylayer();
}

void to_proto_VkOffset3D(
    VulkanHandleMapping* handleMapping,
    const VkOffset3D* input,
    goldfish_vk_proto::VkOffset3D* output)
{
    output->set_x((int32_t)input->x);
    output->set_y((int32_t)input->y);
    output->set_z((int32_t)input->z);
}

void from_proto_VkOffset3D(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkOffset3D* input,
    VkOffset3D* output)
{
    memset(output, 0x0, sizeof(VkOffset3D));
    output->x = (int32_t)input->x();
    output->y = (int32_t)input->y();
    output->z = (int32_t)input->z();
}

void to_proto_VkSparseImageMemoryBind(
    VulkanHandleMapping* handleMapping,
    const VkSparseImageMemoryBind* input,
    goldfish_vk_proto::VkSparseImageMemoryBind* output)
{
    to_proto_VkImageSubresource(handleMapping, &input->subresource, output->mutable_subresource());
    to_proto_VkOffset3D(handleMapping, &input->offset, output->mutable_offset());
    to_proto_VkExtent3D(handleMapping, &input->extent, output->mutable_extent());
    uint64_t cgen_var_7;
    handleMapping->mapHandles_VkDeviceMemory_u64(&input->memory, &cgen_var_7, 1);
    output->set_memory(cgen_var_7);
    output->set_memoryoffset((uint64_t)input->memoryOffset);
    output->set_flags((uint32_t)input->flags);
}

void from_proto_VkSparseImageMemoryBind(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSparseImageMemoryBind* input,
    VkSparseImageMemoryBind* output)
{
    memset(output, 0x0, sizeof(VkSparseImageMemoryBind));
    from_proto_VkImageSubresource(pool, handleMapping, input->mutable_subresource(), (VkImageSubresource*)(&output->subresource));
    from_proto_VkOffset3D(pool, handleMapping, input->mutable_offset(), (VkOffset3D*)(&output->offset));
    from_proto_VkExtent3D(pool, handleMapping, input->mutable_extent(), (VkExtent3D*)(&output->extent));
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->memory();
        handleMapping->mapHandles_u64_VkDeviceMemory(&current, (VkDeviceMemory*)&output->memory, 1);
    }
    output->memoryOffset = (VkDeviceSize)input->memoryoffset();
    output->flags = (VkSparseMemoryBindFlags)input->flags();
}

void to_proto_VkSparseImageMemoryBindInfo(
    VulkanHandleMapping* handleMapping,
    const VkSparseImageMemoryBindInfo* input,
    goldfish_vk_proto::VkSparseImageMemoryBindInfo* output)
{
    uint64_t cgen_var_8;
    handleMapping->mapHandles_VkImage_u64(&input->image, &cgen_var_8, 1);
    output->set_image(cgen_var_8);
    output->set_bindcount((uint32_t)input->bindCount);
    for (uint32_t i = 0; i < (uint32_t)input->bindCount; ++i)
    {
        to_proto_VkSparseImageMemoryBind(handleMapping, input->pBinds + i, output->add_pbinds());
    }
}

void from_proto_VkSparseImageMemoryBindInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSparseImageMemoryBindInfo* input,
    VkSparseImageMemoryBindInfo* output)
{
    memset(output, 0x0, sizeof(VkSparseImageMemoryBindInfo));
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->image();
        handleMapping->mapHandles_u64_VkImage(&current, (VkImage*)&output->image, 1);
    }
    output->bindCount = (uint32_t)input->bindcount();
    *(void**)&output->pBinds = pool->alloc(output->bindCount * sizeof(const VkSparseImageMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)output->bindCount; ++i)
    {
        from_proto_VkSparseImageMemoryBind(pool, handleMapping, input->mutable_pbinds(i), (VkSparseImageMemoryBind*)(output->pBinds + i));
    }
}

void to_proto_VkBindSparseInfo(
    VulkanHandleMapping* handleMapping,
    const VkBindSparseInfo* input,
    goldfish_vk_proto::VkBindSparseInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_waitsemaphorecount((uint32_t)input->waitSemaphoreCount);
    if (input->waitSemaphoreCount)
    {
        std::vector<uint64_t> cgen_var_9(input->waitSemaphoreCount);
        handleMapping->mapHandles_VkSemaphore_u64(input->pWaitSemaphores, cgen_var_9.data(), input->waitSemaphoreCount);
        for (uint32_t i = 0; i < input->waitSemaphoreCount; ++i)
        {
            output->add_pwaitsemaphores(cgen_var_9[i]);
        }
    }
    output->set_bufferbindcount((uint32_t)input->bufferBindCount);
    for (uint32_t i = 0; i < (uint32_t)input->bufferBindCount; ++i)
    {
        to_proto_VkSparseBufferMemoryBindInfo(handleMapping, input->pBufferBinds + i, output->add_pbufferbinds());
    }
    output->set_imageopaquebindcount((uint32_t)input->imageOpaqueBindCount);
    for (uint32_t i = 0; i < (uint32_t)input->imageOpaqueBindCount; ++i)
    {
        to_proto_VkSparseImageOpaqueMemoryBindInfo(handleMapping, input->pImageOpaqueBinds + i, output->add_pimageopaquebinds());
    }
    output->set_imagebindcount((uint32_t)input->imageBindCount);
    for (uint32_t i = 0; i < (uint32_t)input->imageBindCount; ++i)
    {
        to_proto_VkSparseImageMemoryBindInfo(handleMapping, input->pImageBinds + i, output->add_pimagebinds());
    }
    output->set_signalsemaphorecount((uint32_t)input->signalSemaphoreCount);
    if (input->signalSemaphoreCount)
    {
        std::vector<uint64_t> cgen_var_10(input->signalSemaphoreCount);
        handleMapping->mapHandles_VkSemaphore_u64(input->pSignalSemaphores, cgen_var_10.data(), input->signalSemaphoreCount);
        for (uint32_t i = 0; i < input->signalSemaphoreCount; ++i)
        {
            output->add_psignalsemaphores(cgen_var_10[i]);
        }
    }
}

void from_proto_VkBindSparseInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBindSparseInfo* input,
    VkBindSparseInfo* output)
{
    memset(output, 0x0, sizeof(VkBindSparseInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->waitSemaphoreCount = (uint32_t)input->waitsemaphorecount();
    if (output->waitSemaphoreCount)
    {
        for (uint32_t i = 0; i < output->waitSemaphoreCount; ++i)
        {
            uint64_t current = input->pwaitsemaphores(i);
            handleMapping->mapHandles_u64_VkSemaphore(&current, (VkSemaphore*)&output->pWaitSemaphores[i], 1);
        }
    }
    output->bufferBindCount = (uint32_t)input->bufferbindcount();
    *(void**)&output->pBufferBinds = pool->alloc(output->bufferBindCount * sizeof(const VkSparseBufferMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)output->bufferBindCount; ++i)
    {
        from_proto_VkSparseBufferMemoryBindInfo(pool, handleMapping, input->mutable_pbufferbinds(i), (VkSparseBufferMemoryBindInfo*)(output->pBufferBinds + i));
    }
    output->imageOpaqueBindCount = (uint32_t)input->imageopaquebindcount();
    *(void**)&output->pImageOpaqueBinds = pool->alloc(output->imageOpaqueBindCount * sizeof(const VkSparseImageOpaqueMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)output->imageOpaqueBindCount; ++i)
    {
        from_proto_VkSparseImageOpaqueMemoryBindInfo(pool, handleMapping, input->mutable_pimageopaquebinds(i), (VkSparseImageOpaqueMemoryBindInfo*)(output->pImageOpaqueBinds + i));
    }
    output->imageBindCount = (uint32_t)input->imagebindcount();
    *(void**)&output->pImageBinds = pool->alloc(output->imageBindCount * sizeof(const VkSparseImageMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)output->imageBindCount; ++i)
    {
        from_proto_VkSparseImageMemoryBindInfo(pool, handleMapping, input->mutable_pimagebinds(i), (VkSparseImageMemoryBindInfo*)(output->pImageBinds + i));
    }
    output->signalSemaphoreCount = (uint32_t)input->signalsemaphorecount();
    if (output->signalSemaphoreCount)
    {
        for (uint32_t i = 0; i < output->signalSemaphoreCount; ++i)
        {
            uint64_t current = input->psignalsemaphores(i);
            handleMapping->mapHandles_u64_VkSemaphore(&current, (VkSemaphore*)&output->pSignalSemaphores[i], 1);
        }
    }
}

void to_proto_VkFenceCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkFenceCreateInfo* input,
    goldfish_vk_proto::VkFenceCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
}

void from_proto_VkFenceCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkFenceCreateInfo* input,
    VkFenceCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkFenceCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkFenceCreateFlags)input->flags();
}

void to_proto_VkSemaphoreCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkSemaphoreCreateInfo* input,
    goldfish_vk_proto::VkSemaphoreCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
}

void from_proto_VkSemaphoreCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSemaphoreCreateInfo* input,
    VkSemaphoreCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkSemaphoreCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkSemaphoreCreateFlags)input->flags();
}

void to_proto_VkEventCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkEventCreateInfo* input,
    goldfish_vk_proto::VkEventCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
}

void from_proto_VkEventCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkEventCreateInfo* input,
    VkEventCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkEventCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkEventCreateFlags)input->flags();
}

void to_proto_VkQueryPoolCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkQueryPoolCreateInfo* input,
    goldfish_vk_proto::VkQueryPoolCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_querytype((uint32_t)input->queryType);
    output->set_querycount((uint32_t)input->queryCount);
    output->set_pipelinestatistics((uint32_t)input->pipelineStatistics);
}

void from_proto_VkQueryPoolCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkQueryPoolCreateInfo* input,
    VkQueryPoolCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkQueryPoolCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkQueryPoolCreateFlags)input->flags();
    output->queryType = (VkQueryType)input->querytype();
    output->queryCount = (uint32_t)input->querycount();
    output->pipelineStatistics = (VkQueryPipelineStatisticFlags)input->pipelinestatistics();
}

void to_proto_VkBufferCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkBufferCreateInfo* input,
    goldfish_vk_proto::VkBufferCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_size((uint64_t)input->size);
    output->set_usage((uint32_t)input->usage);
    output->set_sharingmode((uint32_t)input->sharingMode);
    output->set_queuefamilyindexcount((uint32_t)input->queueFamilyIndexCount);
    // WARNING PTR CHECK
    if (input->pQueueFamilyIndices)
    {
        for (uint32_t i = 0; i < (uint32_t)input->queueFamilyIndexCount; ++i)
        {
            output->add_pqueuefamilyindices(input->pQueueFamilyIndices[i]);
        }
    }
}

void from_proto_VkBufferCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBufferCreateInfo* input,
    VkBufferCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkBufferCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkBufferCreateFlags)input->flags();
    output->size = (VkDeviceSize)input->size();
    output->usage = (VkBufferUsageFlags)input->usage();
    output->sharingMode = (VkSharingMode)input->sharingmode();
    output->queueFamilyIndexCount = (uint32_t)input->queuefamilyindexcount();
    // WARNING PTR CHECK
    if (input->pqueuefamilyindices_size())
    {
        for (uint32_t i = 0; i < (uint32_t)output->queueFamilyIndexCount; ++i)
        {
            *((uint32_t*)(&output->pQueueFamilyIndices) + i) = (uint32_t)input->pqueuefamilyindices(i);
        }
    }
}

void to_proto_VkBufferViewCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkBufferViewCreateInfo* input,
    goldfish_vk_proto::VkBufferViewCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    uint64_t cgen_var_11;
    handleMapping->mapHandles_VkBuffer_u64(&input->buffer, &cgen_var_11, 1);
    output->set_buffer(cgen_var_11);
    output->set_format((uint32_t)input->format);
    output->set_offset((uint64_t)input->offset);
    output->set_range((uint64_t)input->range);
}

void from_proto_VkBufferViewCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBufferViewCreateInfo* input,
    VkBufferViewCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkBufferViewCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkBufferViewCreateFlags)input->flags();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->buffer();
        handleMapping->mapHandles_u64_VkBuffer(&current, (VkBuffer*)&output->buffer, 1);
    }
    output->format = (VkFormat)input->format();
    output->offset = (VkDeviceSize)input->offset();
    output->range = (VkDeviceSize)input->range();
}

void to_proto_VkImageCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkImageCreateInfo* input,
    goldfish_vk_proto::VkImageCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_imagetype((uint32_t)input->imageType);
    output->set_format((uint32_t)input->format);
    to_proto_VkExtent3D(handleMapping, &input->extent, output->mutable_extent());
    output->set_miplevels((uint32_t)input->mipLevels);
    output->set_arraylayers((uint32_t)input->arrayLayers);
    output->set_samples((uint32_t)input->samples);
    output->set_tiling((uint32_t)input->tiling);
    output->set_usage((uint32_t)input->usage);
    output->set_sharingmode((uint32_t)input->sharingMode);
    output->set_queuefamilyindexcount((uint32_t)input->queueFamilyIndexCount);
    // WARNING PTR CHECK
    if (input->pQueueFamilyIndices)
    {
        for (uint32_t i = 0; i < (uint32_t)input->queueFamilyIndexCount; ++i)
        {
            output->add_pqueuefamilyindices(input->pQueueFamilyIndices[i]);
        }
    }
    output->set_initiallayout((uint32_t)input->initialLayout);
}

void from_proto_VkImageCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageCreateInfo* input,
    VkImageCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkImageCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkImageCreateFlags)input->flags();
    output->imageType = (VkImageType)input->imagetype();
    output->format = (VkFormat)input->format();
    from_proto_VkExtent3D(pool, handleMapping, input->mutable_extent(), (VkExtent3D*)(&output->extent));
    output->mipLevels = (uint32_t)input->miplevels();
    output->arrayLayers = (uint32_t)input->arraylayers();
    output->samples = (VkSampleCountFlagBits)input->samples();
    output->tiling = (VkImageTiling)input->tiling();
    output->usage = (VkImageUsageFlags)input->usage();
    output->sharingMode = (VkSharingMode)input->sharingmode();
    output->queueFamilyIndexCount = (uint32_t)input->queuefamilyindexcount();
    // WARNING PTR CHECK
    if (input->pqueuefamilyindices_size())
    {
        for (uint32_t i = 0; i < (uint32_t)output->queueFamilyIndexCount; ++i)
        {
            *((uint32_t*)(&output->pQueueFamilyIndices) + i) = (uint32_t)input->pqueuefamilyindices(i);
        }
    }
    output->initialLayout = (VkImageLayout)input->initiallayout();
}

void to_proto_VkSubresourceLayout(
    VulkanHandleMapping* handleMapping,
    const VkSubresourceLayout* input,
    goldfish_vk_proto::VkSubresourceLayout* output)
{
    output->set_offset((uint64_t)input->offset);
    output->set_size((uint64_t)input->size);
    output->set_rowpitch((uint64_t)input->rowPitch);
    output->set_arraypitch((uint64_t)input->arrayPitch);
    output->set_depthpitch((uint64_t)input->depthPitch);
}

void from_proto_VkSubresourceLayout(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSubresourceLayout* input,
    VkSubresourceLayout* output)
{
    memset(output, 0x0, sizeof(VkSubresourceLayout));
    output->offset = (VkDeviceSize)input->offset();
    output->size = (VkDeviceSize)input->size();
    output->rowPitch = (VkDeviceSize)input->rowpitch();
    output->arrayPitch = (VkDeviceSize)input->arraypitch();
    output->depthPitch = (VkDeviceSize)input->depthpitch();
}

void to_proto_VkComponentMapping(
    VulkanHandleMapping* handleMapping,
    const VkComponentMapping* input,
    goldfish_vk_proto::VkComponentMapping* output)
{
    output->set_r((uint32_t)input->r);
    output->set_g((uint32_t)input->g);
    output->set_b((uint32_t)input->b);
    output->set_a((uint32_t)input->a);
}

void from_proto_VkComponentMapping(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkComponentMapping* input,
    VkComponentMapping* output)
{
    memset(output, 0x0, sizeof(VkComponentMapping));
    output->r = (VkComponentSwizzle)input->r();
    output->g = (VkComponentSwizzle)input->g();
    output->b = (VkComponentSwizzle)input->b();
    output->a = (VkComponentSwizzle)input->a();
}

void to_proto_VkImageSubresourceRange(
    VulkanHandleMapping* handleMapping,
    const VkImageSubresourceRange* input,
    goldfish_vk_proto::VkImageSubresourceRange* output)
{
    output->set_aspectmask((uint32_t)input->aspectMask);
    output->set_basemiplevel((uint32_t)input->baseMipLevel);
    output->set_levelcount((uint32_t)input->levelCount);
    output->set_basearraylayer((uint32_t)input->baseArrayLayer);
    output->set_layercount((uint32_t)input->layerCount);
}

void from_proto_VkImageSubresourceRange(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageSubresourceRange* input,
    VkImageSubresourceRange* output)
{
    memset(output, 0x0, sizeof(VkImageSubresourceRange));
    output->aspectMask = (VkImageAspectFlags)input->aspectmask();
    output->baseMipLevel = (uint32_t)input->basemiplevel();
    output->levelCount = (uint32_t)input->levelcount();
    output->baseArrayLayer = (uint32_t)input->basearraylayer();
    output->layerCount = (uint32_t)input->layercount();
}

void to_proto_VkImageViewCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkImageViewCreateInfo* input,
    goldfish_vk_proto::VkImageViewCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    uint64_t cgen_var_12;
    handleMapping->mapHandles_VkImage_u64(&input->image, &cgen_var_12, 1);
    output->set_image(cgen_var_12);
    output->set_viewtype((uint32_t)input->viewType);
    output->set_format((uint32_t)input->format);
    to_proto_VkComponentMapping(handleMapping, &input->components, output->mutable_components());
    to_proto_VkImageSubresourceRange(handleMapping, &input->subresourceRange, output->mutable_subresourcerange());
}

void from_proto_VkImageViewCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageViewCreateInfo* input,
    VkImageViewCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkImageViewCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkImageViewCreateFlags)input->flags();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->image();
        handleMapping->mapHandles_u64_VkImage(&current, (VkImage*)&output->image, 1);
    }
    output->viewType = (VkImageViewType)input->viewtype();
    output->format = (VkFormat)input->format();
    from_proto_VkComponentMapping(pool, handleMapping, input->mutable_components(), (VkComponentMapping*)(&output->components));
    from_proto_VkImageSubresourceRange(pool, handleMapping, input->mutable_subresourcerange(), (VkImageSubresourceRange*)(&output->subresourceRange));
}

void to_proto_VkShaderModuleCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkShaderModuleCreateInfo* input,
    goldfish_vk_proto::VkShaderModuleCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_codesize((uint64_t)input->codeSize);
    for (uint32_t i = 0; i < (uint32_t)(input->codeSize / 4); ++i)
    {
        output->add_pcode(input->pCode[i]);
    }
}

void from_proto_VkShaderModuleCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkShaderModuleCreateInfo* input,
    VkShaderModuleCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkShaderModuleCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkShaderModuleCreateFlags)input->flags();
    output->codeSize = (size_t)input->codesize();
    for (uint32_t i = 0; i < (uint32_t)(output->codeSize / 4); ++i)
    {
        *((uint32_t*)(&output->pCode) + i) = (uint32_t)input->pcode(i);
    }
}

void to_proto_VkPipelineCacheCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkPipelineCacheCreateInfo* input,
    goldfish_vk_proto::VkPipelineCacheCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_initialdatasize((uint64_t)input->initialDataSize);
    for (uint32_t i = 0; i < (uint32_t)input->initialDataSize; ++i)
    {
        output->add_pinitialdata(((const char*)(input->pInitialData))[i]);
    }
}

void from_proto_VkPipelineCacheCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineCacheCreateInfo* input,
    VkPipelineCacheCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkPipelineCacheCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineCacheCreateFlags)input->flags();
    output->initialDataSize = (size_t)input->initialdatasize();
    for (uint32_t i = 0; i < (uint32_t)output->initialDataSize; ++i)
    {
        *((char*)(&output->pInitialData) + i) = (char)input->pinitialdata(i);
    }
}

void to_proto_VkSpecializationMapEntry(
    VulkanHandleMapping* handleMapping,
    const VkSpecializationMapEntry* input,
    goldfish_vk_proto::VkSpecializationMapEntry* output)
{
    output->set_constantid((uint32_t)input->constantID);
    output->set_offset((uint32_t)input->offset);
    output->set_size((uint64_t)input->size);
}

void from_proto_VkSpecializationMapEntry(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSpecializationMapEntry* input,
    VkSpecializationMapEntry* output)
{
    memset(output, 0x0, sizeof(VkSpecializationMapEntry));
    output->constantID = (uint32_t)input->constantid();
    output->offset = (uint32_t)input->offset();
    output->size = (size_t)input->size();
}

void to_proto_VkSpecializationInfo(
    VulkanHandleMapping* handleMapping,
    const VkSpecializationInfo* input,
    goldfish_vk_proto::VkSpecializationInfo* output)
{
    output->set_mapentrycount((uint32_t)input->mapEntryCount);
    for (uint32_t i = 0; i < (uint32_t)input->mapEntryCount; ++i)
    {
        to_proto_VkSpecializationMapEntry(handleMapping, input->pMapEntries + i, output->add_pmapentries());
    }
    output->set_datasize((uint64_t)input->dataSize);
    for (uint32_t i = 0; i < (uint32_t)input->dataSize; ++i)
    {
        output->add_pdata(((const char*)(input->pData))[i]);
    }
}

void from_proto_VkSpecializationInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSpecializationInfo* input,
    VkSpecializationInfo* output)
{
    memset(output, 0x0, sizeof(VkSpecializationInfo));
    output->mapEntryCount = (uint32_t)input->mapentrycount();
    *(void**)&output->pMapEntries = pool->alloc(output->mapEntryCount * sizeof(const VkSpecializationMapEntry));
    for (uint32_t i = 0; i < (uint32_t)output->mapEntryCount; ++i)
    {
        from_proto_VkSpecializationMapEntry(pool, handleMapping, input->mutable_pmapentries(i), (VkSpecializationMapEntry*)(output->pMapEntries + i));
    }
    output->dataSize = (size_t)input->datasize();
    for (uint32_t i = 0; i < (uint32_t)output->dataSize; ++i)
    {
        *((char*)(&output->pData) + i) = (char)input->pdata(i);
    }
}

void to_proto_VkPipelineShaderStageCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkPipelineShaderStageCreateInfo* input,
    goldfish_vk_proto::VkPipelineShaderStageCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_stage((uint32_t)input->stage);
    uint64_t cgen_var_13;
    handleMapping->mapHandles_VkShaderModule_u64(&input->module, &cgen_var_13, 1);
    output->set_module(cgen_var_13);
    output->set_pname(input->pName);
    // WARNING PTR CHECK
    if (input->pSpecializationInfo)
    {
        to_proto_VkSpecializationInfo(handleMapping, input->pSpecializationInfo, output->mutable_pspecializationinfo());
    }
}

void from_proto_VkPipelineShaderStageCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineShaderStageCreateInfo* input,
    VkPipelineShaderStageCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkPipelineShaderStageCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineShaderStageCreateFlags)input->flags();
    output->stage = (VkShaderStageFlagBits)input->stage();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->module();
        handleMapping->mapHandles_u64_VkShaderModule(&current, (VkShaderModule*)&output->module, 1);
    }
    *(const char**)(&output->pName) = input->pname().c_str();
    // WARNING PTR CHECK
    if (input->has_pspecializationinfo())
    {
        *(void**)&output->pSpecializationInfo = pool->alloc(sizeof(const VkSpecializationInfo));
        from_proto_VkSpecializationInfo(pool, handleMapping, input->mutable_pspecializationinfo(), (VkSpecializationInfo*)(output->pSpecializationInfo));
    }
}

void to_proto_VkVertexInputBindingDescription(
    VulkanHandleMapping* handleMapping,
    const VkVertexInputBindingDescription* input,
    goldfish_vk_proto::VkVertexInputBindingDescription* output)
{
    output->set_binding((uint32_t)input->binding);
    output->set_stride((uint32_t)input->stride);
    output->set_inputrate((uint32_t)input->inputRate);
}

void from_proto_VkVertexInputBindingDescription(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkVertexInputBindingDescription* input,
    VkVertexInputBindingDescription* output)
{
    memset(output, 0x0, sizeof(VkVertexInputBindingDescription));
    output->binding = (uint32_t)input->binding();
    output->stride = (uint32_t)input->stride();
    output->inputRate = (VkVertexInputRate)input->inputrate();
}

void to_proto_VkVertexInputAttributeDescription(
    VulkanHandleMapping* handleMapping,
    const VkVertexInputAttributeDescription* input,
    goldfish_vk_proto::VkVertexInputAttributeDescription* output)
{
    output->set_location((uint32_t)input->location);
    output->set_binding((uint32_t)input->binding);
    output->set_format((uint32_t)input->format);
    output->set_offset((uint32_t)input->offset);
}

void from_proto_VkVertexInputAttributeDescription(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkVertexInputAttributeDescription* input,
    VkVertexInputAttributeDescription* output)
{
    memset(output, 0x0, sizeof(VkVertexInputAttributeDescription));
    output->location = (uint32_t)input->location();
    output->binding = (uint32_t)input->binding();
    output->format = (VkFormat)input->format();
    output->offset = (uint32_t)input->offset();
}

void to_proto_VkPipelineVertexInputStateCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkPipelineVertexInputStateCreateInfo* input,
    goldfish_vk_proto::VkPipelineVertexInputStateCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_vertexbindingdescriptioncount((uint32_t)input->vertexBindingDescriptionCount);
    for (uint32_t i = 0; i < (uint32_t)input->vertexBindingDescriptionCount; ++i)
    {
        to_proto_VkVertexInputBindingDescription(handleMapping, input->pVertexBindingDescriptions + i, output->add_pvertexbindingdescriptions());
    }
    output->set_vertexattributedescriptioncount((uint32_t)input->vertexAttributeDescriptionCount);
    for (uint32_t i = 0; i < (uint32_t)input->vertexAttributeDescriptionCount; ++i)
    {
        to_proto_VkVertexInputAttributeDescription(handleMapping, input->pVertexAttributeDescriptions + i, output->add_pvertexattributedescriptions());
    }
}

void from_proto_VkPipelineVertexInputStateCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineVertexInputStateCreateInfo* input,
    VkPipelineVertexInputStateCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkPipelineVertexInputStateCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineVertexInputStateCreateFlags)input->flags();
    output->vertexBindingDescriptionCount = (uint32_t)input->vertexbindingdescriptioncount();
    *(void**)&output->pVertexBindingDescriptions = pool->alloc(output->vertexBindingDescriptionCount * sizeof(const VkVertexInputBindingDescription));
    for (uint32_t i = 0; i < (uint32_t)output->vertexBindingDescriptionCount; ++i)
    {
        from_proto_VkVertexInputBindingDescription(pool, handleMapping, input->mutable_pvertexbindingdescriptions(i), (VkVertexInputBindingDescription*)(output->pVertexBindingDescriptions + i));
    }
    output->vertexAttributeDescriptionCount = (uint32_t)input->vertexattributedescriptioncount();
    *(void**)&output->pVertexAttributeDescriptions = pool->alloc(output->vertexAttributeDescriptionCount * sizeof(const VkVertexInputAttributeDescription));
    for (uint32_t i = 0; i < (uint32_t)output->vertexAttributeDescriptionCount; ++i)
    {
        from_proto_VkVertexInputAttributeDescription(pool, handleMapping, input->mutable_pvertexattributedescriptions(i), (VkVertexInputAttributeDescription*)(output->pVertexAttributeDescriptions + i));
    }
}

void to_proto_VkPipelineInputAssemblyStateCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkPipelineInputAssemblyStateCreateInfo* input,
    goldfish_vk_proto::VkPipelineInputAssemblyStateCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_topology((uint32_t)input->topology);
    output->set_primitiverestartenable((uint32_t)input->primitiveRestartEnable);
}

void from_proto_VkPipelineInputAssemblyStateCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineInputAssemblyStateCreateInfo* input,
    VkPipelineInputAssemblyStateCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkPipelineInputAssemblyStateCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineInputAssemblyStateCreateFlags)input->flags();
    output->topology = (VkPrimitiveTopology)input->topology();
    output->primitiveRestartEnable = (VkBool32)input->primitiverestartenable();
}

void to_proto_VkPipelineTessellationStateCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkPipelineTessellationStateCreateInfo* input,
    goldfish_vk_proto::VkPipelineTessellationStateCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_patchcontrolpoints((uint32_t)input->patchControlPoints);
}

void from_proto_VkPipelineTessellationStateCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineTessellationStateCreateInfo* input,
    VkPipelineTessellationStateCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkPipelineTessellationStateCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineTessellationStateCreateFlags)input->flags();
    output->patchControlPoints = (uint32_t)input->patchcontrolpoints();
}

void to_proto_VkViewport(
    VulkanHandleMapping* handleMapping,
    const VkViewport* input,
    goldfish_vk_proto::VkViewport* output)
{
    output->set_x((float)input->x);
    output->set_y((float)input->y);
    output->set_width((float)input->width);
    output->set_height((float)input->height);
    output->set_mindepth((float)input->minDepth);
    output->set_maxdepth((float)input->maxDepth);
}

void from_proto_VkViewport(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkViewport* input,
    VkViewport* output)
{
    memset(output, 0x0, sizeof(VkViewport));
    output->x = (float)input->x();
    output->y = (float)input->y();
    output->width = (float)input->width();
    output->height = (float)input->height();
    output->minDepth = (float)input->mindepth();
    output->maxDepth = (float)input->maxdepth();
}

void to_proto_VkOffset2D(
    VulkanHandleMapping* handleMapping,
    const VkOffset2D* input,
    goldfish_vk_proto::VkOffset2D* output)
{
    output->set_x((int32_t)input->x);
    output->set_y((int32_t)input->y);
}

void from_proto_VkOffset2D(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkOffset2D* input,
    VkOffset2D* output)
{
    memset(output, 0x0, sizeof(VkOffset2D));
    output->x = (int32_t)input->x();
    output->y = (int32_t)input->y();
}

void to_proto_VkExtent2D(
    VulkanHandleMapping* handleMapping,
    const VkExtent2D* input,
    goldfish_vk_proto::VkExtent2D* output)
{
    output->set_width((uint32_t)input->width);
    output->set_height((uint32_t)input->height);
}

void from_proto_VkExtent2D(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExtent2D* input,
    VkExtent2D* output)
{
    memset(output, 0x0, sizeof(VkExtent2D));
    output->width = (uint32_t)input->width();
    output->height = (uint32_t)input->height();
}

void to_proto_VkRect2D(
    VulkanHandleMapping* handleMapping,
    const VkRect2D* input,
    goldfish_vk_proto::VkRect2D* output)
{
    to_proto_VkOffset2D(handleMapping, &input->offset, output->mutable_offset());
    to_proto_VkExtent2D(handleMapping, &input->extent, output->mutable_extent());
}

void from_proto_VkRect2D(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkRect2D* input,
    VkRect2D* output)
{
    memset(output, 0x0, sizeof(VkRect2D));
    from_proto_VkOffset2D(pool, handleMapping, input->mutable_offset(), (VkOffset2D*)(&output->offset));
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_extent(), (VkExtent2D*)(&output->extent));
}

void to_proto_VkPipelineViewportStateCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkPipelineViewportStateCreateInfo* input,
    goldfish_vk_proto::VkPipelineViewportStateCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_viewportcount((uint32_t)input->viewportCount);
    // WARNING PTR CHECK
    if (input->pViewports)
    {
        for (uint32_t i = 0; i < (uint32_t)input->viewportCount; ++i)
        {
            to_proto_VkViewport(handleMapping, input->pViewports + i, output->add_pviewports());
        }
    }
    output->set_scissorcount((uint32_t)input->scissorCount);
    // WARNING PTR CHECK
    if (input->pScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)input->scissorCount; ++i)
        {
            to_proto_VkRect2D(handleMapping, input->pScissors + i, output->add_pscissors());
        }
    }
}

void from_proto_VkPipelineViewportStateCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineViewportStateCreateInfo* input,
    VkPipelineViewportStateCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkPipelineViewportStateCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineViewportStateCreateFlags)input->flags();
    output->viewportCount = (uint32_t)input->viewportcount();
    // WARNING PTR CHECK
    if (input->pviewports_size())
    {
        *(void**)&output->pViewports = pool->alloc(output->viewportCount * sizeof(const VkViewport));
        for (uint32_t i = 0; i < (uint32_t)output->viewportCount; ++i)
        {
            from_proto_VkViewport(pool, handleMapping, input->mutable_pviewports(i), (VkViewport*)(output->pViewports + i));
        }
    }
    output->scissorCount = (uint32_t)input->scissorcount();
    // WARNING PTR CHECK
    if (input->pscissors_size())
    {
        *(void**)&output->pScissors = pool->alloc(output->scissorCount * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)output->scissorCount; ++i)
        {
            from_proto_VkRect2D(pool, handleMapping, input->mutable_pscissors(i), (VkRect2D*)(output->pScissors + i));
        }
    }
}

void to_proto_VkPipelineRasterizationStateCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkPipelineRasterizationStateCreateInfo* input,
    goldfish_vk_proto::VkPipelineRasterizationStateCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_depthclampenable((uint32_t)input->depthClampEnable);
    output->set_rasterizerdiscardenable((uint32_t)input->rasterizerDiscardEnable);
    output->set_polygonmode((uint32_t)input->polygonMode);
    output->set_cullmode((uint32_t)input->cullMode);
    output->set_frontface((uint32_t)input->frontFace);
    output->set_depthbiasenable((uint32_t)input->depthBiasEnable);
    output->set_depthbiasconstantfactor((float)input->depthBiasConstantFactor);
    output->set_depthbiasclamp((float)input->depthBiasClamp);
    output->set_depthbiasslopefactor((float)input->depthBiasSlopeFactor);
    output->set_linewidth((float)input->lineWidth);
}

void from_proto_VkPipelineRasterizationStateCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineRasterizationStateCreateInfo* input,
    VkPipelineRasterizationStateCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkPipelineRasterizationStateCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineRasterizationStateCreateFlags)input->flags();
    output->depthClampEnable = (VkBool32)input->depthclampenable();
    output->rasterizerDiscardEnable = (VkBool32)input->rasterizerdiscardenable();
    output->polygonMode = (VkPolygonMode)input->polygonmode();
    output->cullMode = (VkCullModeFlags)input->cullmode();
    output->frontFace = (VkFrontFace)input->frontface();
    output->depthBiasEnable = (VkBool32)input->depthbiasenable();
    output->depthBiasConstantFactor = (float)input->depthbiasconstantfactor();
    output->depthBiasClamp = (float)input->depthbiasclamp();
    output->depthBiasSlopeFactor = (float)input->depthbiasslopefactor();
    output->lineWidth = (float)input->linewidth();
}

void to_proto_VkPipelineMultisampleStateCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkPipelineMultisampleStateCreateInfo* input,
    goldfish_vk_proto::VkPipelineMultisampleStateCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_rasterizationsamples((uint32_t)input->rasterizationSamples);
    output->set_sampleshadingenable((uint32_t)input->sampleShadingEnable);
    output->set_minsampleshading((float)input->minSampleShading);
    // WARNING PTR CHECK
    if (input->pSampleMask)
    {
        for (uint32_t i = 0; i < (uint32_t)(((input->rasterizationSamples) + 31) / 32); ++i)
        {
            output->add_psamplemask(input->pSampleMask[i]);
        }
    }
    output->set_alphatocoverageenable((uint32_t)input->alphaToCoverageEnable);
    output->set_alphatooneenable((uint32_t)input->alphaToOneEnable);
}

void from_proto_VkPipelineMultisampleStateCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineMultisampleStateCreateInfo* input,
    VkPipelineMultisampleStateCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkPipelineMultisampleStateCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineMultisampleStateCreateFlags)input->flags();
    output->rasterizationSamples = (VkSampleCountFlagBits)input->rasterizationsamples();
    output->sampleShadingEnable = (VkBool32)input->sampleshadingenable();
    output->minSampleShading = (float)input->minsampleshading();
    // WARNING PTR CHECK
    if (input->psamplemask_size())
    {
        for (uint32_t i = 0; i < (uint32_t)(((output->rasterizationSamples) + 31) / 32); ++i)
        {
            *((VkSampleMask*)(&output->pSampleMask) + i) = (VkSampleMask)input->psamplemask(i);
        }
    }
    output->alphaToCoverageEnable = (VkBool32)input->alphatocoverageenable();
    output->alphaToOneEnable = (VkBool32)input->alphatooneenable();
}

void to_proto_VkStencilOpState(
    VulkanHandleMapping* handleMapping,
    const VkStencilOpState* input,
    goldfish_vk_proto::VkStencilOpState* output)
{
    output->set_failop((uint32_t)input->failOp);
    output->set_passop((uint32_t)input->passOp);
    output->set_depthfailop((uint32_t)input->depthFailOp);
    output->set_compareop((uint32_t)input->compareOp);
    output->set_comparemask((uint32_t)input->compareMask);
    output->set_writemask((uint32_t)input->writeMask);
    output->set_reference((uint32_t)input->reference);
}

void from_proto_VkStencilOpState(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkStencilOpState* input,
    VkStencilOpState* output)
{
    memset(output, 0x0, sizeof(VkStencilOpState));
    output->failOp = (VkStencilOp)input->failop();
    output->passOp = (VkStencilOp)input->passop();
    output->depthFailOp = (VkStencilOp)input->depthfailop();
    output->compareOp = (VkCompareOp)input->compareop();
    output->compareMask = (uint32_t)input->comparemask();
    output->writeMask = (uint32_t)input->writemask();
    output->reference = (uint32_t)input->reference();
}

void to_proto_VkPipelineDepthStencilStateCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkPipelineDepthStencilStateCreateInfo* input,
    goldfish_vk_proto::VkPipelineDepthStencilStateCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_depthtestenable((uint32_t)input->depthTestEnable);
    output->set_depthwriteenable((uint32_t)input->depthWriteEnable);
    output->set_depthcompareop((uint32_t)input->depthCompareOp);
    output->set_depthboundstestenable((uint32_t)input->depthBoundsTestEnable);
    output->set_stenciltestenable((uint32_t)input->stencilTestEnable);
    to_proto_VkStencilOpState(handleMapping, &input->front, output->mutable_front());
    to_proto_VkStencilOpState(handleMapping, &input->back, output->mutable_back());
    output->set_mindepthbounds((float)input->minDepthBounds);
    output->set_maxdepthbounds((float)input->maxDepthBounds);
}

void from_proto_VkPipelineDepthStencilStateCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineDepthStencilStateCreateInfo* input,
    VkPipelineDepthStencilStateCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkPipelineDepthStencilStateCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineDepthStencilStateCreateFlags)input->flags();
    output->depthTestEnable = (VkBool32)input->depthtestenable();
    output->depthWriteEnable = (VkBool32)input->depthwriteenable();
    output->depthCompareOp = (VkCompareOp)input->depthcompareop();
    output->depthBoundsTestEnable = (VkBool32)input->depthboundstestenable();
    output->stencilTestEnable = (VkBool32)input->stenciltestenable();
    from_proto_VkStencilOpState(pool, handleMapping, input->mutable_front(), (VkStencilOpState*)(&output->front));
    from_proto_VkStencilOpState(pool, handleMapping, input->mutable_back(), (VkStencilOpState*)(&output->back));
    output->minDepthBounds = (float)input->mindepthbounds();
    output->maxDepthBounds = (float)input->maxdepthbounds();
}

void to_proto_VkPipelineColorBlendAttachmentState(
    VulkanHandleMapping* handleMapping,
    const VkPipelineColorBlendAttachmentState* input,
    goldfish_vk_proto::VkPipelineColorBlendAttachmentState* output)
{
    output->set_blendenable((uint32_t)input->blendEnable);
    output->set_srccolorblendfactor((uint32_t)input->srcColorBlendFactor);
    output->set_dstcolorblendfactor((uint32_t)input->dstColorBlendFactor);
    output->set_colorblendop((uint32_t)input->colorBlendOp);
    output->set_srcalphablendfactor((uint32_t)input->srcAlphaBlendFactor);
    output->set_dstalphablendfactor((uint32_t)input->dstAlphaBlendFactor);
    output->set_alphablendop((uint32_t)input->alphaBlendOp);
    output->set_colorwritemask((uint32_t)input->colorWriteMask);
}

void from_proto_VkPipelineColorBlendAttachmentState(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineColorBlendAttachmentState* input,
    VkPipelineColorBlendAttachmentState* output)
{
    memset(output, 0x0, sizeof(VkPipelineColorBlendAttachmentState));
    output->blendEnable = (VkBool32)input->blendenable();
    output->srcColorBlendFactor = (VkBlendFactor)input->srccolorblendfactor();
    output->dstColorBlendFactor = (VkBlendFactor)input->dstcolorblendfactor();
    output->colorBlendOp = (VkBlendOp)input->colorblendop();
    output->srcAlphaBlendFactor = (VkBlendFactor)input->srcalphablendfactor();
    output->dstAlphaBlendFactor = (VkBlendFactor)input->dstalphablendfactor();
    output->alphaBlendOp = (VkBlendOp)input->alphablendop();
    output->colorWriteMask = (VkColorComponentFlags)input->colorwritemask();
}

void to_proto_VkPipelineColorBlendStateCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkPipelineColorBlendStateCreateInfo* input,
    goldfish_vk_proto::VkPipelineColorBlendStateCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_logicopenable((uint32_t)input->logicOpEnable);
    output->set_logicop((uint32_t)input->logicOp);
    output->set_attachmentcount((uint32_t)input->attachmentCount);
    for (uint32_t i = 0; i < (uint32_t)input->attachmentCount; ++i)
    {
        to_proto_VkPipelineColorBlendAttachmentState(handleMapping, input->pAttachments + i, output->add_pattachments());
    }
    for (uint32_t i = 0; i < (uint32_t)4; ++i)
    {
        output->add_blendconstants(input->blendConstants[i]);
    }
}

void from_proto_VkPipelineColorBlendStateCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineColorBlendStateCreateInfo* input,
    VkPipelineColorBlendStateCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkPipelineColorBlendStateCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineColorBlendStateCreateFlags)input->flags();
    output->logicOpEnable = (VkBool32)input->logicopenable();
    output->logicOp = (VkLogicOp)input->logicop();
    output->attachmentCount = (uint32_t)input->attachmentcount();
    *(void**)&output->pAttachments = pool->alloc(output->attachmentCount * sizeof(const VkPipelineColorBlendAttachmentState));
    for (uint32_t i = 0; i < (uint32_t)output->attachmentCount; ++i)
    {
        from_proto_VkPipelineColorBlendAttachmentState(pool, handleMapping, input->mutable_pattachments(i), (VkPipelineColorBlendAttachmentState*)(output->pAttachments + i));
    }
    for (uint32_t i = 0; i < (uint32_t)4; ++i)
    {
        output->blendConstants[i] = (float)input->blendconstants(i);
    }
}

void to_proto_VkPipelineDynamicStateCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkPipelineDynamicStateCreateInfo* input,
    goldfish_vk_proto::VkPipelineDynamicStateCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_dynamicstatecount((uint32_t)input->dynamicStateCount);
    for (uint32_t i = 0; i < (uint32_t)input->dynamicStateCount; ++i)
    {
        output->add_pdynamicstates(input->pDynamicStates[i]);
    }
}

void from_proto_VkPipelineDynamicStateCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineDynamicStateCreateInfo* input,
    VkPipelineDynamicStateCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkPipelineDynamicStateCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineDynamicStateCreateFlags)input->flags();
    output->dynamicStateCount = (uint32_t)input->dynamicstatecount();
    for (uint32_t i = 0; i < (uint32_t)output->dynamicStateCount; ++i)
    {
        *((VkDynamicState*)(&output->pDynamicStates) + i) = (VkDynamicState)input->pdynamicstates(i);
    }
}

void to_proto_VkGraphicsPipelineCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkGraphicsPipelineCreateInfo* input,
    goldfish_vk_proto::VkGraphicsPipelineCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_stagecount((uint32_t)input->stageCount);
    for (uint32_t i = 0; i < (uint32_t)input->stageCount; ++i)
    {
        to_proto_VkPipelineShaderStageCreateInfo(handleMapping, input->pStages + i, output->add_pstages());
    }
    to_proto_VkPipelineVertexInputStateCreateInfo(handleMapping, input->pVertexInputState, output->mutable_pvertexinputstate());
    to_proto_VkPipelineInputAssemblyStateCreateInfo(handleMapping, input->pInputAssemblyState, output->mutable_pinputassemblystate());
    // WARNING PTR CHECK
    if (input->pTessellationState)
    {
        to_proto_VkPipelineTessellationStateCreateInfo(handleMapping, input->pTessellationState, output->mutable_ptessellationstate());
    }
    // WARNING PTR CHECK
    if (input->pViewportState)
    {
        to_proto_VkPipelineViewportStateCreateInfo(handleMapping, input->pViewportState, output->mutable_pviewportstate());
    }
    to_proto_VkPipelineRasterizationStateCreateInfo(handleMapping, input->pRasterizationState, output->mutable_prasterizationstate());
    // WARNING PTR CHECK
    if (input->pMultisampleState)
    {
        to_proto_VkPipelineMultisampleStateCreateInfo(handleMapping, input->pMultisampleState, output->mutable_pmultisamplestate());
    }
    // WARNING PTR CHECK
    if (input->pDepthStencilState)
    {
        to_proto_VkPipelineDepthStencilStateCreateInfo(handleMapping, input->pDepthStencilState, output->mutable_pdepthstencilstate());
    }
    // WARNING PTR CHECK
    if (input->pColorBlendState)
    {
        to_proto_VkPipelineColorBlendStateCreateInfo(handleMapping, input->pColorBlendState, output->mutable_pcolorblendstate());
    }
    // WARNING PTR CHECK
    if (input->pDynamicState)
    {
        to_proto_VkPipelineDynamicStateCreateInfo(handleMapping, input->pDynamicState, output->mutable_pdynamicstate());
    }
    uint64_t cgen_var_14;
    handleMapping->mapHandles_VkPipelineLayout_u64(&input->layout, &cgen_var_14, 1);
    output->set_layout(cgen_var_14);
    uint64_t cgen_var_15;
    handleMapping->mapHandles_VkRenderPass_u64(&input->renderPass, &cgen_var_15, 1);
    output->set_renderpass(cgen_var_15);
    output->set_subpass((uint32_t)input->subpass);
    uint64_t cgen_var_16;
    handleMapping->mapHandles_VkPipeline_u64(&input->basePipelineHandle, &cgen_var_16, 1);
    output->set_basepipelinehandle(cgen_var_16);
    output->set_basepipelineindex((int32_t)input->basePipelineIndex);
}

void from_proto_VkGraphicsPipelineCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkGraphicsPipelineCreateInfo* input,
    VkGraphicsPipelineCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkGraphicsPipelineCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineCreateFlags)input->flags();
    output->stageCount = (uint32_t)input->stagecount();
    *(void**)&output->pStages = pool->alloc(output->stageCount * sizeof(const VkPipelineShaderStageCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)output->stageCount; ++i)
    {
        from_proto_VkPipelineShaderStageCreateInfo(pool, handleMapping, input->mutable_pstages(i), (VkPipelineShaderStageCreateInfo*)(output->pStages + i));
    }
    *(void**)&output->pVertexInputState = pool->alloc(sizeof(const VkPipelineVertexInputStateCreateInfo));
    from_proto_VkPipelineVertexInputStateCreateInfo(pool, handleMapping, input->mutable_pvertexinputstate(), (VkPipelineVertexInputStateCreateInfo*)(output->pVertexInputState));
    *(void**)&output->pInputAssemblyState = pool->alloc(sizeof(const VkPipelineInputAssemblyStateCreateInfo));
    from_proto_VkPipelineInputAssemblyStateCreateInfo(pool, handleMapping, input->mutable_pinputassemblystate(), (VkPipelineInputAssemblyStateCreateInfo*)(output->pInputAssemblyState));
    // WARNING PTR CHECK
    if (input->has_ptessellationstate())
    {
        *(void**)&output->pTessellationState = pool->alloc(sizeof(const VkPipelineTessellationStateCreateInfo));
        from_proto_VkPipelineTessellationStateCreateInfo(pool, handleMapping, input->mutable_ptessellationstate(), (VkPipelineTessellationStateCreateInfo*)(output->pTessellationState));
    }
    // WARNING PTR CHECK
    if (input->has_pviewportstate())
    {
        *(void**)&output->pViewportState = pool->alloc(sizeof(const VkPipelineViewportStateCreateInfo));
        from_proto_VkPipelineViewportStateCreateInfo(pool, handleMapping, input->mutable_pviewportstate(), (VkPipelineViewportStateCreateInfo*)(output->pViewportState));
    }
    *(void**)&output->pRasterizationState = pool->alloc(sizeof(const VkPipelineRasterizationStateCreateInfo));
    from_proto_VkPipelineRasterizationStateCreateInfo(pool, handleMapping, input->mutable_prasterizationstate(), (VkPipelineRasterizationStateCreateInfo*)(output->pRasterizationState));
    // WARNING PTR CHECK
    if (input->has_pmultisamplestate())
    {
        *(void**)&output->pMultisampleState = pool->alloc(sizeof(const VkPipelineMultisampleStateCreateInfo));
        from_proto_VkPipelineMultisampleStateCreateInfo(pool, handleMapping, input->mutable_pmultisamplestate(), (VkPipelineMultisampleStateCreateInfo*)(output->pMultisampleState));
    }
    // WARNING PTR CHECK
    if (input->has_pdepthstencilstate())
    {
        *(void**)&output->pDepthStencilState = pool->alloc(sizeof(const VkPipelineDepthStencilStateCreateInfo));
        from_proto_VkPipelineDepthStencilStateCreateInfo(pool, handleMapping, input->mutable_pdepthstencilstate(), (VkPipelineDepthStencilStateCreateInfo*)(output->pDepthStencilState));
    }
    // WARNING PTR CHECK
    if (input->has_pcolorblendstate())
    {
        *(void**)&output->pColorBlendState = pool->alloc(sizeof(const VkPipelineColorBlendStateCreateInfo));
        from_proto_VkPipelineColorBlendStateCreateInfo(pool, handleMapping, input->mutable_pcolorblendstate(), (VkPipelineColorBlendStateCreateInfo*)(output->pColorBlendState));
    }
    // WARNING PTR CHECK
    if (input->has_pdynamicstate())
    {
        *(void**)&output->pDynamicState = pool->alloc(sizeof(const VkPipelineDynamicStateCreateInfo));
        from_proto_VkPipelineDynamicStateCreateInfo(pool, handleMapping, input->mutable_pdynamicstate(), (VkPipelineDynamicStateCreateInfo*)(output->pDynamicState));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->layout();
        handleMapping->mapHandles_u64_VkPipelineLayout(&current, (VkPipelineLayout*)&output->layout, 1);
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->renderpass();
        handleMapping->mapHandles_u64_VkRenderPass(&current, (VkRenderPass*)&output->renderPass, 1);
    }
    output->subpass = (uint32_t)input->subpass();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->basepipelinehandle();
        handleMapping->mapHandles_u64_VkPipeline(&current, (VkPipeline*)&output->basePipelineHandle, 1);
    }
    output->basePipelineIndex = (int32_t)input->basepipelineindex();
}

void to_proto_VkComputePipelineCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkComputePipelineCreateInfo* input,
    goldfish_vk_proto::VkComputePipelineCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    to_proto_VkPipelineShaderStageCreateInfo(handleMapping, &input->stage, output->mutable_stage());
    uint64_t cgen_var_17;
    handleMapping->mapHandles_VkPipelineLayout_u64(&input->layout, &cgen_var_17, 1);
    output->set_layout(cgen_var_17);
    uint64_t cgen_var_18;
    handleMapping->mapHandles_VkPipeline_u64(&input->basePipelineHandle, &cgen_var_18, 1);
    output->set_basepipelinehandle(cgen_var_18);
    output->set_basepipelineindex((int32_t)input->basePipelineIndex);
}

void from_proto_VkComputePipelineCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkComputePipelineCreateInfo* input,
    VkComputePipelineCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkComputePipelineCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineCreateFlags)input->flags();
    from_proto_VkPipelineShaderStageCreateInfo(pool, handleMapping, input->mutable_stage(), (VkPipelineShaderStageCreateInfo*)(&output->stage));
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->layout();
        handleMapping->mapHandles_u64_VkPipelineLayout(&current, (VkPipelineLayout*)&output->layout, 1);
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->basepipelinehandle();
        handleMapping->mapHandles_u64_VkPipeline(&current, (VkPipeline*)&output->basePipelineHandle, 1);
    }
    output->basePipelineIndex = (int32_t)input->basepipelineindex();
}

void to_proto_VkPushConstantRange(
    VulkanHandleMapping* handleMapping,
    const VkPushConstantRange* input,
    goldfish_vk_proto::VkPushConstantRange* output)
{
    output->set_stageflags((uint32_t)input->stageFlags);
    output->set_offset((uint32_t)input->offset);
    output->set_size((uint32_t)input->size);
}

void from_proto_VkPushConstantRange(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPushConstantRange* input,
    VkPushConstantRange* output)
{
    memset(output, 0x0, sizeof(VkPushConstantRange));
    output->stageFlags = (VkShaderStageFlags)input->stageflags();
    output->offset = (uint32_t)input->offset();
    output->size = (uint32_t)input->size();
}

void to_proto_VkPipelineLayoutCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkPipelineLayoutCreateInfo* input,
    goldfish_vk_proto::VkPipelineLayoutCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_setlayoutcount((uint32_t)input->setLayoutCount);
    if (input->setLayoutCount)
    {
        std::vector<uint64_t> cgen_var_19(input->setLayoutCount);
        handleMapping->mapHandles_VkDescriptorSetLayout_u64(input->pSetLayouts, cgen_var_19.data(), input->setLayoutCount);
        for (uint32_t i = 0; i < input->setLayoutCount; ++i)
        {
            output->add_psetlayouts(cgen_var_19[i]);
        }
    }
    output->set_pushconstantrangecount((uint32_t)input->pushConstantRangeCount);
    for (uint32_t i = 0; i < (uint32_t)input->pushConstantRangeCount; ++i)
    {
        to_proto_VkPushConstantRange(handleMapping, input->pPushConstantRanges + i, output->add_ppushconstantranges());
    }
}

void from_proto_VkPipelineLayoutCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineLayoutCreateInfo* input,
    VkPipelineLayoutCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkPipelineLayoutCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineLayoutCreateFlags)input->flags();
    output->setLayoutCount = (uint32_t)input->setlayoutcount();
    if (output->setLayoutCount)
    {
        for (uint32_t i = 0; i < output->setLayoutCount; ++i)
        {
            uint64_t current = input->psetlayouts(i);
            handleMapping->mapHandles_u64_VkDescriptorSetLayout(&current, (VkDescriptorSetLayout*)&output->pSetLayouts[i], 1);
        }
    }
    output->pushConstantRangeCount = (uint32_t)input->pushconstantrangecount();
    *(void**)&output->pPushConstantRanges = pool->alloc(output->pushConstantRangeCount * sizeof(const VkPushConstantRange));
    for (uint32_t i = 0; i < (uint32_t)output->pushConstantRangeCount; ++i)
    {
        from_proto_VkPushConstantRange(pool, handleMapping, input->mutable_ppushconstantranges(i), (VkPushConstantRange*)(output->pPushConstantRanges + i));
    }
}

void to_proto_VkSamplerCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkSamplerCreateInfo* input,
    goldfish_vk_proto::VkSamplerCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_magfilter((uint32_t)input->magFilter);
    output->set_minfilter((uint32_t)input->minFilter);
    output->set_mipmapmode((uint32_t)input->mipmapMode);
    output->set_addressmodeu((uint32_t)input->addressModeU);
    output->set_addressmodev((uint32_t)input->addressModeV);
    output->set_addressmodew((uint32_t)input->addressModeW);
    output->set_miplodbias((float)input->mipLodBias);
    output->set_anisotropyenable((uint32_t)input->anisotropyEnable);
    output->set_maxanisotropy((float)input->maxAnisotropy);
    output->set_compareenable((uint32_t)input->compareEnable);
    output->set_compareop((uint32_t)input->compareOp);
    output->set_minlod((float)input->minLod);
    output->set_maxlod((float)input->maxLod);
    output->set_bordercolor((uint32_t)input->borderColor);
    output->set_unnormalizedcoordinates((uint32_t)input->unnormalizedCoordinates);
}

void from_proto_VkSamplerCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSamplerCreateInfo* input,
    VkSamplerCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkSamplerCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkSamplerCreateFlags)input->flags();
    output->magFilter = (VkFilter)input->magfilter();
    output->minFilter = (VkFilter)input->minfilter();
    output->mipmapMode = (VkSamplerMipmapMode)input->mipmapmode();
    output->addressModeU = (VkSamplerAddressMode)input->addressmodeu();
    output->addressModeV = (VkSamplerAddressMode)input->addressmodev();
    output->addressModeW = (VkSamplerAddressMode)input->addressmodew();
    output->mipLodBias = (float)input->miplodbias();
    output->anisotropyEnable = (VkBool32)input->anisotropyenable();
    output->maxAnisotropy = (float)input->maxanisotropy();
    output->compareEnable = (VkBool32)input->compareenable();
    output->compareOp = (VkCompareOp)input->compareop();
    output->minLod = (float)input->minlod();
    output->maxLod = (float)input->maxlod();
    output->borderColor = (VkBorderColor)input->bordercolor();
    output->unnormalizedCoordinates = (VkBool32)input->unnormalizedcoordinates();
}

void to_proto_VkDescriptorSetLayoutBinding(
    VulkanHandleMapping* handleMapping,
    const VkDescriptorSetLayoutBinding* input,
    goldfish_vk_proto::VkDescriptorSetLayoutBinding* output)
{
    output->set_binding((uint32_t)input->binding);
    output->set_descriptortype((uint32_t)input->descriptorType);
    output->set_descriptorcount((uint32_t)input->descriptorCount);
    output->set_stageflags((uint32_t)input->stageFlags);
    // WARNING PTR CHECK
    if (input->pImmutableSamplers)
    {
        if (input->descriptorCount)
        {
            std::vector<uint64_t> cgen_var_20(input->descriptorCount);
            handleMapping->mapHandles_VkSampler_u64(input->pImmutableSamplers, cgen_var_20.data(), input->descriptorCount);
            for (uint32_t i = 0; i < input->descriptorCount; ++i)
            {
                output->add_pimmutablesamplers(cgen_var_20[i]);
            }
        }
    }
}

void from_proto_VkDescriptorSetLayoutBinding(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDescriptorSetLayoutBinding* input,
    VkDescriptorSetLayoutBinding* output)
{
    memset(output, 0x0, sizeof(VkDescriptorSetLayoutBinding));
    output->binding = (uint32_t)input->binding();
    output->descriptorType = (VkDescriptorType)input->descriptortype();
    output->descriptorCount = (uint32_t)input->descriptorcount();
    output->stageFlags = (VkShaderStageFlags)input->stageflags();
    // WARNING PTR CHECK
    if (input->pimmutablesamplers_size())
    {
        if (output->descriptorCount)
        {
            for (uint32_t i = 0; i < output->descriptorCount; ++i)
            {
                uint64_t current = input->pimmutablesamplers(i);
                handleMapping->mapHandles_u64_VkSampler(&current, (VkSampler*)&output->pImmutableSamplers[i], 1);
            }
        }
    }
}

void to_proto_VkDescriptorSetLayoutCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkDescriptorSetLayoutCreateInfo* input,
    goldfish_vk_proto::VkDescriptorSetLayoutCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_bindingcount((uint32_t)input->bindingCount);
    for (uint32_t i = 0; i < (uint32_t)input->bindingCount; ++i)
    {
        to_proto_VkDescriptorSetLayoutBinding(handleMapping, input->pBindings + i, output->add_pbindings());
    }
}

void from_proto_VkDescriptorSetLayoutCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDescriptorSetLayoutCreateInfo* input,
    VkDescriptorSetLayoutCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkDescriptorSetLayoutCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkDescriptorSetLayoutCreateFlags)input->flags();
    output->bindingCount = (uint32_t)input->bindingcount();
    *(void**)&output->pBindings = pool->alloc(output->bindingCount * sizeof(const VkDescriptorSetLayoutBinding));
    for (uint32_t i = 0; i < (uint32_t)output->bindingCount; ++i)
    {
        from_proto_VkDescriptorSetLayoutBinding(pool, handleMapping, input->mutable_pbindings(i), (VkDescriptorSetLayoutBinding*)(output->pBindings + i));
    }
}

void to_proto_VkDescriptorPoolSize(
    VulkanHandleMapping* handleMapping,
    const VkDescriptorPoolSize* input,
    goldfish_vk_proto::VkDescriptorPoolSize* output)
{
    output->set_type((uint32_t)input->type);
    output->set_descriptorcount((uint32_t)input->descriptorCount);
}

void from_proto_VkDescriptorPoolSize(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDescriptorPoolSize* input,
    VkDescriptorPoolSize* output)
{
    memset(output, 0x0, sizeof(VkDescriptorPoolSize));
    output->type = (VkDescriptorType)input->type();
    output->descriptorCount = (uint32_t)input->descriptorcount();
}

void to_proto_VkDescriptorPoolCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkDescriptorPoolCreateInfo* input,
    goldfish_vk_proto::VkDescriptorPoolCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_maxsets((uint32_t)input->maxSets);
    output->set_poolsizecount((uint32_t)input->poolSizeCount);
    for (uint32_t i = 0; i < (uint32_t)input->poolSizeCount; ++i)
    {
        to_proto_VkDescriptorPoolSize(handleMapping, input->pPoolSizes + i, output->add_ppoolsizes());
    }
}

void from_proto_VkDescriptorPoolCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDescriptorPoolCreateInfo* input,
    VkDescriptorPoolCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkDescriptorPoolCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkDescriptorPoolCreateFlags)input->flags();
    output->maxSets = (uint32_t)input->maxsets();
    output->poolSizeCount = (uint32_t)input->poolsizecount();
    *(void**)&output->pPoolSizes = pool->alloc(output->poolSizeCount * sizeof(const VkDescriptorPoolSize));
    for (uint32_t i = 0; i < (uint32_t)output->poolSizeCount; ++i)
    {
        from_proto_VkDescriptorPoolSize(pool, handleMapping, input->mutable_ppoolsizes(i), (VkDescriptorPoolSize*)(output->pPoolSizes + i));
    }
}

void to_proto_VkDescriptorSetAllocateInfo(
    VulkanHandleMapping* handleMapping,
    const VkDescriptorSetAllocateInfo* input,
    goldfish_vk_proto::VkDescriptorSetAllocateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_21;
    handleMapping->mapHandles_VkDescriptorPool_u64(&input->descriptorPool, &cgen_var_21, 1);
    output->set_descriptorpool(cgen_var_21);
    output->set_descriptorsetcount((uint32_t)input->descriptorSetCount);
    if (input->descriptorSetCount)
    {
        std::vector<uint64_t> cgen_var_22(input->descriptorSetCount);
        handleMapping->mapHandles_VkDescriptorSetLayout_u64(input->pSetLayouts, cgen_var_22.data(), input->descriptorSetCount);
        for (uint32_t i = 0; i < input->descriptorSetCount; ++i)
        {
            output->add_psetlayouts(cgen_var_22[i]);
        }
    }
}

void from_proto_VkDescriptorSetAllocateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDescriptorSetAllocateInfo* input,
    VkDescriptorSetAllocateInfo* output)
{
    memset(output, 0x0, sizeof(VkDescriptorSetAllocateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->descriptorpool();
        handleMapping->mapHandles_u64_VkDescriptorPool(&current, (VkDescriptorPool*)&output->descriptorPool, 1);
    }
    output->descriptorSetCount = (uint32_t)input->descriptorsetcount();
    if (output->descriptorSetCount)
    {
        for (uint32_t i = 0; i < output->descriptorSetCount; ++i)
        {
            uint64_t current = input->psetlayouts(i);
            handleMapping->mapHandles_u64_VkDescriptorSetLayout(&current, (VkDescriptorSetLayout*)&output->pSetLayouts[i], 1);
        }
    }
}

void to_proto_VkDescriptorImageInfo(
    VulkanHandleMapping* handleMapping,
    const VkDescriptorImageInfo* input,
    goldfish_vk_proto::VkDescriptorImageInfo* output)
{
    uint64_t cgen_var_23;
    handleMapping->mapHandles_VkSampler_u64(&input->sampler, &cgen_var_23, 1);
    output->set_sampler(cgen_var_23);
    uint64_t cgen_var_24;
    handleMapping->mapHandles_VkImageView_u64(&input->imageView, &cgen_var_24, 1);
    output->set_imageview(cgen_var_24);
    output->set_imagelayout((uint32_t)input->imageLayout);
}

void from_proto_VkDescriptorImageInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDescriptorImageInfo* input,
    VkDescriptorImageInfo* output)
{
    memset(output, 0x0, sizeof(VkDescriptorImageInfo));
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->sampler();
        handleMapping->mapHandles_u64_VkSampler(&current, (VkSampler*)&output->sampler, 1);
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->imageview();
        handleMapping->mapHandles_u64_VkImageView(&current, (VkImageView*)&output->imageView, 1);
    }
    output->imageLayout = (VkImageLayout)input->imagelayout();
}

void to_proto_VkDescriptorBufferInfo(
    VulkanHandleMapping* handleMapping,
    const VkDescriptorBufferInfo* input,
    goldfish_vk_proto::VkDescriptorBufferInfo* output)
{
    uint64_t cgen_var_25;
    handleMapping->mapHandles_VkBuffer_u64(&input->buffer, &cgen_var_25, 1);
    output->set_buffer(cgen_var_25);
    output->set_offset((uint64_t)input->offset);
    output->set_range((uint64_t)input->range);
}

void from_proto_VkDescriptorBufferInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDescriptorBufferInfo* input,
    VkDescriptorBufferInfo* output)
{
    memset(output, 0x0, sizeof(VkDescriptorBufferInfo));
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->buffer();
        handleMapping->mapHandles_u64_VkBuffer(&current, (VkBuffer*)&output->buffer, 1);
    }
    output->offset = (VkDeviceSize)input->offset();
    output->range = (VkDeviceSize)input->range();
}

void to_proto_VkWriteDescriptorSet(
    VulkanHandleMapping* handleMapping,
    const VkWriteDescriptorSet* input,
    goldfish_vk_proto::VkWriteDescriptorSet* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_26;
    handleMapping->mapHandles_VkDescriptorSet_u64(&input->dstSet, &cgen_var_26, 1);
    output->set_dstset(cgen_var_26);
    output->set_dstbinding((uint32_t)input->dstBinding);
    output->set_dstarrayelement((uint32_t)input->dstArrayElement);
    output->set_descriptorcount((uint32_t)input->descriptorCount);
    output->set_descriptortype((uint32_t)input->descriptorType);
    // WARNING PTR CHECK
    if (input->pImageInfo)
    {
        for (uint32_t i = 0; i < (uint32_t)input->descriptorCount; ++i)
        {
            to_proto_VkDescriptorImageInfo(handleMapping, input->pImageInfo + i, output->add_pimageinfo());
        }
    }
    // WARNING PTR CHECK
    if (input->pBufferInfo)
    {
        for (uint32_t i = 0; i < (uint32_t)input->descriptorCount; ++i)
        {
            to_proto_VkDescriptorBufferInfo(handleMapping, input->pBufferInfo + i, output->add_pbufferinfo());
        }
    }
    // WARNING PTR CHECK
    if (input->pTexelBufferView)
    {
        if (input->descriptorCount)
        {
            std::vector<uint64_t> cgen_var_27(input->descriptorCount);
            handleMapping->mapHandles_VkBufferView_u64(input->pTexelBufferView, cgen_var_27.data(), input->descriptorCount);
            for (uint32_t i = 0; i < input->descriptorCount; ++i)
            {
                output->add_ptexelbufferview(cgen_var_27[i]);
            }
        }
    }
}

void from_proto_VkWriteDescriptorSet(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkWriteDescriptorSet* input,
    VkWriteDescriptorSet* output)
{
    memset(output, 0x0, sizeof(VkWriteDescriptorSet));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->dstset();
        handleMapping->mapHandles_u64_VkDescriptorSet(&current, (VkDescriptorSet*)&output->dstSet, 1);
    }
    output->dstBinding = (uint32_t)input->dstbinding();
    output->dstArrayElement = (uint32_t)input->dstarrayelement();
    output->descriptorCount = (uint32_t)input->descriptorcount();
    output->descriptorType = (VkDescriptorType)input->descriptortype();
    // WARNING PTR CHECK
    if (input->pimageinfo_size())
    {
        *(void**)&output->pImageInfo = pool->alloc(output->descriptorCount * sizeof(const VkDescriptorImageInfo));
        for (uint32_t i = 0; i < (uint32_t)output->descriptorCount; ++i)
        {
            from_proto_VkDescriptorImageInfo(pool, handleMapping, input->mutable_pimageinfo(i), (VkDescriptorImageInfo*)(output->pImageInfo + i));
        }
    }
    // WARNING PTR CHECK
    if (input->pbufferinfo_size())
    {
        *(void**)&output->pBufferInfo = pool->alloc(output->descriptorCount * sizeof(const VkDescriptorBufferInfo));
        for (uint32_t i = 0; i < (uint32_t)output->descriptorCount; ++i)
        {
            from_proto_VkDescriptorBufferInfo(pool, handleMapping, input->mutable_pbufferinfo(i), (VkDescriptorBufferInfo*)(output->pBufferInfo + i));
        }
    }
    // WARNING PTR CHECK
    if (input->ptexelbufferview_size())
    {
        if (output->descriptorCount)
        {
            for (uint32_t i = 0; i < output->descriptorCount; ++i)
            {
                uint64_t current = input->ptexelbufferview(i);
                handleMapping->mapHandles_u64_VkBufferView(&current, (VkBufferView*)&output->pTexelBufferView[i], 1);
            }
        }
    }
}

void to_proto_VkCopyDescriptorSet(
    VulkanHandleMapping* handleMapping,
    const VkCopyDescriptorSet* input,
    goldfish_vk_proto::VkCopyDescriptorSet* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_28;
    handleMapping->mapHandles_VkDescriptorSet_u64(&input->srcSet, &cgen_var_28, 1);
    output->set_srcset(cgen_var_28);
    output->set_srcbinding((uint32_t)input->srcBinding);
    output->set_srcarrayelement((uint32_t)input->srcArrayElement);
    uint64_t cgen_var_29;
    handleMapping->mapHandles_VkDescriptorSet_u64(&input->dstSet, &cgen_var_29, 1);
    output->set_dstset(cgen_var_29);
    output->set_dstbinding((uint32_t)input->dstBinding);
    output->set_dstarrayelement((uint32_t)input->dstArrayElement);
    output->set_descriptorcount((uint32_t)input->descriptorCount);
}

void from_proto_VkCopyDescriptorSet(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkCopyDescriptorSet* input,
    VkCopyDescriptorSet* output)
{
    memset(output, 0x0, sizeof(VkCopyDescriptorSet));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->srcset();
        handleMapping->mapHandles_u64_VkDescriptorSet(&current, (VkDescriptorSet*)&output->srcSet, 1);
    }
    output->srcBinding = (uint32_t)input->srcbinding();
    output->srcArrayElement = (uint32_t)input->srcarrayelement();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->dstset();
        handleMapping->mapHandles_u64_VkDescriptorSet(&current, (VkDescriptorSet*)&output->dstSet, 1);
    }
    output->dstBinding = (uint32_t)input->dstbinding();
    output->dstArrayElement = (uint32_t)input->dstarrayelement();
    output->descriptorCount = (uint32_t)input->descriptorcount();
}

void to_proto_VkFramebufferCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkFramebufferCreateInfo* input,
    goldfish_vk_proto::VkFramebufferCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    uint64_t cgen_var_30;
    handleMapping->mapHandles_VkRenderPass_u64(&input->renderPass, &cgen_var_30, 1);
    output->set_renderpass(cgen_var_30);
    output->set_attachmentcount((uint32_t)input->attachmentCount);
    if (input->attachmentCount)
    {
        std::vector<uint64_t> cgen_var_31(input->attachmentCount);
        handleMapping->mapHandles_VkImageView_u64(input->pAttachments, cgen_var_31.data(), input->attachmentCount);
        for (uint32_t i = 0; i < input->attachmentCount; ++i)
        {
            output->add_pattachments(cgen_var_31[i]);
        }
    }
    output->set_width((uint32_t)input->width);
    output->set_height((uint32_t)input->height);
    output->set_layers((uint32_t)input->layers);
}

void from_proto_VkFramebufferCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkFramebufferCreateInfo* input,
    VkFramebufferCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkFramebufferCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkFramebufferCreateFlags)input->flags();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->renderpass();
        handleMapping->mapHandles_u64_VkRenderPass(&current, (VkRenderPass*)&output->renderPass, 1);
    }
    output->attachmentCount = (uint32_t)input->attachmentcount();
    if (output->attachmentCount)
    {
        for (uint32_t i = 0; i < output->attachmentCount; ++i)
        {
            uint64_t current = input->pattachments(i);
            handleMapping->mapHandles_u64_VkImageView(&current, (VkImageView*)&output->pAttachments[i], 1);
        }
    }
    output->width = (uint32_t)input->width();
    output->height = (uint32_t)input->height();
    output->layers = (uint32_t)input->layers();
}

void to_proto_VkAttachmentDescription(
    VulkanHandleMapping* handleMapping,
    const VkAttachmentDescription* input,
    goldfish_vk_proto::VkAttachmentDescription* output)
{
    output->set_flags((uint32_t)input->flags);
    output->set_format((uint32_t)input->format);
    output->set_samples((uint32_t)input->samples);
    output->set_loadop((uint32_t)input->loadOp);
    output->set_storeop((uint32_t)input->storeOp);
    output->set_stencilloadop((uint32_t)input->stencilLoadOp);
    output->set_stencilstoreop((uint32_t)input->stencilStoreOp);
    output->set_initiallayout((uint32_t)input->initialLayout);
    output->set_finallayout((uint32_t)input->finalLayout);
}

void from_proto_VkAttachmentDescription(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkAttachmentDescription* input,
    VkAttachmentDescription* output)
{
    memset(output, 0x0, sizeof(VkAttachmentDescription));
    output->flags = (VkAttachmentDescriptionFlags)input->flags();
    output->format = (VkFormat)input->format();
    output->samples = (VkSampleCountFlagBits)input->samples();
    output->loadOp = (VkAttachmentLoadOp)input->loadop();
    output->storeOp = (VkAttachmentStoreOp)input->storeop();
    output->stencilLoadOp = (VkAttachmentLoadOp)input->stencilloadop();
    output->stencilStoreOp = (VkAttachmentStoreOp)input->stencilstoreop();
    output->initialLayout = (VkImageLayout)input->initiallayout();
    output->finalLayout = (VkImageLayout)input->finallayout();
}

void to_proto_VkAttachmentReference(
    VulkanHandleMapping* handleMapping,
    const VkAttachmentReference* input,
    goldfish_vk_proto::VkAttachmentReference* output)
{
    output->set_attachment((uint32_t)input->attachment);
    output->set_layout((uint32_t)input->layout);
}

void from_proto_VkAttachmentReference(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkAttachmentReference* input,
    VkAttachmentReference* output)
{
    memset(output, 0x0, sizeof(VkAttachmentReference));
    output->attachment = (uint32_t)input->attachment();
    output->layout = (VkImageLayout)input->layout();
}

void to_proto_VkSubpassDescription(
    VulkanHandleMapping* handleMapping,
    const VkSubpassDescription* input,
    goldfish_vk_proto::VkSubpassDescription* output)
{
    output->set_flags((uint32_t)input->flags);
    output->set_pipelinebindpoint((uint32_t)input->pipelineBindPoint);
    output->set_inputattachmentcount((uint32_t)input->inputAttachmentCount);
    for (uint32_t i = 0; i < (uint32_t)input->inputAttachmentCount; ++i)
    {
        to_proto_VkAttachmentReference(handleMapping, input->pInputAttachments + i, output->add_pinputattachments());
    }
    output->set_colorattachmentcount((uint32_t)input->colorAttachmentCount);
    for (uint32_t i = 0; i < (uint32_t)input->colorAttachmentCount; ++i)
    {
        to_proto_VkAttachmentReference(handleMapping, input->pColorAttachments + i, output->add_pcolorattachments());
    }
    // WARNING PTR CHECK
    if (input->pResolveAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)input->colorAttachmentCount; ++i)
        {
            to_proto_VkAttachmentReference(handleMapping, input->pResolveAttachments + i, output->add_presolveattachments());
        }
    }
    // WARNING PTR CHECK
    if (input->pDepthStencilAttachment)
    {
        to_proto_VkAttachmentReference(handleMapping, input->pDepthStencilAttachment, output->mutable_pdepthstencilattachment());
    }
    output->set_preserveattachmentcount((uint32_t)input->preserveAttachmentCount);
    for (uint32_t i = 0; i < (uint32_t)input->preserveAttachmentCount; ++i)
    {
        output->add_ppreserveattachments(input->pPreserveAttachments[i]);
    }
}

void from_proto_VkSubpassDescription(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSubpassDescription* input,
    VkSubpassDescription* output)
{
    memset(output, 0x0, sizeof(VkSubpassDescription));
    output->flags = (VkSubpassDescriptionFlags)input->flags();
    output->pipelineBindPoint = (VkPipelineBindPoint)input->pipelinebindpoint();
    output->inputAttachmentCount = (uint32_t)input->inputattachmentcount();
    *(void**)&output->pInputAttachments = pool->alloc(output->inputAttachmentCount * sizeof(const VkAttachmentReference));
    for (uint32_t i = 0; i < (uint32_t)output->inputAttachmentCount; ++i)
    {
        from_proto_VkAttachmentReference(pool, handleMapping, input->mutable_pinputattachments(i), (VkAttachmentReference*)(output->pInputAttachments + i));
    }
    output->colorAttachmentCount = (uint32_t)input->colorattachmentcount();
    *(void**)&output->pColorAttachments = pool->alloc(output->colorAttachmentCount * sizeof(const VkAttachmentReference));
    for (uint32_t i = 0; i < (uint32_t)output->colorAttachmentCount; ++i)
    {
        from_proto_VkAttachmentReference(pool, handleMapping, input->mutable_pcolorattachments(i), (VkAttachmentReference*)(output->pColorAttachments + i));
    }
    // WARNING PTR CHECK
    if (input->presolveattachments_size())
    {
        *(void**)&output->pResolveAttachments = pool->alloc(output->colorAttachmentCount * sizeof(const VkAttachmentReference));
        for (uint32_t i = 0; i < (uint32_t)output->colorAttachmentCount; ++i)
        {
            from_proto_VkAttachmentReference(pool, handleMapping, input->mutable_presolveattachments(i), (VkAttachmentReference*)(output->pResolveAttachments + i));
        }
    }
    // WARNING PTR CHECK
    if (input->has_pdepthstencilattachment())
    {
        *(void**)&output->pDepthStencilAttachment = pool->alloc(sizeof(const VkAttachmentReference));
        from_proto_VkAttachmentReference(pool, handleMapping, input->mutable_pdepthstencilattachment(), (VkAttachmentReference*)(output->pDepthStencilAttachment));
    }
    output->preserveAttachmentCount = (uint32_t)input->preserveattachmentcount();
    for (uint32_t i = 0; i < (uint32_t)output->preserveAttachmentCount; ++i)
    {
        *((uint32_t*)(&output->pPreserveAttachments) + i) = (uint32_t)input->ppreserveattachments(i);
    }
}

void to_proto_VkSubpassDependency(
    VulkanHandleMapping* handleMapping,
    const VkSubpassDependency* input,
    goldfish_vk_proto::VkSubpassDependency* output)
{
    output->set_srcsubpass((uint32_t)input->srcSubpass);
    output->set_dstsubpass((uint32_t)input->dstSubpass);
    output->set_srcstagemask((uint32_t)input->srcStageMask);
    output->set_dststagemask((uint32_t)input->dstStageMask);
    output->set_srcaccessmask((uint32_t)input->srcAccessMask);
    output->set_dstaccessmask((uint32_t)input->dstAccessMask);
    output->set_dependencyflags((uint32_t)input->dependencyFlags);
}

void from_proto_VkSubpassDependency(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSubpassDependency* input,
    VkSubpassDependency* output)
{
    memset(output, 0x0, sizeof(VkSubpassDependency));
    output->srcSubpass = (uint32_t)input->srcsubpass();
    output->dstSubpass = (uint32_t)input->dstsubpass();
    output->srcStageMask = (VkPipelineStageFlags)input->srcstagemask();
    output->dstStageMask = (VkPipelineStageFlags)input->dststagemask();
    output->srcAccessMask = (VkAccessFlags)input->srcaccessmask();
    output->dstAccessMask = (VkAccessFlags)input->dstaccessmask();
    output->dependencyFlags = (VkDependencyFlags)input->dependencyflags();
}

void to_proto_VkRenderPassCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkRenderPassCreateInfo* input,
    goldfish_vk_proto::VkRenderPassCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_attachmentcount((uint32_t)input->attachmentCount);
    for (uint32_t i = 0; i < (uint32_t)input->attachmentCount; ++i)
    {
        to_proto_VkAttachmentDescription(handleMapping, input->pAttachments + i, output->add_pattachments());
    }
    output->set_subpasscount((uint32_t)input->subpassCount);
    for (uint32_t i = 0; i < (uint32_t)input->subpassCount; ++i)
    {
        to_proto_VkSubpassDescription(handleMapping, input->pSubpasses + i, output->add_psubpasses());
    }
    output->set_dependencycount((uint32_t)input->dependencyCount);
    for (uint32_t i = 0; i < (uint32_t)input->dependencyCount; ++i)
    {
        to_proto_VkSubpassDependency(handleMapping, input->pDependencies + i, output->add_pdependencies());
    }
}

void from_proto_VkRenderPassCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkRenderPassCreateInfo* input,
    VkRenderPassCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkRenderPassCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkRenderPassCreateFlags)input->flags();
    output->attachmentCount = (uint32_t)input->attachmentcount();
    *(void**)&output->pAttachments = pool->alloc(output->attachmentCount * sizeof(const VkAttachmentDescription));
    for (uint32_t i = 0; i < (uint32_t)output->attachmentCount; ++i)
    {
        from_proto_VkAttachmentDescription(pool, handleMapping, input->mutable_pattachments(i), (VkAttachmentDescription*)(output->pAttachments + i));
    }
    output->subpassCount = (uint32_t)input->subpasscount();
    *(void**)&output->pSubpasses = pool->alloc(output->subpassCount * sizeof(const VkSubpassDescription));
    for (uint32_t i = 0; i < (uint32_t)output->subpassCount; ++i)
    {
        from_proto_VkSubpassDescription(pool, handleMapping, input->mutable_psubpasses(i), (VkSubpassDescription*)(output->pSubpasses + i));
    }
    output->dependencyCount = (uint32_t)input->dependencycount();
    *(void**)&output->pDependencies = pool->alloc(output->dependencyCount * sizeof(const VkSubpassDependency));
    for (uint32_t i = 0; i < (uint32_t)output->dependencyCount; ++i)
    {
        from_proto_VkSubpassDependency(pool, handleMapping, input->mutable_pdependencies(i), (VkSubpassDependency*)(output->pDependencies + i));
    }
}

void to_proto_VkCommandPoolCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkCommandPoolCreateInfo* input,
    goldfish_vk_proto::VkCommandPoolCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_queuefamilyindex((uint32_t)input->queueFamilyIndex);
}

void from_proto_VkCommandPoolCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkCommandPoolCreateInfo* input,
    VkCommandPoolCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkCommandPoolCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkCommandPoolCreateFlags)input->flags();
    output->queueFamilyIndex = (uint32_t)input->queuefamilyindex();
}

void to_proto_VkCommandBufferAllocateInfo(
    VulkanHandleMapping* handleMapping,
    const VkCommandBufferAllocateInfo* input,
    goldfish_vk_proto::VkCommandBufferAllocateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_32;
    handleMapping->mapHandles_VkCommandPool_u64(&input->commandPool, &cgen_var_32, 1);
    output->set_commandpool(cgen_var_32);
    output->set_level((uint32_t)input->level);
    output->set_commandbuffercount((uint32_t)input->commandBufferCount);
}

void from_proto_VkCommandBufferAllocateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkCommandBufferAllocateInfo* input,
    VkCommandBufferAllocateInfo* output)
{
    memset(output, 0x0, sizeof(VkCommandBufferAllocateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->commandpool();
        handleMapping->mapHandles_u64_VkCommandPool(&current, (VkCommandPool*)&output->commandPool, 1);
    }
    output->level = (VkCommandBufferLevel)input->level();
    output->commandBufferCount = (uint32_t)input->commandbuffercount();
}

void to_proto_VkCommandBufferInheritanceInfo(
    VulkanHandleMapping* handleMapping,
    const VkCommandBufferInheritanceInfo* input,
    goldfish_vk_proto::VkCommandBufferInheritanceInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_33;
    handleMapping->mapHandles_VkRenderPass_u64(&input->renderPass, &cgen_var_33, 1);
    output->set_renderpass(cgen_var_33);
    output->set_subpass((uint32_t)input->subpass);
    uint64_t cgen_var_34;
    handleMapping->mapHandles_VkFramebuffer_u64(&input->framebuffer, &cgen_var_34, 1);
    output->set_framebuffer(cgen_var_34);
    output->set_occlusionqueryenable((uint32_t)input->occlusionQueryEnable);
    output->set_queryflags((uint32_t)input->queryFlags);
    output->set_pipelinestatistics((uint32_t)input->pipelineStatistics);
}

void from_proto_VkCommandBufferInheritanceInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkCommandBufferInheritanceInfo* input,
    VkCommandBufferInheritanceInfo* output)
{
    memset(output, 0x0, sizeof(VkCommandBufferInheritanceInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->renderpass();
        handleMapping->mapHandles_u64_VkRenderPass(&current, (VkRenderPass*)&output->renderPass, 1);
    }
    output->subpass = (uint32_t)input->subpass();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->framebuffer();
        handleMapping->mapHandles_u64_VkFramebuffer(&current, (VkFramebuffer*)&output->framebuffer, 1);
    }
    output->occlusionQueryEnable = (VkBool32)input->occlusionqueryenable();
    output->queryFlags = (VkQueryControlFlags)input->queryflags();
    output->pipelineStatistics = (VkQueryPipelineStatisticFlags)input->pipelinestatistics();
}

void to_proto_VkCommandBufferBeginInfo(
    VulkanHandleMapping* handleMapping,
    const VkCommandBufferBeginInfo* input,
    goldfish_vk_proto::VkCommandBufferBeginInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    // WARNING PTR CHECK
    if (input->pInheritanceInfo)
    {
        to_proto_VkCommandBufferInheritanceInfo(handleMapping, input->pInheritanceInfo, output->mutable_pinheritanceinfo());
    }
}

void from_proto_VkCommandBufferBeginInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkCommandBufferBeginInfo* input,
    VkCommandBufferBeginInfo* output)
{
    memset(output, 0x0, sizeof(VkCommandBufferBeginInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkCommandBufferUsageFlags)input->flags();
    // WARNING PTR CHECK
    if (input->has_pinheritanceinfo())
    {
        *(void**)&output->pInheritanceInfo = pool->alloc(sizeof(const VkCommandBufferInheritanceInfo));
        from_proto_VkCommandBufferInheritanceInfo(pool, handleMapping, input->mutable_pinheritanceinfo(), (VkCommandBufferInheritanceInfo*)(output->pInheritanceInfo));
    }
}

void to_proto_VkBufferCopy(
    VulkanHandleMapping* handleMapping,
    const VkBufferCopy* input,
    goldfish_vk_proto::VkBufferCopy* output)
{
    output->set_srcoffset((uint64_t)input->srcOffset);
    output->set_dstoffset((uint64_t)input->dstOffset);
    output->set_size((uint64_t)input->size);
}

void from_proto_VkBufferCopy(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBufferCopy* input,
    VkBufferCopy* output)
{
    memset(output, 0x0, sizeof(VkBufferCopy));
    output->srcOffset = (VkDeviceSize)input->srcoffset();
    output->dstOffset = (VkDeviceSize)input->dstoffset();
    output->size = (VkDeviceSize)input->size();
}

void to_proto_VkImageSubresourceLayers(
    VulkanHandleMapping* handleMapping,
    const VkImageSubresourceLayers* input,
    goldfish_vk_proto::VkImageSubresourceLayers* output)
{
    output->set_aspectmask((uint32_t)input->aspectMask);
    output->set_miplevel((uint32_t)input->mipLevel);
    output->set_basearraylayer((uint32_t)input->baseArrayLayer);
    output->set_layercount((uint32_t)input->layerCount);
}

void from_proto_VkImageSubresourceLayers(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageSubresourceLayers* input,
    VkImageSubresourceLayers* output)
{
    memset(output, 0x0, sizeof(VkImageSubresourceLayers));
    output->aspectMask = (VkImageAspectFlags)input->aspectmask();
    output->mipLevel = (uint32_t)input->miplevel();
    output->baseArrayLayer = (uint32_t)input->basearraylayer();
    output->layerCount = (uint32_t)input->layercount();
}

void to_proto_VkImageCopy(
    VulkanHandleMapping* handleMapping,
    const VkImageCopy* input,
    goldfish_vk_proto::VkImageCopy* output)
{
    to_proto_VkImageSubresourceLayers(handleMapping, &input->srcSubresource, output->mutable_srcsubresource());
    to_proto_VkOffset3D(handleMapping, &input->srcOffset, output->mutable_srcoffset());
    to_proto_VkImageSubresourceLayers(handleMapping, &input->dstSubresource, output->mutable_dstsubresource());
    to_proto_VkOffset3D(handleMapping, &input->dstOffset, output->mutable_dstoffset());
    to_proto_VkExtent3D(handleMapping, &input->extent, output->mutable_extent());
}

void from_proto_VkImageCopy(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageCopy* input,
    VkImageCopy* output)
{
    memset(output, 0x0, sizeof(VkImageCopy));
    from_proto_VkImageSubresourceLayers(pool, handleMapping, input->mutable_srcsubresource(), (VkImageSubresourceLayers*)(&output->srcSubresource));
    from_proto_VkOffset3D(pool, handleMapping, input->mutable_srcoffset(), (VkOffset3D*)(&output->srcOffset));
    from_proto_VkImageSubresourceLayers(pool, handleMapping, input->mutable_dstsubresource(), (VkImageSubresourceLayers*)(&output->dstSubresource));
    from_proto_VkOffset3D(pool, handleMapping, input->mutable_dstoffset(), (VkOffset3D*)(&output->dstOffset));
    from_proto_VkExtent3D(pool, handleMapping, input->mutable_extent(), (VkExtent3D*)(&output->extent));
}

void to_proto_VkImageBlit(
    VulkanHandleMapping* handleMapping,
    const VkImageBlit* input,
    goldfish_vk_proto::VkImageBlit* output)
{
    to_proto_VkImageSubresourceLayers(handleMapping, &input->srcSubresource, output->mutable_srcsubresource());
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        to_proto_VkOffset3D(handleMapping, input->srcOffsets + i, output->add_srcoffsets());
    }
    to_proto_VkImageSubresourceLayers(handleMapping, &input->dstSubresource, output->mutable_dstsubresource());
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        to_proto_VkOffset3D(handleMapping, input->dstOffsets + i, output->add_dstoffsets());
    }
}

void from_proto_VkImageBlit(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageBlit* input,
    VkImageBlit* output)
{
    memset(output, 0x0, sizeof(VkImageBlit));
    from_proto_VkImageSubresourceLayers(pool, handleMapping, input->mutable_srcsubresource(), (VkImageSubresourceLayers*)(&output->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        from_proto_VkOffset3D(pool, handleMapping, input->mutable_srcoffsets(i), (VkOffset3D*)(output->srcOffsets + i));
    }
    from_proto_VkImageSubresourceLayers(pool, handleMapping, input->mutable_dstsubresource(), (VkImageSubresourceLayers*)(&output->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        from_proto_VkOffset3D(pool, handleMapping, input->mutable_dstoffsets(i), (VkOffset3D*)(output->dstOffsets + i));
    }
}

void to_proto_VkBufferImageCopy(
    VulkanHandleMapping* handleMapping,
    const VkBufferImageCopy* input,
    goldfish_vk_proto::VkBufferImageCopy* output)
{
    output->set_bufferoffset((uint64_t)input->bufferOffset);
    output->set_bufferrowlength((uint32_t)input->bufferRowLength);
    output->set_bufferimageheight((uint32_t)input->bufferImageHeight);
    to_proto_VkImageSubresourceLayers(handleMapping, &input->imageSubresource, output->mutable_imagesubresource());
    to_proto_VkOffset3D(handleMapping, &input->imageOffset, output->mutable_imageoffset());
    to_proto_VkExtent3D(handleMapping, &input->imageExtent, output->mutable_imageextent());
}

void from_proto_VkBufferImageCopy(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBufferImageCopy* input,
    VkBufferImageCopy* output)
{
    memset(output, 0x0, sizeof(VkBufferImageCopy));
    output->bufferOffset = (VkDeviceSize)input->bufferoffset();
    output->bufferRowLength = (uint32_t)input->bufferrowlength();
    output->bufferImageHeight = (uint32_t)input->bufferimageheight();
    from_proto_VkImageSubresourceLayers(pool, handleMapping, input->mutable_imagesubresource(), (VkImageSubresourceLayers*)(&output->imageSubresource));
    from_proto_VkOffset3D(pool, handleMapping, input->mutable_imageoffset(), (VkOffset3D*)(&output->imageOffset));
    from_proto_VkExtent3D(pool, handleMapping, input->mutable_imageextent(), (VkExtent3D*)(&output->imageExtent));
}

void to_proto_VkClearColorValue(
    VulkanHandleMapping* handleMapping,
    const VkClearColorValue* input,
    goldfish_vk_proto::VkClearColorValue* output)
{
    for (uint32_t i = 0; i < (uint32_t)4; ++i)
    {
        output->add_float32(input->float32[i]);
    }
}

void from_proto_VkClearColorValue(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkClearColorValue* input,
    VkClearColorValue* output)
{
    for (uint32_t i = 0; i < (uint32_t)4; ++i)
    {
        output->float32[i] = (float)input->float32(i);
    }
}

void to_proto_VkClearDepthStencilValue(
    VulkanHandleMapping* handleMapping,
    const VkClearDepthStencilValue* input,
    goldfish_vk_proto::VkClearDepthStencilValue* output)
{
    output->set_depth((float)input->depth);
    output->set_stencil((uint32_t)input->stencil);
}

void from_proto_VkClearDepthStencilValue(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkClearDepthStencilValue* input,
    VkClearDepthStencilValue* output)
{
    memset(output, 0x0, sizeof(VkClearDepthStencilValue));
    output->depth = (float)input->depth();
    output->stencil = (uint32_t)input->stencil();
}

void to_proto_VkClearValue(
    VulkanHandleMapping* handleMapping,
    const VkClearValue* input,
    goldfish_vk_proto::VkClearValue* output)
{
    to_proto_VkClearColorValue(handleMapping, &input->color, output->mutable_color());
}

void from_proto_VkClearValue(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkClearValue* input,
    VkClearValue* output)
{
    from_proto_VkClearColorValue(pool, handleMapping, input->mutable_color(), (VkClearColorValue*)(&output->color));
}

void to_proto_VkClearAttachment(
    VulkanHandleMapping* handleMapping,
    const VkClearAttachment* input,
    goldfish_vk_proto::VkClearAttachment* output)
{
    output->set_aspectmask((uint32_t)input->aspectMask);
    output->set_colorattachment((uint32_t)input->colorAttachment);
    to_proto_VkClearValue(handleMapping, &input->clearValue, output->mutable_clearvalue());
}

void from_proto_VkClearAttachment(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkClearAttachment* input,
    VkClearAttachment* output)
{
    memset(output, 0x0, sizeof(VkClearAttachment));
    output->aspectMask = (VkImageAspectFlags)input->aspectmask();
    output->colorAttachment = (uint32_t)input->colorattachment();
    from_proto_VkClearValue(pool, handleMapping, input->mutable_clearvalue(), (VkClearValue*)(&output->clearValue));
}

void to_proto_VkClearRect(
    VulkanHandleMapping* handleMapping,
    const VkClearRect* input,
    goldfish_vk_proto::VkClearRect* output)
{
    to_proto_VkRect2D(handleMapping, &input->rect, output->mutable_rect());
    output->set_basearraylayer((uint32_t)input->baseArrayLayer);
    output->set_layercount((uint32_t)input->layerCount);
}

void from_proto_VkClearRect(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkClearRect* input,
    VkClearRect* output)
{
    memset(output, 0x0, sizeof(VkClearRect));
    from_proto_VkRect2D(pool, handleMapping, input->mutable_rect(), (VkRect2D*)(&output->rect));
    output->baseArrayLayer = (uint32_t)input->basearraylayer();
    output->layerCount = (uint32_t)input->layercount();
}

void to_proto_VkImageResolve(
    VulkanHandleMapping* handleMapping,
    const VkImageResolve* input,
    goldfish_vk_proto::VkImageResolve* output)
{
    to_proto_VkImageSubresourceLayers(handleMapping, &input->srcSubresource, output->mutable_srcsubresource());
    to_proto_VkOffset3D(handleMapping, &input->srcOffset, output->mutable_srcoffset());
    to_proto_VkImageSubresourceLayers(handleMapping, &input->dstSubresource, output->mutable_dstsubresource());
    to_proto_VkOffset3D(handleMapping, &input->dstOffset, output->mutable_dstoffset());
    to_proto_VkExtent3D(handleMapping, &input->extent, output->mutable_extent());
}

void from_proto_VkImageResolve(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageResolve* input,
    VkImageResolve* output)
{
    memset(output, 0x0, sizeof(VkImageResolve));
    from_proto_VkImageSubresourceLayers(pool, handleMapping, input->mutable_srcsubresource(), (VkImageSubresourceLayers*)(&output->srcSubresource));
    from_proto_VkOffset3D(pool, handleMapping, input->mutable_srcoffset(), (VkOffset3D*)(&output->srcOffset));
    from_proto_VkImageSubresourceLayers(pool, handleMapping, input->mutable_dstsubresource(), (VkImageSubresourceLayers*)(&output->dstSubresource));
    from_proto_VkOffset3D(pool, handleMapping, input->mutable_dstoffset(), (VkOffset3D*)(&output->dstOffset));
    from_proto_VkExtent3D(pool, handleMapping, input->mutable_extent(), (VkExtent3D*)(&output->extent));
}

void to_proto_VkMemoryBarrier(
    VulkanHandleMapping* handleMapping,
    const VkMemoryBarrier* input,
    goldfish_vk_proto::VkMemoryBarrier* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_srcaccessmask((uint32_t)input->srcAccessMask);
    output->set_dstaccessmask((uint32_t)input->dstAccessMask);
}

void from_proto_VkMemoryBarrier(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryBarrier* input,
    VkMemoryBarrier* output)
{
    memset(output, 0x0, sizeof(VkMemoryBarrier));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->srcAccessMask = (VkAccessFlags)input->srcaccessmask();
    output->dstAccessMask = (VkAccessFlags)input->dstaccessmask();
}

void to_proto_VkBufferMemoryBarrier(
    VulkanHandleMapping* handleMapping,
    const VkBufferMemoryBarrier* input,
    goldfish_vk_proto::VkBufferMemoryBarrier* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_srcaccessmask((uint32_t)input->srcAccessMask);
    output->set_dstaccessmask((uint32_t)input->dstAccessMask);
    output->set_srcqueuefamilyindex((uint32_t)input->srcQueueFamilyIndex);
    output->set_dstqueuefamilyindex((uint32_t)input->dstQueueFamilyIndex);
    uint64_t cgen_var_35;
    handleMapping->mapHandles_VkBuffer_u64(&input->buffer, &cgen_var_35, 1);
    output->set_buffer(cgen_var_35);
    output->set_offset((uint64_t)input->offset);
    output->set_size((uint64_t)input->size);
}

void from_proto_VkBufferMemoryBarrier(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBufferMemoryBarrier* input,
    VkBufferMemoryBarrier* output)
{
    memset(output, 0x0, sizeof(VkBufferMemoryBarrier));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->srcAccessMask = (VkAccessFlags)input->srcaccessmask();
    output->dstAccessMask = (VkAccessFlags)input->dstaccessmask();
    output->srcQueueFamilyIndex = (uint32_t)input->srcqueuefamilyindex();
    output->dstQueueFamilyIndex = (uint32_t)input->dstqueuefamilyindex();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->buffer();
        handleMapping->mapHandles_u64_VkBuffer(&current, (VkBuffer*)&output->buffer, 1);
    }
    output->offset = (VkDeviceSize)input->offset();
    output->size = (VkDeviceSize)input->size();
}

void to_proto_VkImageMemoryBarrier(
    VulkanHandleMapping* handleMapping,
    const VkImageMemoryBarrier* input,
    goldfish_vk_proto::VkImageMemoryBarrier* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_srcaccessmask((uint32_t)input->srcAccessMask);
    output->set_dstaccessmask((uint32_t)input->dstAccessMask);
    output->set_oldlayout((uint32_t)input->oldLayout);
    output->set_newlayout((uint32_t)input->newLayout);
    output->set_srcqueuefamilyindex((uint32_t)input->srcQueueFamilyIndex);
    output->set_dstqueuefamilyindex((uint32_t)input->dstQueueFamilyIndex);
    uint64_t cgen_var_36;
    handleMapping->mapHandles_VkImage_u64(&input->image, &cgen_var_36, 1);
    output->set_image(cgen_var_36);
    to_proto_VkImageSubresourceRange(handleMapping, &input->subresourceRange, output->mutable_subresourcerange());
}

void from_proto_VkImageMemoryBarrier(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageMemoryBarrier* input,
    VkImageMemoryBarrier* output)
{
    memset(output, 0x0, sizeof(VkImageMemoryBarrier));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->srcAccessMask = (VkAccessFlags)input->srcaccessmask();
    output->dstAccessMask = (VkAccessFlags)input->dstaccessmask();
    output->oldLayout = (VkImageLayout)input->oldlayout();
    output->newLayout = (VkImageLayout)input->newlayout();
    output->srcQueueFamilyIndex = (uint32_t)input->srcqueuefamilyindex();
    output->dstQueueFamilyIndex = (uint32_t)input->dstqueuefamilyindex();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->image();
        handleMapping->mapHandles_u64_VkImage(&current, (VkImage*)&output->image, 1);
    }
    from_proto_VkImageSubresourceRange(pool, handleMapping, input->mutable_subresourcerange(), (VkImageSubresourceRange*)(&output->subresourceRange));
}

void to_proto_VkRenderPassBeginInfo(
    VulkanHandleMapping* handleMapping,
    const VkRenderPassBeginInfo* input,
    goldfish_vk_proto::VkRenderPassBeginInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_37;
    handleMapping->mapHandles_VkRenderPass_u64(&input->renderPass, &cgen_var_37, 1);
    output->set_renderpass(cgen_var_37);
    uint64_t cgen_var_38;
    handleMapping->mapHandles_VkFramebuffer_u64(&input->framebuffer, &cgen_var_38, 1);
    output->set_framebuffer(cgen_var_38);
    to_proto_VkRect2D(handleMapping, &input->renderArea, output->mutable_renderarea());
    output->set_clearvaluecount((uint32_t)input->clearValueCount);
    // WARNING PTR CHECK
    if (input->pClearValues)
    {
        for (uint32_t i = 0; i < (uint32_t)input->clearValueCount; ++i)
        {
            to_proto_VkClearValue(handleMapping, input->pClearValues + i, output->add_pclearvalues());
        }
    }
}

void from_proto_VkRenderPassBeginInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkRenderPassBeginInfo* input,
    VkRenderPassBeginInfo* output)
{
    memset(output, 0x0, sizeof(VkRenderPassBeginInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->renderpass();
        handleMapping->mapHandles_u64_VkRenderPass(&current, (VkRenderPass*)&output->renderPass, 1);
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->framebuffer();
        handleMapping->mapHandles_u64_VkFramebuffer(&current, (VkFramebuffer*)&output->framebuffer, 1);
    }
    from_proto_VkRect2D(pool, handleMapping, input->mutable_renderarea(), (VkRect2D*)(&output->renderArea));
    output->clearValueCount = (uint32_t)input->clearvaluecount();
    // WARNING PTR CHECK
    if (input->pclearvalues_size())
    {
        *(void**)&output->pClearValues = pool->alloc(output->clearValueCount * sizeof(const VkClearValue));
        for (uint32_t i = 0; i < (uint32_t)output->clearValueCount; ++i)
        {
            from_proto_VkClearValue(pool, handleMapping, input->mutable_pclearvalues(i), (VkClearValue*)(output->pClearValues + i));
        }
    }
}

void to_proto_VkDispatchIndirectCommand(
    VulkanHandleMapping* handleMapping,
    const VkDispatchIndirectCommand* input,
    goldfish_vk_proto::VkDispatchIndirectCommand* output)
{
    output->set_x((uint32_t)input->x);
    output->set_y((uint32_t)input->y);
    output->set_z((uint32_t)input->z);
}

void from_proto_VkDispatchIndirectCommand(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDispatchIndirectCommand* input,
    VkDispatchIndirectCommand* output)
{
    memset(output, 0x0, sizeof(VkDispatchIndirectCommand));
    output->x = (uint32_t)input->x();
    output->y = (uint32_t)input->y();
    output->z = (uint32_t)input->z();
}

void to_proto_VkDrawIndexedIndirectCommand(
    VulkanHandleMapping* handleMapping,
    const VkDrawIndexedIndirectCommand* input,
    goldfish_vk_proto::VkDrawIndexedIndirectCommand* output)
{
    output->set_indexcount((uint32_t)input->indexCount);
    output->set_instancecount((uint32_t)input->instanceCount);
    output->set_firstindex((uint32_t)input->firstIndex);
    output->set_vertexoffset((int32_t)input->vertexOffset);
    output->set_firstinstance((uint32_t)input->firstInstance);
}

void from_proto_VkDrawIndexedIndirectCommand(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDrawIndexedIndirectCommand* input,
    VkDrawIndexedIndirectCommand* output)
{
    memset(output, 0x0, sizeof(VkDrawIndexedIndirectCommand));
    output->indexCount = (uint32_t)input->indexcount();
    output->instanceCount = (uint32_t)input->instancecount();
    output->firstIndex = (uint32_t)input->firstindex();
    output->vertexOffset = (int32_t)input->vertexoffset();
    output->firstInstance = (uint32_t)input->firstinstance();
}

void to_proto_VkDrawIndirectCommand(
    VulkanHandleMapping* handleMapping,
    const VkDrawIndirectCommand* input,
    goldfish_vk_proto::VkDrawIndirectCommand* output)
{
    output->set_vertexcount((uint32_t)input->vertexCount);
    output->set_instancecount((uint32_t)input->instanceCount);
    output->set_firstvertex((uint32_t)input->firstVertex);
    output->set_firstinstance((uint32_t)input->firstInstance);
}

void from_proto_VkDrawIndirectCommand(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDrawIndirectCommand* input,
    VkDrawIndirectCommand* output)
{
    memset(output, 0x0, sizeof(VkDrawIndirectCommand));
    output->vertexCount = (uint32_t)input->vertexcount();
    output->instanceCount = (uint32_t)input->instancecount();
    output->firstVertex = (uint32_t)input->firstvertex();
    output->firstInstance = (uint32_t)input->firstinstance();
}

void to_proto_VkBaseOutStructure(
    VulkanHandleMapping* handleMapping,
    const VkBaseOutStructure* input,
    goldfish_vk_proto::VkBaseOutStructure* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_VkBaseOutStructure(handleMapping, input->pNext, output->mutable_pnext());
    }
}

void from_proto_VkBaseOutStructure(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBaseOutStructure* input,
    VkBaseOutStructure* output)
{
    memset(output, 0x0, sizeof(VkBaseOutStructure));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        *(void**)&output->pNext = pool->alloc(sizeof(VkBaseOutStructure));
        from_proto_VkBaseOutStructure(pool, handleMapping, input->mutable_pnext(), (VkBaseOutStructure*)(output->pNext));
    }
}

void to_proto_VkBaseInStructure(
    VulkanHandleMapping* handleMapping,
    const VkBaseInStructure* input,
    goldfish_vk_proto::VkBaseInStructure* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_VkBaseInStructure(handleMapping, input->pNext, output->mutable_pnext());
    }
}

void from_proto_VkBaseInStructure(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBaseInStructure* input,
    VkBaseInStructure* output)
{
    memset(output, 0x0, sizeof(VkBaseInStructure));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        *(void**)&output->pNext = pool->alloc(sizeof(VkBaseInStructure));
        from_proto_VkBaseInStructure(pool, handleMapping, input->mutable_pnext(), (VkBaseInStructure*)(output->pNext));
    }
}

#endif
#ifdef VK_VERSION_1_1
void to_proto_VkPhysicalDeviceSubgroupProperties(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceSubgroupProperties* input,
    goldfish_vk_proto::VkPhysicalDeviceSubgroupProperties* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_subgroupsize((uint32_t)input->subgroupSize);
    output->set_supportedstages((uint32_t)input->supportedStages);
    output->set_supportedoperations((uint32_t)input->supportedOperations);
    output->set_quadoperationsinallstages((uint32_t)input->quadOperationsInAllStages);
}

void from_proto_VkPhysicalDeviceSubgroupProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceSubgroupProperties* input,
    VkPhysicalDeviceSubgroupProperties* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceSubgroupProperties));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->subgroupSize = (uint32_t)input->subgroupsize();
    output->supportedStages = (VkShaderStageFlags)input->supportedstages();
    output->supportedOperations = (VkSubgroupFeatureFlags)input->supportedoperations();
    output->quadOperationsInAllStages = (VkBool32)input->quadoperationsinallstages();
}

void to_proto_VkBindBufferMemoryInfo(
    VulkanHandleMapping* handleMapping,
    const VkBindBufferMemoryInfo* input,
    goldfish_vk_proto::VkBindBufferMemoryInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_39;
    handleMapping->mapHandles_VkBuffer_u64(&input->buffer, &cgen_var_39, 1);
    output->set_buffer(cgen_var_39);
    uint64_t cgen_var_40;
    handleMapping->mapHandles_VkDeviceMemory_u64(&input->memory, &cgen_var_40, 1);
    output->set_memory(cgen_var_40);
    output->set_memoryoffset((uint64_t)input->memoryOffset);
}

void from_proto_VkBindBufferMemoryInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBindBufferMemoryInfo* input,
    VkBindBufferMemoryInfo* output)
{
    memset(output, 0x0, sizeof(VkBindBufferMemoryInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->buffer();
        handleMapping->mapHandles_u64_VkBuffer(&current, (VkBuffer*)&output->buffer, 1);
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->memory();
        handleMapping->mapHandles_u64_VkDeviceMemory(&current, (VkDeviceMemory*)&output->memory, 1);
    }
    output->memoryOffset = (VkDeviceSize)input->memoryoffset();
}

void to_proto_VkBindImageMemoryInfo(
    VulkanHandleMapping* handleMapping,
    const VkBindImageMemoryInfo* input,
    goldfish_vk_proto::VkBindImageMemoryInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_41;
    handleMapping->mapHandles_VkImage_u64(&input->image, &cgen_var_41, 1);
    output->set_image(cgen_var_41);
    uint64_t cgen_var_42;
    handleMapping->mapHandles_VkDeviceMemory_u64(&input->memory, &cgen_var_42, 1);
    output->set_memory(cgen_var_42);
    output->set_memoryoffset((uint64_t)input->memoryOffset);
}

void from_proto_VkBindImageMemoryInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBindImageMemoryInfo* input,
    VkBindImageMemoryInfo* output)
{
    memset(output, 0x0, sizeof(VkBindImageMemoryInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->image();
        handleMapping->mapHandles_u64_VkImage(&current, (VkImage*)&output->image, 1);
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->memory();
        handleMapping->mapHandles_u64_VkDeviceMemory(&current, (VkDeviceMemory*)&output->memory, 1);
    }
    output->memoryOffset = (VkDeviceSize)input->memoryoffset();
}

void to_proto_VkPhysicalDevice16BitStorageFeatures(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDevice16BitStorageFeatures* input,
    goldfish_vk_proto::VkPhysicalDevice16BitStorageFeatures* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_storagebuffer16bitaccess((uint32_t)input->storageBuffer16BitAccess);
    output->set_uniformandstoragebuffer16bitaccess((uint32_t)input->uniformAndStorageBuffer16BitAccess);
    output->set_storagepushconstant16((uint32_t)input->storagePushConstant16);
    output->set_storageinputoutput16((uint32_t)input->storageInputOutput16);
}

void from_proto_VkPhysicalDevice16BitStorageFeatures(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDevice16BitStorageFeatures* input,
    VkPhysicalDevice16BitStorageFeatures* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDevice16BitStorageFeatures));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->storageBuffer16BitAccess = (VkBool32)input->storagebuffer16bitaccess();
    output->uniformAndStorageBuffer16BitAccess = (VkBool32)input->uniformandstoragebuffer16bitaccess();
    output->storagePushConstant16 = (VkBool32)input->storagepushconstant16();
    output->storageInputOutput16 = (VkBool32)input->storageinputoutput16();
}

void to_proto_VkMemoryDedicatedRequirements(
    VulkanHandleMapping* handleMapping,
    const VkMemoryDedicatedRequirements* input,
    goldfish_vk_proto::VkMemoryDedicatedRequirements* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_prefersdedicatedallocation((uint32_t)input->prefersDedicatedAllocation);
    output->set_requiresdedicatedallocation((uint32_t)input->requiresDedicatedAllocation);
}

void from_proto_VkMemoryDedicatedRequirements(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryDedicatedRequirements* input,
    VkMemoryDedicatedRequirements* output)
{
    memset(output, 0x0, sizeof(VkMemoryDedicatedRequirements));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->prefersDedicatedAllocation = (VkBool32)input->prefersdedicatedallocation();
    output->requiresDedicatedAllocation = (VkBool32)input->requiresdedicatedallocation();
}

void to_proto_VkMemoryDedicatedAllocateInfo(
    VulkanHandleMapping* handleMapping,
    const VkMemoryDedicatedAllocateInfo* input,
    goldfish_vk_proto::VkMemoryDedicatedAllocateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_43;
    handleMapping->mapHandles_VkImage_u64(&input->image, &cgen_var_43, 1);
    output->set_image(cgen_var_43);
    uint64_t cgen_var_44;
    handleMapping->mapHandles_VkBuffer_u64(&input->buffer, &cgen_var_44, 1);
    output->set_buffer(cgen_var_44);
}

void from_proto_VkMemoryDedicatedAllocateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryDedicatedAllocateInfo* input,
    VkMemoryDedicatedAllocateInfo* output)
{
    memset(output, 0x0, sizeof(VkMemoryDedicatedAllocateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->image();
        handleMapping->mapHandles_u64_VkImage(&current, (VkImage*)&output->image, 1);
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->buffer();
        handleMapping->mapHandles_u64_VkBuffer(&current, (VkBuffer*)&output->buffer, 1);
    }
}

void to_proto_VkMemoryAllocateFlagsInfo(
    VulkanHandleMapping* handleMapping,
    const VkMemoryAllocateFlagsInfo* input,
    goldfish_vk_proto::VkMemoryAllocateFlagsInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_devicemask((uint32_t)input->deviceMask);
}

void from_proto_VkMemoryAllocateFlagsInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryAllocateFlagsInfo* input,
    VkMemoryAllocateFlagsInfo* output)
{
    memset(output, 0x0, sizeof(VkMemoryAllocateFlagsInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkMemoryAllocateFlags)input->flags();
    output->deviceMask = (uint32_t)input->devicemask();
}

void to_proto_VkDeviceGroupRenderPassBeginInfo(
    VulkanHandleMapping* handleMapping,
    const VkDeviceGroupRenderPassBeginInfo* input,
    goldfish_vk_proto::VkDeviceGroupRenderPassBeginInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_devicemask((uint32_t)input->deviceMask);
    output->set_devicerenderareacount((uint32_t)input->deviceRenderAreaCount);
    for (uint32_t i = 0; i < (uint32_t)input->deviceRenderAreaCount; ++i)
    {
        to_proto_VkRect2D(handleMapping, input->pDeviceRenderAreas + i, output->add_pdevicerenderareas());
    }
}

void from_proto_VkDeviceGroupRenderPassBeginInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceGroupRenderPassBeginInfo* input,
    VkDeviceGroupRenderPassBeginInfo* output)
{
    memset(output, 0x0, sizeof(VkDeviceGroupRenderPassBeginInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->deviceMask = (uint32_t)input->devicemask();
    output->deviceRenderAreaCount = (uint32_t)input->devicerenderareacount();
    *(void**)&output->pDeviceRenderAreas = pool->alloc(output->deviceRenderAreaCount * sizeof(const VkRect2D));
    for (uint32_t i = 0; i < (uint32_t)output->deviceRenderAreaCount; ++i)
    {
        from_proto_VkRect2D(pool, handleMapping, input->mutable_pdevicerenderareas(i), (VkRect2D*)(output->pDeviceRenderAreas + i));
    }
}

void to_proto_VkDeviceGroupCommandBufferBeginInfo(
    VulkanHandleMapping* handleMapping,
    const VkDeviceGroupCommandBufferBeginInfo* input,
    goldfish_vk_proto::VkDeviceGroupCommandBufferBeginInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_devicemask((uint32_t)input->deviceMask);
}

void from_proto_VkDeviceGroupCommandBufferBeginInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceGroupCommandBufferBeginInfo* input,
    VkDeviceGroupCommandBufferBeginInfo* output)
{
    memset(output, 0x0, sizeof(VkDeviceGroupCommandBufferBeginInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->deviceMask = (uint32_t)input->devicemask();
}

void to_proto_VkDeviceGroupSubmitInfo(
    VulkanHandleMapping* handleMapping,
    const VkDeviceGroupSubmitInfo* input,
    goldfish_vk_proto::VkDeviceGroupSubmitInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_waitsemaphorecount((uint32_t)input->waitSemaphoreCount);
    for (uint32_t i = 0; i < (uint32_t)input->waitSemaphoreCount; ++i)
    {
        output->add_pwaitsemaphoredeviceindices(input->pWaitSemaphoreDeviceIndices[i]);
    }
    output->set_commandbuffercount((uint32_t)input->commandBufferCount);
    for (uint32_t i = 0; i < (uint32_t)input->commandBufferCount; ++i)
    {
        output->add_pcommandbufferdevicemasks(input->pCommandBufferDeviceMasks[i]);
    }
    output->set_signalsemaphorecount((uint32_t)input->signalSemaphoreCount);
    for (uint32_t i = 0; i < (uint32_t)input->signalSemaphoreCount; ++i)
    {
        output->add_psignalsemaphoredeviceindices(input->pSignalSemaphoreDeviceIndices[i]);
    }
}

void from_proto_VkDeviceGroupSubmitInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceGroupSubmitInfo* input,
    VkDeviceGroupSubmitInfo* output)
{
    memset(output, 0x0, sizeof(VkDeviceGroupSubmitInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->waitSemaphoreCount = (uint32_t)input->waitsemaphorecount();
    for (uint32_t i = 0; i < (uint32_t)output->waitSemaphoreCount; ++i)
    {
        *((uint32_t*)(&output->pWaitSemaphoreDeviceIndices) + i) = (uint32_t)input->pwaitsemaphoredeviceindices(i);
    }
    output->commandBufferCount = (uint32_t)input->commandbuffercount();
    for (uint32_t i = 0; i < (uint32_t)output->commandBufferCount; ++i)
    {
        *((uint32_t*)(&output->pCommandBufferDeviceMasks) + i) = (uint32_t)input->pcommandbufferdevicemasks(i);
    }
    output->signalSemaphoreCount = (uint32_t)input->signalsemaphorecount();
    for (uint32_t i = 0; i < (uint32_t)output->signalSemaphoreCount; ++i)
    {
        *((uint32_t*)(&output->pSignalSemaphoreDeviceIndices) + i) = (uint32_t)input->psignalsemaphoredeviceindices(i);
    }
}

void to_proto_VkDeviceGroupBindSparseInfo(
    VulkanHandleMapping* handleMapping,
    const VkDeviceGroupBindSparseInfo* input,
    goldfish_vk_proto::VkDeviceGroupBindSparseInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_resourcedeviceindex((uint32_t)input->resourceDeviceIndex);
    output->set_memorydeviceindex((uint32_t)input->memoryDeviceIndex);
}

void from_proto_VkDeviceGroupBindSparseInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceGroupBindSparseInfo* input,
    VkDeviceGroupBindSparseInfo* output)
{
    memset(output, 0x0, sizeof(VkDeviceGroupBindSparseInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->resourceDeviceIndex = (uint32_t)input->resourcedeviceindex();
    output->memoryDeviceIndex = (uint32_t)input->memorydeviceindex();
}

void to_proto_VkBindBufferMemoryDeviceGroupInfo(
    VulkanHandleMapping* handleMapping,
    const VkBindBufferMemoryDeviceGroupInfo* input,
    goldfish_vk_proto::VkBindBufferMemoryDeviceGroupInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_deviceindexcount((uint32_t)input->deviceIndexCount);
    for (uint32_t i = 0; i < (uint32_t)input->deviceIndexCount; ++i)
    {
        output->add_pdeviceindices(input->pDeviceIndices[i]);
    }
}

void from_proto_VkBindBufferMemoryDeviceGroupInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBindBufferMemoryDeviceGroupInfo* input,
    VkBindBufferMemoryDeviceGroupInfo* output)
{
    memset(output, 0x0, sizeof(VkBindBufferMemoryDeviceGroupInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->deviceIndexCount = (uint32_t)input->deviceindexcount();
    for (uint32_t i = 0; i < (uint32_t)output->deviceIndexCount; ++i)
    {
        *((uint32_t*)(&output->pDeviceIndices) + i) = (uint32_t)input->pdeviceindices(i);
    }
}

void to_proto_VkBindImageMemoryDeviceGroupInfo(
    VulkanHandleMapping* handleMapping,
    const VkBindImageMemoryDeviceGroupInfo* input,
    goldfish_vk_proto::VkBindImageMemoryDeviceGroupInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_deviceindexcount((uint32_t)input->deviceIndexCount);
    for (uint32_t i = 0; i < (uint32_t)input->deviceIndexCount; ++i)
    {
        output->add_pdeviceindices(input->pDeviceIndices[i]);
    }
    output->set_splitinstancebindregioncount((uint32_t)input->splitInstanceBindRegionCount);
    for (uint32_t i = 0; i < (uint32_t)input->splitInstanceBindRegionCount; ++i)
    {
        to_proto_VkRect2D(handleMapping, input->pSplitInstanceBindRegions + i, output->add_psplitinstancebindregions());
    }
}

void from_proto_VkBindImageMemoryDeviceGroupInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBindImageMemoryDeviceGroupInfo* input,
    VkBindImageMemoryDeviceGroupInfo* output)
{
    memset(output, 0x0, sizeof(VkBindImageMemoryDeviceGroupInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->deviceIndexCount = (uint32_t)input->deviceindexcount();
    for (uint32_t i = 0; i < (uint32_t)output->deviceIndexCount; ++i)
    {
        *((uint32_t*)(&output->pDeviceIndices) + i) = (uint32_t)input->pdeviceindices(i);
    }
    output->splitInstanceBindRegionCount = (uint32_t)input->splitinstancebindregioncount();
    *(void**)&output->pSplitInstanceBindRegions = pool->alloc(output->splitInstanceBindRegionCount * sizeof(const VkRect2D));
    for (uint32_t i = 0; i < (uint32_t)output->splitInstanceBindRegionCount; ++i)
    {
        from_proto_VkRect2D(pool, handleMapping, input->mutable_psplitinstancebindregions(i), (VkRect2D*)(output->pSplitInstanceBindRegions + i));
    }
}

void to_proto_VkPhysicalDeviceGroupProperties(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceGroupProperties* input,
    goldfish_vk_proto::VkPhysicalDeviceGroupProperties* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_physicaldevicecount((uint32_t)input->physicalDeviceCount);
    if (VK_MAX_DEVICE_GROUP_SIZE)
    {
        std::vector<uint64_t> cgen_var_45(VK_MAX_DEVICE_GROUP_SIZE);
        handleMapping->mapHandles_VkPhysicalDevice_u64(input->physicalDevices, cgen_var_45.data(), VK_MAX_DEVICE_GROUP_SIZE);
        for (uint32_t i = 0; i < VK_MAX_DEVICE_GROUP_SIZE; ++i)
        {
            output->add_physicaldevices(cgen_var_45[i]);
        }
    }
    output->set_subsetallocation((uint32_t)input->subsetAllocation);
}

void from_proto_VkPhysicalDeviceGroupProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceGroupProperties* input,
    VkPhysicalDeviceGroupProperties* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceGroupProperties));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->physicalDeviceCount = (uint32_t)input->physicaldevicecount();
    if (VK_MAX_DEVICE_GROUP_SIZE)
    {
        for (uint32_t i = 0; i < VK_MAX_DEVICE_GROUP_SIZE; ++i)
        {
            uint64_t current = input->physicaldevices(i);
            handleMapping->mapHandles_u64_VkPhysicalDevice(&current, (VkPhysicalDevice*)&output->physicalDevices[i], 1);
        }
    }
    output->subsetAllocation = (VkBool32)input->subsetallocation();
}

void to_proto_VkDeviceGroupDeviceCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkDeviceGroupDeviceCreateInfo* input,
    goldfish_vk_proto::VkDeviceGroupDeviceCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_physicaldevicecount((uint32_t)input->physicalDeviceCount);
    if (input->physicalDeviceCount)
    {
        std::vector<uint64_t> cgen_var_46(input->physicalDeviceCount);
        handleMapping->mapHandles_VkPhysicalDevice_u64(input->pPhysicalDevices, cgen_var_46.data(), input->physicalDeviceCount);
        for (uint32_t i = 0; i < input->physicalDeviceCount; ++i)
        {
            output->add_pphysicaldevices(cgen_var_46[i]);
        }
    }
}

void from_proto_VkDeviceGroupDeviceCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceGroupDeviceCreateInfo* input,
    VkDeviceGroupDeviceCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkDeviceGroupDeviceCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->physicalDeviceCount = (uint32_t)input->physicaldevicecount();
    if (output->physicalDeviceCount)
    {
        for (uint32_t i = 0; i < output->physicalDeviceCount; ++i)
        {
            uint64_t current = input->pphysicaldevices(i);
            handleMapping->mapHandles_u64_VkPhysicalDevice(&current, (VkPhysicalDevice*)&output->pPhysicalDevices[i], 1);
        }
    }
}

void to_proto_VkBufferMemoryRequirementsInfo2(
    VulkanHandleMapping* handleMapping,
    const VkBufferMemoryRequirementsInfo2* input,
    goldfish_vk_proto::VkBufferMemoryRequirementsInfo2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_47;
    handleMapping->mapHandles_VkBuffer_u64(&input->buffer, &cgen_var_47, 1);
    output->set_buffer(cgen_var_47);
}

void from_proto_VkBufferMemoryRequirementsInfo2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBufferMemoryRequirementsInfo2* input,
    VkBufferMemoryRequirementsInfo2* output)
{
    memset(output, 0x0, sizeof(VkBufferMemoryRequirementsInfo2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->buffer();
        handleMapping->mapHandles_u64_VkBuffer(&current, (VkBuffer*)&output->buffer, 1);
    }
}

void to_proto_VkImageMemoryRequirementsInfo2(
    VulkanHandleMapping* handleMapping,
    const VkImageMemoryRequirementsInfo2* input,
    goldfish_vk_proto::VkImageMemoryRequirementsInfo2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_48;
    handleMapping->mapHandles_VkImage_u64(&input->image, &cgen_var_48, 1);
    output->set_image(cgen_var_48);
}

void from_proto_VkImageMemoryRequirementsInfo2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageMemoryRequirementsInfo2* input,
    VkImageMemoryRequirementsInfo2* output)
{
    memset(output, 0x0, sizeof(VkImageMemoryRequirementsInfo2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->image();
        handleMapping->mapHandles_u64_VkImage(&current, (VkImage*)&output->image, 1);
    }
}

void to_proto_VkImageSparseMemoryRequirementsInfo2(
    VulkanHandleMapping* handleMapping,
    const VkImageSparseMemoryRequirementsInfo2* input,
    goldfish_vk_proto::VkImageSparseMemoryRequirementsInfo2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_49;
    handleMapping->mapHandles_VkImage_u64(&input->image, &cgen_var_49, 1);
    output->set_image(cgen_var_49);
}

void from_proto_VkImageSparseMemoryRequirementsInfo2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageSparseMemoryRequirementsInfo2* input,
    VkImageSparseMemoryRequirementsInfo2* output)
{
    memset(output, 0x0, sizeof(VkImageSparseMemoryRequirementsInfo2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->image();
        handleMapping->mapHandles_u64_VkImage(&current, (VkImage*)&output->image, 1);
    }
}

void to_proto_VkMemoryRequirements2(
    VulkanHandleMapping* handleMapping,
    const VkMemoryRequirements2* input,
    goldfish_vk_proto::VkMemoryRequirements2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkMemoryRequirements(handleMapping, &input->memoryRequirements, output->mutable_memoryrequirements());
}

void from_proto_VkMemoryRequirements2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryRequirements2* input,
    VkMemoryRequirements2* output)
{
    memset(output, 0x0, sizeof(VkMemoryRequirements2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkMemoryRequirements(pool, handleMapping, input->mutable_memoryrequirements(), (VkMemoryRequirements*)(&output->memoryRequirements));
}

void to_proto_VkSparseImageMemoryRequirements2(
    VulkanHandleMapping* handleMapping,
    const VkSparseImageMemoryRequirements2* input,
    goldfish_vk_proto::VkSparseImageMemoryRequirements2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkSparseImageMemoryRequirements(handleMapping, &input->memoryRequirements, output->mutable_memoryrequirements());
}

void from_proto_VkSparseImageMemoryRequirements2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSparseImageMemoryRequirements2* input,
    VkSparseImageMemoryRequirements2* output)
{
    memset(output, 0x0, sizeof(VkSparseImageMemoryRequirements2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkSparseImageMemoryRequirements(pool, handleMapping, input->mutable_memoryrequirements(), (VkSparseImageMemoryRequirements*)(&output->memoryRequirements));
}

void to_proto_VkPhysicalDeviceFeatures2(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceFeatures2* input,
    goldfish_vk_proto::VkPhysicalDeviceFeatures2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkPhysicalDeviceFeatures(handleMapping, &input->features, output->mutable_features());
}

void from_proto_VkPhysicalDeviceFeatures2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceFeatures2* input,
    VkPhysicalDeviceFeatures2* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceFeatures2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkPhysicalDeviceFeatures(pool, handleMapping, input->mutable_features(), (VkPhysicalDeviceFeatures*)(&output->features));
}

void to_proto_VkPhysicalDeviceProperties2(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceProperties2* input,
    goldfish_vk_proto::VkPhysicalDeviceProperties2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkPhysicalDeviceProperties(handleMapping, &input->properties, output->mutable_properties());
}

void from_proto_VkPhysicalDeviceProperties2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceProperties2* input,
    VkPhysicalDeviceProperties2* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceProperties2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkPhysicalDeviceProperties(pool, handleMapping, input->mutable_properties(), (VkPhysicalDeviceProperties*)(&output->properties));
}

void to_proto_VkFormatProperties2(
    VulkanHandleMapping* handleMapping,
    const VkFormatProperties2* input,
    goldfish_vk_proto::VkFormatProperties2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkFormatProperties(handleMapping, &input->formatProperties, output->mutable_formatproperties());
}

void from_proto_VkFormatProperties2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkFormatProperties2* input,
    VkFormatProperties2* output)
{
    memset(output, 0x0, sizeof(VkFormatProperties2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkFormatProperties(pool, handleMapping, input->mutable_formatproperties(), (VkFormatProperties*)(&output->formatProperties));
}

void to_proto_VkImageFormatProperties2(
    VulkanHandleMapping* handleMapping,
    const VkImageFormatProperties2* input,
    goldfish_vk_proto::VkImageFormatProperties2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkImageFormatProperties(handleMapping, &input->imageFormatProperties, output->mutable_imageformatproperties());
}

void from_proto_VkImageFormatProperties2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageFormatProperties2* input,
    VkImageFormatProperties2* output)
{
    memset(output, 0x0, sizeof(VkImageFormatProperties2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkImageFormatProperties(pool, handleMapping, input->mutable_imageformatproperties(), (VkImageFormatProperties*)(&output->imageFormatProperties));
}

void to_proto_VkPhysicalDeviceImageFormatInfo2(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceImageFormatInfo2* input,
    goldfish_vk_proto::VkPhysicalDeviceImageFormatInfo2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_format((uint32_t)input->format);
    output->set_type((uint32_t)input->type);
    output->set_tiling((uint32_t)input->tiling);
    output->set_usage((uint32_t)input->usage);
    output->set_flags((uint32_t)input->flags);
}

void from_proto_VkPhysicalDeviceImageFormatInfo2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceImageFormatInfo2* input,
    VkPhysicalDeviceImageFormatInfo2* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceImageFormatInfo2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->format = (VkFormat)input->format();
    output->type = (VkImageType)input->type();
    output->tiling = (VkImageTiling)input->tiling();
    output->usage = (VkImageUsageFlags)input->usage();
    output->flags = (VkImageCreateFlags)input->flags();
}

void to_proto_VkQueueFamilyProperties2(
    VulkanHandleMapping* handleMapping,
    const VkQueueFamilyProperties2* input,
    goldfish_vk_proto::VkQueueFamilyProperties2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkQueueFamilyProperties(handleMapping, &input->queueFamilyProperties, output->mutable_queuefamilyproperties());
}

void from_proto_VkQueueFamilyProperties2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkQueueFamilyProperties2* input,
    VkQueueFamilyProperties2* output)
{
    memset(output, 0x0, sizeof(VkQueueFamilyProperties2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkQueueFamilyProperties(pool, handleMapping, input->mutable_queuefamilyproperties(), (VkQueueFamilyProperties*)(&output->queueFamilyProperties));
}

void to_proto_VkPhysicalDeviceMemoryProperties2(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceMemoryProperties2* input,
    goldfish_vk_proto::VkPhysicalDeviceMemoryProperties2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkPhysicalDeviceMemoryProperties(handleMapping, &input->memoryProperties, output->mutable_memoryproperties());
}

void from_proto_VkPhysicalDeviceMemoryProperties2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceMemoryProperties2* input,
    VkPhysicalDeviceMemoryProperties2* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceMemoryProperties2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkPhysicalDeviceMemoryProperties(pool, handleMapping, input->mutable_memoryproperties(), (VkPhysicalDeviceMemoryProperties*)(&output->memoryProperties));
}

void to_proto_VkSparseImageFormatProperties2(
    VulkanHandleMapping* handleMapping,
    const VkSparseImageFormatProperties2* input,
    goldfish_vk_proto::VkSparseImageFormatProperties2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkSparseImageFormatProperties(handleMapping, &input->properties, output->mutable_properties());
}

void from_proto_VkSparseImageFormatProperties2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSparseImageFormatProperties2* input,
    VkSparseImageFormatProperties2* output)
{
    memset(output, 0x0, sizeof(VkSparseImageFormatProperties2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkSparseImageFormatProperties(pool, handleMapping, input->mutable_properties(), (VkSparseImageFormatProperties*)(&output->properties));
}

void to_proto_VkPhysicalDeviceSparseImageFormatInfo2(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceSparseImageFormatInfo2* input,
    goldfish_vk_proto::VkPhysicalDeviceSparseImageFormatInfo2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_format((uint32_t)input->format);
    output->set_type((uint32_t)input->type);
    output->set_samples((uint32_t)input->samples);
    output->set_usage((uint32_t)input->usage);
    output->set_tiling((uint32_t)input->tiling);
}

void from_proto_VkPhysicalDeviceSparseImageFormatInfo2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceSparseImageFormatInfo2* input,
    VkPhysicalDeviceSparseImageFormatInfo2* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceSparseImageFormatInfo2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->format = (VkFormat)input->format();
    output->type = (VkImageType)input->type();
    output->samples = (VkSampleCountFlagBits)input->samples();
    output->usage = (VkImageUsageFlags)input->usage();
    output->tiling = (VkImageTiling)input->tiling();
}

void to_proto_VkPhysicalDevicePointClippingProperties(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDevicePointClippingProperties* input,
    goldfish_vk_proto::VkPhysicalDevicePointClippingProperties* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_pointclippingbehavior((uint32_t)input->pointClippingBehavior);
}

void from_proto_VkPhysicalDevicePointClippingProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDevicePointClippingProperties* input,
    VkPhysicalDevicePointClippingProperties* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDevicePointClippingProperties));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->pointClippingBehavior = (VkPointClippingBehavior)input->pointclippingbehavior();
}

void to_proto_VkInputAttachmentAspectReference(
    VulkanHandleMapping* handleMapping,
    const VkInputAttachmentAspectReference* input,
    goldfish_vk_proto::VkInputAttachmentAspectReference* output)
{
    output->set_subpass((uint32_t)input->subpass);
    output->set_inputattachmentindex((uint32_t)input->inputAttachmentIndex);
    output->set_aspectmask((uint32_t)input->aspectMask);
}

void from_proto_VkInputAttachmentAspectReference(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkInputAttachmentAspectReference* input,
    VkInputAttachmentAspectReference* output)
{
    memset(output, 0x0, sizeof(VkInputAttachmentAspectReference));
    output->subpass = (uint32_t)input->subpass();
    output->inputAttachmentIndex = (uint32_t)input->inputattachmentindex();
    output->aspectMask = (VkImageAspectFlags)input->aspectmask();
}

void to_proto_VkRenderPassInputAttachmentAspectCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkRenderPassInputAttachmentAspectCreateInfo* input,
    goldfish_vk_proto::VkRenderPassInputAttachmentAspectCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_aspectreferencecount((uint32_t)input->aspectReferenceCount);
    for (uint32_t i = 0; i < (uint32_t)input->aspectReferenceCount; ++i)
    {
        to_proto_VkInputAttachmentAspectReference(handleMapping, input->pAspectReferences + i, output->add_paspectreferences());
    }
}

void from_proto_VkRenderPassInputAttachmentAspectCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkRenderPassInputAttachmentAspectCreateInfo* input,
    VkRenderPassInputAttachmentAspectCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkRenderPassInputAttachmentAspectCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->aspectReferenceCount = (uint32_t)input->aspectreferencecount();
    *(void**)&output->pAspectReferences = pool->alloc(output->aspectReferenceCount * sizeof(const VkInputAttachmentAspectReference));
    for (uint32_t i = 0; i < (uint32_t)output->aspectReferenceCount; ++i)
    {
        from_proto_VkInputAttachmentAspectReference(pool, handleMapping, input->mutable_paspectreferences(i), (VkInputAttachmentAspectReference*)(output->pAspectReferences + i));
    }
}

void to_proto_VkImageViewUsageCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkImageViewUsageCreateInfo* input,
    goldfish_vk_proto::VkImageViewUsageCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_usage((uint32_t)input->usage);
}

void from_proto_VkImageViewUsageCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageViewUsageCreateInfo* input,
    VkImageViewUsageCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkImageViewUsageCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->usage = (VkImageUsageFlags)input->usage();
}

void to_proto_VkPipelineTessellationDomainOriginStateCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkPipelineTessellationDomainOriginStateCreateInfo* input,
    goldfish_vk_proto::VkPipelineTessellationDomainOriginStateCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_domainorigin((uint32_t)input->domainOrigin);
}

void from_proto_VkPipelineTessellationDomainOriginStateCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineTessellationDomainOriginStateCreateInfo* input,
    VkPipelineTessellationDomainOriginStateCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkPipelineTessellationDomainOriginStateCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->domainOrigin = (VkTessellationDomainOrigin)input->domainorigin();
}

void to_proto_VkRenderPassMultiviewCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkRenderPassMultiviewCreateInfo* input,
    goldfish_vk_proto::VkRenderPassMultiviewCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_subpasscount((uint32_t)input->subpassCount);
    for (uint32_t i = 0; i < (uint32_t)input->subpassCount; ++i)
    {
        output->add_pviewmasks(input->pViewMasks[i]);
    }
    output->set_dependencycount((uint32_t)input->dependencyCount);
    for (uint32_t i = 0; i < (uint32_t)input->dependencyCount; ++i)
    {
        output->add_pviewoffsets(input->pViewOffsets[i]);
    }
    output->set_correlationmaskcount((uint32_t)input->correlationMaskCount);
    for (uint32_t i = 0; i < (uint32_t)input->correlationMaskCount; ++i)
    {
        output->add_pcorrelationmasks(input->pCorrelationMasks[i]);
    }
}

void from_proto_VkRenderPassMultiviewCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkRenderPassMultiviewCreateInfo* input,
    VkRenderPassMultiviewCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkRenderPassMultiviewCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->subpassCount = (uint32_t)input->subpasscount();
    for (uint32_t i = 0; i < (uint32_t)output->subpassCount; ++i)
    {
        *((uint32_t*)(&output->pViewMasks) + i) = (uint32_t)input->pviewmasks(i);
    }
    output->dependencyCount = (uint32_t)input->dependencycount();
    for (uint32_t i = 0; i < (uint32_t)output->dependencyCount; ++i)
    {
        *((int32_t*)(&output->pViewOffsets) + i) = (int32_t)input->pviewoffsets(i);
    }
    output->correlationMaskCount = (uint32_t)input->correlationmaskcount();
    for (uint32_t i = 0; i < (uint32_t)output->correlationMaskCount; ++i)
    {
        *((uint32_t*)(&output->pCorrelationMasks) + i) = (uint32_t)input->pcorrelationmasks(i);
    }
}

void to_proto_VkPhysicalDeviceMultiviewFeatures(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceMultiviewFeatures* input,
    goldfish_vk_proto::VkPhysicalDeviceMultiviewFeatures* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_multiview((uint32_t)input->multiview);
    output->set_multiviewgeometryshader((uint32_t)input->multiviewGeometryShader);
    output->set_multiviewtessellationshader((uint32_t)input->multiviewTessellationShader);
}

void from_proto_VkPhysicalDeviceMultiviewFeatures(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceMultiviewFeatures* input,
    VkPhysicalDeviceMultiviewFeatures* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceMultiviewFeatures));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->multiview = (VkBool32)input->multiview();
    output->multiviewGeometryShader = (VkBool32)input->multiviewgeometryshader();
    output->multiviewTessellationShader = (VkBool32)input->multiviewtessellationshader();
}

void to_proto_VkPhysicalDeviceMultiviewProperties(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceMultiviewProperties* input,
    goldfish_vk_proto::VkPhysicalDeviceMultiviewProperties* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_maxmultiviewviewcount((uint32_t)input->maxMultiviewViewCount);
    output->set_maxmultiviewinstanceindex((uint32_t)input->maxMultiviewInstanceIndex);
}

void from_proto_VkPhysicalDeviceMultiviewProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceMultiviewProperties* input,
    VkPhysicalDeviceMultiviewProperties* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceMultiviewProperties));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->maxMultiviewViewCount = (uint32_t)input->maxmultiviewviewcount();
    output->maxMultiviewInstanceIndex = (uint32_t)input->maxmultiviewinstanceindex();
}

void to_proto_VkPhysicalDeviceVariablePointerFeatures(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceVariablePointerFeatures* input,
    goldfish_vk_proto::VkPhysicalDeviceVariablePointerFeatures* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_variablepointersstoragebuffer((uint32_t)input->variablePointersStorageBuffer);
    output->set_variablepointers((uint32_t)input->variablePointers);
}

void from_proto_VkPhysicalDeviceVariablePointerFeatures(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceVariablePointerFeatures* input,
    VkPhysicalDeviceVariablePointerFeatures* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceVariablePointerFeatures));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->variablePointersStorageBuffer = (VkBool32)input->variablepointersstoragebuffer();
    output->variablePointers = (VkBool32)input->variablepointers();
}

void to_proto_VkPhysicalDeviceProtectedMemoryFeatures(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceProtectedMemoryFeatures* input,
    goldfish_vk_proto::VkPhysicalDeviceProtectedMemoryFeatures* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_protectedmemory((uint32_t)input->protectedMemory);
}

void from_proto_VkPhysicalDeviceProtectedMemoryFeatures(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceProtectedMemoryFeatures* input,
    VkPhysicalDeviceProtectedMemoryFeatures* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceProtectedMemoryFeatures));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->protectedMemory = (VkBool32)input->protectedmemory();
}

void to_proto_VkPhysicalDeviceProtectedMemoryProperties(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceProtectedMemoryProperties* input,
    goldfish_vk_proto::VkPhysicalDeviceProtectedMemoryProperties* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_protectednofault((uint32_t)input->protectedNoFault);
}

void from_proto_VkPhysicalDeviceProtectedMemoryProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceProtectedMemoryProperties* input,
    VkPhysicalDeviceProtectedMemoryProperties* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceProtectedMemoryProperties));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->protectedNoFault = (VkBool32)input->protectednofault();
}

void to_proto_VkDeviceQueueInfo2(
    VulkanHandleMapping* handleMapping,
    const VkDeviceQueueInfo2* input,
    goldfish_vk_proto::VkDeviceQueueInfo2* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_queuefamilyindex((uint32_t)input->queueFamilyIndex);
    output->set_queueindex((uint32_t)input->queueIndex);
}

void from_proto_VkDeviceQueueInfo2(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceQueueInfo2* input,
    VkDeviceQueueInfo2* output)
{
    memset(output, 0x0, sizeof(VkDeviceQueueInfo2));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkDeviceQueueCreateFlags)input->flags();
    output->queueFamilyIndex = (uint32_t)input->queuefamilyindex();
    output->queueIndex = (uint32_t)input->queueindex();
}

void to_proto_VkProtectedSubmitInfo(
    VulkanHandleMapping* handleMapping,
    const VkProtectedSubmitInfo* input,
    goldfish_vk_proto::VkProtectedSubmitInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_protectedsubmit((uint32_t)input->protectedSubmit);
}

void from_proto_VkProtectedSubmitInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkProtectedSubmitInfo* input,
    VkProtectedSubmitInfo* output)
{
    memset(output, 0x0, sizeof(VkProtectedSubmitInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->protectedSubmit = (VkBool32)input->protectedsubmit();
}

void to_proto_VkSamplerYcbcrConversionCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkSamplerYcbcrConversionCreateInfo* input,
    goldfish_vk_proto::VkSamplerYcbcrConversionCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_format((uint32_t)input->format);
    output->set_ycbcrmodel((uint32_t)input->ycbcrModel);
    output->set_ycbcrrange((uint32_t)input->ycbcrRange);
    to_proto_VkComponentMapping(handleMapping, &input->components, output->mutable_components());
    output->set_xchromaoffset((uint32_t)input->xChromaOffset);
    output->set_ychromaoffset((uint32_t)input->yChromaOffset);
    output->set_chromafilter((uint32_t)input->chromaFilter);
    output->set_forceexplicitreconstruction((uint32_t)input->forceExplicitReconstruction);
}

void from_proto_VkSamplerYcbcrConversionCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSamplerYcbcrConversionCreateInfo* input,
    VkSamplerYcbcrConversionCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkSamplerYcbcrConversionCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->format = (VkFormat)input->format();
    output->ycbcrModel = (VkSamplerYcbcrModelConversion)input->ycbcrmodel();
    output->ycbcrRange = (VkSamplerYcbcrRange)input->ycbcrrange();
    from_proto_VkComponentMapping(pool, handleMapping, input->mutable_components(), (VkComponentMapping*)(&output->components));
    output->xChromaOffset = (VkChromaLocation)input->xchromaoffset();
    output->yChromaOffset = (VkChromaLocation)input->ychromaoffset();
    output->chromaFilter = (VkFilter)input->chromafilter();
    output->forceExplicitReconstruction = (VkBool32)input->forceexplicitreconstruction();
}

void to_proto_VkSamplerYcbcrConversionInfo(
    VulkanHandleMapping* handleMapping,
    const VkSamplerYcbcrConversionInfo* input,
    goldfish_vk_proto::VkSamplerYcbcrConversionInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_50;
    handleMapping->mapHandles_VkSamplerYcbcrConversion_u64(&input->conversion, &cgen_var_50, 1);
    output->set_conversion(cgen_var_50);
}

void from_proto_VkSamplerYcbcrConversionInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSamplerYcbcrConversionInfo* input,
    VkSamplerYcbcrConversionInfo* output)
{
    memset(output, 0x0, sizeof(VkSamplerYcbcrConversionInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->conversion();
        handleMapping->mapHandles_u64_VkSamplerYcbcrConversion(&current, (VkSamplerYcbcrConversion*)&output->conversion, 1);
    }
}

void to_proto_VkBindImagePlaneMemoryInfo(
    VulkanHandleMapping* handleMapping,
    const VkBindImagePlaneMemoryInfo* input,
    goldfish_vk_proto::VkBindImagePlaneMemoryInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_planeaspect((uint32_t)input->planeAspect);
}

void from_proto_VkBindImagePlaneMemoryInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBindImagePlaneMemoryInfo* input,
    VkBindImagePlaneMemoryInfo* output)
{
    memset(output, 0x0, sizeof(VkBindImagePlaneMemoryInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->planeAspect = (VkImageAspectFlagBits)input->planeaspect();
}

void to_proto_VkImagePlaneMemoryRequirementsInfo(
    VulkanHandleMapping* handleMapping,
    const VkImagePlaneMemoryRequirementsInfo* input,
    goldfish_vk_proto::VkImagePlaneMemoryRequirementsInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_planeaspect((uint32_t)input->planeAspect);
}

void from_proto_VkImagePlaneMemoryRequirementsInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImagePlaneMemoryRequirementsInfo* input,
    VkImagePlaneMemoryRequirementsInfo* output)
{
    memset(output, 0x0, sizeof(VkImagePlaneMemoryRequirementsInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->planeAspect = (VkImageAspectFlagBits)input->planeaspect();
}

void to_proto_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures* input,
    goldfish_vk_proto::VkPhysicalDeviceSamplerYcbcrConversionFeatures* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_samplerycbcrconversion((uint32_t)input->samplerYcbcrConversion);
}

void from_proto_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceSamplerYcbcrConversionFeatures* input,
    VkPhysicalDeviceSamplerYcbcrConversionFeatures* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeatures));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->samplerYcbcrConversion = (VkBool32)input->samplerycbcrconversion();
}

void to_proto_VkSamplerYcbcrConversionImageFormatProperties(
    VulkanHandleMapping* handleMapping,
    const VkSamplerYcbcrConversionImageFormatProperties* input,
    goldfish_vk_proto::VkSamplerYcbcrConversionImageFormatProperties* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_combinedimagesamplerdescriptorcount((uint32_t)input->combinedImageSamplerDescriptorCount);
}

void from_proto_VkSamplerYcbcrConversionImageFormatProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSamplerYcbcrConversionImageFormatProperties* input,
    VkSamplerYcbcrConversionImageFormatProperties* output)
{
    memset(output, 0x0, sizeof(VkSamplerYcbcrConversionImageFormatProperties));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->combinedImageSamplerDescriptorCount = (uint32_t)input->combinedimagesamplerdescriptorcount();
}

void to_proto_VkDescriptorUpdateTemplateEntry(
    VulkanHandleMapping* handleMapping,
    const VkDescriptorUpdateTemplateEntry* input,
    goldfish_vk_proto::VkDescriptorUpdateTemplateEntry* output)
{
    output->set_dstbinding((uint32_t)input->dstBinding);
    output->set_dstarrayelement((uint32_t)input->dstArrayElement);
    output->set_descriptorcount((uint32_t)input->descriptorCount);
    output->set_descriptortype((uint32_t)input->descriptorType);
    output->set_offset((uint64_t)input->offset);
    output->set_stride((uint64_t)input->stride);
}

void from_proto_VkDescriptorUpdateTemplateEntry(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDescriptorUpdateTemplateEntry* input,
    VkDescriptorUpdateTemplateEntry* output)
{
    memset(output, 0x0, sizeof(VkDescriptorUpdateTemplateEntry));
    output->dstBinding = (uint32_t)input->dstbinding();
    output->dstArrayElement = (uint32_t)input->dstarrayelement();
    output->descriptorCount = (uint32_t)input->descriptorcount();
    output->descriptorType = (VkDescriptorType)input->descriptortype();
    output->offset = (size_t)input->offset();
    output->stride = (size_t)input->stride();
}

void to_proto_VkDescriptorUpdateTemplateCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkDescriptorUpdateTemplateCreateInfo* input,
    goldfish_vk_proto::VkDescriptorUpdateTemplateCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_descriptorupdateentrycount((uint32_t)input->descriptorUpdateEntryCount);
    for (uint32_t i = 0; i < (uint32_t)input->descriptorUpdateEntryCount; ++i)
    {
        to_proto_VkDescriptorUpdateTemplateEntry(handleMapping, input->pDescriptorUpdateEntries + i, output->add_pdescriptorupdateentries());
    }
    output->set_templatetype((uint32_t)input->templateType);
    uint64_t cgen_var_51;
    handleMapping->mapHandles_VkDescriptorSetLayout_u64(&input->descriptorSetLayout, &cgen_var_51, 1);
    output->set_descriptorsetlayout(cgen_var_51);
    output->set_pipelinebindpoint((uint32_t)input->pipelineBindPoint);
    uint64_t cgen_var_52;
    handleMapping->mapHandles_VkPipelineLayout_u64(&input->pipelineLayout, &cgen_var_52, 1);
    output->set_pipelinelayout(cgen_var_52);
    output->set_set((uint32_t)input->set);
}

void from_proto_VkDescriptorUpdateTemplateCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDescriptorUpdateTemplateCreateInfo* input,
    VkDescriptorUpdateTemplateCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkDescriptorUpdateTemplateCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkDescriptorUpdateTemplateCreateFlags)input->flags();
    output->descriptorUpdateEntryCount = (uint32_t)input->descriptorupdateentrycount();
    *(void**)&output->pDescriptorUpdateEntries = pool->alloc(output->descriptorUpdateEntryCount * sizeof(const VkDescriptorUpdateTemplateEntry));
    for (uint32_t i = 0; i < (uint32_t)output->descriptorUpdateEntryCount; ++i)
    {
        from_proto_VkDescriptorUpdateTemplateEntry(pool, handleMapping, input->mutable_pdescriptorupdateentries(i), (VkDescriptorUpdateTemplateEntry*)(output->pDescriptorUpdateEntries + i));
    }
    output->templateType = (VkDescriptorUpdateTemplateType)input->templatetype();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->descriptorsetlayout();
        handleMapping->mapHandles_u64_VkDescriptorSetLayout(&current, (VkDescriptorSetLayout*)&output->descriptorSetLayout, 1);
    }
    output->pipelineBindPoint = (VkPipelineBindPoint)input->pipelinebindpoint();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->pipelinelayout();
        handleMapping->mapHandles_u64_VkPipelineLayout(&current, (VkPipelineLayout*)&output->pipelineLayout, 1);
    }
    output->set = (uint32_t)input->set();
}

void to_proto_VkExternalMemoryProperties(
    VulkanHandleMapping* handleMapping,
    const VkExternalMemoryProperties* input,
    goldfish_vk_proto::VkExternalMemoryProperties* output)
{
    output->set_externalmemoryfeatures((uint32_t)input->externalMemoryFeatures);
    output->set_exportfromimportedhandletypes((uint32_t)input->exportFromImportedHandleTypes);
    output->set_compatiblehandletypes((uint32_t)input->compatibleHandleTypes);
}

void from_proto_VkExternalMemoryProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExternalMemoryProperties* input,
    VkExternalMemoryProperties* output)
{
    memset(output, 0x0, sizeof(VkExternalMemoryProperties));
    output->externalMemoryFeatures = (VkExternalMemoryFeatureFlags)input->externalmemoryfeatures();
    output->exportFromImportedHandleTypes = (VkExternalMemoryHandleTypeFlags)input->exportfromimportedhandletypes();
    output->compatibleHandleTypes = (VkExternalMemoryHandleTypeFlags)input->compatiblehandletypes();
}

void to_proto_VkPhysicalDeviceExternalImageFormatInfo(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceExternalImageFormatInfo* input,
    goldfish_vk_proto::VkPhysicalDeviceExternalImageFormatInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_handletype((uint32_t)input->handleType);
}

void from_proto_VkPhysicalDeviceExternalImageFormatInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceExternalImageFormatInfo* input,
    VkPhysicalDeviceExternalImageFormatInfo* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceExternalImageFormatInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->handleType = (VkExternalMemoryHandleTypeFlagBits)input->handletype();
}

void to_proto_VkExternalImageFormatProperties(
    VulkanHandleMapping* handleMapping,
    const VkExternalImageFormatProperties* input,
    goldfish_vk_proto::VkExternalImageFormatProperties* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkExternalMemoryProperties(handleMapping, &input->externalMemoryProperties, output->mutable_externalmemoryproperties());
}

void from_proto_VkExternalImageFormatProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExternalImageFormatProperties* input,
    VkExternalImageFormatProperties* output)
{
    memset(output, 0x0, sizeof(VkExternalImageFormatProperties));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkExternalMemoryProperties(pool, handleMapping, input->mutable_externalmemoryproperties(), (VkExternalMemoryProperties*)(&output->externalMemoryProperties));
}

void to_proto_VkPhysicalDeviceExternalBufferInfo(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceExternalBufferInfo* input,
    goldfish_vk_proto::VkPhysicalDeviceExternalBufferInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_usage((uint32_t)input->usage);
    output->set_handletype((uint32_t)input->handleType);
}

void from_proto_VkPhysicalDeviceExternalBufferInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceExternalBufferInfo* input,
    VkPhysicalDeviceExternalBufferInfo* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceExternalBufferInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkBufferCreateFlags)input->flags();
    output->usage = (VkBufferUsageFlags)input->usage();
    output->handleType = (VkExternalMemoryHandleTypeFlagBits)input->handletype();
}

void to_proto_VkExternalBufferProperties(
    VulkanHandleMapping* handleMapping,
    const VkExternalBufferProperties* input,
    goldfish_vk_proto::VkExternalBufferProperties* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkExternalMemoryProperties(handleMapping, &input->externalMemoryProperties, output->mutable_externalmemoryproperties());
}

void from_proto_VkExternalBufferProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExternalBufferProperties* input,
    VkExternalBufferProperties* output)
{
    memset(output, 0x0, sizeof(VkExternalBufferProperties));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkExternalMemoryProperties(pool, handleMapping, input->mutable_externalmemoryproperties(), (VkExternalMemoryProperties*)(&output->externalMemoryProperties));
}

void to_proto_VkPhysicalDeviceIDProperties(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceIDProperties* input,
    goldfish_vk_proto::VkPhysicalDeviceIDProperties* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    for (uint32_t i = 0; i < (uint32_t)VK_UUID_SIZE; ++i)
    {
        output->add_deviceuuid(input->deviceUUID[i]);
    }
    for (uint32_t i = 0; i < (uint32_t)VK_UUID_SIZE; ++i)
    {
        output->add_driveruuid(input->driverUUID[i]);
    }
    for (uint32_t i = 0; i < (uint32_t)VK_LUID_SIZE; ++i)
    {
        output->add_deviceluid(input->deviceLUID[i]);
    }
    output->set_devicenodemask((uint32_t)input->deviceNodeMask);
    output->set_deviceluidvalid((uint32_t)input->deviceLUIDValid);
}

void from_proto_VkPhysicalDeviceIDProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceIDProperties* input,
    VkPhysicalDeviceIDProperties* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceIDProperties));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < (uint32_t)VK_UUID_SIZE; ++i)
    {
        output->deviceUUID[i] = (uint8_t)input->deviceuuid(i);
    }
    for (uint32_t i = 0; i < (uint32_t)VK_UUID_SIZE; ++i)
    {
        output->driverUUID[i] = (uint8_t)input->driveruuid(i);
    }
    for (uint32_t i = 0; i < (uint32_t)VK_LUID_SIZE; ++i)
    {
        output->deviceLUID[i] = (uint8_t)input->deviceluid(i);
    }
    output->deviceNodeMask = (uint32_t)input->devicenodemask();
    output->deviceLUIDValid = (VkBool32)input->deviceluidvalid();
}

void to_proto_VkExternalMemoryImageCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkExternalMemoryImageCreateInfo* input,
    goldfish_vk_proto::VkExternalMemoryImageCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_handletypes((uint32_t)input->handleTypes);
}

void from_proto_VkExternalMemoryImageCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExternalMemoryImageCreateInfo* input,
    VkExternalMemoryImageCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkExternalMemoryImageCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->handleTypes = (VkExternalMemoryHandleTypeFlags)input->handletypes();
}

void to_proto_VkExternalMemoryBufferCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkExternalMemoryBufferCreateInfo* input,
    goldfish_vk_proto::VkExternalMemoryBufferCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_handletypes((uint32_t)input->handleTypes);
}

void from_proto_VkExternalMemoryBufferCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExternalMemoryBufferCreateInfo* input,
    VkExternalMemoryBufferCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkExternalMemoryBufferCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->handleTypes = (VkExternalMemoryHandleTypeFlags)input->handletypes();
}

void to_proto_VkExportMemoryAllocateInfo(
    VulkanHandleMapping* handleMapping,
    const VkExportMemoryAllocateInfo* input,
    goldfish_vk_proto::VkExportMemoryAllocateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_handletypes((uint32_t)input->handleTypes);
}

void from_proto_VkExportMemoryAllocateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExportMemoryAllocateInfo* input,
    VkExportMemoryAllocateInfo* output)
{
    memset(output, 0x0, sizeof(VkExportMemoryAllocateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->handleTypes = (VkExternalMemoryHandleTypeFlags)input->handletypes();
}

void to_proto_VkPhysicalDeviceExternalFenceInfo(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceExternalFenceInfo* input,
    goldfish_vk_proto::VkPhysicalDeviceExternalFenceInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_handletype((uint32_t)input->handleType);
}

void from_proto_VkPhysicalDeviceExternalFenceInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceExternalFenceInfo* input,
    VkPhysicalDeviceExternalFenceInfo* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceExternalFenceInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->handleType = (VkExternalFenceHandleTypeFlagBits)input->handletype();
}

void to_proto_VkExternalFenceProperties(
    VulkanHandleMapping* handleMapping,
    const VkExternalFenceProperties* input,
    goldfish_vk_proto::VkExternalFenceProperties* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_exportfromimportedhandletypes((uint32_t)input->exportFromImportedHandleTypes);
    output->set_compatiblehandletypes((uint32_t)input->compatibleHandleTypes);
    output->set_externalfencefeatures((uint32_t)input->externalFenceFeatures);
}

void from_proto_VkExternalFenceProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExternalFenceProperties* input,
    VkExternalFenceProperties* output)
{
    memset(output, 0x0, sizeof(VkExternalFenceProperties));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->exportFromImportedHandleTypes = (VkExternalFenceHandleTypeFlags)input->exportfromimportedhandletypes();
    output->compatibleHandleTypes = (VkExternalFenceHandleTypeFlags)input->compatiblehandletypes();
    output->externalFenceFeatures = (VkExternalFenceFeatureFlags)input->externalfencefeatures();
}

void to_proto_VkExportFenceCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkExportFenceCreateInfo* input,
    goldfish_vk_proto::VkExportFenceCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_handletypes((uint32_t)input->handleTypes);
}

void from_proto_VkExportFenceCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExportFenceCreateInfo* input,
    VkExportFenceCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkExportFenceCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->handleTypes = (VkExternalFenceHandleTypeFlags)input->handletypes();
}

void to_proto_VkExportSemaphoreCreateInfo(
    VulkanHandleMapping* handleMapping,
    const VkExportSemaphoreCreateInfo* input,
    goldfish_vk_proto::VkExportSemaphoreCreateInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_handletypes((uint32_t)input->handleTypes);
}

void from_proto_VkExportSemaphoreCreateInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExportSemaphoreCreateInfo* input,
    VkExportSemaphoreCreateInfo* output)
{
    memset(output, 0x0, sizeof(VkExportSemaphoreCreateInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->handleTypes = (VkExternalSemaphoreHandleTypeFlags)input->handletypes();
}

void to_proto_VkPhysicalDeviceExternalSemaphoreInfo(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceExternalSemaphoreInfo* input,
    goldfish_vk_proto::VkPhysicalDeviceExternalSemaphoreInfo* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_handletype((uint32_t)input->handleType);
}

void from_proto_VkPhysicalDeviceExternalSemaphoreInfo(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceExternalSemaphoreInfo* input,
    VkPhysicalDeviceExternalSemaphoreInfo* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceExternalSemaphoreInfo));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->handleType = (VkExternalSemaphoreHandleTypeFlagBits)input->handletype();
}

void to_proto_VkExternalSemaphoreProperties(
    VulkanHandleMapping* handleMapping,
    const VkExternalSemaphoreProperties* input,
    goldfish_vk_proto::VkExternalSemaphoreProperties* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_exportfromimportedhandletypes((uint32_t)input->exportFromImportedHandleTypes);
    output->set_compatiblehandletypes((uint32_t)input->compatibleHandleTypes);
    output->set_externalsemaphorefeatures((uint32_t)input->externalSemaphoreFeatures);
}

void from_proto_VkExternalSemaphoreProperties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExternalSemaphoreProperties* input,
    VkExternalSemaphoreProperties* output)
{
    memset(output, 0x0, sizeof(VkExternalSemaphoreProperties));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->exportFromImportedHandleTypes = (VkExternalSemaphoreHandleTypeFlags)input->exportfromimportedhandletypes();
    output->compatibleHandleTypes = (VkExternalSemaphoreHandleTypeFlags)input->compatiblehandletypes();
    output->externalSemaphoreFeatures = (VkExternalSemaphoreFeatureFlags)input->externalsemaphorefeatures();
}

void to_proto_VkPhysicalDeviceMaintenance3Properties(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceMaintenance3Properties* input,
    goldfish_vk_proto::VkPhysicalDeviceMaintenance3Properties* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_maxpersetdescriptors((uint32_t)input->maxPerSetDescriptors);
    output->set_maxmemoryallocationsize((uint64_t)input->maxMemoryAllocationSize);
}

void from_proto_VkPhysicalDeviceMaintenance3Properties(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceMaintenance3Properties* input,
    VkPhysicalDeviceMaintenance3Properties* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceMaintenance3Properties));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->maxPerSetDescriptors = (uint32_t)input->maxpersetdescriptors();
    output->maxMemoryAllocationSize = (VkDeviceSize)input->maxmemoryallocationsize();
}

void to_proto_VkDescriptorSetLayoutSupport(
    VulkanHandleMapping* handleMapping,
    const VkDescriptorSetLayoutSupport* input,
    goldfish_vk_proto::VkDescriptorSetLayoutSupport* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_supported((uint32_t)input->supported);
}

void from_proto_VkDescriptorSetLayoutSupport(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDescriptorSetLayoutSupport* input,
    VkDescriptorSetLayoutSupport* output)
{
    memset(output, 0x0, sizeof(VkDescriptorSetLayoutSupport));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->supported = (VkBool32)input->supported();
}

void to_proto_VkPhysicalDeviceShaderDrawParameterFeatures(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceShaderDrawParameterFeatures* input,
    goldfish_vk_proto::VkPhysicalDeviceShaderDrawParameterFeatures* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_shaderdrawparameters((uint32_t)input->shaderDrawParameters);
}

void from_proto_VkPhysicalDeviceShaderDrawParameterFeatures(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceShaderDrawParameterFeatures* input,
    VkPhysicalDeviceShaderDrawParameterFeatures* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceShaderDrawParameterFeatures));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->shaderDrawParameters = (VkBool32)input->shaderdrawparameters();
}

#endif
#ifdef VK_KHR_surface
void to_proto_VkSurfaceCapabilitiesKHR(
    VulkanHandleMapping* handleMapping,
    const VkSurfaceCapabilitiesKHR* input,
    goldfish_vk_proto::VkSurfaceCapabilitiesKHR* output)
{
    output->set_minimagecount((uint32_t)input->minImageCount);
    output->set_maximagecount((uint32_t)input->maxImageCount);
    to_proto_VkExtent2D(handleMapping, &input->currentExtent, output->mutable_currentextent());
    to_proto_VkExtent2D(handleMapping, &input->minImageExtent, output->mutable_minimageextent());
    to_proto_VkExtent2D(handleMapping, &input->maxImageExtent, output->mutable_maximageextent());
    output->set_maximagearraylayers((uint32_t)input->maxImageArrayLayers);
    output->set_supportedtransforms((uint32_t)input->supportedTransforms);
    output->set_currenttransform((uint32_t)input->currentTransform);
    output->set_supportedcompositealpha((uint32_t)input->supportedCompositeAlpha);
    output->set_supportedusageflags((uint32_t)input->supportedUsageFlags);
}

void from_proto_VkSurfaceCapabilitiesKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSurfaceCapabilitiesKHR* input,
    VkSurfaceCapabilitiesKHR* output)
{
    memset(output, 0x0, sizeof(VkSurfaceCapabilitiesKHR));
    output->minImageCount = (uint32_t)input->minimagecount();
    output->maxImageCount = (uint32_t)input->maximagecount();
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_currentextent(), (VkExtent2D*)(&output->currentExtent));
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_minimageextent(), (VkExtent2D*)(&output->minImageExtent));
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_maximageextent(), (VkExtent2D*)(&output->maxImageExtent));
    output->maxImageArrayLayers = (uint32_t)input->maximagearraylayers();
    output->supportedTransforms = (VkSurfaceTransformFlagsKHR)input->supportedtransforms();
    output->currentTransform = (VkSurfaceTransformFlagBitsKHR)input->currenttransform();
    output->supportedCompositeAlpha = (VkCompositeAlphaFlagsKHR)input->supportedcompositealpha();
    output->supportedUsageFlags = (VkImageUsageFlags)input->supportedusageflags();
}

void to_proto_VkSurfaceFormatKHR(
    VulkanHandleMapping* handleMapping,
    const VkSurfaceFormatKHR* input,
    goldfish_vk_proto::VkSurfaceFormatKHR* output)
{
    output->set_format((uint32_t)input->format);
    output->set_colorspace((uint32_t)input->colorSpace);
}

void from_proto_VkSurfaceFormatKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSurfaceFormatKHR* input,
    VkSurfaceFormatKHR* output)
{
    memset(output, 0x0, sizeof(VkSurfaceFormatKHR));
    output->format = (VkFormat)input->format();
    output->colorSpace = (VkColorSpaceKHR)input->colorspace();
}

#endif
#ifdef VK_KHR_swapchain
void to_proto_VkSwapchainCreateInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkSwapchainCreateInfoKHR* input,
    goldfish_vk_proto::VkSwapchainCreateInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    uint64_t cgen_var_53;
    handleMapping->mapHandles_VkSurfaceKHR_u64(&input->surface, &cgen_var_53, 1);
    output->set_surface(cgen_var_53);
    output->set_minimagecount((uint32_t)input->minImageCount);
    output->set_imageformat((uint32_t)input->imageFormat);
    output->set_imagecolorspace((uint32_t)input->imageColorSpace);
    to_proto_VkExtent2D(handleMapping, &input->imageExtent, output->mutable_imageextent());
    output->set_imagearraylayers((uint32_t)input->imageArrayLayers);
    output->set_imageusage((uint32_t)input->imageUsage);
    output->set_imagesharingmode((uint32_t)input->imageSharingMode);
    output->set_queuefamilyindexcount((uint32_t)input->queueFamilyIndexCount);
    // WARNING PTR CHECK
    if (input->pQueueFamilyIndices)
    {
        for (uint32_t i = 0; i < (uint32_t)input->queueFamilyIndexCount; ++i)
        {
            output->add_pqueuefamilyindices(input->pQueueFamilyIndices[i]);
        }
    }
    output->set_pretransform((uint32_t)input->preTransform);
    output->set_compositealpha((uint32_t)input->compositeAlpha);
    output->set_presentmode((uint32_t)input->presentMode);
    output->set_clipped((uint32_t)input->clipped);
    uint64_t cgen_var_54;
    handleMapping->mapHandles_VkSwapchainKHR_u64(&input->oldSwapchain, &cgen_var_54, 1);
    output->set_oldswapchain(cgen_var_54);
}

void from_proto_VkSwapchainCreateInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSwapchainCreateInfoKHR* input,
    VkSwapchainCreateInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkSwapchainCreateInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkSwapchainCreateFlagsKHR)input->flags();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->surface();
        handleMapping->mapHandles_u64_VkSurfaceKHR(&current, (VkSurfaceKHR*)&output->surface, 1);
    }
    output->minImageCount = (uint32_t)input->minimagecount();
    output->imageFormat = (VkFormat)input->imageformat();
    output->imageColorSpace = (VkColorSpaceKHR)input->imagecolorspace();
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_imageextent(), (VkExtent2D*)(&output->imageExtent));
    output->imageArrayLayers = (uint32_t)input->imagearraylayers();
    output->imageUsage = (VkImageUsageFlags)input->imageusage();
    output->imageSharingMode = (VkSharingMode)input->imagesharingmode();
    output->queueFamilyIndexCount = (uint32_t)input->queuefamilyindexcount();
    // WARNING PTR CHECK
    if (input->pqueuefamilyindices_size())
    {
        for (uint32_t i = 0; i < (uint32_t)output->queueFamilyIndexCount; ++i)
        {
            *((uint32_t*)(&output->pQueueFamilyIndices) + i) = (uint32_t)input->pqueuefamilyindices(i);
        }
    }
    output->preTransform = (VkSurfaceTransformFlagBitsKHR)input->pretransform();
    output->compositeAlpha = (VkCompositeAlphaFlagBitsKHR)input->compositealpha();
    output->presentMode = (VkPresentModeKHR)input->presentmode();
    output->clipped = (VkBool32)input->clipped();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->oldswapchain();
        handleMapping->mapHandles_u64_VkSwapchainKHR(&current, (VkSwapchainKHR*)&output->oldSwapchain, 1);
    }
}

void to_proto_VkPresentInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkPresentInfoKHR* input,
    goldfish_vk_proto::VkPresentInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_waitsemaphorecount((uint32_t)input->waitSemaphoreCount);
    if (input->waitSemaphoreCount)
    {
        std::vector<uint64_t> cgen_var_55(input->waitSemaphoreCount);
        handleMapping->mapHandles_VkSemaphore_u64(input->pWaitSemaphores, cgen_var_55.data(), input->waitSemaphoreCount);
        for (uint32_t i = 0; i < input->waitSemaphoreCount; ++i)
        {
            output->add_pwaitsemaphores(cgen_var_55[i]);
        }
    }
    output->set_swapchaincount((uint32_t)input->swapchainCount);
    if (input->swapchainCount)
    {
        std::vector<uint64_t> cgen_var_56(input->swapchainCount);
        handleMapping->mapHandles_VkSwapchainKHR_u64(input->pSwapchains, cgen_var_56.data(), input->swapchainCount);
        for (uint32_t i = 0; i < input->swapchainCount; ++i)
        {
            output->add_pswapchains(cgen_var_56[i]);
        }
    }
    for (uint32_t i = 0; i < (uint32_t)input->swapchainCount; ++i)
    {
        output->add_pimageindices(input->pImageIndices[i]);
    }
    // WARNING PTR CHECK
    if (input->pResults)
    {
        for (uint32_t i = 0; i < (uint32_t)input->swapchainCount; ++i)
        {
            output->add_presults(input->pResults[i]);
        }
    }
}

void from_proto_VkPresentInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPresentInfoKHR* input,
    VkPresentInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkPresentInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->waitSemaphoreCount = (uint32_t)input->waitsemaphorecount();
    if (output->waitSemaphoreCount)
    {
        for (uint32_t i = 0; i < output->waitSemaphoreCount; ++i)
        {
            uint64_t current = input->pwaitsemaphores(i);
            handleMapping->mapHandles_u64_VkSemaphore(&current, (VkSemaphore*)&output->pWaitSemaphores[i], 1);
        }
    }
    output->swapchainCount = (uint32_t)input->swapchaincount();
    if (output->swapchainCount)
    {
        for (uint32_t i = 0; i < output->swapchainCount; ++i)
        {
            uint64_t current = input->pswapchains(i);
            handleMapping->mapHandles_u64_VkSwapchainKHR(&current, (VkSwapchainKHR*)&output->pSwapchains[i], 1);
        }
    }
    for (uint32_t i = 0; i < (uint32_t)output->swapchainCount; ++i)
    {
        *((uint32_t*)(&output->pImageIndices) + i) = (uint32_t)input->pimageindices(i);
    }
    // WARNING PTR CHECK
    if (input->presults_size())
    {
        for (uint32_t i = 0; i < (uint32_t)output->swapchainCount; ++i)
        {
            *((VkResult*)(&output->pResults) + i) = (VkResult)input->presults(i);
        }
    }
}

void to_proto_VkImageSwapchainCreateInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkImageSwapchainCreateInfoKHR* input,
    goldfish_vk_proto::VkImageSwapchainCreateInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_57;
    handleMapping->mapHandles_VkSwapchainKHR_u64(&input->swapchain, &cgen_var_57, 1);
    output->set_swapchain(cgen_var_57);
}

void from_proto_VkImageSwapchainCreateInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageSwapchainCreateInfoKHR* input,
    VkImageSwapchainCreateInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkImageSwapchainCreateInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->swapchain();
        handleMapping->mapHandles_u64_VkSwapchainKHR(&current, (VkSwapchainKHR*)&output->swapchain, 1);
    }
}

void to_proto_VkBindImageMemorySwapchainInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkBindImageMemorySwapchainInfoKHR* input,
    goldfish_vk_proto::VkBindImageMemorySwapchainInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_58;
    handleMapping->mapHandles_VkSwapchainKHR_u64(&input->swapchain, &cgen_var_58, 1);
    output->set_swapchain(cgen_var_58);
    output->set_imageindex((uint32_t)input->imageIndex);
}

void from_proto_VkBindImageMemorySwapchainInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkBindImageMemorySwapchainInfoKHR* input,
    VkBindImageMemorySwapchainInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkBindImageMemorySwapchainInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->swapchain();
        handleMapping->mapHandles_u64_VkSwapchainKHR(&current, (VkSwapchainKHR*)&output->swapchain, 1);
    }
    output->imageIndex = (uint32_t)input->imageindex();
}

void to_proto_VkAcquireNextImageInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkAcquireNextImageInfoKHR* input,
    goldfish_vk_proto::VkAcquireNextImageInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_59;
    handleMapping->mapHandles_VkSwapchainKHR_u64(&input->swapchain, &cgen_var_59, 1);
    output->set_swapchain(cgen_var_59);
    output->set_timeout((uint64_t)input->timeout);
    uint64_t cgen_var_60;
    handleMapping->mapHandles_VkSemaphore_u64(&input->semaphore, &cgen_var_60, 1);
    output->set_semaphore(cgen_var_60);
    uint64_t cgen_var_61;
    handleMapping->mapHandles_VkFence_u64(&input->fence, &cgen_var_61, 1);
    output->set_fence(cgen_var_61);
    output->set_devicemask((uint32_t)input->deviceMask);
}

void from_proto_VkAcquireNextImageInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkAcquireNextImageInfoKHR* input,
    VkAcquireNextImageInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkAcquireNextImageInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->swapchain();
        handleMapping->mapHandles_u64_VkSwapchainKHR(&current, (VkSwapchainKHR*)&output->swapchain, 1);
    }
    output->timeout = (uint64_t)input->timeout();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->semaphore();
        handleMapping->mapHandles_u64_VkSemaphore(&current, (VkSemaphore*)&output->semaphore, 1);
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->fence();
        handleMapping->mapHandles_u64_VkFence(&current, (VkFence*)&output->fence, 1);
    }
    output->deviceMask = (uint32_t)input->devicemask();
}

void to_proto_VkDeviceGroupPresentCapabilitiesKHR(
    VulkanHandleMapping* handleMapping,
    const VkDeviceGroupPresentCapabilitiesKHR* input,
    goldfish_vk_proto::VkDeviceGroupPresentCapabilitiesKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_DEVICE_GROUP_SIZE; ++i)
    {
        output->add_presentmask(input->presentMask[i]);
    }
    output->set_modes((uint32_t)input->modes);
}

void from_proto_VkDeviceGroupPresentCapabilitiesKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceGroupPresentCapabilitiesKHR* input,
    VkDeviceGroupPresentCapabilitiesKHR* output)
{
    memset(output, 0x0, sizeof(VkDeviceGroupPresentCapabilitiesKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_DEVICE_GROUP_SIZE; ++i)
    {
        output->presentMask[i] = (uint32_t)input->presentmask(i);
    }
    output->modes = (VkDeviceGroupPresentModeFlagsKHR)input->modes();
}

void to_proto_VkDeviceGroupPresentInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkDeviceGroupPresentInfoKHR* input,
    goldfish_vk_proto::VkDeviceGroupPresentInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_swapchaincount((uint32_t)input->swapchainCount);
    for (uint32_t i = 0; i < (uint32_t)input->swapchainCount; ++i)
    {
        output->add_pdevicemasks(input->pDeviceMasks[i]);
    }
    output->set_mode((uint32_t)input->mode);
}

void from_proto_VkDeviceGroupPresentInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceGroupPresentInfoKHR* input,
    VkDeviceGroupPresentInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkDeviceGroupPresentInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->swapchainCount = (uint32_t)input->swapchaincount();
    for (uint32_t i = 0; i < (uint32_t)output->swapchainCount; ++i)
    {
        *((uint32_t*)(&output->pDeviceMasks) + i) = (uint32_t)input->pdevicemasks(i);
    }
    output->mode = (VkDeviceGroupPresentModeFlagBitsKHR)input->mode();
}

void to_proto_VkDeviceGroupSwapchainCreateInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkDeviceGroupSwapchainCreateInfoKHR* input,
    goldfish_vk_proto::VkDeviceGroupSwapchainCreateInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_modes((uint32_t)input->modes);
}

void from_proto_VkDeviceGroupSwapchainCreateInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceGroupSwapchainCreateInfoKHR* input,
    VkDeviceGroupSwapchainCreateInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkDeviceGroupSwapchainCreateInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->modes = (VkDeviceGroupPresentModeFlagsKHR)input->modes();
}

#endif
#ifdef VK_KHR_display
void to_proto_VkDisplayPropertiesKHR(
    VulkanHandleMapping* handleMapping,
    const VkDisplayPropertiesKHR* input,
    goldfish_vk_proto::VkDisplayPropertiesKHR* output)
{
    uint64_t cgen_var_62;
    handleMapping->mapHandles_VkDisplayKHR_u64(&input->display, &cgen_var_62, 1);
    output->set_display(cgen_var_62);
    output->set_displayname(input->displayName);
    to_proto_VkExtent2D(handleMapping, &input->physicalDimensions, output->mutable_physicaldimensions());
    to_proto_VkExtent2D(handleMapping, &input->physicalResolution, output->mutable_physicalresolution());
    output->set_supportedtransforms((uint32_t)input->supportedTransforms);
    output->set_planereorderpossible((uint32_t)input->planeReorderPossible);
    output->set_persistentcontent((uint32_t)input->persistentContent);
}

void from_proto_VkDisplayPropertiesKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplayPropertiesKHR* input,
    VkDisplayPropertiesKHR* output)
{
    memset(output, 0x0, sizeof(VkDisplayPropertiesKHR));
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->display();
        handleMapping->mapHandles_u64_VkDisplayKHR(&current, (VkDisplayKHR*)&output->display, 1);
    }
    *(const char**)(&output->displayName) = input->displayname().c_str();
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_physicaldimensions(), (VkExtent2D*)(&output->physicalDimensions));
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_physicalresolution(), (VkExtent2D*)(&output->physicalResolution));
    output->supportedTransforms = (VkSurfaceTransformFlagsKHR)input->supportedtransforms();
    output->planeReorderPossible = (VkBool32)input->planereorderpossible();
    output->persistentContent = (VkBool32)input->persistentcontent();
}

void to_proto_VkDisplayModeParametersKHR(
    VulkanHandleMapping* handleMapping,
    const VkDisplayModeParametersKHR* input,
    goldfish_vk_proto::VkDisplayModeParametersKHR* output)
{
    to_proto_VkExtent2D(handleMapping, &input->visibleRegion, output->mutable_visibleregion());
    output->set_refreshrate((uint32_t)input->refreshRate);
}

void from_proto_VkDisplayModeParametersKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplayModeParametersKHR* input,
    VkDisplayModeParametersKHR* output)
{
    memset(output, 0x0, sizeof(VkDisplayModeParametersKHR));
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_visibleregion(), (VkExtent2D*)(&output->visibleRegion));
    output->refreshRate = (uint32_t)input->refreshrate();
}

void to_proto_VkDisplayModePropertiesKHR(
    VulkanHandleMapping* handleMapping,
    const VkDisplayModePropertiesKHR* input,
    goldfish_vk_proto::VkDisplayModePropertiesKHR* output)
{
    uint64_t cgen_var_63;
    handleMapping->mapHandles_VkDisplayModeKHR_u64(&input->displayMode, &cgen_var_63, 1);
    output->set_displaymode(cgen_var_63);
    to_proto_VkDisplayModeParametersKHR(handleMapping, &input->parameters, output->mutable_parameters());
}

void from_proto_VkDisplayModePropertiesKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplayModePropertiesKHR* input,
    VkDisplayModePropertiesKHR* output)
{
    memset(output, 0x0, sizeof(VkDisplayModePropertiesKHR));
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->displaymode();
        handleMapping->mapHandles_u64_VkDisplayModeKHR(&current, (VkDisplayModeKHR*)&output->displayMode, 1);
    }
    from_proto_VkDisplayModeParametersKHR(pool, handleMapping, input->mutable_parameters(), (VkDisplayModeParametersKHR*)(&output->parameters));
}

void to_proto_VkDisplayModeCreateInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkDisplayModeCreateInfoKHR* input,
    goldfish_vk_proto::VkDisplayModeCreateInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    to_proto_VkDisplayModeParametersKHR(handleMapping, &input->parameters, output->mutable_parameters());
}

void from_proto_VkDisplayModeCreateInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplayModeCreateInfoKHR* input,
    VkDisplayModeCreateInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkDisplayModeCreateInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkDisplayModeCreateFlagsKHR)input->flags();
    from_proto_VkDisplayModeParametersKHR(pool, handleMapping, input->mutable_parameters(), (VkDisplayModeParametersKHR*)(&output->parameters));
}

void to_proto_VkDisplayPlaneCapabilitiesKHR(
    VulkanHandleMapping* handleMapping,
    const VkDisplayPlaneCapabilitiesKHR* input,
    goldfish_vk_proto::VkDisplayPlaneCapabilitiesKHR* output)
{
    output->set_supportedalpha((uint32_t)input->supportedAlpha);
    to_proto_VkOffset2D(handleMapping, &input->minSrcPosition, output->mutable_minsrcposition());
    to_proto_VkOffset2D(handleMapping, &input->maxSrcPosition, output->mutable_maxsrcposition());
    to_proto_VkExtent2D(handleMapping, &input->minSrcExtent, output->mutable_minsrcextent());
    to_proto_VkExtent2D(handleMapping, &input->maxSrcExtent, output->mutable_maxsrcextent());
    to_proto_VkOffset2D(handleMapping, &input->minDstPosition, output->mutable_mindstposition());
    to_proto_VkOffset2D(handleMapping, &input->maxDstPosition, output->mutable_maxdstposition());
    to_proto_VkExtent2D(handleMapping, &input->minDstExtent, output->mutable_mindstextent());
    to_proto_VkExtent2D(handleMapping, &input->maxDstExtent, output->mutable_maxdstextent());
}

void from_proto_VkDisplayPlaneCapabilitiesKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplayPlaneCapabilitiesKHR* input,
    VkDisplayPlaneCapabilitiesKHR* output)
{
    memset(output, 0x0, sizeof(VkDisplayPlaneCapabilitiesKHR));
    output->supportedAlpha = (VkDisplayPlaneAlphaFlagsKHR)input->supportedalpha();
    from_proto_VkOffset2D(pool, handleMapping, input->mutable_minsrcposition(), (VkOffset2D*)(&output->minSrcPosition));
    from_proto_VkOffset2D(pool, handleMapping, input->mutable_maxsrcposition(), (VkOffset2D*)(&output->maxSrcPosition));
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_minsrcextent(), (VkExtent2D*)(&output->minSrcExtent));
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_maxsrcextent(), (VkExtent2D*)(&output->maxSrcExtent));
    from_proto_VkOffset2D(pool, handleMapping, input->mutable_mindstposition(), (VkOffset2D*)(&output->minDstPosition));
    from_proto_VkOffset2D(pool, handleMapping, input->mutable_maxdstposition(), (VkOffset2D*)(&output->maxDstPosition));
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_mindstextent(), (VkExtent2D*)(&output->minDstExtent));
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_maxdstextent(), (VkExtent2D*)(&output->maxDstExtent));
}

void to_proto_VkDisplayPlanePropertiesKHR(
    VulkanHandleMapping* handleMapping,
    const VkDisplayPlanePropertiesKHR* input,
    goldfish_vk_proto::VkDisplayPlanePropertiesKHR* output)
{
    uint64_t cgen_var_64;
    handleMapping->mapHandles_VkDisplayKHR_u64(&input->currentDisplay, &cgen_var_64, 1);
    output->set_currentdisplay(cgen_var_64);
    output->set_currentstackindex((uint32_t)input->currentStackIndex);
}

void from_proto_VkDisplayPlanePropertiesKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplayPlanePropertiesKHR* input,
    VkDisplayPlanePropertiesKHR* output)
{
    memset(output, 0x0, sizeof(VkDisplayPlanePropertiesKHR));
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->currentdisplay();
        handleMapping->mapHandles_u64_VkDisplayKHR(&current, (VkDisplayKHR*)&output->currentDisplay, 1);
    }
    output->currentStackIndex = (uint32_t)input->currentstackindex();
}

void to_proto_VkDisplaySurfaceCreateInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkDisplaySurfaceCreateInfoKHR* input,
    goldfish_vk_proto::VkDisplaySurfaceCreateInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    uint64_t cgen_var_65;
    handleMapping->mapHandles_VkDisplayModeKHR_u64(&input->displayMode, &cgen_var_65, 1);
    output->set_displaymode(cgen_var_65);
    output->set_planeindex((uint32_t)input->planeIndex);
    output->set_planestackindex((uint32_t)input->planeStackIndex);
    output->set_transform((uint32_t)input->transform);
    output->set_globalalpha((float)input->globalAlpha);
    output->set_alphamode((uint32_t)input->alphaMode);
    to_proto_VkExtent2D(handleMapping, &input->imageExtent, output->mutable_imageextent());
}

void from_proto_VkDisplaySurfaceCreateInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplaySurfaceCreateInfoKHR* input,
    VkDisplaySurfaceCreateInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkDisplaySurfaceCreateInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkDisplaySurfaceCreateFlagsKHR)input->flags();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->displaymode();
        handleMapping->mapHandles_u64_VkDisplayModeKHR(&current, (VkDisplayModeKHR*)&output->displayMode, 1);
    }
    output->planeIndex = (uint32_t)input->planeindex();
    output->planeStackIndex = (uint32_t)input->planestackindex();
    output->transform = (VkSurfaceTransformFlagBitsKHR)input->transform();
    output->globalAlpha = (float)input->globalalpha();
    output->alphaMode = (VkDisplayPlaneAlphaFlagBitsKHR)input->alphamode();
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_imageextent(), (VkExtent2D*)(&output->imageExtent));
}

#endif
#ifdef VK_KHR_display_swapchain
void to_proto_VkDisplayPresentInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkDisplayPresentInfoKHR* input,
    goldfish_vk_proto::VkDisplayPresentInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkRect2D(handleMapping, &input->srcRect, output->mutable_srcrect());
    to_proto_VkRect2D(handleMapping, &input->dstRect, output->mutable_dstrect());
    output->set_persistent((uint32_t)input->persistent);
}

void from_proto_VkDisplayPresentInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplayPresentInfoKHR* input,
    VkDisplayPresentInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkDisplayPresentInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkRect2D(pool, handleMapping, input->mutable_srcrect(), (VkRect2D*)(&output->srcRect));
    from_proto_VkRect2D(pool, handleMapping, input->mutable_dstrect(), (VkRect2D*)(&output->dstRect));
    output->persistent = (VkBool32)input->persistent();
}

#endif
#ifdef VK_KHR_xlib_surface
void to_proto_VkXlibSurfaceCreateInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkXlibSurfaceCreateInfoKHR* input,
    goldfish_vk_proto::VkXlibSurfaceCreateInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    // WARNING PTR CHECK
    if (input->dpy)
    {
        output->set_dpy((uint64_t)(uintptr_t)input->dpy);
    }
    output->set_window((uint64_t)input->window);
}

void from_proto_VkXlibSurfaceCreateInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkXlibSurfaceCreateInfoKHR* input,
    VkXlibSurfaceCreateInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkXlibSurfaceCreateInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkXlibSurfaceCreateFlagsKHR)input->flags();
    // WARNING PTR CHECK
    if (input->has_dpy())
    {
        output->dpy = (Display*)(uintptr_t)input->dpy();
    }
    output->window = (Window)input->window();
}

#endif
#ifdef VK_KHR_xcb_surface
void to_proto_VkXcbSurfaceCreateInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkXcbSurfaceCreateInfoKHR* input,
    goldfish_vk_proto::VkXcbSurfaceCreateInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    // WARNING PTR CHECK
    if (input->connection)
    {
        output->set_connection((uint64_t)(uintptr_t)input->connection);
    }
    output->set_window((uint64_t)input->window);
}

void from_proto_VkXcbSurfaceCreateInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkXcbSurfaceCreateInfoKHR* input,
    VkXcbSurfaceCreateInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkXcbSurfaceCreateInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkXcbSurfaceCreateFlagsKHR)input->flags();
    // WARNING PTR CHECK
    if (input->has_connection())
    {
        output->connection = (xcb_connection_t*)(uintptr_t)input->connection();
    }
    output->window = (xcb_window_t)input->window();
}

#endif
#ifdef VK_KHR_wayland_surface
void to_proto_VkWaylandSurfaceCreateInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkWaylandSurfaceCreateInfoKHR* input,
    goldfish_vk_proto::VkWaylandSurfaceCreateInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    // WARNING PTR CHECK
    if (input->display)
    {
        output->set_display((uint64_t)(uintptr_t)input->display);
    }
    // WARNING PTR CHECK
    if (input->surface)
    {
        output->set_surface((uint64_t)(uintptr_t)input->surface);
    }
}

void from_proto_VkWaylandSurfaceCreateInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkWaylandSurfaceCreateInfoKHR* input,
    VkWaylandSurfaceCreateInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkWaylandSurfaceCreateInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkWaylandSurfaceCreateFlagsKHR)input->flags();
    // WARNING PTR CHECK
    if (input->has_display())
    {
        output->display = (wl_display*)(uintptr_t)input->display();
    }
    // WARNING PTR CHECK
    if (input->has_surface())
    {
        output->surface = (wl_surface*)(uintptr_t)input->surface();
    }
}

#endif
#ifdef VK_KHR_mir_surface
void to_proto_VkMirSurfaceCreateInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkMirSurfaceCreateInfoKHR* input,
    goldfish_vk_proto::VkMirSurfaceCreateInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    // WARNING PTR CHECK
    if (input->connection)
    {
        output->set_connection((uint64_t)(uintptr_t)input->connection);
    }
    // WARNING PTR CHECK
    if (input->mirSurface)
    {
        output->set_mirsurface((uint64_t)(uintptr_t)input->mirSurface);
    }
}

void from_proto_VkMirSurfaceCreateInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMirSurfaceCreateInfoKHR* input,
    VkMirSurfaceCreateInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkMirSurfaceCreateInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkMirSurfaceCreateFlagsKHR)input->flags();
    // WARNING PTR CHECK
    if (input->has_connection())
    {
        output->connection = (MirConnection*)(uintptr_t)input->connection();
    }
    // WARNING PTR CHECK
    if (input->has_mirsurface())
    {
        output->mirSurface = (MirSurface*)(uintptr_t)input->mirsurface();
    }
}

#endif
#ifdef VK_KHR_android_surface
void to_proto_VkAndroidSurfaceCreateInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkAndroidSurfaceCreateInfoKHR* input,
    goldfish_vk_proto::VkAndroidSurfaceCreateInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    // WARNING PTR CHECK
    if (input->window)
    {
        output->set_window((uint64_t)(uintptr_t)input->window);
    }
}

void from_proto_VkAndroidSurfaceCreateInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkAndroidSurfaceCreateInfoKHR* input,
    VkAndroidSurfaceCreateInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkAndroidSurfaceCreateInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkAndroidSurfaceCreateFlagsKHR)input->flags();
    // WARNING PTR CHECK
    if (input->has_window())
    {
        output->window = (ANativeWindow*)(uintptr_t)input->window();
    }
}

#endif
#ifdef VK_KHR_win32_surface
void to_proto_VkWin32SurfaceCreateInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkWin32SurfaceCreateInfoKHR* input,
    goldfish_vk_proto::VkWin32SurfaceCreateInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_hinstance((uint64_t)input->hinstance);
    output->set_hwnd((uint64_t)input->hwnd);
}

void from_proto_VkWin32SurfaceCreateInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkWin32SurfaceCreateInfoKHR* input,
    VkWin32SurfaceCreateInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkWin32SurfaceCreateInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkWin32SurfaceCreateFlagsKHR)input->flags();
    output->hinstance = (HINSTANCE)input->hinstance();
    output->hwnd = (HWND)input->hwnd();
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_device_group
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_device_group_creation
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void to_proto_VkImportMemoryWin32HandleInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkImportMemoryWin32HandleInfoKHR* input,
    goldfish_vk_proto::VkImportMemoryWin32HandleInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_handletype((uint32_t)input->handleType);
    output->set_handle((uint64_t)input->handle);
    output->set_name((uint64_t)input->name);
}

void from_proto_VkImportMemoryWin32HandleInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImportMemoryWin32HandleInfoKHR* input,
    VkImportMemoryWin32HandleInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkImportMemoryWin32HandleInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->handleType = (VkExternalMemoryHandleTypeFlagBits)input->handletype();
    output->handle = (HANDLE)input->handle();
    output->name = (LPCWSTR)input->name();
}

void to_proto_VkExportMemoryWin32HandleInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkExportMemoryWin32HandleInfoKHR* input,
    goldfish_vk_proto::VkExportMemoryWin32HandleInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    // WARNING PTR CHECK
    if (input->pAttributes)
    {
        output->set_pattributes((uint64_t)(uintptr_t)input->pAttributes);
    }
    output->set_dwaccess((uint64_t)input->dwAccess);
    output->set_name((uint64_t)input->name);
}

void from_proto_VkExportMemoryWin32HandleInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExportMemoryWin32HandleInfoKHR* input,
    VkExportMemoryWin32HandleInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkExportMemoryWin32HandleInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    // WARNING PTR CHECK
    if (input->has_pattributes())
    {
        output->pAttributes = (SECURITY_ATTRIBUTES*)(uintptr_t)input->pattributes();
    }
    output->dwAccess = (DWORD)input->dwaccess();
    output->name = (LPCWSTR)input->name();
}

void to_proto_VkMemoryWin32HandlePropertiesKHR(
    VulkanHandleMapping* handleMapping,
    const VkMemoryWin32HandlePropertiesKHR* input,
    goldfish_vk_proto::VkMemoryWin32HandlePropertiesKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_memorytypebits((uint32_t)input->memoryTypeBits);
}

void from_proto_VkMemoryWin32HandlePropertiesKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryWin32HandlePropertiesKHR* input,
    VkMemoryWin32HandlePropertiesKHR* output)
{
    memset(output, 0x0, sizeof(VkMemoryWin32HandlePropertiesKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->memoryTypeBits = (uint32_t)input->memorytypebits();
}

void to_proto_VkMemoryGetWin32HandleInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkMemoryGetWin32HandleInfoKHR* input,
    goldfish_vk_proto::VkMemoryGetWin32HandleInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_66;
    handleMapping->mapHandles_VkDeviceMemory_u64(&input->memory, &cgen_var_66, 1);
    output->set_memory(cgen_var_66);
    output->set_handletype((uint32_t)input->handleType);
}

void from_proto_VkMemoryGetWin32HandleInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryGetWin32HandleInfoKHR* input,
    VkMemoryGetWin32HandleInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkMemoryGetWin32HandleInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->memory();
        handleMapping->mapHandles_u64_VkDeviceMemory(&current, (VkDeviceMemory*)&output->memory, 1);
    }
    output->handleType = (VkExternalMemoryHandleTypeFlagBits)input->handletype();
}

#endif
#ifdef VK_KHR_external_memory_fd
void to_proto_VkImportMemoryFdInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkImportMemoryFdInfoKHR* input,
    goldfish_vk_proto::VkImportMemoryFdInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_handletype((uint32_t)input->handleType);
    output->set_fd((uint64_t)input->fd);
}

void from_proto_VkImportMemoryFdInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImportMemoryFdInfoKHR* input,
    VkImportMemoryFdInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkImportMemoryFdInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->handleType = (VkExternalMemoryHandleTypeFlagBits)input->handletype();
    output->fd = (int)input->fd();
}

void to_proto_VkMemoryFdPropertiesKHR(
    VulkanHandleMapping* handleMapping,
    const VkMemoryFdPropertiesKHR* input,
    goldfish_vk_proto::VkMemoryFdPropertiesKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_memorytypebits((uint32_t)input->memoryTypeBits);
}

void from_proto_VkMemoryFdPropertiesKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryFdPropertiesKHR* input,
    VkMemoryFdPropertiesKHR* output)
{
    memset(output, 0x0, sizeof(VkMemoryFdPropertiesKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->memoryTypeBits = (uint32_t)input->memorytypebits();
}

void to_proto_VkMemoryGetFdInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkMemoryGetFdInfoKHR* input,
    goldfish_vk_proto::VkMemoryGetFdInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_67;
    handleMapping->mapHandles_VkDeviceMemory_u64(&input->memory, &cgen_var_67, 1);
    output->set_memory(cgen_var_67);
    output->set_handletype((uint32_t)input->handleType);
}

void from_proto_VkMemoryGetFdInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryGetFdInfoKHR* input,
    VkMemoryGetFdInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkMemoryGetFdInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->memory();
        handleMapping->mapHandles_u64_VkDeviceMemory(&current, (VkDeviceMemory*)&output->memory, 1);
    }
    output->handleType = (VkExternalMemoryHandleTypeFlagBits)input->handletype();
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void to_proto_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkWin32KeyedMutexAcquireReleaseInfoKHR* input,
    goldfish_vk_proto::VkWin32KeyedMutexAcquireReleaseInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_acquirecount((uint32_t)input->acquireCount);
    if (input->acquireCount)
    {
        std::vector<uint64_t> cgen_var_68(input->acquireCount);
        handleMapping->mapHandles_VkDeviceMemory_u64(input->pAcquireSyncs, cgen_var_68.data(), input->acquireCount);
        for (uint32_t i = 0; i < input->acquireCount; ++i)
        {
            output->add_pacquiresyncs(cgen_var_68[i]);
        }
    }
    for (uint32_t i = 0; i < (uint32_t)input->acquireCount; ++i)
    {
        output->add_pacquirekeys(input->pAcquireKeys[i]);
    }
    for (uint32_t i = 0; i < (uint32_t)input->acquireCount; ++i)
    {
        output->add_pacquiretimeouts(input->pAcquireTimeouts[i]);
    }
    output->set_releasecount((uint32_t)input->releaseCount);
    if (input->releaseCount)
    {
        std::vector<uint64_t> cgen_var_69(input->releaseCount);
        handleMapping->mapHandles_VkDeviceMemory_u64(input->pReleaseSyncs, cgen_var_69.data(), input->releaseCount);
        for (uint32_t i = 0; i < input->releaseCount; ++i)
        {
            output->add_preleasesyncs(cgen_var_69[i]);
        }
    }
    for (uint32_t i = 0; i < (uint32_t)input->releaseCount; ++i)
    {
        output->add_preleasekeys(input->pReleaseKeys[i]);
    }
}

void from_proto_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkWin32KeyedMutexAcquireReleaseInfoKHR* input,
    VkWin32KeyedMutexAcquireReleaseInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkWin32KeyedMutexAcquireReleaseInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->acquireCount = (uint32_t)input->acquirecount();
    if (output->acquireCount)
    {
        for (uint32_t i = 0; i < output->acquireCount; ++i)
        {
            uint64_t current = input->pacquiresyncs(i);
            handleMapping->mapHandles_u64_VkDeviceMemory(&current, (VkDeviceMemory*)&output->pAcquireSyncs[i], 1);
        }
    }
    for (uint32_t i = 0; i < (uint32_t)output->acquireCount; ++i)
    {
        *((uint64_t*)(&output->pAcquireKeys) + i) = (uint64_t)input->pacquirekeys(i);
    }
    for (uint32_t i = 0; i < (uint32_t)output->acquireCount; ++i)
    {
        *((uint32_t*)(&output->pAcquireTimeouts) + i) = (uint32_t)input->pacquiretimeouts(i);
    }
    output->releaseCount = (uint32_t)input->releasecount();
    if (output->releaseCount)
    {
        for (uint32_t i = 0; i < output->releaseCount; ++i)
        {
            uint64_t current = input->preleasesyncs(i);
            handleMapping->mapHandles_u64_VkDeviceMemory(&current, (VkDeviceMemory*)&output->pReleaseSyncs[i], 1);
        }
    }
    for (uint32_t i = 0; i < (uint32_t)output->releaseCount; ++i)
    {
        *((uint64_t*)(&output->pReleaseKeys) + i) = (uint64_t)input->preleasekeys(i);
    }
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void to_proto_VkImportSemaphoreWin32HandleInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkImportSemaphoreWin32HandleInfoKHR* input,
    goldfish_vk_proto::VkImportSemaphoreWin32HandleInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_70;
    handleMapping->mapHandles_VkSemaphore_u64(&input->semaphore, &cgen_var_70, 1);
    output->set_semaphore(cgen_var_70);
    output->set_flags((uint32_t)input->flags);
    output->set_handletype((uint32_t)input->handleType);
    output->set_handle((uint64_t)input->handle);
    output->set_name((uint64_t)input->name);
}

void from_proto_VkImportSemaphoreWin32HandleInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImportSemaphoreWin32HandleInfoKHR* input,
    VkImportSemaphoreWin32HandleInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkImportSemaphoreWin32HandleInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->semaphore();
        handleMapping->mapHandles_u64_VkSemaphore(&current, (VkSemaphore*)&output->semaphore, 1);
    }
    output->flags = (VkSemaphoreImportFlags)input->flags();
    output->handleType = (VkExternalSemaphoreHandleTypeFlagBits)input->handletype();
    output->handle = (HANDLE)input->handle();
    output->name = (LPCWSTR)input->name();
}

void to_proto_VkExportSemaphoreWin32HandleInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkExportSemaphoreWin32HandleInfoKHR* input,
    goldfish_vk_proto::VkExportSemaphoreWin32HandleInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    // WARNING PTR CHECK
    if (input->pAttributes)
    {
        output->set_pattributes((uint64_t)(uintptr_t)input->pAttributes);
    }
    output->set_dwaccess((uint64_t)input->dwAccess);
    output->set_name((uint64_t)input->name);
}

void from_proto_VkExportSemaphoreWin32HandleInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExportSemaphoreWin32HandleInfoKHR* input,
    VkExportSemaphoreWin32HandleInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkExportSemaphoreWin32HandleInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    // WARNING PTR CHECK
    if (input->has_pattributes())
    {
        output->pAttributes = (SECURITY_ATTRIBUTES*)(uintptr_t)input->pattributes();
    }
    output->dwAccess = (DWORD)input->dwaccess();
    output->name = (LPCWSTR)input->name();
}

void to_proto_VkD3D12FenceSubmitInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkD3D12FenceSubmitInfoKHR* input,
    goldfish_vk_proto::VkD3D12FenceSubmitInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_waitsemaphorevaluescount((uint32_t)input->waitSemaphoreValuesCount);
    // WARNING PTR CHECK
    if (input->pWaitSemaphoreValues)
    {
        for (uint32_t i = 0; i < (uint32_t)input->waitSemaphoreValuesCount; ++i)
        {
            output->add_pwaitsemaphorevalues(input->pWaitSemaphoreValues[i]);
        }
    }
    output->set_signalsemaphorevaluescount((uint32_t)input->signalSemaphoreValuesCount);
    // WARNING PTR CHECK
    if (input->pSignalSemaphoreValues)
    {
        for (uint32_t i = 0; i < (uint32_t)input->signalSemaphoreValuesCount; ++i)
        {
            output->add_psignalsemaphorevalues(input->pSignalSemaphoreValues[i]);
        }
    }
}

void from_proto_VkD3D12FenceSubmitInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkD3D12FenceSubmitInfoKHR* input,
    VkD3D12FenceSubmitInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkD3D12FenceSubmitInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->waitSemaphoreValuesCount = (uint32_t)input->waitsemaphorevaluescount();
    // WARNING PTR CHECK
    if (input->pwaitsemaphorevalues_size())
    {
        for (uint32_t i = 0; i < (uint32_t)output->waitSemaphoreValuesCount; ++i)
        {
            *((uint64_t*)(&output->pWaitSemaphoreValues) + i) = (uint64_t)input->pwaitsemaphorevalues(i);
        }
    }
    output->signalSemaphoreValuesCount = (uint32_t)input->signalsemaphorevaluescount();
    // WARNING PTR CHECK
    if (input->psignalsemaphorevalues_size())
    {
        for (uint32_t i = 0; i < (uint32_t)output->signalSemaphoreValuesCount; ++i)
        {
            *((uint64_t*)(&output->pSignalSemaphoreValues) + i) = (uint64_t)input->psignalsemaphorevalues(i);
        }
    }
}

void to_proto_VkSemaphoreGetWin32HandleInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkSemaphoreGetWin32HandleInfoKHR* input,
    goldfish_vk_proto::VkSemaphoreGetWin32HandleInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_71;
    handleMapping->mapHandles_VkSemaphore_u64(&input->semaphore, &cgen_var_71, 1);
    output->set_semaphore(cgen_var_71);
    output->set_handletype((uint32_t)input->handleType);
}

void from_proto_VkSemaphoreGetWin32HandleInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSemaphoreGetWin32HandleInfoKHR* input,
    VkSemaphoreGetWin32HandleInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkSemaphoreGetWin32HandleInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->semaphore();
        handleMapping->mapHandles_u64_VkSemaphore(&current, (VkSemaphore*)&output->semaphore, 1);
    }
    output->handleType = (VkExternalSemaphoreHandleTypeFlagBits)input->handletype();
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void to_proto_VkImportSemaphoreFdInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkImportSemaphoreFdInfoKHR* input,
    goldfish_vk_proto::VkImportSemaphoreFdInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_72;
    handleMapping->mapHandles_VkSemaphore_u64(&input->semaphore, &cgen_var_72, 1);
    output->set_semaphore(cgen_var_72);
    output->set_flags((uint32_t)input->flags);
    output->set_handletype((uint32_t)input->handleType);
    output->set_fd((uint64_t)input->fd);
}

void from_proto_VkImportSemaphoreFdInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImportSemaphoreFdInfoKHR* input,
    VkImportSemaphoreFdInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkImportSemaphoreFdInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->semaphore();
        handleMapping->mapHandles_u64_VkSemaphore(&current, (VkSemaphore*)&output->semaphore, 1);
    }
    output->flags = (VkSemaphoreImportFlags)input->flags();
    output->handleType = (VkExternalSemaphoreHandleTypeFlagBits)input->handletype();
    output->fd = (int)input->fd();
}

void to_proto_VkSemaphoreGetFdInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkSemaphoreGetFdInfoKHR* input,
    goldfish_vk_proto::VkSemaphoreGetFdInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_73;
    handleMapping->mapHandles_VkSemaphore_u64(&input->semaphore, &cgen_var_73, 1);
    output->set_semaphore(cgen_var_73);
    output->set_handletype((uint32_t)input->handleType);
}

void from_proto_VkSemaphoreGetFdInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSemaphoreGetFdInfoKHR* input,
    VkSemaphoreGetFdInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkSemaphoreGetFdInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->semaphore();
        handleMapping->mapHandles_u64_VkSemaphore(&current, (VkSemaphore*)&output->semaphore, 1);
    }
    output->handleType = (VkExternalSemaphoreHandleTypeFlagBits)input->handletype();
}

#endif
#ifdef VK_KHR_push_descriptor
void to_proto_VkPhysicalDevicePushDescriptorPropertiesKHR(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDevicePushDescriptorPropertiesKHR* input,
    goldfish_vk_proto::VkPhysicalDevicePushDescriptorPropertiesKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_maxpushdescriptors((uint32_t)input->maxPushDescriptors);
}

void from_proto_VkPhysicalDevicePushDescriptorPropertiesKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDevicePushDescriptorPropertiesKHR* input,
    VkPhysicalDevicePushDescriptorPropertiesKHR* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDevicePushDescriptorPropertiesKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->maxPushDescriptors = (uint32_t)input->maxpushdescriptors();
}

#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void to_proto_VkRectLayerKHR(
    VulkanHandleMapping* handleMapping,
    const VkRectLayerKHR* input,
    goldfish_vk_proto::VkRectLayerKHR* output)
{
    to_proto_VkOffset2D(handleMapping, &input->offset, output->mutable_offset());
    to_proto_VkExtent2D(handleMapping, &input->extent, output->mutable_extent());
    output->set_layer((uint32_t)input->layer);
}

void from_proto_VkRectLayerKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkRectLayerKHR* input,
    VkRectLayerKHR* output)
{
    memset(output, 0x0, sizeof(VkRectLayerKHR));
    from_proto_VkOffset2D(pool, handleMapping, input->mutable_offset(), (VkOffset2D*)(&output->offset));
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_extent(), (VkExtent2D*)(&output->extent));
    output->layer = (uint32_t)input->layer();
}

void to_proto_VkPresentRegionKHR(
    VulkanHandleMapping* handleMapping,
    const VkPresentRegionKHR* input,
    goldfish_vk_proto::VkPresentRegionKHR* output)
{
    output->set_rectanglecount((uint32_t)input->rectangleCount);
    // WARNING PTR CHECK
    if (input->pRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)input->rectangleCount; ++i)
        {
            to_proto_VkRectLayerKHR(handleMapping, input->pRectangles + i, output->add_prectangles());
        }
    }
}

void from_proto_VkPresentRegionKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPresentRegionKHR* input,
    VkPresentRegionKHR* output)
{
    memset(output, 0x0, sizeof(VkPresentRegionKHR));
    output->rectangleCount = (uint32_t)input->rectanglecount();
    // WARNING PTR CHECK
    if (input->prectangles_size())
    {
        *(void**)&output->pRectangles = pool->alloc(output->rectangleCount * sizeof(const VkRectLayerKHR));
        for (uint32_t i = 0; i < (uint32_t)output->rectangleCount; ++i)
        {
            from_proto_VkRectLayerKHR(pool, handleMapping, input->mutable_prectangles(i), (VkRectLayerKHR*)(output->pRectangles + i));
        }
    }
}

void to_proto_VkPresentRegionsKHR(
    VulkanHandleMapping* handleMapping,
    const VkPresentRegionsKHR* input,
    goldfish_vk_proto::VkPresentRegionsKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_swapchaincount((uint32_t)input->swapchainCount);
    // WARNING PTR CHECK
    if (input->pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)input->swapchainCount; ++i)
        {
            to_proto_VkPresentRegionKHR(handleMapping, input->pRegions + i, output->add_pregions());
        }
    }
}

void from_proto_VkPresentRegionsKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPresentRegionsKHR* input,
    VkPresentRegionsKHR* output)
{
    memset(output, 0x0, sizeof(VkPresentRegionsKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->swapchainCount = (uint32_t)input->swapchaincount();
    // WARNING PTR CHECK
    if (input->pregions_size())
    {
        *(void**)&output->pRegions = pool->alloc(output->swapchainCount * sizeof(const VkPresentRegionKHR));
        for (uint32_t i = 0; i < (uint32_t)output->swapchainCount; ++i)
        {
            from_proto_VkPresentRegionKHR(pool, handleMapping, input->mutable_pregions(i), (VkPresentRegionKHR*)(output->pRegions + i));
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_create_renderpass2
void to_proto_VkAttachmentDescription2KHR(
    VulkanHandleMapping* handleMapping,
    const VkAttachmentDescription2KHR* input,
    goldfish_vk_proto::VkAttachmentDescription2KHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_format((uint32_t)input->format);
    output->set_samples((uint32_t)input->samples);
    output->set_loadop((uint32_t)input->loadOp);
    output->set_storeop((uint32_t)input->storeOp);
    output->set_stencilloadop((uint32_t)input->stencilLoadOp);
    output->set_stencilstoreop((uint32_t)input->stencilStoreOp);
    output->set_initiallayout((uint32_t)input->initialLayout);
    output->set_finallayout((uint32_t)input->finalLayout);
}

void from_proto_VkAttachmentDescription2KHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkAttachmentDescription2KHR* input,
    VkAttachmentDescription2KHR* output)
{
    memset(output, 0x0, sizeof(VkAttachmentDescription2KHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkAttachmentDescriptionFlags)input->flags();
    output->format = (VkFormat)input->format();
    output->samples = (VkSampleCountFlagBits)input->samples();
    output->loadOp = (VkAttachmentLoadOp)input->loadop();
    output->storeOp = (VkAttachmentStoreOp)input->storeop();
    output->stencilLoadOp = (VkAttachmentLoadOp)input->stencilloadop();
    output->stencilStoreOp = (VkAttachmentStoreOp)input->stencilstoreop();
    output->initialLayout = (VkImageLayout)input->initiallayout();
    output->finalLayout = (VkImageLayout)input->finallayout();
}

void to_proto_VkAttachmentReference2KHR(
    VulkanHandleMapping* handleMapping,
    const VkAttachmentReference2KHR* input,
    goldfish_vk_proto::VkAttachmentReference2KHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_attachment((uint32_t)input->attachment);
    output->set_layout((uint32_t)input->layout);
    output->set_aspectmask((uint32_t)input->aspectMask);
}

void from_proto_VkAttachmentReference2KHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkAttachmentReference2KHR* input,
    VkAttachmentReference2KHR* output)
{
    memset(output, 0x0, sizeof(VkAttachmentReference2KHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->attachment = (uint32_t)input->attachment();
    output->layout = (VkImageLayout)input->layout();
    output->aspectMask = (VkImageAspectFlags)input->aspectmask();
}

void to_proto_VkSubpassDescription2KHR(
    VulkanHandleMapping* handleMapping,
    const VkSubpassDescription2KHR* input,
    goldfish_vk_proto::VkSubpassDescription2KHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_pipelinebindpoint((uint32_t)input->pipelineBindPoint);
    output->set_viewmask((uint32_t)input->viewMask);
    output->set_inputattachmentcount((uint32_t)input->inputAttachmentCount);
    for (uint32_t i = 0; i < (uint32_t)input->inputAttachmentCount; ++i)
    {
        to_proto_VkAttachmentReference2KHR(handleMapping, input->pInputAttachments + i, output->add_pinputattachments());
    }
    output->set_colorattachmentcount((uint32_t)input->colorAttachmentCount);
    for (uint32_t i = 0; i < (uint32_t)input->colorAttachmentCount; ++i)
    {
        to_proto_VkAttachmentReference2KHR(handleMapping, input->pColorAttachments + i, output->add_pcolorattachments());
    }
    // WARNING PTR CHECK
    if (input->pResolveAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)input->colorAttachmentCount; ++i)
        {
            to_proto_VkAttachmentReference2KHR(handleMapping, input->pResolveAttachments + i, output->add_presolveattachments());
        }
    }
    // WARNING PTR CHECK
    if (input->pDepthStencilAttachment)
    {
        to_proto_VkAttachmentReference2KHR(handleMapping, input->pDepthStencilAttachment, output->mutable_pdepthstencilattachment());
    }
    output->set_preserveattachmentcount((uint32_t)input->preserveAttachmentCount);
    for (uint32_t i = 0; i < (uint32_t)input->preserveAttachmentCount; ++i)
    {
        output->add_ppreserveattachments(input->pPreserveAttachments[i]);
    }
}

void from_proto_VkSubpassDescription2KHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSubpassDescription2KHR* input,
    VkSubpassDescription2KHR* output)
{
    memset(output, 0x0, sizeof(VkSubpassDescription2KHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkSubpassDescriptionFlags)input->flags();
    output->pipelineBindPoint = (VkPipelineBindPoint)input->pipelinebindpoint();
    output->viewMask = (uint32_t)input->viewmask();
    output->inputAttachmentCount = (uint32_t)input->inputattachmentcount();
    *(void**)&output->pInputAttachments = pool->alloc(output->inputAttachmentCount * sizeof(const VkAttachmentReference2KHR));
    for (uint32_t i = 0; i < (uint32_t)output->inputAttachmentCount; ++i)
    {
        from_proto_VkAttachmentReference2KHR(pool, handleMapping, input->mutable_pinputattachments(i), (VkAttachmentReference2KHR*)(output->pInputAttachments + i));
    }
    output->colorAttachmentCount = (uint32_t)input->colorattachmentcount();
    *(void**)&output->pColorAttachments = pool->alloc(output->colorAttachmentCount * sizeof(const VkAttachmentReference2KHR));
    for (uint32_t i = 0; i < (uint32_t)output->colorAttachmentCount; ++i)
    {
        from_proto_VkAttachmentReference2KHR(pool, handleMapping, input->mutable_pcolorattachments(i), (VkAttachmentReference2KHR*)(output->pColorAttachments + i));
    }
    // WARNING PTR CHECK
    if (input->presolveattachments_size())
    {
        *(void**)&output->pResolveAttachments = pool->alloc(output->colorAttachmentCount * sizeof(const VkAttachmentReference2KHR));
        for (uint32_t i = 0; i < (uint32_t)output->colorAttachmentCount; ++i)
        {
            from_proto_VkAttachmentReference2KHR(pool, handleMapping, input->mutable_presolveattachments(i), (VkAttachmentReference2KHR*)(output->pResolveAttachments + i));
        }
    }
    // WARNING PTR CHECK
    if (input->has_pdepthstencilattachment())
    {
        *(void**)&output->pDepthStencilAttachment = pool->alloc(sizeof(const VkAttachmentReference2KHR));
        from_proto_VkAttachmentReference2KHR(pool, handleMapping, input->mutable_pdepthstencilattachment(), (VkAttachmentReference2KHR*)(output->pDepthStencilAttachment));
    }
    output->preserveAttachmentCount = (uint32_t)input->preserveattachmentcount();
    for (uint32_t i = 0; i < (uint32_t)output->preserveAttachmentCount; ++i)
    {
        *((uint32_t*)(&output->pPreserveAttachments) + i) = (uint32_t)input->ppreserveattachments(i);
    }
}

void to_proto_VkSubpassDependency2KHR(
    VulkanHandleMapping* handleMapping,
    const VkSubpassDependency2KHR* input,
    goldfish_vk_proto::VkSubpassDependency2KHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_srcsubpass((uint32_t)input->srcSubpass);
    output->set_dstsubpass((uint32_t)input->dstSubpass);
    output->set_srcstagemask((uint32_t)input->srcStageMask);
    output->set_dststagemask((uint32_t)input->dstStageMask);
    output->set_srcaccessmask((uint32_t)input->srcAccessMask);
    output->set_dstaccessmask((uint32_t)input->dstAccessMask);
    output->set_dependencyflags((uint32_t)input->dependencyFlags);
    output->set_viewoffset((int32_t)input->viewOffset);
}

void from_proto_VkSubpassDependency2KHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSubpassDependency2KHR* input,
    VkSubpassDependency2KHR* output)
{
    memset(output, 0x0, sizeof(VkSubpassDependency2KHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->srcSubpass = (uint32_t)input->srcsubpass();
    output->dstSubpass = (uint32_t)input->dstsubpass();
    output->srcStageMask = (VkPipelineStageFlags)input->srcstagemask();
    output->dstStageMask = (VkPipelineStageFlags)input->dststagemask();
    output->srcAccessMask = (VkAccessFlags)input->srcaccessmask();
    output->dstAccessMask = (VkAccessFlags)input->dstaccessmask();
    output->dependencyFlags = (VkDependencyFlags)input->dependencyflags();
    output->viewOffset = (int32_t)input->viewoffset();
}

void to_proto_VkRenderPassCreateInfo2KHR(
    VulkanHandleMapping* handleMapping,
    const VkRenderPassCreateInfo2KHR* input,
    goldfish_vk_proto::VkRenderPassCreateInfo2KHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_attachmentcount((uint32_t)input->attachmentCount);
    for (uint32_t i = 0; i < (uint32_t)input->attachmentCount; ++i)
    {
        to_proto_VkAttachmentDescription2KHR(handleMapping, input->pAttachments + i, output->add_pattachments());
    }
    output->set_subpasscount((uint32_t)input->subpassCount);
    for (uint32_t i = 0; i < (uint32_t)input->subpassCount; ++i)
    {
        to_proto_VkSubpassDescription2KHR(handleMapping, input->pSubpasses + i, output->add_psubpasses());
    }
    output->set_dependencycount((uint32_t)input->dependencyCount);
    for (uint32_t i = 0; i < (uint32_t)input->dependencyCount; ++i)
    {
        to_proto_VkSubpassDependency2KHR(handleMapping, input->pDependencies + i, output->add_pdependencies());
    }
    output->set_correlatedviewmaskcount((uint32_t)input->correlatedViewMaskCount);
    for (uint32_t i = 0; i < (uint32_t)input->correlatedViewMaskCount; ++i)
    {
        output->add_pcorrelatedviewmasks(input->pCorrelatedViewMasks[i]);
    }
}

void from_proto_VkRenderPassCreateInfo2KHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkRenderPassCreateInfo2KHR* input,
    VkRenderPassCreateInfo2KHR* output)
{
    memset(output, 0x0, sizeof(VkRenderPassCreateInfo2KHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkRenderPassCreateFlags)input->flags();
    output->attachmentCount = (uint32_t)input->attachmentcount();
    *(void**)&output->pAttachments = pool->alloc(output->attachmentCount * sizeof(const VkAttachmentDescription2KHR));
    for (uint32_t i = 0; i < (uint32_t)output->attachmentCount; ++i)
    {
        from_proto_VkAttachmentDescription2KHR(pool, handleMapping, input->mutable_pattachments(i), (VkAttachmentDescription2KHR*)(output->pAttachments + i));
    }
    output->subpassCount = (uint32_t)input->subpasscount();
    *(void**)&output->pSubpasses = pool->alloc(output->subpassCount * sizeof(const VkSubpassDescription2KHR));
    for (uint32_t i = 0; i < (uint32_t)output->subpassCount; ++i)
    {
        from_proto_VkSubpassDescription2KHR(pool, handleMapping, input->mutable_psubpasses(i), (VkSubpassDescription2KHR*)(output->pSubpasses + i));
    }
    output->dependencyCount = (uint32_t)input->dependencycount();
    *(void**)&output->pDependencies = pool->alloc(output->dependencyCount * sizeof(const VkSubpassDependency2KHR));
    for (uint32_t i = 0; i < (uint32_t)output->dependencyCount; ++i)
    {
        from_proto_VkSubpassDependency2KHR(pool, handleMapping, input->mutable_pdependencies(i), (VkSubpassDependency2KHR*)(output->pDependencies + i));
    }
    output->correlatedViewMaskCount = (uint32_t)input->correlatedviewmaskcount();
    for (uint32_t i = 0; i < (uint32_t)output->correlatedViewMaskCount; ++i)
    {
        *((uint32_t*)(&output->pCorrelatedViewMasks) + i) = (uint32_t)input->pcorrelatedviewmasks(i);
    }
}

void to_proto_VkSubpassBeginInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkSubpassBeginInfoKHR* input,
    goldfish_vk_proto::VkSubpassBeginInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_contents((uint32_t)input->contents);
}

void from_proto_VkSubpassBeginInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSubpassBeginInfoKHR* input,
    VkSubpassBeginInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkSubpassBeginInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->contents = (VkSubpassContents)input->contents();
}

void to_proto_VkSubpassEndInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkSubpassEndInfoKHR* input,
    goldfish_vk_proto::VkSubpassEndInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
}

void from_proto_VkSubpassEndInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSubpassEndInfoKHR* input,
    VkSubpassEndInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkSubpassEndInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
}

#endif
#ifdef VK_KHR_shared_presentable_image
void to_proto_VkSharedPresentSurfaceCapabilitiesKHR(
    VulkanHandleMapping* handleMapping,
    const VkSharedPresentSurfaceCapabilitiesKHR* input,
    goldfish_vk_proto::VkSharedPresentSurfaceCapabilitiesKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_sharedpresentsupportedusageflags((uint32_t)input->sharedPresentSupportedUsageFlags);
}

void from_proto_VkSharedPresentSurfaceCapabilitiesKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSharedPresentSurfaceCapabilitiesKHR* input,
    VkSharedPresentSurfaceCapabilitiesKHR* output)
{
    memset(output, 0x0, sizeof(VkSharedPresentSurfaceCapabilitiesKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->sharedPresentSupportedUsageFlags = (VkImageUsageFlags)input->sharedpresentsupportedusageflags();
}

#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void to_proto_VkImportFenceWin32HandleInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkImportFenceWin32HandleInfoKHR* input,
    goldfish_vk_proto::VkImportFenceWin32HandleInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_74;
    handleMapping->mapHandles_VkFence_u64(&input->fence, &cgen_var_74, 1);
    output->set_fence(cgen_var_74);
    output->set_flags((uint32_t)input->flags);
    output->set_handletype((uint32_t)input->handleType);
    output->set_handle((uint64_t)input->handle);
    output->set_name((uint64_t)input->name);
}

void from_proto_VkImportFenceWin32HandleInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImportFenceWin32HandleInfoKHR* input,
    VkImportFenceWin32HandleInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkImportFenceWin32HandleInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->fence();
        handleMapping->mapHandles_u64_VkFence(&current, (VkFence*)&output->fence, 1);
    }
    output->flags = (VkFenceImportFlags)input->flags();
    output->handleType = (VkExternalFenceHandleTypeFlagBits)input->handletype();
    output->handle = (HANDLE)input->handle();
    output->name = (LPCWSTR)input->name();
}

void to_proto_VkExportFenceWin32HandleInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkExportFenceWin32HandleInfoKHR* input,
    goldfish_vk_proto::VkExportFenceWin32HandleInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    // WARNING PTR CHECK
    if (input->pAttributes)
    {
        output->set_pattributes((uint64_t)(uintptr_t)input->pAttributes);
    }
    output->set_dwaccess((uint64_t)input->dwAccess);
    output->set_name((uint64_t)input->name);
}

void from_proto_VkExportFenceWin32HandleInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExportFenceWin32HandleInfoKHR* input,
    VkExportFenceWin32HandleInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkExportFenceWin32HandleInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    // WARNING PTR CHECK
    if (input->has_pattributes())
    {
        output->pAttributes = (SECURITY_ATTRIBUTES*)(uintptr_t)input->pattributes();
    }
    output->dwAccess = (DWORD)input->dwaccess();
    output->name = (LPCWSTR)input->name();
}

void to_proto_VkFenceGetWin32HandleInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkFenceGetWin32HandleInfoKHR* input,
    goldfish_vk_proto::VkFenceGetWin32HandleInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_75;
    handleMapping->mapHandles_VkFence_u64(&input->fence, &cgen_var_75, 1);
    output->set_fence(cgen_var_75);
    output->set_handletype((uint32_t)input->handleType);
}

void from_proto_VkFenceGetWin32HandleInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkFenceGetWin32HandleInfoKHR* input,
    VkFenceGetWin32HandleInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkFenceGetWin32HandleInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->fence();
        handleMapping->mapHandles_u64_VkFence(&current, (VkFence*)&output->fence, 1);
    }
    output->handleType = (VkExternalFenceHandleTypeFlagBits)input->handletype();
}

#endif
#ifdef VK_KHR_external_fence_fd
void to_proto_VkImportFenceFdInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkImportFenceFdInfoKHR* input,
    goldfish_vk_proto::VkImportFenceFdInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_76;
    handleMapping->mapHandles_VkFence_u64(&input->fence, &cgen_var_76, 1);
    output->set_fence(cgen_var_76);
    output->set_flags((uint32_t)input->flags);
    output->set_handletype((uint32_t)input->handleType);
    output->set_fd((uint64_t)input->fd);
}

void from_proto_VkImportFenceFdInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImportFenceFdInfoKHR* input,
    VkImportFenceFdInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkImportFenceFdInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->fence();
        handleMapping->mapHandles_u64_VkFence(&current, (VkFence*)&output->fence, 1);
    }
    output->flags = (VkFenceImportFlags)input->flags();
    output->handleType = (VkExternalFenceHandleTypeFlagBits)input->handletype();
    output->fd = (int)input->fd();
}

void to_proto_VkFenceGetFdInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkFenceGetFdInfoKHR* input,
    goldfish_vk_proto::VkFenceGetFdInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_77;
    handleMapping->mapHandles_VkFence_u64(&input->fence, &cgen_var_77, 1);
    output->set_fence(cgen_var_77);
    output->set_handletype((uint32_t)input->handleType);
}

void from_proto_VkFenceGetFdInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkFenceGetFdInfoKHR* input,
    VkFenceGetFdInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkFenceGetFdInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->fence();
        handleMapping->mapHandles_u64_VkFence(&current, (VkFence*)&output->fence, 1);
    }
    output->handleType = (VkExternalFenceHandleTypeFlagBits)input->handletype();
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void to_proto_VkPhysicalDeviceSurfaceInfo2KHR(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceSurfaceInfo2KHR* input,
    goldfish_vk_proto::VkPhysicalDeviceSurfaceInfo2KHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_78;
    handleMapping->mapHandles_VkSurfaceKHR_u64(&input->surface, &cgen_var_78, 1);
    output->set_surface(cgen_var_78);
}

void from_proto_VkPhysicalDeviceSurfaceInfo2KHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceSurfaceInfo2KHR* input,
    VkPhysicalDeviceSurfaceInfo2KHR* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceSurfaceInfo2KHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->surface();
        handleMapping->mapHandles_u64_VkSurfaceKHR(&current, (VkSurfaceKHR*)&output->surface, 1);
    }
}

void to_proto_VkSurfaceCapabilities2KHR(
    VulkanHandleMapping* handleMapping,
    const VkSurfaceCapabilities2KHR* input,
    goldfish_vk_proto::VkSurfaceCapabilities2KHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkSurfaceCapabilitiesKHR(handleMapping, &input->surfaceCapabilities, output->mutable_surfacecapabilities());
}

void from_proto_VkSurfaceCapabilities2KHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSurfaceCapabilities2KHR* input,
    VkSurfaceCapabilities2KHR* output)
{
    memset(output, 0x0, sizeof(VkSurfaceCapabilities2KHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkSurfaceCapabilitiesKHR(pool, handleMapping, input->mutable_surfacecapabilities(), (VkSurfaceCapabilitiesKHR*)(&output->surfaceCapabilities));
}

void to_proto_VkSurfaceFormat2KHR(
    VulkanHandleMapping* handleMapping,
    const VkSurfaceFormat2KHR* input,
    goldfish_vk_proto::VkSurfaceFormat2KHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkSurfaceFormatKHR(handleMapping, &input->surfaceFormat, output->mutable_surfaceformat());
}

void from_proto_VkSurfaceFormat2KHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSurfaceFormat2KHR* input,
    VkSurfaceFormat2KHR* output)
{
    memset(output, 0x0, sizeof(VkSurfaceFormat2KHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkSurfaceFormatKHR(pool, handleMapping, input->mutable_surfaceformat(), (VkSurfaceFormatKHR*)(&output->surfaceFormat));
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void to_proto_VkDisplayProperties2KHR(
    VulkanHandleMapping* handleMapping,
    const VkDisplayProperties2KHR* input,
    goldfish_vk_proto::VkDisplayProperties2KHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkDisplayPropertiesKHR(handleMapping, &input->displayProperties, output->mutable_displayproperties());
}

void from_proto_VkDisplayProperties2KHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplayProperties2KHR* input,
    VkDisplayProperties2KHR* output)
{
    memset(output, 0x0, sizeof(VkDisplayProperties2KHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkDisplayPropertiesKHR(pool, handleMapping, input->mutable_displayproperties(), (VkDisplayPropertiesKHR*)(&output->displayProperties));
}

void to_proto_VkDisplayPlaneProperties2KHR(
    VulkanHandleMapping* handleMapping,
    const VkDisplayPlaneProperties2KHR* input,
    goldfish_vk_proto::VkDisplayPlaneProperties2KHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkDisplayPlanePropertiesKHR(handleMapping, &input->displayPlaneProperties, output->mutable_displayplaneproperties());
}

void from_proto_VkDisplayPlaneProperties2KHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplayPlaneProperties2KHR* input,
    VkDisplayPlaneProperties2KHR* output)
{
    memset(output, 0x0, sizeof(VkDisplayPlaneProperties2KHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkDisplayPlanePropertiesKHR(pool, handleMapping, input->mutable_displayplaneproperties(), (VkDisplayPlanePropertiesKHR*)(&output->displayPlaneProperties));
}

void to_proto_VkDisplayModeProperties2KHR(
    VulkanHandleMapping* handleMapping,
    const VkDisplayModeProperties2KHR* input,
    goldfish_vk_proto::VkDisplayModeProperties2KHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkDisplayModePropertiesKHR(handleMapping, &input->displayModeProperties, output->mutable_displaymodeproperties());
}

void from_proto_VkDisplayModeProperties2KHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplayModeProperties2KHR* input,
    VkDisplayModeProperties2KHR* output)
{
    memset(output, 0x0, sizeof(VkDisplayModeProperties2KHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkDisplayModePropertiesKHR(pool, handleMapping, input->mutable_displaymodeproperties(), (VkDisplayModePropertiesKHR*)(&output->displayModeProperties));
}

void to_proto_VkDisplayPlaneInfo2KHR(
    VulkanHandleMapping* handleMapping,
    const VkDisplayPlaneInfo2KHR* input,
    goldfish_vk_proto::VkDisplayPlaneInfo2KHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_79;
    handleMapping->mapHandles_VkDisplayModeKHR_u64(&input->mode, &cgen_var_79, 1);
    output->set_mode(cgen_var_79);
    output->set_planeindex((uint32_t)input->planeIndex);
}

void from_proto_VkDisplayPlaneInfo2KHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplayPlaneInfo2KHR* input,
    VkDisplayPlaneInfo2KHR* output)
{
    memset(output, 0x0, sizeof(VkDisplayPlaneInfo2KHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->mode();
        handleMapping->mapHandles_u64_VkDisplayModeKHR(&current, (VkDisplayModeKHR*)&output->mode, 1);
    }
    output->planeIndex = (uint32_t)input->planeindex();
}

void to_proto_VkDisplayPlaneCapabilities2KHR(
    VulkanHandleMapping* handleMapping,
    const VkDisplayPlaneCapabilities2KHR* input,
    goldfish_vk_proto::VkDisplayPlaneCapabilities2KHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkDisplayPlaneCapabilitiesKHR(handleMapping, &input->capabilities, output->mutable_capabilities());
}

void from_proto_VkDisplayPlaneCapabilities2KHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplayPlaneCapabilities2KHR* input,
    VkDisplayPlaneCapabilities2KHR* output)
{
    memset(output, 0x0, sizeof(VkDisplayPlaneCapabilities2KHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkDisplayPlaneCapabilitiesKHR(pool, handleMapping, input->mutable_capabilities(), (VkDisplayPlaneCapabilitiesKHR*)(&output->capabilities));
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
void to_proto_VkImageFormatListCreateInfoKHR(
    VulkanHandleMapping* handleMapping,
    const VkImageFormatListCreateInfoKHR* input,
    goldfish_vk_proto::VkImageFormatListCreateInfoKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_viewformatcount((uint32_t)input->viewFormatCount);
    for (uint32_t i = 0; i < (uint32_t)input->viewFormatCount; ++i)
    {
        output->add_pviewformats(input->pViewFormats[i]);
    }
}

void from_proto_VkImageFormatListCreateInfoKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImageFormatListCreateInfoKHR* input,
    VkImageFormatListCreateInfoKHR* output)
{
    memset(output, 0x0, sizeof(VkImageFormatListCreateInfoKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->viewFormatCount = (uint32_t)input->viewformatcount();
    for (uint32_t i = 0; i < (uint32_t)output->viewFormatCount; ++i)
    {
        *((VkFormat*)(&output->pViewFormats) + i) = (VkFormat)input->pviewformats(i);
    }
}

#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_draw_indirect_count
#endif
#ifdef VK_KHR_8bit_storage
void to_proto_VkPhysicalDevice8BitStorageFeaturesKHR(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDevice8BitStorageFeaturesKHR* input,
    goldfish_vk_proto::VkPhysicalDevice8BitStorageFeaturesKHR* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_storagebuffer8bitaccess((uint32_t)input->storageBuffer8BitAccess);
    output->set_uniformandstoragebuffer8bitaccess((uint32_t)input->uniformAndStorageBuffer8BitAccess);
    output->set_storagepushconstant8((uint32_t)input->storagePushConstant8);
}

void from_proto_VkPhysicalDevice8BitStorageFeaturesKHR(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDevice8BitStorageFeaturesKHR* input,
    VkPhysicalDevice8BitStorageFeaturesKHR* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDevice8BitStorageFeaturesKHR));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->storageBuffer8BitAccess = (VkBool32)input->storagebuffer8bitaccess();
    output->uniformAndStorageBuffer8BitAccess = (VkBool32)input->uniformandstoragebuffer8bitaccess();
    output->storagePushConstant8 = (VkBool32)input->storagepushconstant8();
}

#endif
#ifdef VK_ANDROID_native_buffer
void to_proto_VkNativeBufferANDROID(
    VulkanHandleMapping* handleMapping,
    const VkNativeBufferANDROID* input,
    goldfish_vk_proto::VkNativeBufferANDROID* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    // WARNING PTR CHECK
    if (input->handle)
    {
        output->set_handle((uint32_t)(uintptr_t)input->handle);
    }
    output->set_stride((uint64_t)input->stride);
    output->set_format((uint64_t)input->format);
    output->set_usage((uint64_t)input->usage);
    output->set_consumer((uint64_t)input->consumer);
    output->set_producer((uint64_t)input->producer);
}

void from_proto_VkNativeBufferANDROID(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkNativeBufferANDROID* input,
    VkNativeBufferANDROID* output)
{
    memset(output, 0x0, sizeof(VkNativeBufferANDROID));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    // WARNING PTR CHECK
    if (input->has_handle())
    {
        output->handle = (uint32_t*)(uintptr_t)input->handle();
    }
    output->stride = (int)input->stride();
    output->format = (int)input->format();
    output->usage = (int)input->usage();
    output->consumer = (uint64_t)input->consumer();
    output->producer = (uint64_t)input->producer();
}

#endif
#ifdef VK_EXT_debug_report
void to_proto_VkDebugReportCallbackCreateInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkDebugReportCallbackCreateInfoEXT* input,
    goldfish_vk_proto::VkDebugReportCallbackCreateInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_pfncallback((uint64_t)input->pfnCallback);
    // WARNING PTR CHECK
    if (input->pUserData)
    {
        output->set_puserdata((uint64_t)(uintptr_t)input->pUserData);
    }
}

void from_proto_VkDebugReportCallbackCreateInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDebugReportCallbackCreateInfoEXT* input,
    VkDebugReportCallbackCreateInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkDebugReportCallbackCreateInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkDebugReportFlagsEXT)input->flags();
    output->pfnCallback = (PFN_vkDebugReportCallbackEXT)input->pfncallback();
    // WARNING PTR CHECK
    if (input->has_puserdata())
    {
        output->pUserData = (void*)(uintptr_t)input->puserdata();
    }
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void to_proto_VkPipelineRasterizationStateRasterizationOrderAMD(
    VulkanHandleMapping* handleMapping,
    const VkPipelineRasterizationStateRasterizationOrderAMD* input,
    goldfish_vk_proto::VkPipelineRasterizationStateRasterizationOrderAMD* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_rasterizationorder((uint32_t)input->rasterizationOrder);
}

void from_proto_VkPipelineRasterizationStateRasterizationOrderAMD(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineRasterizationStateRasterizationOrderAMD* input,
    VkPipelineRasterizationStateRasterizationOrderAMD* output)
{
    memset(output, 0x0, sizeof(VkPipelineRasterizationStateRasterizationOrderAMD));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->rasterizationOrder = (VkRasterizationOrderAMD)input->rasterizationorder();
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void to_proto_VkDebugMarkerObjectNameInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkDebugMarkerObjectNameInfoEXT* input,
    goldfish_vk_proto::VkDebugMarkerObjectNameInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_objecttype((uint32_t)input->objectType);
    output->set_object((uint64_t)input->object);
    output->set_pobjectname(input->pObjectName);
}

void from_proto_VkDebugMarkerObjectNameInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDebugMarkerObjectNameInfoEXT* input,
    VkDebugMarkerObjectNameInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkDebugMarkerObjectNameInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->objectType = (VkDebugReportObjectTypeEXT)input->objecttype();
    output->object = (uint64_t)input->object();
    *(const char**)(&output->pObjectName) = input->pobjectname().c_str();
}

void to_proto_VkDebugMarkerObjectTagInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkDebugMarkerObjectTagInfoEXT* input,
    goldfish_vk_proto::VkDebugMarkerObjectTagInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_objecttype((uint32_t)input->objectType);
    output->set_object((uint64_t)input->object);
    output->set_tagname((uint64_t)input->tagName);
    output->set_tagsize((uint64_t)input->tagSize);
    for (uint32_t i = 0; i < (uint32_t)input->tagSize; ++i)
    {
        output->add_ptag(((const char*)(input->pTag))[i]);
    }
}

void from_proto_VkDebugMarkerObjectTagInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDebugMarkerObjectTagInfoEXT* input,
    VkDebugMarkerObjectTagInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkDebugMarkerObjectTagInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->objectType = (VkDebugReportObjectTypeEXT)input->objecttype();
    output->object = (uint64_t)input->object();
    output->tagName = (uint64_t)input->tagname();
    output->tagSize = (size_t)input->tagsize();
    for (uint32_t i = 0; i < (uint32_t)output->tagSize; ++i)
    {
        *((char*)(&output->pTag) + i) = (char)input->ptag(i);
    }
}

void to_proto_VkDebugMarkerMarkerInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkDebugMarkerMarkerInfoEXT* input,
    goldfish_vk_proto::VkDebugMarkerMarkerInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_pmarkername(input->pMarkerName);
    for (uint32_t i = 0; i < (uint32_t)4; ++i)
    {
        output->add_color(input->color[i]);
    }
}

void from_proto_VkDebugMarkerMarkerInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDebugMarkerMarkerInfoEXT* input,
    VkDebugMarkerMarkerInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkDebugMarkerMarkerInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    *(const char**)(&output->pMarkerName) = input->pmarkername().c_str();
    for (uint32_t i = 0; i < (uint32_t)4; ++i)
    {
        output->color[i] = (float)input->color(i);
    }
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void to_proto_VkDedicatedAllocationImageCreateInfoNV(
    VulkanHandleMapping* handleMapping,
    const VkDedicatedAllocationImageCreateInfoNV* input,
    goldfish_vk_proto::VkDedicatedAllocationImageCreateInfoNV* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_dedicatedallocation((uint32_t)input->dedicatedAllocation);
}

void from_proto_VkDedicatedAllocationImageCreateInfoNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDedicatedAllocationImageCreateInfoNV* input,
    VkDedicatedAllocationImageCreateInfoNV* output)
{
    memset(output, 0x0, sizeof(VkDedicatedAllocationImageCreateInfoNV));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->dedicatedAllocation = (VkBool32)input->dedicatedallocation();
}

void to_proto_VkDedicatedAllocationBufferCreateInfoNV(
    VulkanHandleMapping* handleMapping,
    const VkDedicatedAllocationBufferCreateInfoNV* input,
    goldfish_vk_proto::VkDedicatedAllocationBufferCreateInfoNV* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_dedicatedallocation((uint32_t)input->dedicatedAllocation);
}

void from_proto_VkDedicatedAllocationBufferCreateInfoNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDedicatedAllocationBufferCreateInfoNV* input,
    VkDedicatedAllocationBufferCreateInfoNV* output)
{
    memset(output, 0x0, sizeof(VkDedicatedAllocationBufferCreateInfoNV));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->dedicatedAllocation = (VkBool32)input->dedicatedallocation();
}

void to_proto_VkDedicatedAllocationMemoryAllocateInfoNV(
    VulkanHandleMapping* handleMapping,
    const VkDedicatedAllocationMemoryAllocateInfoNV* input,
    goldfish_vk_proto::VkDedicatedAllocationMemoryAllocateInfoNV* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_80;
    handleMapping->mapHandles_VkImage_u64(&input->image, &cgen_var_80, 1);
    output->set_image(cgen_var_80);
    uint64_t cgen_var_81;
    handleMapping->mapHandles_VkBuffer_u64(&input->buffer, &cgen_var_81, 1);
    output->set_buffer(cgen_var_81);
}

void from_proto_VkDedicatedAllocationMemoryAllocateInfoNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDedicatedAllocationMemoryAllocateInfoNV* input,
    VkDedicatedAllocationMemoryAllocateInfoNV* output)
{
    memset(output, 0x0, sizeof(VkDedicatedAllocationMemoryAllocateInfoNV));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->image();
        handleMapping->mapHandles_u64_VkImage(&current, (VkImage*)&output->image, 1);
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->buffer();
        handleMapping->mapHandles_u64_VkBuffer(&current, (VkBuffer*)&output->buffer, 1);
    }
}

#endif
#ifdef VK_AMD_draw_indirect_count
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
void to_proto_VkTextureLODGatherFormatPropertiesAMD(
    VulkanHandleMapping* handleMapping,
    const VkTextureLODGatherFormatPropertiesAMD* input,
    goldfish_vk_proto::VkTextureLODGatherFormatPropertiesAMD* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_supportstexturegatherlodbiasamd((uint32_t)input->supportsTextureGatherLODBiasAMD);
}

void from_proto_VkTextureLODGatherFormatPropertiesAMD(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkTextureLODGatherFormatPropertiesAMD* input,
    VkTextureLODGatherFormatPropertiesAMD* output)
{
    memset(output, 0x0, sizeof(VkTextureLODGatherFormatPropertiesAMD));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->supportsTextureGatherLODBiasAMD = (VkBool32)input->supportstexturegatherlodbiasamd();
}

#endif
#ifdef VK_AMD_shader_info
void to_proto_VkShaderResourceUsageAMD(
    VulkanHandleMapping* handleMapping,
    const VkShaderResourceUsageAMD* input,
    goldfish_vk_proto::VkShaderResourceUsageAMD* output)
{
    output->set_numusedvgprs((uint32_t)input->numUsedVgprs);
    output->set_numusedsgprs((uint32_t)input->numUsedSgprs);
    output->set_ldssizeperlocalworkgroup((uint32_t)input->ldsSizePerLocalWorkGroup);
    output->set_ldsusagesizeinbytes((uint64_t)input->ldsUsageSizeInBytes);
    output->set_scratchmemusageinbytes((uint64_t)input->scratchMemUsageInBytes);
}

void from_proto_VkShaderResourceUsageAMD(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkShaderResourceUsageAMD* input,
    VkShaderResourceUsageAMD* output)
{
    memset(output, 0x0, sizeof(VkShaderResourceUsageAMD));
    output->numUsedVgprs = (uint32_t)input->numusedvgprs();
    output->numUsedSgprs = (uint32_t)input->numusedsgprs();
    output->ldsSizePerLocalWorkGroup = (uint32_t)input->ldssizeperlocalworkgroup();
    output->ldsUsageSizeInBytes = (size_t)input->ldsusagesizeinbytes();
    output->scratchMemUsageInBytes = (size_t)input->scratchmemusageinbytes();
}

void to_proto_VkShaderStatisticsInfoAMD(
    VulkanHandleMapping* handleMapping,
    const VkShaderStatisticsInfoAMD* input,
    goldfish_vk_proto::VkShaderStatisticsInfoAMD* output)
{
    output->set_shaderstagemask((uint32_t)input->shaderStageMask);
    to_proto_VkShaderResourceUsageAMD(handleMapping, &input->resourceUsage, output->mutable_resourceusage());
    output->set_numphysicalvgprs((uint32_t)input->numPhysicalVgprs);
    output->set_numphysicalsgprs((uint32_t)input->numPhysicalSgprs);
    output->set_numavailablevgprs((uint32_t)input->numAvailableVgprs);
    output->set_numavailablesgprs((uint32_t)input->numAvailableSgprs);
    for (uint32_t i = 0; i < (uint32_t)3; ++i)
    {
        output->add_computeworkgroupsize(input->computeWorkGroupSize[i]);
    }
}

void from_proto_VkShaderStatisticsInfoAMD(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkShaderStatisticsInfoAMD* input,
    VkShaderStatisticsInfoAMD* output)
{
    memset(output, 0x0, sizeof(VkShaderStatisticsInfoAMD));
    output->shaderStageMask = (VkShaderStageFlags)input->shaderstagemask();
    from_proto_VkShaderResourceUsageAMD(pool, handleMapping, input->mutable_resourceusage(), (VkShaderResourceUsageAMD*)(&output->resourceUsage));
    output->numPhysicalVgprs = (uint32_t)input->numphysicalvgprs();
    output->numPhysicalSgprs = (uint32_t)input->numphysicalsgprs();
    output->numAvailableVgprs = (uint32_t)input->numavailablevgprs();
    output->numAvailableSgprs = (uint32_t)input->numavailablesgprs();
    for (uint32_t i = 0; i < (uint32_t)3; ++i)
    {
        output->computeWorkGroupSize[i] = (uint32_t)input->computeworkgroupsize(i);
    }
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void to_proto_VkExternalImageFormatPropertiesNV(
    VulkanHandleMapping* handleMapping,
    const VkExternalImageFormatPropertiesNV* input,
    goldfish_vk_proto::VkExternalImageFormatPropertiesNV* output)
{
    to_proto_VkImageFormatProperties(handleMapping, &input->imageFormatProperties, output->mutable_imageformatproperties());
    output->set_externalmemoryfeatures((uint32_t)input->externalMemoryFeatures);
    output->set_exportfromimportedhandletypes((uint32_t)input->exportFromImportedHandleTypes);
    output->set_compatiblehandletypes((uint32_t)input->compatibleHandleTypes);
}

void from_proto_VkExternalImageFormatPropertiesNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExternalImageFormatPropertiesNV* input,
    VkExternalImageFormatPropertiesNV* output)
{
    memset(output, 0x0, sizeof(VkExternalImageFormatPropertiesNV));
    from_proto_VkImageFormatProperties(pool, handleMapping, input->mutable_imageformatproperties(), (VkImageFormatProperties*)(&output->imageFormatProperties));
    output->externalMemoryFeatures = (VkExternalMemoryFeatureFlagsNV)input->externalmemoryfeatures();
    output->exportFromImportedHandleTypes = (VkExternalMemoryHandleTypeFlagsNV)input->exportfromimportedhandletypes();
    output->compatibleHandleTypes = (VkExternalMemoryHandleTypeFlagsNV)input->compatiblehandletypes();
}

#endif
#ifdef VK_NV_external_memory
void to_proto_VkExternalMemoryImageCreateInfoNV(
    VulkanHandleMapping* handleMapping,
    const VkExternalMemoryImageCreateInfoNV* input,
    goldfish_vk_proto::VkExternalMemoryImageCreateInfoNV* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_handletypes((uint32_t)input->handleTypes);
}

void from_proto_VkExternalMemoryImageCreateInfoNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExternalMemoryImageCreateInfoNV* input,
    VkExternalMemoryImageCreateInfoNV* output)
{
    memset(output, 0x0, sizeof(VkExternalMemoryImageCreateInfoNV));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->handleTypes = (VkExternalMemoryHandleTypeFlagsNV)input->handletypes();
}

void to_proto_VkExportMemoryAllocateInfoNV(
    VulkanHandleMapping* handleMapping,
    const VkExportMemoryAllocateInfoNV* input,
    goldfish_vk_proto::VkExportMemoryAllocateInfoNV* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_handletypes((uint32_t)input->handleTypes);
}

void from_proto_VkExportMemoryAllocateInfoNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExportMemoryAllocateInfoNV* input,
    VkExportMemoryAllocateInfoNV* output)
{
    memset(output, 0x0, sizeof(VkExportMemoryAllocateInfoNV));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->handleTypes = (VkExternalMemoryHandleTypeFlagsNV)input->handletypes();
}

#endif
#ifdef VK_NV_external_memory_win32
void to_proto_VkImportMemoryWin32HandleInfoNV(
    VulkanHandleMapping* handleMapping,
    const VkImportMemoryWin32HandleInfoNV* input,
    goldfish_vk_proto::VkImportMemoryWin32HandleInfoNV* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_handletype((uint32_t)input->handleType);
    output->set_handle((uint64_t)input->handle);
}

void from_proto_VkImportMemoryWin32HandleInfoNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImportMemoryWin32HandleInfoNV* input,
    VkImportMemoryWin32HandleInfoNV* output)
{
    memset(output, 0x0, sizeof(VkImportMemoryWin32HandleInfoNV));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->handleType = (VkExternalMemoryHandleTypeFlagsNV)input->handletype();
    output->handle = (HANDLE)input->handle();
}

void to_proto_VkExportMemoryWin32HandleInfoNV(
    VulkanHandleMapping* handleMapping,
    const VkExportMemoryWin32HandleInfoNV* input,
    goldfish_vk_proto::VkExportMemoryWin32HandleInfoNV* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    // WARNING PTR CHECK
    if (input->pAttributes)
    {
        output->set_pattributes((uint64_t)(uintptr_t)input->pAttributes);
    }
    output->set_dwaccess((uint64_t)input->dwAccess);
}

void from_proto_VkExportMemoryWin32HandleInfoNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExportMemoryWin32HandleInfoNV* input,
    VkExportMemoryWin32HandleInfoNV* output)
{
    memset(output, 0x0, sizeof(VkExportMemoryWin32HandleInfoNV));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    // WARNING PTR CHECK
    if (input->has_pattributes())
    {
        output->pAttributes = (SECURITY_ATTRIBUTES*)(uintptr_t)input->pattributes();
    }
    output->dwAccess = (DWORD)input->dwaccess();
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void to_proto_VkWin32KeyedMutexAcquireReleaseInfoNV(
    VulkanHandleMapping* handleMapping,
    const VkWin32KeyedMutexAcquireReleaseInfoNV* input,
    goldfish_vk_proto::VkWin32KeyedMutexAcquireReleaseInfoNV* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_acquirecount((uint32_t)input->acquireCount);
    if (input->acquireCount)
    {
        std::vector<uint64_t> cgen_var_82(input->acquireCount);
        handleMapping->mapHandles_VkDeviceMemory_u64(input->pAcquireSyncs, cgen_var_82.data(), input->acquireCount);
        for (uint32_t i = 0; i < input->acquireCount; ++i)
        {
            output->add_pacquiresyncs(cgen_var_82[i]);
        }
    }
    for (uint32_t i = 0; i < (uint32_t)input->acquireCount; ++i)
    {
        output->add_pacquirekeys(input->pAcquireKeys[i]);
    }
    for (uint32_t i = 0; i < (uint32_t)input->acquireCount; ++i)
    {
        output->add_pacquiretimeoutmilliseconds(input->pAcquireTimeoutMilliseconds[i]);
    }
    output->set_releasecount((uint32_t)input->releaseCount);
    if (input->releaseCount)
    {
        std::vector<uint64_t> cgen_var_83(input->releaseCount);
        handleMapping->mapHandles_VkDeviceMemory_u64(input->pReleaseSyncs, cgen_var_83.data(), input->releaseCount);
        for (uint32_t i = 0; i < input->releaseCount; ++i)
        {
            output->add_preleasesyncs(cgen_var_83[i]);
        }
    }
    for (uint32_t i = 0; i < (uint32_t)input->releaseCount; ++i)
    {
        output->add_preleasekeys(input->pReleaseKeys[i]);
    }
}

void from_proto_VkWin32KeyedMutexAcquireReleaseInfoNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkWin32KeyedMutexAcquireReleaseInfoNV* input,
    VkWin32KeyedMutexAcquireReleaseInfoNV* output)
{
    memset(output, 0x0, sizeof(VkWin32KeyedMutexAcquireReleaseInfoNV));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->acquireCount = (uint32_t)input->acquirecount();
    if (output->acquireCount)
    {
        for (uint32_t i = 0; i < output->acquireCount; ++i)
        {
            uint64_t current = input->pacquiresyncs(i);
            handleMapping->mapHandles_u64_VkDeviceMemory(&current, (VkDeviceMemory*)&output->pAcquireSyncs[i], 1);
        }
    }
    for (uint32_t i = 0; i < (uint32_t)output->acquireCount; ++i)
    {
        *((uint64_t*)(&output->pAcquireKeys) + i) = (uint64_t)input->pacquirekeys(i);
    }
    for (uint32_t i = 0; i < (uint32_t)output->acquireCount; ++i)
    {
        *((uint32_t*)(&output->pAcquireTimeoutMilliseconds) + i) = (uint32_t)input->pacquiretimeoutmilliseconds(i);
    }
    output->releaseCount = (uint32_t)input->releasecount();
    if (output->releaseCount)
    {
        for (uint32_t i = 0; i < output->releaseCount; ++i)
        {
            uint64_t current = input->preleasesyncs(i);
            handleMapping->mapHandles_u64_VkDeviceMemory(&current, (VkDeviceMemory*)&output->pReleaseSyncs[i], 1);
        }
    }
    for (uint32_t i = 0; i < (uint32_t)output->releaseCount; ++i)
    {
        *((uint64_t*)(&output->pReleaseKeys) + i) = (uint64_t)input->preleasekeys(i);
    }
}

#endif
#ifdef VK_EXT_validation_flags
void to_proto_VkValidationFlagsEXT(
    VulkanHandleMapping* handleMapping,
    const VkValidationFlagsEXT* input,
    goldfish_vk_proto::VkValidationFlagsEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_disabledvalidationcheckcount((uint32_t)input->disabledValidationCheckCount);
    for (uint32_t i = 0; i < (uint32_t)input->disabledValidationCheckCount; ++i)
    {
        output->add_pdisabledvalidationchecks(input->pDisabledValidationChecks[i]);
    }
}

void from_proto_VkValidationFlagsEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkValidationFlagsEXT* input,
    VkValidationFlagsEXT* output)
{
    memset(output, 0x0, sizeof(VkValidationFlagsEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->disabledValidationCheckCount = (uint32_t)input->disabledvalidationcheckcount();
    for (uint32_t i = 0; i < (uint32_t)output->disabledValidationCheckCount; ++i)
    {
        *((VkValidationCheckEXT*)(&output->pDisabledValidationChecks) + i) = (VkValidationCheckEXT)input->pdisabledvalidationchecks(i);
    }
}

#endif
#ifdef VK_NN_vi_surface
void to_proto_VkViSurfaceCreateInfoNN(
    VulkanHandleMapping* handleMapping,
    const VkViSurfaceCreateInfoNN* input,
    goldfish_vk_proto::VkViSurfaceCreateInfoNN* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    // WARNING PTR CHECK
    if (input->window)
    {
        output->set_window((uint64_t)(uintptr_t)input->window);
    }
}

void from_proto_VkViSurfaceCreateInfoNN(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkViSurfaceCreateInfoNN* input,
    VkViSurfaceCreateInfoNN* output)
{
    memset(output, 0x0, sizeof(VkViSurfaceCreateInfoNN));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkViSurfaceCreateFlagsNN)input->flags();
    // WARNING PTR CHECK
    if (input->has_window())
    {
        output->window = (void*)(uintptr_t)input->window();
    }
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
void to_proto_VkConditionalRenderingBeginInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkConditionalRenderingBeginInfoEXT* input,
    goldfish_vk_proto::VkConditionalRenderingBeginInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_84;
    handleMapping->mapHandles_VkBuffer_u64(&input->buffer, &cgen_var_84, 1);
    output->set_buffer(cgen_var_84);
    output->set_offset((uint64_t)input->offset);
    output->set_flags((uint32_t)input->flags);
}

void from_proto_VkConditionalRenderingBeginInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkConditionalRenderingBeginInfoEXT* input,
    VkConditionalRenderingBeginInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkConditionalRenderingBeginInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->buffer();
        handleMapping->mapHandles_u64_VkBuffer(&current, (VkBuffer*)&output->buffer, 1);
    }
    output->offset = (VkDeviceSize)input->offset();
    output->flags = (VkConditionalRenderingFlagsEXT)input->flags();
}

void to_proto_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT* input,
    goldfish_vk_proto::VkPhysicalDeviceConditionalRenderingFeaturesEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_conditionalrendering((uint32_t)input->conditionalRendering);
    output->set_inheritedconditionalrendering((uint32_t)input->inheritedConditionalRendering);
}

void from_proto_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceConditionalRenderingFeaturesEXT* input,
    VkPhysicalDeviceConditionalRenderingFeaturesEXT* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceConditionalRenderingFeaturesEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->conditionalRendering = (VkBool32)input->conditionalrendering();
    output->inheritedConditionalRendering = (VkBool32)input->inheritedconditionalrendering();
}

void to_proto_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* input,
    goldfish_vk_proto::VkCommandBufferInheritanceConditionalRenderingInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_conditionalrenderingenable((uint32_t)input->conditionalRenderingEnable);
}

void from_proto_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkCommandBufferInheritanceConditionalRenderingInfoEXT* input,
    VkCommandBufferInheritanceConditionalRenderingInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkCommandBufferInheritanceConditionalRenderingInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->conditionalRenderingEnable = (VkBool32)input->conditionalrenderingenable();
}

#endif
#ifdef VK_NVX_device_generated_commands
void to_proto_VkDeviceGeneratedCommandsFeaturesNVX(
    VulkanHandleMapping* handleMapping,
    const VkDeviceGeneratedCommandsFeaturesNVX* input,
    goldfish_vk_proto::VkDeviceGeneratedCommandsFeaturesNVX* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_computebindingpointsupport((uint32_t)input->computeBindingPointSupport);
}

void from_proto_VkDeviceGeneratedCommandsFeaturesNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceGeneratedCommandsFeaturesNVX* input,
    VkDeviceGeneratedCommandsFeaturesNVX* output)
{
    memset(output, 0x0, sizeof(VkDeviceGeneratedCommandsFeaturesNVX));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->computeBindingPointSupport = (VkBool32)input->computebindingpointsupport();
}

void to_proto_VkDeviceGeneratedCommandsLimitsNVX(
    VulkanHandleMapping* handleMapping,
    const VkDeviceGeneratedCommandsLimitsNVX* input,
    goldfish_vk_proto::VkDeviceGeneratedCommandsLimitsNVX* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_maxindirectcommandslayouttokencount((uint32_t)input->maxIndirectCommandsLayoutTokenCount);
    output->set_maxobjectentrycounts((uint32_t)input->maxObjectEntryCounts);
    output->set_minsequencecountbufferoffsetalignment((uint32_t)input->minSequenceCountBufferOffsetAlignment);
    output->set_minsequenceindexbufferoffsetalignment((uint32_t)input->minSequenceIndexBufferOffsetAlignment);
    output->set_mincommandstokenbufferoffsetalignment((uint32_t)input->minCommandsTokenBufferOffsetAlignment);
}

void from_proto_VkDeviceGeneratedCommandsLimitsNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceGeneratedCommandsLimitsNVX* input,
    VkDeviceGeneratedCommandsLimitsNVX* output)
{
    memset(output, 0x0, sizeof(VkDeviceGeneratedCommandsLimitsNVX));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->maxIndirectCommandsLayoutTokenCount = (uint32_t)input->maxindirectcommandslayouttokencount();
    output->maxObjectEntryCounts = (uint32_t)input->maxobjectentrycounts();
    output->minSequenceCountBufferOffsetAlignment = (uint32_t)input->minsequencecountbufferoffsetalignment();
    output->minSequenceIndexBufferOffsetAlignment = (uint32_t)input->minsequenceindexbufferoffsetalignment();
    output->minCommandsTokenBufferOffsetAlignment = (uint32_t)input->mincommandstokenbufferoffsetalignment();
}

void to_proto_VkIndirectCommandsTokenNVX(
    VulkanHandleMapping* handleMapping,
    const VkIndirectCommandsTokenNVX* input,
    goldfish_vk_proto::VkIndirectCommandsTokenNVX* output)
{
    output->set_tokentype((uint32_t)input->tokenType);
    uint64_t cgen_var_85;
    handleMapping->mapHandles_VkBuffer_u64(&input->buffer, &cgen_var_85, 1);
    output->set_buffer(cgen_var_85);
    output->set_offset((uint64_t)input->offset);
}

void from_proto_VkIndirectCommandsTokenNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkIndirectCommandsTokenNVX* input,
    VkIndirectCommandsTokenNVX* output)
{
    memset(output, 0x0, sizeof(VkIndirectCommandsTokenNVX));
    output->tokenType = (VkIndirectCommandsTokenTypeNVX)input->tokentype();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->buffer();
        handleMapping->mapHandles_u64_VkBuffer(&current, (VkBuffer*)&output->buffer, 1);
    }
    output->offset = (VkDeviceSize)input->offset();
}

void to_proto_VkIndirectCommandsLayoutTokenNVX(
    VulkanHandleMapping* handleMapping,
    const VkIndirectCommandsLayoutTokenNVX* input,
    goldfish_vk_proto::VkIndirectCommandsLayoutTokenNVX* output)
{
    output->set_tokentype((uint32_t)input->tokenType);
    output->set_bindingunit((uint32_t)input->bindingUnit);
    output->set_dynamiccount((uint32_t)input->dynamicCount);
    output->set_divisor((uint32_t)input->divisor);
}

void from_proto_VkIndirectCommandsLayoutTokenNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkIndirectCommandsLayoutTokenNVX* input,
    VkIndirectCommandsLayoutTokenNVX* output)
{
    memset(output, 0x0, sizeof(VkIndirectCommandsLayoutTokenNVX));
    output->tokenType = (VkIndirectCommandsTokenTypeNVX)input->tokentype();
    output->bindingUnit = (uint32_t)input->bindingunit();
    output->dynamicCount = (uint32_t)input->dynamiccount();
    output->divisor = (uint32_t)input->divisor();
}

void to_proto_VkIndirectCommandsLayoutCreateInfoNVX(
    VulkanHandleMapping* handleMapping,
    const VkIndirectCommandsLayoutCreateInfoNVX* input,
    goldfish_vk_proto::VkIndirectCommandsLayoutCreateInfoNVX* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_pipelinebindpoint((uint32_t)input->pipelineBindPoint);
    output->set_flags((uint32_t)input->flags);
    output->set_tokencount((uint32_t)input->tokenCount);
    for (uint32_t i = 0; i < (uint32_t)input->tokenCount; ++i)
    {
        to_proto_VkIndirectCommandsLayoutTokenNVX(handleMapping, input->pTokens + i, output->add_ptokens());
    }
}

void from_proto_VkIndirectCommandsLayoutCreateInfoNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkIndirectCommandsLayoutCreateInfoNVX* input,
    VkIndirectCommandsLayoutCreateInfoNVX* output)
{
    memset(output, 0x0, sizeof(VkIndirectCommandsLayoutCreateInfoNVX));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->pipelineBindPoint = (VkPipelineBindPoint)input->pipelinebindpoint();
    output->flags = (VkIndirectCommandsLayoutUsageFlagsNVX)input->flags();
    output->tokenCount = (uint32_t)input->tokencount();
    *(void**)&output->pTokens = pool->alloc(output->tokenCount * sizeof(const VkIndirectCommandsLayoutTokenNVX));
    for (uint32_t i = 0; i < (uint32_t)output->tokenCount; ++i)
    {
        from_proto_VkIndirectCommandsLayoutTokenNVX(pool, handleMapping, input->mutable_ptokens(i), (VkIndirectCommandsLayoutTokenNVX*)(output->pTokens + i));
    }
}

void to_proto_VkCmdProcessCommandsInfoNVX(
    VulkanHandleMapping* handleMapping,
    const VkCmdProcessCommandsInfoNVX* input,
    goldfish_vk_proto::VkCmdProcessCommandsInfoNVX* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_86;
    handleMapping->mapHandles_VkObjectTableNVX_u64(&input->objectTable, &cgen_var_86, 1);
    output->set_objecttable(cgen_var_86);
    uint64_t cgen_var_87;
    handleMapping->mapHandles_VkIndirectCommandsLayoutNVX_u64(&input->indirectCommandsLayout, &cgen_var_87, 1);
    output->set_indirectcommandslayout(cgen_var_87);
    output->set_indirectcommandstokencount((uint32_t)input->indirectCommandsTokenCount);
    for (uint32_t i = 0; i < (uint32_t)input->indirectCommandsTokenCount; ++i)
    {
        to_proto_VkIndirectCommandsTokenNVX(handleMapping, input->pIndirectCommandsTokens + i, output->add_pindirectcommandstokens());
    }
    output->set_maxsequencescount((uint32_t)input->maxSequencesCount);
    uint64_t cgen_var_88;
    handleMapping->mapHandles_VkCommandBuffer_u64(&input->targetCommandBuffer, &cgen_var_88, 1);
    output->set_targetcommandbuffer(cgen_var_88);
    uint64_t cgen_var_89;
    handleMapping->mapHandles_VkBuffer_u64(&input->sequencesCountBuffer, &cgen_var_89, 1);
    output->set_sequencescountbuffer(cgen_var_89);
    output->set_sequencescountoffset((uint64_t)input->sequencesCountOffset);
    uint64_t cgen_var_90;
    handleMapping->mapHandles_VkBuffer_u64(&input->sequencesIndexBuffer, &cgen_var_90, 1);
    output->set_sequencesindexbuffer(cgen_var_90);
    output->set_sequencesindexoffset((uint64_t)input->sequencesIndexOffset);
}

void from_proto_VkCmdProcessCommandsInfoNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkCmdProcessCommandsInfoNVX* input,
    VkCmdProcessCommandsInfoNVX* output)
{
    memset(output, 0x0, sizeof(VkCmdProcessCommandsInfoNVX));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->objecttable();
        handleMapping->mapHandles_u64_VkObjectTableNVX(&current, (VkObjectTableNVX*)&output->objectTable, 1);
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->indirectcommandslayout();
        handleMapping->mapHandles_u64_VkIndirectCommandsLayoutNVX(&current, (VkIndirectCommandsLayoutNVX*)&output->indirectCommandsLayout, 1);
    }
    output->indirectCommandsTokenCount = (uint32_t)input->indirectcommandstokencount();
    *(void**)&output->pIndirectCommandsTokens = pool->alloc(output->indirectCommandsTokenCount * sizeof(const VkIndirectCommandsTokenNVX));
    for (uint32_t i = 0; i < (uint32_t)output->indirectCommandsTokenCount; ++i)
    {
        from_proto_VkIndirectCommandsTokenNVX(pool, handleMapping, input->mutable_pindirectcommandstokens(i), (VkIndirectCommandsTokenNVX*)(output->pIndirectCommandsTokens + i));
    }
    output->maxSequencesCount = (uint32_t)input->maxsequencescount();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->targetcommandbuffer();
        handleMapping->mapHandles_u64_VkCommandBuffer(&current, (VkCommandBuffer*)&output->targetCommandBuffer, 1);
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->sequencescountbuffer();
        handleMapping->mapHandles_u64_VkBuffer(&current, (VkBuffer*)&output->sequencesCountBuffer, 1);
    }
    output->sequencesCountOffset = (VkDeviceSize)input->sequencescountoffset();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->sequencesindexbuffer();
        handleMapping->mapHandles_u64_VkBuffer(&current, (VkBuffer*)&output->sequencesIndexBuffer, 1);
    }
    output->sequencesIndexOffset = (VkDeviceSize)input->sequencesindexoffset();
}

void to_proto_VkCmdReserveSpaceForCommandsInfoNVX(
    VulkanHandleMapping* handleMapping,
    const VkCmdReserveSpaceForCommandsInfoNVX* input,
    goldfish_vk_proto::VkCmdReserveSpaceForCommandsInfoNVX* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_91;
    handleMapping->mapHandles_VkObjectTableNVX_u64(&input->objectTable, &cgen_var_91, 1);
    output->set_objecttable(cgen_var_91);
    uint64_t cgen_var_92;
    handleMapping->mapHandles_VkIndirectCommandsLayoutNVX_u64(&input->indirectCommandsLayout, &cgen_var_92, 1);
    output->set_indirectcommandslayout(cgen_var_92);
    output->set_maxsequencescount((uint32_t)input->maxSequencesCount);
}

void from_proto_VkCmdReserveSpaceForCommandsInfoNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkCmdReserveSpaceForCommandsInfoNVX* input,
    VkCmdReserveSpaceForCommandsInfoNVX* output)
{
    memset(output, 0x0, sizeof(VkCmdReserveSpaceForCommandsInfoNVX));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->objecttable();
        handleMapping->mapHandles_u64_VkObjectTableNVX(&current, (VkObjectTableNVX*)&output->objectTable, 1);
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->indirectcommandslayout();
        handleMapping->mapHandles_u64_VkIndirectCommandsLayoutNVX(&current, (VkIndirectCommandsLayoutNVX*)&output->indirectCommandsLayout, 1);
    }
    output->maxSequencesCount = (uint32_t)input->maxsequencescount();
}

void to_proto_VkObjectTableCreateInfoNVX(
    VulkanHandleMapping* handleMapping,
    const VkObjectTableCreateInfoNVX* input,
    goldfish_vk_proto::VkObjectTableCreateInfoNVX* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_objectcount((uint32_t)input->objectCount);
    for (uint32_t i = 0; i < (uint32_t)input->objectCount; ++i)
    {
        output->add_pobjectentrytypes(input->pObjectEntryTypes[i]);
    }
    for (uint32_t i = 0; i < (uint32_t)input->objectCount; ++i)
    {
        output->add_pobjectentrycounts(input->pObjectEntryCounts[i]);
    }
    for (uint32_t i = 0; i < (uint32_t)input->objectCount; ++i)
    {
        output->add_pobjectentryusageflags(input->pObjectEntryUsageFlags[i]);
    }
    output->set_maxuniformbuffersperdescriptor((uint32_t)input->maxUniformBuffersPerDescriptor);
    output->set_maxstoragebuffersperdescriptor((uint32_t)input->maxStorageBuffersPerDescriptor);
    output->set_maxstorageimagesperdescriptor((uint32_t)input->maxStorageImagesPerDescriptor);
    output->set_maxsampledimagesperdescriptor((uint32_t)input->maxSampledImagesPerDescriptor);
    output->set_maxpipelinelayouts((uint32_t)input->maxPipelineLayouts);
}

void from_proto_VkObjectTableCreateInfoNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkObjectTableCreateInfoNVX* input,
    VkObjectTableCreateInfoNVX* output)
{
    memset(output, 0x0, sizeof(VkObjectTableCreateInfoNVX));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->objectCount = (uint32_t)input->objectcount();
    for (uint32_t i = 0; i < (uint32_t)output->objectCount; ++i)
    {
        *((VkObjectEntryTypeNVX*)(&output->pObjectEntryTypes) + i) = (VkObjectEntryTypeNVX)input->pobjectentrytypes(i);
    }
    for (uint32_t i = 0; i < (uint32_t)output->objectCount; ++i)
    {
        *((uint32_t*)(&output->pObjectEntryCounts) + i) = (uint32_t)input->pobjectentrycounts(i);
    }
    for (uint32_t i = 0; i < (uint32_t)output->objectCount; ++i)
    {
        *((VkObjectEntryUsageFlagsNVX*)(&output->pObjectEntryUsageFlags) + i) = (VkObjectEntryUsageFlagsNVX)input->pobjectentryusageflags(i);
    }
    output->maxUniformBuffersPerDescriptor = (uint32_t)input->maxuniformbuffersperdescriptor();
    output->maxStorageBuffersPerDescriptor = (uint32_t)input->maxstoragebuffersperdescriptor();
    output->maxStorageImagesPerDescriptor = (uint32_t)input->maxstorageimagesperdescriptor();
    output->maxSampledImagesPerDescriptor = (uint32_t)input->maxsampledimagesperdescriptor();
    output->maxPipelineLayouts = (uint32_t)input->maxpipelinelayouts();
}

void to_proto_VkObjectTableEntryNVX(
    VulkanHandleMapping* handleMapping,
    const VkObjectTableEntryNVX* input,
    goldfish_vk_proto::VkObjectTableEntryNVX* output)
{
    output->set_type((uint32_t)input->type);
    output->set_flags((uint32_t)input->flags);
}

void from_proto_VkObjectTableEntryNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkObjectTableEntryNVX* input,
    VkObjectTableEntryNVX* output)
{
    memset(output, 0x0, sizeof(VkObjectTableEntryNVX));
    output->type = (VkObjectEntryTypeNVX)input->type();
    output->flags = (VkObjectEntryUsageFlagsNVX)input->flags();
}

void to_proto_VkObjectTablePipelineEntryNVX(
    VulkanHandleMapping* handleMapping,
    const VkObjectTablePipelineEntryNVX* input,
    goldfish_vk_proto::VkObjectTablePipelineEntryNVX* output)
{
    output->set_type((uint32_t)input->type);
    output->set_flags((uint32_t)input->flags);
    uint64_t cgen_var_93;
    handleMapping->mapHandles_VkPipeline_u64(&input->pipeline, &cgen_var_93, 1);
    output->set_pipeline(cgen_var_93);
}

void from_proto_VkObjectTablePipelineEntryNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkObjectTablePipelineEntryNVX* input,
    VkObjectTablePipelineEntryNVX* output)
{
    memset(output, 0x0, sizeof(VkObjectTablePipelineEntryNVX));
    output->type = (VkObjectEntryTypeNVX)input->type();
    output->flags = (VkObjectEntryUsageFlagsNVX)input->flags();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->pipeline();
        handleMapping->mapHandles_u64_VkPipeline(&current, (VkPipeline*)&output->pipeline, 1);
    }
}

void to_proto_VkObjectTableDescriptorSetEntryNVX(
    VulkanHandleMapping* handleMapping,
    const VkObjectTableDescriptorSetEntryNVX* input,
    goldfish_vk_proto::VkObjectTableDescriptorSetEntryNVX* output)
{
    output->set_type((uint32_t)input->type);
    output->set_flags((uint32_t)input->flags);
    uint64_t cgen_var_94;
    handleMapping->mapHandles_VkPipelineLayout_u64(&input->pipelineLayout, &cgen_var_94, 1);
    output->set_pipelinelayout(cgen_var_94);
    uint64_t cgen_var_95;
    handleMapping->mapHandles_VkDescriptorSet_u64(&input->descriptorSet, &cgen_var_95, 1);
    output->set_descriptorset(cgen_var_95);
}

void from_proto_VkObjectTableDescriptorSetEntryNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkObjectTableDescriptorSetEntryNVX* input,
    VkObjectTableDescriptorSetEntryNVX* output)
{
    memset(output, 0x0, sizeof(VkObjectTableDescriptorSetEntryNVX));
    output->type = (VkObjectEntryTypeNVX)input->type();
    output->flags = (VkObjectEntryUsageFlagsNVX)input->flags();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->pipelinelayout();
        handleMapping->mapHandles_u64_VkPipelineLayout(&current, (VkPipelineLayout*)&output->pipelineLayout, 1);
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->descriptorset();
        handleMapping->mapHandles_u64_VkDescriptorSet(&current, (VkDescriptorSet*)&output->descriptorSet, 1);
    }
}

void to_proto_VkObjectTableVertexBufferEntryNVX(
    VulkanHandleMapping* handleMapping,
    const VkObjectTableVertexBufferEntryNVX* input,
    goldfish_vk_proto::VkObjectTableVertexBufferEntryNVX* output)
{
    output->set_type((uint32_t)input->type);
    output->set_flags((uint32_t)input->flags);
    uint64_t cgen_var_96;
    handleMapping->mapHandles_VkBuffer_u64(&input->buffer, &cgen_var_96, 1);
    output->set_buffer(cgen_var_96);
}

void from_proto_VkObjectTableVertexBufferEntryNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkObjectTableVertexBufferEntryNVX* input,
    VkObjectTableVertexBufferEntryNVX* output)
{
    memset(output, 0x0, sizeof(VkObjectTableVertexBufferEntryNVX));
    output->type = (VkObjectEntryTypeNVX)input->type();
    output->flags = (VkObjectEntryUsageFlagsNVX)input->flags();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->buffer();
        handleMapping->mapHandles_u64_VkBuffer(&current, (VkBuffer*)&output->buffer, 1);
    }
}

void to_proto_VkObjectTableIndexBufferEntryNVX(
    VulkanHandleMapping* handleMapping,
    const VkObjectTableIndexBufferEntryNVX* input,
    goldfish_vk_proto::VkObjectTableIndexBufferEntryNVX* output)
{
    output->set_type((uint32_t)input->type);
    output->set_flags((uint32_t)input->flags);
    uint64_t cgen_var_97;
    handleMapping->mapHandles_VkBuffer_u64(&input->buffer, &cgen_var_97, 1);
    output->set_buffer(cgen_var_97);
    output->set_indextype((uint32_t)input->indexType);
}

void from_proto_VkObjectTableIndexBufferEntryNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkObjectTableIndexBufferEntryNVX* input,
    VkObjectTableIndexBufferEntryNVX* output)
{
    memset(output, 0x0, sizeof(VkObjectTableIndexBufferEntryNVX));
    output->type = (VkObjectEntryTypeNVX)input->type();
    output->flags = (VkObjectEntryUsageFlagsNVX)input->flags();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->buffer();
        handleMapping->mapHandles_u64_VkBuffer(&current, (VkBuffer*)&output->buffer, 1);
    }
    output->indexType = (VkIndexType)input->indextype();
}

void to_proto_VkObjectTablePushConstantEntryNVX(
    VulkanHandleMapping* handleMapping,
    const VkObjectTablePushConstantEntryNVX* input,
    goldfish_vk_proto::VkObjectTablePushConstantEntryNVX* output)
{
    output->set_type((uint32_t)input->type);
    output->set_flags((uint32_t)input->flags);
    uint64_t cgen_var_98;
    handleMapping->mapHandles_VkPipelineLayout_u64(&input->pipelineLayout, &cgen_var_98, 1);
    output->set_pipelinelayout(cgen_var_98);
    output->set_stageflags((uint32_t)input->stageFlags);
}

void from_proto_VkObjectTablePushConstantEntryNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkObjectTablePushConstantEntryNVX* input,
    VkObjectTablePushConstantEntryNVX* output)
{
    memset(output, 0x0, sizeof(VkObjectTablePushConstantEntryNVX));
    output->type = (VkObjectEntryTypeNVX)input->type();
    output->flags = (VkObjectEntryUsageFlagsNVX)input->flags();
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->pipelinelayout();
        handleMapping->mapHandles_u64_VkPipelineLayout(&current, (VkPipelineLayout*)&output->pipelineLayout, 1);
    }
    output->stageFlags = (VkShaderStageFlags)input->stageflags();
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void to_proto_VkViewportWScalingNV(
    VulkanHandleMapping* handleMapping,
    const VkViewportWScalingNV* input,
    goldfish_vk_proto::VkViewportWScalingNV* output)
{
    output->set_xcoeff((float)input->xcoeff);
    output->set_ycoeff((float)input->ycoeff);
}

void from_proto_VkViewportWScalingNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkViewportWScalingNV* input,
    VkViewportWScalingNV* output)
{
    memset(output, 0x0, sizeof(VkViewportWScalingNV));
    output->xcoeff = (float)input->xcoeff();
    output->ycoeff = (float)input->ycoeff();
}

void to_proto_VkPipelineViewportWScalingStateCreateInfoNV(
    VulkanHandleMapping* handleMapping,
    const VkPipelineViewportWScalingStateCreateInfoNV* input,
    goldfish_vk_proto::VkPipelineViewportWScalingStateCreateInfoNV* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_viewportwscalingenable((uint32_t)input->viewportWScalingEnable);
    output->set_viewportcount((uint32_t)input->viewportCount);
    // WARNING PTR CHECK
    if (input->pViewportWScalings)
    {
        for (uint32_t i = 0; i < (uint32_t)input->viewportCount; ++i)
        {
            to_proto_VkViewportWScalingNV(handleMapping, input->pViewportWScalings + i, output->add_pviewportwscalings());
        }
    }
}

void from_proto_VkPipelineViewportWScalingStateCreateInfoNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineViewportWScalingStateCreateInfoNV* input,
    VkPipelineViewportWScalingStateCreateInfoNV* output)
{
    memset(output, 0x0, sizeof(VkPipelineViewportWScalingStateCreateInfoNV));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->viewportWScalingEnable = (VkBool32)input->viewportwscalingenable();
    output->viewportCount = (uint32_t)input->viewportcount();
    // WARNING PTR CHECK
    if (input->pviewportwscalings_size())
    {
        *(void**)&output->pViewportWScalings = pool->alloc(output->viewportCount * sizeof(const VkViewportWScalingNV));
        for (uint32_t i = 0; i < (uint32_t)output->viewportCount; ++i)
        {
            from_proto_VkViewportWScalingNV(pool, handleMapping, input->mutable_pviewportwscalings(i), (VkViewportWScalingNV*)(output->pViewportWScalings + i));
        }
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
#endif
#ifdef VK_EXT_acquire_xlib_display
#endif
#ifdef VK_EXT_display_surface_counter
void to_proto_VkSurfaceCapabilities2EXT(
    VulkanHandleMapping* handleMapping,
    const VkSurfaceCapabilities2EXT* input,
    goldfish_vk_proto::VkSurfaceCapabilities2EXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_minimagecount((uint32_t)input->minImageCount);
    output->set_maximagecount((uint32_t)input->maxImageCount);
    to_proto_VkExtent2D(handleMapping, &input->currentExtent, output->mutable_currentextent());
    to_proto_VkExtent2D(handleMapping, &input->minImageExtent, output->mutable_minimageextent());
    to_proto_VkExtent2D(handleMapping, &input->maxImageExtent, output->mutable_maximageextent());
    output->set_maximagearraylayers((uint32_t)input->maxImageArrayLayers);
    output->set_supportedtransforms((uint32_t)input->supportedTransforms);
    output->set_currenttransform((uint32_t)input->currentTransform);
    output->set_supportedcompositealpha((uint32_t)input->supportedCompositeAlpha);
    output->set_supportedusageflags((uint32_t)input->supportedUsageFlags);
    output->set_supportedsurfacecounters((uint32_t)input->supportedSurfaceCounters);
}

void from_proto_VkSurfaceCapabilities2EXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSurfaceCapabilities2EXT* input,
    VkSurfaceCapabilities2EXT* output)
{
    memset(output, 0x0, sizeof(VkSurfaceCapabilities2EXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->minImageCount = (uint32_t)input->minimagecount();
    output->maxImageCount = (uint32_t)input->maximagecount();
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_currentextent(), (VkExtent2D*)(&output->currentExtent));
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_minimageextent(), (VkExtent2D*)(&output->minImageExtent));
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_maximageextent(), (VkExtent2D*)(&output->maxImageExtent));
    output->maxImageArrayLayers = (uint32_t)input->maximagearraylayers();
    output->supportedTransforms = (VkSurfaceTransformFlagsKHR)input->supportedtransforms();
    output->currentTransform = (VkSurfaceTransformFlagBitsKHR)input->currenttransform();
    output->supportedCompositeAlpha = (VkCompositeAlphaFlagsKHR)input->supportedcompositealpha();
    output->supportedUsageFlags = (VkImageUsageFlags)input->supportedusageflags();
    output->supportedSurfaceCounters = (VkSurfaceCounterFlagsEXT)input->supportedsurfacecounters();
}

#endif
#ifdef VK_EXT_display_control
void to_proto_VkDisplayPowerInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkDisplayPowerInfoEXT* input,
    goldfish_vk_proto::VkDisplayPowerInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_powerstate((uint32_t)input->powerState);
}

void from_proto_VkDisplayPowerInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplayPowerInfoEXT* input,
    VkDisplayPowerInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkDisplayPowerInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->powerState = (VkDisplayPowerStateEXT)input->powerstate();
}

void to_proto_VkDeviceEventInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkDeviceEventInfoEXT* input,
    goldfish_vk_proto::VkDeviceEventInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_deviceevent((uint32_t)input->deviceEvent);
}

void from_proto_VkDeviceEventInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceEventInfoEXT* input,
    VkDeviceEventInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkDeviceEventInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->deviceEvent = (VkDeviceEventTypeEXT)input->deviceevent();
}

void to_proto_VkDisplayEventInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkDisplayEventInfoEXT* input,
    goldfish_vk_proto::VkDisplayEventInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_displayevent((uint32_t)input->displayEvent);
}

void from_proto_VkDisplayEventInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDisplayEventInfoEXT* input,
    VkDisplayEventInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkDisplayEventInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->displayEvent = (VkDisplayEventTypeEXT)input->displayevent();
}

void to_proto_VkSwapchainCounterCreateInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkSwapchainCounterCreateInfoEXT* input,
    goldfish_vk_proto::VkSwapchainCounterCreateInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_surfacecounters((uint32_t)input->surfaceCounters);
}

void from_proto_VkSwapchainCounterCreateInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSwapchainCounterCreateInfoEXT* input,
    VkSwapchainCounterCreateInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkSwapchainCounterCreateInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->surfaceCounters = (VkSurfaceCounterFlagsEXT)input->surfacecounters();
}

#endif
#ifdef VK_GOOGLE_display_timing
void to_proto_VkRefreshCycleDurationGOOGLE(
    VulkanHandleMapping* handleMapping,
    const VkRefreshCycleDurationGOOGLE* input,
    goldfish_vk_proto::VkRefreshCycleDurationGOOGLE* output)
{
    output->set_refreshduration((uint64_t)input->refreshDuration);
}

void from_proto_VkRefreshCycleDurationGOOGLE(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkRefreshCycleDurationGOOGLE* input,
    VkRefreshCycleDurationGOOGLE* output)
{
    memset(output, 0x0, sizeof(VkRefreshCycleDurationGOOGLE));
    output->refreshDuration = (uint64_t)input->refreshduration();
}

void to_proto_VkPastPresentationTimingGOOGLE(
    VulkanHandleMapping* handleMapping,
    const VkPastPresentationTimingGOOGLE* input,
    goldfish_vk_proto::VkPastPresentationTimingGOOGLE* output)
{
    output->set_presentid((uint32_t)input->presentID);
    output->set_desiredpresenttime((uint64_t)input->desiredPresentTime);
    output->set_actualpresenttime((uint64_t)input->actualPresentTime);
    output->set_earliestpresenttime((uint64_t)input->earliestPresentTime);
    output->set_presentmargin((uint64_t)input->presentMargin);
}

void from_proto_VkPastPresentationTimingGOOGLE(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPastPresentationTimingGOOGLE* input,
    VkPastPresentationTimingGOOGLE* output)
{
    memset(output, 0x0, sizeof(VkPastPresentationTimingGOOGLE));
    output->presentID = (uint32_t)input->presentid();
    output->desiredPresentTime = (uint64_t)input->desiredpresenttime();
    output->actualPresentTime = (uint64_t)input->actualpresenttime();
    output->earliestPresentTime = (uint64_t)input->earliestpresenttime();
    output->presentMargin = (uint64_t)input->presentmargin();
}

void to_proto_VkPresentTimeGOOGLE(
    VulkanHandleMapping* handleMapping,
    const VkPresentTimeGOOGLE* input,
    goldfish_vk_proto::VkPresentTimeGOOGLE* output)
{
    output->set_presentid((uint32_t)input->presentID);
    output->set_desiredpresenttime((uint64_t)input->desiredPresentTime);
}

void from_proto_VkPresentTimeGOOGLE(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPresentTimeGOOGLE* input,
    VkPresentTimeGOOGLE* output)
{
    memset(output, 0x0, sizeof(VkPresentTimeGOOGLE));
    output->presentID = (uint32_t)input->presentid();
    output->desiredPresentTime = (uint64_t)input->desiredpresenttime();
}

void to_proto_VkPresentTimesInfoGOOGLE(
    VulkanHandleMapping* handleMapping,
    const VkPresentTimesInfoGOOGLE* input,
    goldfish_vk_proto::VkPresentTimesInfoGOOGLE* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_swapchaincount((uint32_t)input->swapchainCount);
    // WARNING PTR CHECK
    if (input->pTimes)
    {
        for (uint32_t i = 0; i < (uint32_t)input->swapchainCount; ++i)
        {
            to_proto_VkPresentTimeGOOGLE(handleMapping, input->pTimes + i, output->add_ptimes());
        }
    }
}

void from_proto_VkPresentTimesInfoGOOGLE(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPresentTimesInfoGOOGLE* input,
    VkPresentTimesInfoGOOGLE* output)
{
    memset(output, 0x0, sizeof(VkPresentTimesInfoGOOGLE));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->swapchainCount = (uint32_t)input->swapchaincount();
    // WARNING PTR CHECK
    if (input->ptimes_size())
    {
        *(void**)&output->pTimes = pool->alloc(output->swapchainCount * sizeof(const VkPresentTimeGOOGLE));
        for (uint32_t i = 0; i < (uint32_t)output->swapchainCount; ++i)
        {
            from_proto_VkPresentTimeGOOGLE(pool, handleMapping, input->mutable_ptimes(i), (VkPresentTimeGOOGLE*)(output->pTimes + i));
        }
    }
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void to_proto_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* input,
    goldfish_vk_proto::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_perviewpositionallcomponents((uint32_t)input->perViewPositionAllComponents);
}

void from_proto_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* input,
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->perViewPositionAllComponents = (VkBool32)input->perviewpositionallcomponents();
}

#endif
#ifdef VK_NV_viewport_swizzle
void to_proto_VkViewportSwizzleNV(
    VulkanHandleMapping* handleMapping,
    const VkViewportSwizzleNV* input,
    goldfish_vk_proto::VkViewportSwizzleNV* output)
{
    output->set_x((uint32_t)input->x);
    output->set_y((uint32_t)input->y);
    output->set_z((uint32_t)input->z);
    output->set_w((uint32_t)input->w);
}

void from_proto_VkViewportSwizzleNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkViewportSwizzleNV* input,
    VkViewportSwizzleNV* output)
{
    memset(output, 0x0, sizeof(VkViewportSwizzleNV));
    output->x = (VkViewportCoordinateSwizzleNV)input->x();
    output->y = (VkViewportCoordinateSwizzleNV)input->y();
    output->z = (VkViewportCoordinateSwizzleNV)input->z();
    output->w = (VkViewportCoordinateSwizzleNV)input->w();
}

void to_proto_VkPipelineViewportSwizzleStateCreateInfoNV(
    VulkanHandleMapping* handleMapping,
    const VkPipelineViewportSwizzleStateCreateInfoNV* input,
    goldfish_vk_proto::VkPipelineViewportSwizzleStateCreateInfoNV* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_viewportcount((uint32_t)input->viewportCount);
    // WARNING PTR CHECK
    if (input->pViewportSwizzles)
    {
        for (uint32_t i = 0; i < (uint32_t)input->viewportCount; ++i)
        {
            to_proto_VkViewportSwizzleNV(handleMapping, input->pViewportSwizzles + i, output->add_pviewportswizzles());
        }
    }
}

void from_proto_VkPipelineViewportSwizzleStateCreateInfoNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineViewportSwizzleStateCreateInfoNV* input,
    VkPipelineViewportSwizzleStateCreateInfoNV* output)
{
    memset(output, 0x0, sizeof(VkPipelineViewportSwizzleStateCreateInfoNV));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineViewportSwizzleStateCreateFlagsNV)input->flags();
    output->viewportCount = (uint32_t)input->viewportcount();
    // WARNING PTR CHECK
    if (input->pviewportswizzles_size())
    {
        *(void**)&output->pViewportSwizzles = pool->alloc(output->viewportCount * sizeof(const VkViewportSwizzleNV));
        for (uint32_t i = 0; i < (uint32_t)output->viewportCount; ++i)
        {
            from_proto_VkViewportSwizzleNV(pool, handleMapping, input->mutable_pviewportswizzles(i), (VkViewportSwizzleNV*)(output->pViewportSwizzles + i));
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void to_proto_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT* input,
    goldfish_vk_proto::VkPhysicalDeviceDiscardRectanglePropertiesEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_maxdiscardrectangles((uint32_t)input->maxDiscardRectangles);
}

void from_proto_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceDiscardRectanglePropertiesEXT* input,
    VkPhysicalDeviceDiscardRectanglePropertiesEXT* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceDiscardRectanglePropertiesEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->maxDiscardRectangles = (uint32_t)input->maxdiscardrectangles();
}

void to_proto_VkPipelineDiscardRectangleStateCreateInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkPipelineDiscardRectangleStateCreateInfoEXT* input,
    goldfish_vk_proto::VkPipelineDiscardRectangleStateCreateInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_discardrectanglemode((uint32_t)input->discardRectangleMode);
    output->set_discardrectanglecount((uint32_t)input->discardRectangleCount);
    // WARNING PTR CHECK
    if (input->pDiscardRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)input->discardRectangleCount; ++i)
        {
            to_proto_VkRect2D(handleMapping, input->pDiscardRectangles + i, output->add_pdiscardrectangles());
        }
    }
}

void from_proto_VkPipelineDiscardRectangleStateCreateInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineDiscardRectangleStateCreateInfoEXT* input,
    VkPipelineDiscardRectangleStateCreateInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkPipelineDiscardRectangleStateCreateInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineDiscardRectangleStateCreateFlagsEXT)input->flags();
    output->discardRectangleMode = (VkDiscardRectangleModeEXT)input->discardrectanglemode();
    output->discardRectangleCount = (uint32_t)input->discardrectanglecount();
    // WARNING PTR CHECK
    if (input->pdiscardrectangles_size())
    {
        *(void**)&output->pDiscardRectangles = pool->alloc(output->discardRectangleCount * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)output->discardRectangleCount; ++i)
        {
            from_proto_VkRect2D(pool, handleMapping, input->mutable_pdiscardrectangles(i), (VkRect2D*)(output->pDiscardRectangles + i));
        }
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void to_proto_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* input,
    goldfish_vk_proto::VkPhysicalDeviceConservativeRasterizationPropertiesEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_primitiveoverestimationsize((float)input->primitiveOverestimationSize);
    output->set_maxextraprimitiveoverestimationsize((float)input->maxExtraPrimitiveOverestimationSize);
    output->set_extraprimitiveoverestimationsizegranularity((float)input->extraPrimitiveOverestimationSizeGranularity);
    output->set_primitiveunderestimation((uint32_t)input->primitiveUnderestimation);
    output->set_conservativepointandlinerasterization((uint32_t)input->conservativePointAndLineRasterization);
    output->set_degeneratetrianglesrasterized((uint32_t)input->degenerateTrianglesRasterized);
    output->set_degeneratelinesrasterized((uint32_t)input->degenerateLinesRasterized);
    output->set_fullycoveredfragmentshaderinputvariable((uint32_t)input->fullyCoveredFragmentShaderInputVariable);
    output->set_conservativerasterizationpostdepthcoverage((uint32_t)input->conservativeRasterizationPostDepthCoverage);
}

void from_proto_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceConservativeRasterizationPropertiesEXT* input,
    VkPhysicalDeviceConservativeRasterizationPropertiesEXT* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->primitiveOverestimationSize = (float)input->primitiveoverestimationsize();
    output->maxExtraPrimitiveOverestimationSize = (float)input->maxextraprimitiveoverestimationsize();
    output->extraPrimitiveOverestimationSizeGranularity = (float)input->extraprimitiveoverestimationsizegranularity();
    output->primitiveUnderestimation = (VkBool32)input->primitiveunderestimation();
    output->conservativePointAndLineRasterization = (VkBool32)input->conservativepointandlinerasterization();
    output->degenerateTrianglesRasterized = (VkBool32)input->degeneratetrianglesrasterized();
    output->degenerateLinesRasterized = (VkBool32)input->degeneratelinesrasterized();
    output->fullyCoveredFragmentShaderInputVariable = (VkBool32)input->fullycoveredfragmentshaderinputvariable();
    output->conservativeRasterizationPostDepthCoverage = (VkBool32)input->conservativerasterizationpostdepthcoverage();
}

void to_proto_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* input,
    goldfish_vk_proto::VkPipelineRasterizationConservativeStateCreateInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_conservativerasterizationmode((uint32_t)input->conservativeRasterizationMode);
    output->set_extraprimitiveoverestimationsize((float)input->extraPrimitiveOverestimationSize);
}

void from_proto_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineRasterizationConservativeStateCreateInfoEXT* input,
    VkPipelineRasterizationConservativeStateCreateInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkPipelineRasterizationConservativeStateCreateInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineRasterizationConservativeStateCreateFlagsEXT)input->flags();
    output->conservativeRasterizationMode = (VkConservativeRasterizationModeEXT)input->conservativerasterizationmode();
    output->extraPrimitiveOverestimationSize = (float)input->extraprimitiveoverestimationsize();
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void to_proto_VkXYColorEXT(
    VulkanHandleMapping* handleMapping,
    const VkXYColorEXT* input,
    goldfish_vk_proto::VkXYColorEXT* output)
{
    output->set_x((float)input->x);
    output->set_y((float)input->y);
}

void from_proto_VkXYColorEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkXYColorEXT* input,
    VkXYColorEXT* output)
{
    memset(output, 0x0, sizeof(VkXYColorEXT));
    output->x = (float)input->x();
    output->y = (float)input->y();
}

void to_proto_VkHdrMetadataEXT(
    VulkanHandleMapping* handleMapping,
    const VkHdrMetadataEXT* input,
    goldfish_vk_proto::VkHdrMetadataEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkXYColorEXT(handleMapping, &input->displayPrimaryRed, output->mutable_displayprimaryred());
    to_proto_VkXYColorEXT(handleMapping, &input->displayPrimaryGreen, output->mutable_displayprimarygreen());
    to_proto_VkXYColorEXT(handleMapping, &input->displayPrimaryBlue, output->mutable_displayprimaryblue());
    to_proto_VkXYColorEXT(handleMapping, &input->whitePoint, output->mutable_whitepoint());
    output->set_maxluminance((float)input->maxLuminance);
    output->set_minluminance((float)input->minLuminance);
    output->set_maxcontentlightlevel((float)input->maxContentLightLevel);
    output->set_maxframeaveragelightlevel((float)input->maxFrameAverageLightLevel);
}

void from_proto_VkHdrMetadataEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkHdrMetadataEXT* input,
    VkHdrMetadataEXT* output)
{
    memset(output, 0x0, sizeof(VkHdrMetadataEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkXYColorEXT(pool, handleMapping, input->mutable_displayprimaryred(), (VkXYColorEXT*)(&output->displayPrimaryRed));
    from_proto_VkXYColorEXT(pool, handleMapping, input->mutable_displayprimarygreen(), (VkXYColorEXT*)(&output->displayPrimaryGreen));
    from_proto_VkXYColorEXT(pool, handleMapping, input->mutable_displayprimaryblue(), (VkXYColorEXT*)(&output->displayPrimaryBlue));
    from_proto_VkXYColorEXT(pool, handleMapping, input->mutable_whitepoint(), (VkXYColorEXT*)(&output->whitePoint));
    output->maxLuminance = (float)input->maxluminance();
    output->minLuminance = (float)input->minluminance();
    output->maxContentLightLevel = (float)input->maxcontentlightlevel();
    output->maxFrameAverageLightLevel = (float)input->maxframeaveragelightlevel();
}

#endif
#ifdef VK_MVK_ios_surface
void to_proto_VkIOSSurfaceCreateInfoMVK(
    VulkanHandleMapping* handleMapping,
    const VkIOSSurfaceCreateInfoMVK* input,
    goldfish_vk_proto::VkIOSSurfaceCreateInfoMVK* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    // WARNING PTR CHECK
    if (input->pView)
    {
        output->set_pview((uint64_t)(uintptr_t)input->pView);
    }
}

void from_proto_VkIOSSurfaceCreateInfoMVK(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkIOSSurfaceCreateInfoMVK* input,
    VkIOSSurfaceCreateInfoMVK* output)
{
    memset(output, 0x0, sizeof(VkIOSSurfaceCreateInfoMVK));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkIOSSurfaceCreateFlagsMVK)input->flags();
    // WARNING PTR CHECK
    if (input->has_pview())
    {
        output->pView = (void*)(uintptr_t)input->pview();
    }
}

#endif
#ifdef VK_MVK_macos_surface
void to_proto_VkMacOSSurfaceCreateInfoMVK(
    VulkanHandleMapping* handleMapping,
    const VkMacOSSurfaceCreateInfoMVK* input,
    goldfish_vk_proto::VkMacOSSurfaceCreateInfoMVK* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    // WARNING PTR CHECK
    if (input->pView)
    {
        output->set_pview((uint64_t)(uintptr_t)input->pView);
    }
}

void from_proto_VkMacOSSurfaceCreateInfoMVK(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMacOSSurfaceCreateInfoMVK* input,
    VkMacOSSurfaceCreateInfoMVK* output)
{
    memset(output, 0x0, sizeof(VkMacOSSurfaceCreateInfoMVK));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkMacOSSurfaceCreateFlagsMVK)input->flags();
    // WARNING PTR CHECK
    if (input->has_pview())
    {
        output->pView = (void*)(uintptr_t)input->pview();
    }
}

#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void to_proto_VkDebugUtilsObjectNameInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkDebugUtilsObjectNameInfoEXT* input,
    goldfish_vk_proto::VkDebugUtilsObjectNameInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_objecttype((uint32_t)input->objectType);
    output->set_objecthandle((uint64_t)input->objectHandle);
    output->set_pobjectname(input->pObjectName);
}

void from_proto_VkDebugUtilsObjectNameInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDebugUtilsObjectNameInfoEXT* input,
    VkDebugUtilsObjectNameInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkDebugUtilsObjectNameInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->objectType = (VkObjectType)input->objecttype();
    output->objectHandle = (uint64_t)input->objecthandle();
    *(const char**)(&output->pObjectName) = input->pobjectname().c_str();
}

void to_proto_VkDebugUtilsObjectTagInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkDebugUtilsObjectTagInfoEXT* input,
    goldfish_vk_proto::VkDebugUtilsObjectTagInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_objecttype((uint32_t)input->objectType);
    output->set_objecthandle((uint64_t)input->objectHandle);
    output->set_tagname((uint64_t)input->tagName);
    output->set_tagsize((uint64_t)input->tagSize);
    for (uint32_t i = 0; i < (uint32_t)input->tagSize; ++i)
    {
        output->add_ptag(((const char*)(input->pTag))[i]);
    }
}

void from_proto_VkDebugUtilsObjectTagInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDebugUtilsObjectTagInfoEXT* input,
    VkDebugUtilsObjectTagInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkDebugUtilsObjectTagInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->objectType = (VkObjectType)input->objecttype();
    output->objectHandle = (uint64_t)input->objecthandle();
    output->tagName = (uint64_t)input->tagname();
    output->tagSize = (size_t)input->tagsize();
    for (uint32_t i = 0; i < (uint32_t)output->tagSize; ++i)
    {
        *((char*)(&output->pTag) + i) = (char)input->ptag(i);
    }
}

void to_proto_VkDebugUtilsLabelEXT(
    VulkanHandleMapping* handleMapping,
    const VkDebugUtilsLabelEXT* input,
    goldfish_vk_proto::VkDebugUtilsLabelEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_plabelname(input->pLabelName);
    for (uint32_t i = 0; i < (uint32_t)4; ++i)
    {
        output->add_color(input->color[i]);
    }
}

void from_proto_VkDebugUtilsLabelEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDebugUtilsLabelEXT* input,
    VkDebugUtilsLabelEXT* output)
{
    memset(output, 0x0, sizeof(VkDebugUtilsLabelEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    *(const char**)(&output->pLabelName) = input->plabelname().c_str();
    for (uint32_t i = 0; i < (uint32_t)4; ++i)
    {
        output->color[i] = (float)input->color(i);
    }
}

void to_proto_VkDebugUtilsMessengerCallbackDataEXT(
    VulkanHandleMapping* handleMapping,
    const VkDebugUtilsMessengerCallbackDataEXT* input,
    goldfish_vk_proto::VkDebugUtilsMessengerCallbackDataEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_pmessageidname(input->pMessageIdName);
    output->set_messageidnumber((int32_t)input->messageIdNumber);
    output->set_pmessage(input->pMessage);
    output->set_queuelabelcount((uint32_t)input->queueLabelCount);
    // WARNING PTR CHECK
    if (input->pQueueLabels)
    {
        for (uint32_t i = 0; i < (uint32_t)input->queueLabelCount; ++i)
        {
            to_proto_VkDebugUtilsLabelEXT(handleMapping, input->pQueueLabels + i, output->add_pqueuelabels());
        }
    }
    output->set_cmdbuflabelcount((uint32_t)input->cmdBufLabelCount);
    // WARNING PTR CHECK
    if (input->pCmdBufLabels)
    {
        for (uint32_t i = 0; i < (uint32_t)input->cmdBufLabelCount; ++i)
        {
            to_proto_VkDebugUtilsLabelEXT(handleMapping, input->pCmdBufLabels + i, output->add_pcmdbuflabels());
        }
    }
    output->set_objectcount((uint32_t)input->objectCount);
    // WARNING PTR CHECK
    if (input->pObjects)
    {
        for (uint32_t i = 0; i < (uint32_t)input->objectCount; ++i)
        {
            to_proto_VkDebugUtilsObjectNameInfoEXT(handleMapping, input->pObjects + i, output->add_pobjects());
        }
    }
}

void from_proto_VkDebugUtilsMessengerCallbackDataEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDebugUtilsMessengerCallbackDataEXT* input,
    VkDebugUtilsMessengerCallbackDataEXT* output)
{
    memset(output, 0x0, sizeof(VkDebugUtilsMessengerCallbackDataEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkDebugUtilsMessengerCallbackDataFlagsEXT)input->flags();
    *(const char**)(&output->pMessageIdName) = input->pmessageidname().c_str();
    output->messageIdNumber = (int32_t)input->messageidnumber();
    *(const char**)(&output->pMessage) = input->pmessage().c_str();
    output->queueLabelCount = (uint32_t)input->queuelabelcount();
    // WARNING PTR CHECK
    if (input->pqueuelabels_size())
    {
        *(void**)&output->pQueueLabels = pool->alloc(output->queueLabelCount * sizeof(VkDebugUtilsLabelEXT));
        for (uint32_t i = 0; i < (uint32_t)output->queueLabelCount; ++i)
        {
            from_proto_VkDebugUtilsLabelEXT(pool, handleMapping, input->mutable_pqueuelabels(i), (VkDebugUtilsLabelEXT*)(output->pQueueLabels + i));
        }
    }
    output->cmdBufLabelCount = (uint32_t)input->cmdbuflabelcount();
    // WARNING PTR CHECK
    if (input->pcmdbuflabels_size())
    {
        *(void**)&output->pCmdBufLabels = pool->alloc(output->cmdBufLabelCount * sizeof(VkDebugUtilsLabelEXT));
        for (uint32_t i = 0; i < (uint32_t)output->cmdBufLabelCount; ++i)
        {
            from_proto_VkDebugUtilsLabelEXT(pool, handleMapping, input->mutable_pcmdbuflabels(i), (VkDebugUtilsLabelEXT*)(output->pCmdBufLabels + i));
        }
    }
    output->objectCount = (uint32_t)input->objectcount();
    // WARNING PTR CHECK
    if (input->pobjects_size())
    {
        *(void**)&output->pObjects = pool->alloc(output->objectCount * sizeof(VkDebugUtilsObjectNameInfoEXT));
        for (uint32_t i = 0; i < (uint32_t)output->objectCount; ++i)
        {
            from_proto_VkDebugUtilsObjectNameInfoEXT(pool, handleMapping, input->mutable_pobjects(i), (VkDebugUtilsObjectNameInfoEXT*)(output->pObjects + i));
        }
    }
}

void to_proto_VkDebugUtilsMessengerCreateInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkDebugUtilsMessengerCreateInfoEXT* input,
    goldfish_vk_proto::VkDebugUtilsMessengerCreateInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_messageseverity((uint32_t)input->messageSeverity);
    output->set_messagetype((uint32_t)input->messageType);
    output->set_pfnusercallback((uint64_t)input->pfnUserCallback);
    // WARNING PTR CHECK
    if (input->pUserData)
    {
        output->set_puserdata((uint64_t)(uintptr_t)input->pUserData);
    }
}

void from_proto_VkDebugUtilsMessengerCreateInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDebugUtilsMessengerCreateInfoEXT* input,
    VkDebugUtilsMessengerCreateInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkDebugUtilsMessengerCreateInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkDebugUtilsMessengerCreateFlagsEXT)input->flags();
    output->messageSeverity = (VkDebugUtilsMessageSeverityFlagsEXT)input->messageseverity();
    output->messageType = (VkDebugUtilsMessageTypeFlagsEXT)input->messagetype();
    output->pfnUserCallback = (PFN_vkDebugUtilsMessengerCallbackEXT)input->pfnusercallback();
    // WARNING PTR CHECK
    if (input->has_puserdata())
    {
        output->pUserData = (void*)(uintptr_t)input->puserdata();
    }
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void to_proto_VkAndroidHardwareBufferUsageANDROID(
    VulkanHandleMapping* handleMapping,
    const VkAndroidHardwareBufferUsageANDROID* input,
    goldfish_vk_proto::VkAndroidHardwareBufferUsageANDROID* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_androidhardwarebufferusage((uint64_t)input->androidHardwareBufferUsage);
}

void from_proto_VkAndroidHardwareBufferUsageANDROID(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkAndroidHardwareBufferUsageANDROID* input,
    VkAndroidHardwareBufferUsageANDROID* output)
{
    memset(output, 0x0, sizeof(VkAndroidHardwareBufferUsageANDROID));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->androidHardwareBufferUsage = (uint64_t)input->androidhardwarebufferusage();
}

void to_proto_VkAndroidHardwareBufferPropertiesANDROID(
    VulkanHandleMapping* handleMapping,
    const VkAndroidHardwareBufferPropertiesANDROID* input,
    goldfish_vk_proto::VkAndroidHardwareBufferPropertiesANDROID* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_allocationsize((uint64_t)input->allocationSize);
    output->set_memorytypebits((uint32_t)input->memoryTypeBits);
}

void from_proto_VkAndroidHardwareBufferPropertiesANDROID(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkAndroidHardwareBufferPropertiesANDROID* input,
    VkAndroidHardwareBufferPropertiesANDROID* output)
{
    memset(output, 0x0, sizeof(VkAndroidHardwareBufferPropertiesANDROID));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->allocationSize = (VkDeviceSize)input->allocationsize();
    output->memoryTypeBits = (uint32_t)input->memorytypebits();
}

void to_proto_VkAndroidHardwareBufferFormatPropertiesANDROID(
    VulkanHandleMapping* handleMapping,
    const VkAndroidHardwareBufferFormatPropertiesANDROID* input,
    goldfish_vk_proto::VkAndroidHardwareBufferFormatPropertiesANDROID* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_format((uint32_t)input->format);
    output->set_externalformat((uint64_t)input->externalFormat);
    output->set_formatfeatures((uint32_t)input->formatFeatures);
    to_proto_VkComponentMapping(handleMapping, &input->samplerYcbcrConversionComponents, output->mutable_samplerycbcrconversioncomponents());
    output->set_suggestedycbcrmodel((uint32_t)input->suggestedYcbcrModel);
    output->set_suggestedycbcrrange((uint32_t)input->suggestedYcbcrRange);
    output->set_suggestedxchromaoffset((uint32_t)input->suggestedXChromaOffset);
    output->set_suggestedychromaoffset((uint32_t)input->suggestedYChromaOffset);
}

void from_proto_VkAndroidHardwareBufferFormatPropertiesANDROID(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkAndroidHardwareBufferFormatPropertiesANDROID* input,
    VkAndroidHardwareBufferFormatPropertiesANDROID* output)
{
    memset(output, 0x0, sizeof(VkAndroidHardwareBufferFormatPropertiesANDROID));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->format = (VkFormat)input->format();
    output->externalFormat = (uint64_t)input->externalformat();
    output->formatFeatures = (VkFormatFeatureFlags)input->formatfeatures();
    from_proto_VkComponentMapping(pool, handleMapping, input->mutable_samplerycbcrconversioncomponents(), (VkComponentMapping*)(&output->samplerYcbcrConversionComponents));
    output->suggestedYcbcrModel = (VkSamplerYcbcrModelConversion)input->suggestedycbcrmodel();
    output->suggestedYcbcrRange = (VkSamplerYcbcrRange)input->suggestedycbcrrange();
    output->suggestedXChromaOffset = (VkChromaLocation)input->suggestedxchromaoffset();
    output->suggestedYChromaOffset = (VkChromaLocation)input->suggestedychromaoffset();
}

void to_proto_VkImportAndroidHardwareBufferInfoANDROID(
    VulkanHandleMapping* handleMapping,
    const VkImportAndroidHardwareBufferInfoANDROID* input,
    goldfish_vk_proto::VkImportAndroidHardwareBufferInfoANDROID* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_buffer((uint64_t)(uintptr_t)input->buffer);
}

void from_proto_VkImportAndroidHardwareBufferInfoANDROID(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImportAndroidHardwareBufferInfoANDROID* input,
    VkImportAndroidHardwareBufferInfoANDROID* output)
{
    memset(output, 0x0, sizeof(VkImportAndroidHardwareBufferInfoANDROID));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->buffer = (AHardwareBuffer*)(uintptr_t)input->buffer();
}

void to_proto_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    VulkanHandleMapping* handleMapping,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* input,
    goldfish_vk_proto::VkMemoryGetAndroidHardwareBufferInfoANDROID* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_99;
    handleMapping->mapHandles_VkDeviceMemory_u64(&input->memory, &cgen_var_99, 1);
    output->set_memory(cgen_var_99);
}

void from_proto_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryGetAndroidHardwareBufferInfoANDROID* input,
    VkMemoryGetAndroidHardwareBufferInfoANDROID* output)
{
    memset(output, 0x0, sizeof(VkMemoryGetAndroidHardwareBufferInfoANDROID));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->memory();
        handleMapping->mapHandles_u64_VkDeviceMemory(&current, (VkDeviceMemory*)&output->memory, 1);
    }
}

void to_proto_VkExternalFormatANDROID(
    VulkanHandleMapping* handleMapping,
    const VkExternalFormatANDROID* input,
    goldfish_vk_proto::VkExternalFormatANDROID* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_externalformat((uint64_t)input->externalFormat);
}

void from_proto_VkExternalFormatANDROID(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkExternalFormatANDROID* input,
    VkExternalFormatANDROID* output)
{
    memset(output, 0x0, sizeof(VkExternalFormatANDROID));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->externalFormat = (uint64_t)input->externalformat();
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
void to_proto_VkSamplerReductionModeCreateInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkSamplerReductionModeCreateInfoEXT* input,
    goldfish_vk_proto::VkSamplerReductionModeCreateInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_reductionmode((uint32_t)input->reductionMode);
}

void from_proto_VkSamplerReductionModeCreateInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSamplerReductionModeCreateInfoEXT* input,
    VkSamplerReductionModeCreateInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkSamplerReductionModeCreateInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->reductionMode = (VkSamplerReductionModeEXT)input->reductionmode();
}

void to_proto_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* input,
    goldfish_vk_proto::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_filterminmaxsinglecomponentformats((uint32_t)input->filterMinmaxSingleComponentFormats);
    output->set_filterminmaximagecomponentmapping((uint32_t)input->filterMinmaxImageComponentMapping);
}

void from_proto_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* input,
    VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->filterMinmaxSingleComponentFormats = (VkBool32)input->filterminmaxsinglecomponentformats();
    output->filterMinmaxImageComponentMapping = (VkBool32)input->filterminmaximagecomponentmapping();
}

#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void to_proto_VkSampleLocationEXT(
    VulkanHandleMapping* handleMapping,
    const VkSampleLocationEXT* input,
    goldfish_vk_proto::VkSampleLocationEXT* output)
{
    output->set_x((float)input->x);
    output->set_y((float)input->y);
}

void from_proto_VkSampleLocationEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSampleLocationEXT* input,
    VkSampleLocationEXT* output)
{
    memset(output, 0x0, sizeof(VkSampleLocationEXT));
    output->x = (float)input->x();
    output->y = (float)input->y();
}

void to_proto_VkSampleLocationsInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkSampleLocationsInfoEXT* input,
    goldfish_vk_proto::VkSampleLocationsInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_samplelocationsperpixel((uint32_t)input->sampleLocationsPerPixel);
    to_proto_VkExtent2D(handleMapping, &input->sampleLocationGridSize, output->mutable_samplelocationgridsize());
    output->set_samplelocationscount((uint32_t)input->sampleLocationsCount);
    for (uint32_t i = 0; i < (uint32_t)input->sampleLocationsCount; ++i)
    {
        to_proto_VkSampleLocationEXT(handleMapping, input->pSampleLocations + i, output->add_psamplelocations());
    }
}

void from_proto_VkSampleLocationsInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSampleLocationsInfoEXT* input,
    VkSampleLocationsInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkSampleLocationsInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->sampleLocationsPerPixel = (VkSampleCountFlagBits)input->samplelocationsperpixel();
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_samplelocationgridsize(), (VkExtent2D*)(&output->sampleLocationGridSize));
    output->sampleLocationsCount = (uint32_t)input->samplelocationscount();
    *(void**)&output->pSampleLocations = pool->alloc(output->sampleLocationsCount * sizeof(const VkSampleLocationEXT));
    for (uint32_t i = 0; i < (uint32_t)output->sampleLocationsCount; ++i)
    {
        from_proto_VkSampleLocationEXT(pool, handleMapping, input->mutable_psamplelocations(i), (VkSampleLocationEXT*)(output->pSampleLocations + i));
    }
}

void to_proto_VkAttachmentSampleLocationsEXT(
    VulkanHandleMapping* handleMapping,
    const VkAttachmentSampleLocationsEXT* input,
    goldfish_vk_proto::VkAttachmentSampleLocationsEXT* output)
{
    output->set_attachmentindex((uint32_t)input->attachmentIndex);
    to_proto_VkSampleLocationsInfoEXT(handleMapping, &input->sampleLocationsInfo, output->mutable_samplelocationsinfo());
}

void from_proto_VkAttachmentSampleLocationsEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkAttachmentSampleLocationsEXT* input,
    VkAttachmentSampleLocationsEXT* output)
{
    memset(output, 0x0, sizeof(VkAttachmentSampleLocationsEXT));
    output->attachmentIndex = (uint32_t)input->attachmentindex();
    from_proto_VkSampleLocationsInfoEXT(pool, handleMapping, input->mutable_samplelocationsinfo(), (VkSampleLocationsInfoEXT*)(&output->sampleLocationsInfo));
}

void to_proto_VkSubpassSampleLocationsEXT(
    VulkanHandleMapping* handleMapping,
    const VkSubpassSampleLocationsEXT* input,
    goldfish_vk_proto::VkSubpassSampleLocationsEXT* output)
{
    output->set_subpassindex((uint32_t)input->subpassIndex);
    to_proto_VkSampleLocationsInfoEXT(handleMapping, &input->sampleLocationsInfo, output->mutable_samplelocationsinfo());
}

void from_proto_VkSubpassSampleLocationsEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkSubpassSampleLocationsEXT* input,
    VkSubpassSampleLocationsEXT* output)
{
    memset(output, 0x0, sizeof(VkSubpassSampleLocationsEXT));
    output->subpassIndex = (uint32_t)input->subpassindex();
    from_proto_VkSampleLocationsInfoEXT(pool, handleMapping, input->mutable_samplelocationsinfo(), (VkSampleLocationsInfoEXT*)(&output->sampleLocationsInfo));
}

void to_proto_VkRenderPassSampleLocationsBeginInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkRenderPassSampleLocationsBeginInfoEXT* input,
    goldfish_vk_proto::VkRenderPassSampleLocationsBeginInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_attachmentinitialsamplelocationscount((uint32_t)input->attachmentInitialSampleLocationsCount);
    for (uint32_t i = 0; i < (uint32_t)input->attachmentInitialSampleLocationsCount; ++i)
    {
        to_proto_VkAttachmentSampleLocationsEXT(handleMapping, input->pAttachmentInitialSampleLocations + i, output->add_pattachmentinitialsamplelocations());
    }
    output->set_postsubpasssamplelocationscount((uint32_t)input->postSubpassSampleLocationsCount);
    for (uint32_t i = 0; i < (uint32_t)input->postSubpassSampleLocationsCount; ++i)
    {
        to_proto_VkSubpassSampleLocationsEXT(handleMapping, input->pPostSubpassSampleLocations + i, output->add_ppostsubpasssamplelocations());
    }
}

void from_proto_VkRenderPassSampleLocationsBeginInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkRenderPassSampleLocationsBeginInfoEXT* input,
    VkRenderPassSampleLocationsBeginInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkRenderPassSampleLocationsBeginInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->attachmentInitialSampleLocationsCount = (uint32_t)input->attachmentinitialsamplelocationscount();
    *(void**)&output->pAttachmentInitialSampleLocations = pool->alloc(output->attachmentInitialSampleLocationsCount * sizeof(const VkAttachmentSampleLocationsEXT));
    for (uint32_t i = 0; i < (uint32_t)output->attachmentInitialSampleLocationsCount; ++i)
    {
        from_proto_VkAttachmentSampleLocationsEXT(pool, handleMapping, input->mutable_pattachmentinitialsamplelocations(i), (VkAttachmentSampleLocationsEXT*)(output->pAttachmentInitialSampleLocations + i));
    }
    output->postSubpassSampleLocationsCount = (uint32_t)input->postsubpasssamplelocationscount();
    *(void**)&output->pPostSubpassSampleLocations = pool->alloc(output->postSubpassSampleLocationsCount * sizeof(const VkSubpassSampleLocationsEXT));
    for (uint32_t i = 0; i < (uint32_t)output->postSubpassSampleLocationsCount; ++i)
    {
        from_proto_VkSubpassSampleLocationsEXT(pool, handleMapping, input->mutable_ppostsubpasssamplelocations(i), (VkSubpassSampleLocationsEXT*)(output->pPostSubpassSampleLocations + i));
    }
}

void to_proto_VkPipelineSampleLocationsStateCreateInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkPipelineSampleLocationsStateCreateInfoEXT* input,
    goldfish_vk_proto::VkPipelineSampleLocationsStateCreateInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_samplelocationsenable((uint32_t)input->sampleLocationsEnable);
    to_proto_VkSampleLocationsInfoEXT(handleMapping, &input->sampleLocationsInfo, output->mutable_samplelocationsinfo());
}

void from_proto_VkPipelineSampleLocationsStateCreateInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineSampleLocationsStateCreateInfoEXT* input,
    VkPipelineSampleLocationsStateCreateInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkPipelineSampleLocationsStateCreateInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->sampleLocationsEnable = (VkBool32)input->samplelocationsenable();
    from_proto_VkSampleLocationsInfoEXT(pool, handleMapping, input->mutable_samplelocationsinfo(), (VkSampleLocationsInfoEXT*)(&output->sampleLocationsInfo));
}

void to_proto_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceSampleLocationsPropertiesEXT* input,
    goldfish_vk_proto::VkPhysicalDeviceSampleLocationsPropertiesEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_samplelocationsamplecounts((uint32_t)input->sampleLocationSampleCounts);
    to_proto_VkExtent2D(handleMapping, &input->maxSampleLocationGridSize, output->mutable_maxsamplelocationgridsize());
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        output->add_samplelocationcoordinaterange(input->sampleLocationCoordinateRange[i]);
    }
    output->set_samplelocationsubpixelbits((uint32_t)input->sampleLocationSubPixelBits);
    output->set_variablesamplelocations((uint32_t)input->variableSampleLocations);
}

void from_proto_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceSampleLocationsPropertiesEXT* input,
    VkPhysicalDeviceSampleLocationsPropertiesEXT* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceSampleLocationsPropertiesEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->sampleLocationSampleCounts = (VkSampleCountFlags)input->samplelocationsamplecounts();
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_maxsamplelocationgridsize(), (VkExtent2D*)(&output->maxSampleLocationGridSize));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        output->sampleLocationCoordinateRange[i] = (float)input->samplelocationcoordinaterange(i);
    }
    output->sampleLocationSubPixelBits = (uint32_t)input->samplelocationsubpixelbits();
    output->variableSampleLocations = (VkBool32)input->variablesamplelocations();
}

void to_proto_VkMultisamplePropertiesEXT(
    VulkanHandleMapping* handleMapping,
    const VkMultisamplePropertiesEXT* input,
    goldfish_vk_proto::VkMultisamplePropertiesEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    to_proto_VkExtent2D(handleMapping, &input->maxSampleLocationGridSize, output->mutable_maxsamplelocationgridsize());
}

void from_proto_VkMultisamplePropertiesEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMultisamplePropertiesEXT* input,
    VkMultisamplePropertiesEXT* output)
{
    memset(output, 0x0, sizeof(VkMultisamplePropertiesEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    from_proto_VkExtent2D(pool, handleMapping, input->mutable_maxsamplelocationgridsize(), (VkExtent2D*)(&output->maxSampleLocationGridSize));
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void to_proto_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* input,
    goldfish_vk_proto::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_advancedblendcoherentoperations((uint32_t)input->advancedBlendCoherentOperations);
}

void from_proto_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* input,
    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->advancedBlendCoherentOperations = (VkBool32)input->advancedblendcoherentoperations();
}

void to_proto_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* input,
    goldfish_vk_proto::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_advancedblendmaxcolorattachments((uint32_t)input->advancedBlendMaxColorAttachments);
    output->set_advancedblendindependentblend((uint32_t)input->advancedBlendIndependentBlend);
    output->set_advancedblendnonpremultipliedsrccolor((uint32_t)input->advancedBlendNonPremultipliedSrcColor);
    output->set_advancedblendnonpremultiplieddstcolor((uint32_t)input->advancedBlendNonPremultipliedDstColor);
    output->set_advancedblendcorrelatedoverlap((uint32_t)input->advancedBlendCorrelatedOverlap);
    output->set_advancedblendalloperations((uint32_t)input->advancedBlendAllOperations);
}

void from_proto_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* input,
    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->advancedBlendMaxColorAttachments = (uint32_t)input->advancedblendmaxcolorattachments();
    output->advancedBlendIndependentBlend = (VkBool32)input->advancedblendindependentblend();
    output->advancedBlendNonPremultipliedSrcColor = (VkBool32)input->advancedblendnonpremultipliedsrccolor();
    output->advancedBlendNonPremultipliedDstColor = (VkBool32)input->advancedblendnonpremultiplieddstcolor();
    output->advancedBlendCorrelatedOverlap = (VkBool32)input->advancedblendcorrelatedoverlap();
    output->advancedBlendAllOperations = (VkBool32)input->advancedblendalloperations();
}

void to_proto_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT* input,
    goldfish_vk_proto::VkPipelineColorBlendAdvancedStateCreateInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_srcpremultiplied((uint32_t)input->srcPremultiplied);
    output->set_dstpremultiplied((uint32_t)input->dstPremultiplied);
    output->set_blendoverlap((uint32_t)input->blendOverlap);
}

void from_proto_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineColorBlendAdvancedStateCreateInfoEXT* input,
    VkPipelineColorBlendAdvancedStateCreateInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkPipelineColorBlendAdvancedStateCreateInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->srcPremultiplied = (VkBool32)input->srcpremultiplied();
    output->dstPremultiplied = (VkBool32)input->dstpremultiplied();
    output->blendOverlap = (VkBlendOverlapEXT)input->blendoverlap();
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void to_proto_VkPipelineCoverageToColorStateCreateInfoNV(
    VulkanHandleMapping* handleMapping,
    const VkPipelineCoverageToColorStateCreateInfoNV* input,
    goldfish_vk_proto::VkPipelineCoverageToColorStateCreateInfoNV* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_coveragetocolorenable((uint32_t)input->coverageToColorEnable);
    output->set_coveragetocolorlocation((uint32_t)input->coverageToColorLocation);
}

void from_proto_VkPipelineCoverageToColorStateCreateInfoNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineCoverageToColorStateCreateInfoNV* input,
    VkPipelineCoverageToColorStateCreateInfoNV* output)
{
    memset(output, 0x0, sizeof(VkPipelineCoverageToColorStateCreateInfoNV));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineCoverageToColorStateCreateFlagsNV)input->flags();
    output->coverageToColorEnable = (VkBool32)input->coveragetocolorenable();
    output->coverageToColorLocation = (uint32_t)input->coveragetocolorlocation();
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void to_proto_VkPipelineCoverageModulationStateCreateInfoNV(
    VulkanHandleMapping* handleMapping,
    const VkPipelineCoverageModulationStateCreateInfoNV* input,
    goldfish_vk_proto::VkPipelineCoverageModulationStateCreateInfoNV* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_coveragemodulationmode((uint32_t)input->coverageModulationMode);
    output->set_coveragemodulationtableenable((uint32_t)input->coverageModulationTableEnable);
    output->set_coveragemodulationtablecount((uint32_t)input->coverageModulationTableCount);
    // WARNING PTR CHECK
    if (input->pCoverageModulationTable)
    {
        for (uint32_t i = 0; i < (uint32_t)input->coverageModulationTableCount; ++i)
        {
            output->add_pcoveragemodulationtable(input->pCoverageModulationTable[i]);
        }
    }
}

void from_proto_VkPipelineCoverageModulationStateCreateInfoNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineCoverageModulationStateCreateInfoNV* input,
    VkPipelineCoverageModulationStateCreateInfoNV* output)
{
    memset(output, 0x0, sizeof(VkPipelineCoverageModulationStateCreateInfoNV));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkPipelineCoverageModulationStateCreateFlagsNV)input->flags();
    output->coverageModulationMode = (VkCoverageModulationModeNV)input->coveragemodulationmode();
    output->coverageModulationTableEnable = (VkBool32)input->coveragemodulationtableenable();
    output->coverageModulationTableCount = (uint32_t)input->coveragemodulationtablecount();
    // WARNING PTR CHECK
    if (input->pcoveragemodulationtable_size())
    {
        for (uint32_t i = 0; i < (uint32_t)output->coverageModulationTableCount; ++i)
        {
            *((float*)(&output->pCoverageModulationTable) + i) = (float)input->pcoveragemodulationtable(i);
        }
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
void to_proto_VkValidationCacheCreateInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkValidationCacheCreateInfoEXT* input,
    goldfish_vk_proto::VkValidationCacheCreateInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_flags((uint32_t)input->flags);
    output->set_initialdatasize((uint64_t)input->initialDataSize);
    for (uint32_t i = 0; i < (uint32_t)input->initialDataSize; ++i)
    {
        output->add_pinitialdata(((const char*)(input->pInitialData))[i]);
    }
}

void from_proto_VkValidationCacheCreateInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkValidationCacheCreateInfoEXT* input,
    VkValidationCacheCreateInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkValidationCacheCreateInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->flags = (VkValidationCacheCreateFlagsEXT)input->flags();
    output->initialDataSize = (size_t)input->initialdatasize();
    for (uint32_t i = 0; i < (uint32_t)output->initialDataSize; ++i)
    {
        *((char*)(&output->pInitialData) + i) = (char)input->pinitialdata(i);
    }
}

void to_proto_VkShaderModuleValidationCacheCreateInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkShaderModuleValidationCacheCreateInfoEXT* input,
    goldfish_vk_proto::VkShaderModuleValidationCacheCreateInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    uint64_t cgen_var_100;
    handleMapping->mapHandles_VkValidationCacheEXT_u64(&input->validationCache, &cgen_var_100, 1);
    output->set_validationcache(cgen_var_100);
}

void from_proto_VkShaderModuleValidationCacheCreateInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkShaderModuleValidationCacheCreateInfoEXT* input,
    VkShaderModuleValidationCacheCreateInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkShaderModuleValidationCacheCreateInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    for (uint32_t i = 0; i < 1; ++i)
    {
        uint64_t current = input->validationcache();
        handleMapping->mapHandles_u64_VkValidationCacheEXT(&current, (VkValidationCacheEXT*)&output->validationCache, 1);
    }
}

#endif
#ifdef VK_EXT_descriptor_indexing
void to_proto_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* input,
    goldfish_vk_proto::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_bindingcount((uint32_t)input->bindingCount);
    for (uint32_t i = 0; i < (uint32_t)input->bindingCount; ++i)
    {
        output->add_pbindingflags(input->pBindingFlags[i]);
    }
}

void from_proto_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* input,
    VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkDescriptorSetLayoutBindingFlagsCreateInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->bindingCount = (uint32_t)input->bindingcount();
    for (uint32_t i = 0; i < (uint32_t)output->bindingCount; ++i)
    {
        *((VkDescriptorBindingFlagsEXT*)(&output->pBindingFlags) + i) = (VkDescriptorBindingFlagsEXT)input->pbindingflags(i);
    }
}

void to_proto_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceDescriptorIndexingFeaturesEXT* input,
    goldfish_vk_proto::VkPhysicalDeviceDescriptorIndexingFeaturesEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_shaderinputattachmentarraydynamicindexing((uint32_t)input->shaderInputAttachmentArrayDynamicIndexing);
    output->set_shaderuniformtexelbufferarraydynamicindexing((uint32_t)input->shaderUniformTexelBufferArrayDynamicIndexing);
    output->set_shaderstoragetexelbufferarraydynamicindexing((uint32_t)input->shaderStorageTexelBufferArrayDynamicIndexing);
    output->set_shaderuniformbufferarraynonuniformindexing((uint32_t)input->shaderUniformBufferArrayNonUniformIndexing);
    output->set_shadersampledimagearraynonuniformindexing((uint32_t)input->shaderSampledImageArrayNonUniformIndexing);
    output->set_shaderstoragebufferarraynonuniformindexing((uint32_t)input->shaderStorageBufferArrayNonUniformIndexing);
    output->set_shaderstorageimagearraynonuniformindexing((uint32_t)input->shaderStorageImageArrayNonUniformIndexing);
    output->set_shaderinputattachmentarraynonuniformindexing((uint32_t)input->shaderInputAttachmentArrayNonUniformIndexing);
    output->set_shaderuniformtexelbufferarraynonuniformindexing((uint32_t)input->shaderUniformTexelBufferArrayNonUniformIndexing);
    output->set_shaderstoragetexelbufferarraynonuniformindexing((uint32_t)input->shaderStorageTexelBufferArrayNonUniformIndexing);
    output->set_descriptorbindinguniformbufferupdateafterbind((uint32_t)input->descriptorBindingUniformBufferUpdateAfterBind);
    output->set_descriptorbindingsampledimageupdateafterbind((uint32_t)input->descriptorBindingSampledImageUpdateAfterBind);
    output->set_descriptorbindingstorageimageupdateafterbind((uint32_t)input->descriptorBindingStorageImageUpdateAfterBind);
    output->set_descriptorbindingstoragebufferupdateafterbind((uint32_t)input->descriptorBindingStorageBufferUpdateAfterBind);
    output->set_descriptorbindinguniformtexelbufferupdateafterbind((uint32_t)input->descriptorBindingUniformTexelBufferUpdateAfterBind);
    output->set_descriptorbindingstoragetexelbufferupdateafterbind((uint32_t)input->descriptorBindingStorageTexelBufferUpdateAfterBind);
    output->set_descriptorbindingupdateunusedwhilepending((uint32_t)input->descriptorBindingUpdateUnusedWhilePending);
    output->set_descriptorbindingpartiallybound((uint32_t)input->descriptorBindingPartiallyBound);
    output->set_descriptorbindingvariabledescriptorcount((uint32_t)input->descriptorBindingVariableDescriptorCount);
    output->set_runtimedescriptorarray((uint32_t)input->runtimeDescriptorArray);
}

void from_proto_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceDescriptorIndexingFeaturesEXT* input,
    VkPhysicalDeviceDescriptorIndexingFeaturesEXT* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceDescriptorIndexingFeaturesEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->shaderInputAttachmentArrayDynamicIndexing = (VkBool32)input->shaderinputattachmentarraydynamicindexing();
    output->shaderUniformTexelBufferArrayDynamicIndexing = (VkBool32)input->shaderuniformtexelbufferarraydynamicindexing();
    output->shaderStorageTexelBufferArrayDynamicIndexing = (VkBool32)input->shaderstoragetexelbufferarraydynamicindexing();
    output->shaderUniformBufferArrayNonUniformIndexing = (VkBool32)input->shaderuniformbufferarraynonuniformindexing();
    output->shaderSampledImageArrayNonUniformIndexing = (VkBool32)input->shadersampledimagearraynonuniformindexing();
    output->shaderStorageBufferArrayNonUniformIndexing = (VkBool32)input->shaderstoragebufferarraynonuniformindexing();
    output->shaderStorageImageArrayNonUniformIndexing = (VkBool32)input->shaderstorageimagearraynonuniformindexing();
    output->shaderInputAttachmentArrayNonUniformIndexing = (VkBool32)input->shaderinputattachmentarraynonuniformindexing();
    output->shaderUniformTexelBufferArrayNonUniformIndexing = (VkBool32)input->shaderuniformtexelbufferarraynonuniformindexing();
    output->shaderStorageTexelBufferArrayNonUniformIndexing = (VkBool32)input->shaderstoragetexelbufferarraynonuniformindexing();
    output->descriptorBindingUniformBufferUpdateAfterBind = (VkBool32)input->descriptorbindinguniformbufferupdateafterbind();
    output->descriptorBindingSampledImageUpdateAfterBind = (VkBool32)input->descriptorbindingsampledimageupdateafterbind();
    output->descriptorBindingStorageImageUpdateAfterBind = (VkBool32)input->descriptorbindingstorageimageupdateafterbind();
    output->descriptorBindingStorageBufferUpdateAfterBind = (VkBool32)input->descriptorbindingstoragebufferupdateafterbind();
    output->descriptorBindingUniformTexelBufferUpdateAfterBind = (VkBool32)input->descriptorbindinguniformtexelbufferupdateafterbind();
    output->descriptorBindingStorageTexelBufferUpdateAfterBind = (VkBool32)input->descriptorbindingstoragetexelbufferupdateafterbind();
    output->descriptorBindingUpdateUnusedWhilePending = (VkBool32)input->descriptorbindingupdateunusedwhilepending();
    output->descriptorBindingPartiallyBound = (VkBool32)input->descriptorbindingpartiallybound();
    output->descriptorBindingVariableDescriptorCount = (VkBool32)input->descriptorbindingvariabledescriptorcount();
    output->runtimeDescriptorArray = (VkBool32)input->runtimedescriptorarray();
}

void to_proto_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceDescriptorIndexingPropertiesEXT* input,
    goldfish_vk_proto::VkPhysicalDeviceDescriptorIndexingPropertiesEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_maxupdateafterbinddescriptorsinallpools((uint32_t)input->maxUpdateAfterBindDescriptorsInAllPools);
    output->set_shaderuniformbufferarraynonuniformindexingnative((uint32_t)input->shaderUniformBufferArrayNonUniformIndexingNative);
    output->set_shadersampledimagearraynonuniformindexingnative((uint32_t)input->shaderSampledImageArrayNonUniformIndexingNative);
    output->set_shaderstoragebufferarraynonuniformindexingnative((uint32_t)input->shaderStorageBufferArrayNonUniformIndexingNative);
    output->set_shaderstorageimagearraynonuniformindexingnative((uint32_t)input->shaderStorageImageArrayNonUniformIndexingNative);
    output->set_shaderinputattachmentarraynonuniformindexingnative((uint32_t)input->shaderInputAttachmentArrayNonUniformIndexingNative);
    output->set_robustbufferaccessupdateafterbind((uint32_t)input->robustBufferAccessUpdateAfterBind);
    output->set_quaddivergentimplicitlod((uint32_t)input->quadDivergentImplicitLod);
    output->set_maxperstagedescriptorupdateafterbindsamplers((uint32_t)input->maxPerStageDescriptorUpdateAfterBindSamplers);
    output->set_maxperstagedescriptorupdateafterbinduniformbuffers((uint32_t)input->maxPerStageDescriptorUpdateAfterBindUniformBuffers);
    output->set_maxperstagedescriptorupdateafterbindstoragebuffers((uint32_t)input->maxPerStageDescriptorUpdateAfterBindStorageBuffers);
    output->set_maxperstagedescriptorupdateafterbindsampledimages((uint32_t)input->maxPerStageDescriptorUpdateAfterBindSampledImages);
    output->set_maxperstagedescriptorupdateafterbindstorageimages((uint32_t)input->maxPerStageDescriptorUpdateAfterBindStorageImages);
    output->set_maxperstagedescriptorupdateafterbindinputattachments((uint32_t)input->maxPerStageDescriptorUpdateAfterBindInputAttachments);
    output->set_maxperstageupdateafterbindresources((uint32_t)input->maxPerStageUpdateAfterBindResources);
    output->set_maxdescriptorsetupdateafterbindsamplers((uint32_t)input->maxDescriptorSetUpdateAfterBindSamplers);
    output->set_maxdescriptorsetupdateafterbinduniformbuffers((uint32_t)input->maxDescriptorSetUpdateAfterBindUniformBuffers);
    output->set_maxdescriptorsetupdateafterbinduniformbuffersdynamic((uint32_t)input->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic);
    output->set_maxdescriptorsetupdateafterbindstoragebuffers((uint32_t)input->maxDescriptorSetUpdateAfterBindStorageBuffers);
    output->set_maxdescriptorsetupdateafterbindstoragebuffersdynamic((uint32_t)input->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic);
    output->set_maxdescriptorsetupdateafterbindsampledimages((uint32_t)input->maxDescriptorSetUpdateAfterBindSampledImages);
    output->set_maxdescriptorsetupdateafterbindstorageimages((uint32_t)input->maxDescriptorSetUpdateAfterBindStorageImages);
    output->set_maxdescriptorsetupdateafterbindinputattachments((uint32_t)input->maxDescriptorSetUpdateAfterBindInputAttachments);
}

void from_proto_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceDescriptorIndexingPropertiesEXT* input,
    VkPhysicalDeviceDescriptorIndexingPropertiesEXT* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceDescriptorIndexingPropertiesEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->maxUpdateAfterBindDescriptorsInAllPools = (uint32_t)input->maxupdateafterbinddescriptorsinallpools();
    output->shaderUniformBufferArrayNonUniformIndexingNative = (VkBool32)input->shaderuniformbufferarraynonuniformindexingnative();
    output->shaderSampledImageArrayNonUniformIndexingNative = (VkBool32)input->shadersampledimagearraynonuniformindexingnative();
    output->shaderStorageBufferArrayNonUniformIndexingNative = (VkBool32)input->shaderstoragebufferarraynonuniformindexingnative();
    output->shaderStorageImageArrayNonUniformIndexingNative = (VkBool32)input->shaderstorageimagearraynonuniformindexingnative();
    output->shaderInputAttachmentArrayNonUniformIndexingNative = (VkBool32)input->shaderinputattachmentarraynonuniformindexingnative();
    output->robustBufferAccessUpdateAfterBind = (VkBool32)input->robustbufferaccessupdateafterbind();
    output->quadDivergentImplicitLod = (VkBool32)input->quaddivergentimplicitlod();
    output->maxPerStageDescriptorUpdateAfterBindSamplers = (uint32_t)input->maxperstagedescriptorupdateafterbindsamplers();
    output->maxPerStageDescriptorUpdateAfterBindUniformBuffers = (uint32_t)input->maxperstagedescriptorupdateafterbinduniformbuffers();
    output->maxPerStageDescriptorUpdateAfterBindStorageBuffers = (uint32_t)input->maxperstagedescriptorupdateafterbindstoragebuffers();
    output->maxPerStageDescriptorUpdateAfterBindSampledImages = (uint32_t)input->maxperstagedescriptorupdateafterbindsampledimages();
    output->maxPerStageDescriptorUpdateAfterBindStorageImages = (uint32_t)input->maxperstagedescriptorupdateafterbindstorageimages();
    output->maxPerStageDescriptorUpdateAfterBindInputAttachments = (uint32_t)input->maxperstagedescriptorupdateafterbindinputattachments();
    output->maxPerStageUpdateAfterBindResources = (uint32_t)input->maxperstageupdateafterbindresources();
    output->maxDescriptorSetUpdateAfterBindSamplers = (uint32_t)input->maxdescriptorsetupdateafterbindsamplers();
    output->maxDescriptorSetUpdateAfterBindUniformBuffers = (uint32_t)input->maxdescriptorsetupdateafterbinduniformbuffers();
    output->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = (uint32_t)input->maxdescriptorsetupdateafterbinduniformbuffersdynamic();
    output->maxDescriptorSetUpdateAfterBindStorageBuffers = (uint32_t)input->maxdescriptorsetupdateafterbindstoragebuffers();
    output->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = (uint32_t)input->maxdescriptorsetupdateafterbindstoragebuffersdynamic();
    output->maxDescriptorSetUpdateAfterBindSampledImages = (uint32_t)input->maxdescriptorsetupdateafterbindsampledimages();
    output->maxDescriptorSetUpdateAfterBindStorageImages = (uint32_t)input->maxdescriptorsetupdateafterbindstorageimages();
    output->maxDescriptorSetUpdateAfterBindInputAttachments = (uint32_t)input->maxdescriptorsetupdateafterbindinputattachments();
}

void to_proto_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* input,
    goldfish_vk_proto::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_descriptorsetcount((uint32_t)input->descriptorSetCount);
    for (uint32_t i = 0; i < (uint32_t)input->descriptorSetCount; ++i)
    {
        output->add_pdescriptorcounts(input->pDescriptorCounts[i]);
    }
}

void from_proto_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* input,
    VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkDescriptorSetVariableDescriptorCountAllocateInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->descriptorSetCount = (uint32_t)input->descriptorsetcount();
    for (uint32_t i = 0; i < (uint32_t)output->descriptorSetCount; ++i)
    {
        *((uint32_t*)(&output->pDescriptorCounts) + i) = (uint32_t)input->pdescriptorcounts(i);
    }
}

void to_proto_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(
    VulkanHandleMapping* handleMapping,
    const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* input,
    goldfish_vk_proto::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_maxvariabledescriptorcount((uint32_t)input->maxVariableDescriptorCount);
}

void from_proto_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* input,
    VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* output)
{
    memset(output, 0x0, sizeof(VkDescriptorSetVariableDescriptorCountLayoutSupportEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->maxVariableDescriptorCount = (uint32_t)input->maxvariabledescriptorcount();
}

#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
void to_proto_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkDeviceQueueGlobalPriorityCreateInfoEXT* input,
    goldfish_vk_proto::VkDeviceQueueGlobalPriorityCreateInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_globalpriority((uint32_t)input->globalPriority);
}

void from_proto_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkDeviceQueueGlobalPriorityCreateInfoEXT* input,
    VkDeviceQueueGlobalPriorityCreateInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkDeviceQueueGlobalPriorityCreateInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->globalPriority = (VkQueueGlobalPriorityEXT)input->globalpriority();
}

#endif
#ifdef VK_EXT_external_memory_host
void to_proto_VkImportMemoryHostPointerInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkImportMemoryHostPointerInfoEXT* input,
    goldfish_vk_proto::VkImportMemoryHostPointerInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_handletype((uint32_t)input->handleType);
    // WARNING PTR CHECK
    if (input->pHostPointer)
    {
        output->set_phostpointer((uint64_t)(uintptr_t)input->pHostPointer);
    }
}

void from_proto_VkImportMemoryHostPointerInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImportMemoryHostPointerInfoEXT* input,
    VkImportMemoryHostPointerInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkImportMemoryHostPointerInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->handleType = (VkExternalMemoryHandleTypeFlagBits)input->handletype();
    // WARNING PTR CHECK
    if (input->has_phostpointer())
    {
        output->pHostPointer = (void*)(uintptr_t)input->phostpointer();
    }
}

void to_proto_VkMemoryHostPointerPropertiesEXT(
    VulkanHandleMapping* handleMapping,
    const VkMemoryHostPointerPropertiesEXT* input,
    goldfish_vk_proto::VkMemoryHostPointerPropertiesEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_memorytypebits((uint32_t)input->memoryTypeBits);
}

void from_proto_VkMemoryHostPointerPropertiesEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkMemoryHostPointerPropertiesEXT* input,
    VkMemoryHostPointerPropertiesEXT* output)
{
    memset(output, 0x0, sizeof(VkMemoryHostPointerPropertiesEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->memoryTypeBits = (uint32_t)input->memorytypebits();
}

void to_proto_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* input,
    goldfish_vk_proto::VkPhysicalDeviceExternalMemoryHostPropertiesEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_minimportedhostpointeralignment((uint64_t)input->minImportedHostPointerAlignment);
}

void from_proto_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceExternalMemoryHostPropertiesEXT* input,
    VkPhysicalDeviceExternalMemoryHostPropertiesEXT* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceExternalMemoryHostPropertiesEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->minImportedHostPointerAlignment = (VkDeviceSize)input->minimportedhostpointeralignment();
}

#endif
#ifdef VK_AMD_buffer_marker
#endif
#ifdef VK_AMD_shader_core_properties
void to_proto_VkPhysicalDeviceShaderCorePropertiesAMD(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceShaderCorePropertiesAMD* input,
    goldfish_vk_proto::VkPhysicalDeviceShaderCorePropertiesAMD* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_shaderenginecount((uint32_t)input->shaderEngineCount);
    output->set_shaderarraysperenginecount((uint32_t)input->shaderArraysPerEngineCount);
    output->set_computeunitspershaderarray((uint32_t)input->computeUnitsPerShaderArray);
    output->set_simdpercomputeunit((uint32_t)input->simdPerComputeUnit);
    output->set_wavefrontspersimd((uint32_t)input->wavefrontsPerSimd);
    output->set_wavefrontsize((uint32_t)input->wavefrontSize);
    output->set_sgprspersimd((uint32_t)input->sgprsPerSimd);
    output->set_minsgprallocation((uint32_t)input->minSgprAllocation);
    output->set_maxsgprallocation((uint32_t)input->maxSgprAllocation);
    output->set_sgprallocationgranularity((uint32_t)input->sgprAllocationGranularity);
    output->set_vgprspersimd((uint32_t)input->vgprsPerSimd);
    output->set_minvgprallocation((uint32_t)input->minVgprAllocation);
    output->set_maxvgprallocation((uint32_t)input->maxVgprAllocation);
    output->set_vgprallocationgranularity((uint32_t)input->vgprAllocationGranularity);
}

void from_proto_VkPhysicalDeviceShaderCorePropertiesAMD(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceShaderCorePropertiesAMD* input,
    VkPhysicalDeviceShaderCorePropertiesAMD* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceShaderCorePropertiesAMD));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->shaderEngineCount = (uint32_t)input->shaderenginecount();
    output->shaderArraysPerEngineCount = (uint32_t)input->shaderarraysperenginecount();
    output->computeUnitsPerShaderArray = (uint32_t)input->computeunitspershaderarray();
    output->simdPerComputeUnit = (uint32_t)input->simdpercomputeunit();
    output->wavefrontsPerSimd = (uint32_t)input->wavefrontspersimd();
    output->wavefrontSize = (uint32_t)input->wavefrontsize();
    output->sgprsPerSimd = (uint32_t)input->sgprspersimd();
    output->minSgprAllocation = (uint32_t)input->minsgprallocation();
    output->maxSgprAllocation = (uint32_t)input->maxsgprallocation();
    output->sgprAllocationGranularity = (uint32_t)input->sgprallocationgranularity();
    output->vgprsPerSimd = (uint32_t)input->vgprspersimd();
    output->minVgprAllocation = (uint32_t)input->minvgprallocation();
    output->maxVgprAllocation = (uint32_t)input->maxvgprallocation();
    output->vgprAllocationGranularity = (uint32_t)input->vgprallocationgranularity();
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void to_proto_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    VulkanHandleMapping* handleMapping,
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* input,
    goldfish_vk_proto::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_maxvertexattribdivisor((uint32_t)input->maxVertexAttribDivisor);
}

void from_proto_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* input,
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* output)
{
    memset(output, 0x0, sizeof(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->maxVertexAttribDivisor = (uint32_t)input->maxvertexattribdivisor();
}

void to_proto_VkVertexInputBindingDivisorDescriptionEXT(
    VulkanHandleMapping* handleMapping,
    const VkVertexInputBindingDivisorDescriptionEXT* input,
    goldfish_vk_proto::VkVertexInputBindingDivisorDescriptionEXT* output)
{
    output->set_binding((uint32_t)input->binding);
    output->set_divisor((uint32_t)input->divisor);
}

void from_proto_VkVertexInputBindingDivisorDescriptionEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkVertexInputBindingDivisorDescriptionEXT* input,
    VkVertexInputBindingDivisorDescriptionEXT* output)
{
    memset(output, 0x0, sizeof(VkVertexInputBindingDivisorDescriptionEXT));
    output->binding = (uint32_t)input->binding();
    output->divisor = (uint32_t)input->divisor();
}

void to_proto_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    VulkanHandleMapping* handleMapping,
    const VkPipelineVertexInputDivisorStateCreateInfoEXT* input,
    goldfish_vk_proto::VkPipelineVertexInputDivisorStateCreateInfoEXT* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_vertexbindingdivisorcount((uint32_t)input->vertexBindingDivisorCount);
    for (uint32_t i = 0; i < (uint32_t)input->vertexBindingDivisorCount; ++i)
    {
        to_proto_VkVertexInputBindingDivisorDescriptionEXT(handleMapping, input->pVertexBindingDivisors + i, output->add_pvertexbindingdivisors());
    }
}

void from_proto_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkPipelineVertexInputDivisorStateCreateInfoEXT* input,
    VkPipelineVertexInputDivisorStateCreateInfoEXT* output)
{
    memset(output, 0x0, sizeof(VkPipelineVertexInputDivisorStateCreateInfoEXT));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->vertexBindingDivisorCount = (uint32_t)input->vertexbindingdivisorcount();
    *(void**)&output->pVertexBindingDivisors = pool->alloc(output->vertexBindingDivisorCount * sizeof(const VkVertexInputBindingDivisorDescriptionEXT));
    for (uint32_t i = 0; i < (uint32_t)output->vertexBindingDivisorCount; ++i)
    {
        from_proto_VkVertexInputBindingDivisorDescriptionEXT(pool, handleMapping, input->mutable_pvertexbindingdivisors(i), (VkVertexInputBindingDivisorDescriptionEXT*)(output->pVertexBindingDivisors + i));
    }
}

#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void to_proto_VkQueueFamilyCheckpointPropertiesNV(
    VulkanHandleMapping* handleMapping,
    const VkQueueFamilyCheckpointPropertiesNV* input,
    goldfish_vk_proto::VkQueueFamilyCheckpointPropertiesNV* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_checkpointexecutionstagemask((uint32_t)input->checkpointExecutionStageMask);
}

void from_proto_VkQueueFamilyCheckpointPropertiesNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkQueueFamilyCheckpointPropertiesNV* input,
    VkQueueFamilyCheckpointPropertiesNV* output)
{
    memset(output, 0x0, sizeof(VkQueueFamilyCheckpointPropertiesNV));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->checkpointExecutionStageMask = (VkPipelineStageFlags)input->checkpointexecutionstagemask();
}

void to_proto_VkCheckpointDataNV(
    VulkanHandleMapping* handleMapping,
    const VkCheckpointDataNV* input,
    goldfish_vk_proto::VkCheckpointDataNV* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_stage((uint32_t)input->stage);
    // WARNING PTR CHECK
    if (input->pCheckpointMarker)
    {
        output->set_pcheckpointmarker((uint64_t)(uintptr_t)input->pCheckpointMarker);
    }
}

void from_proto_VkCheckpointDataNV(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkCheckpointDataNV* input,
    VkCheckpointDataNV* output)
{
    memset(output, 0x0, sizeof(VkCheckpointDataNV));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->stage = (VkPipelineStageFlagBits)input->stage();
    // WARNING PTR CHECK
    if (input->has_pcheckpointmarker())
    {
        output->pCheckpointMarker = (void*)(uintptr_t)input->pcheckpointmarker();
    }
}

#endif
#ifdef VK_GOOGLE_address_space
#endif
#ifdef VK_GOOGLE_color_buffer
void to_proto_VkImportColorBufferGOOGLE(
    VulkanHandleMapping* handleMapping,
    const VkImportColorBufferGOOGLE* input,
    goldfish_vk_proto::VkImportColorBufferGOOGLE* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_colorbuffer((uint32_t)input->colorBuffer);
}

void from_proto_VkImportColorBufferGOOGLE(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImportColorBufferGOOGLE* input,
    VkImportColorBufferGOOGLE* output)
{
    memset(output, 0x0, sizeof(VkImportColorBufferGOOGLE));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->colorBuffer = (uint32_t)input->colorbuffer();
}

void to_proto_VkImportPhysicalAddressGOOGLE(
    VulkanHandleMapping* handleMapping,
    const VkImportPhysicalAddressGOOGLE* input,
    goldfish_vk_proto::VkImportPhysicalAddressGOOGLE* output)
{
    output->set_stype((uint32_t)input->sType);
    if (input->pNext)
    {
        to_proto_extension_struct(handleMapping, input->pNext, output->mutable_pnext());
    }
    output->set_physicaladdress((uint64_t)input->physicalAddress);
    output->set_size((uint64_t)input->size);
    output->set_format((uint32_t)input->format);
    output->set_tiling((uint32_t)input->tiling);
    output->set_tilingparameter((uint32_t)input->tilingParameter);
}

void from_proto_VkImportPhysicalAddressGOOGLE(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    goldfish_vk_proto::VkImportPhysicalAddressGOOGLE* input,
    VkImportPhysicalAddressGOOGLE* output)
{
    memset(output, 0x0, sizeof(VkImportPhysicalAddressGOOGLE));
    output->sType = (VkStructureType)input->stype();
    if (input->has_pnext())
    {
        VkStructureType structType = extension_proto_to_struct_type(input->mutable_pnext());
        *(void**)&output->pNext = pool->alloc(goldfish_vk_extension_struct_size((const void*)(&structType)));
        *(VkStructureType*)output->pNext = structType;
        from_proto_extension_struct(pool, handleMapping, input->mutable_pnext(), (void*)(output->pNext));
    }
    output->physicalAddress = (uint64_t)input->physicaladdress();
    output->size = (VkDeviceSize)input->size();
    output->format = (VkFormat)input->format();
    output->tiling = (VkImageTiling)input->tiling();
    output->tilingParameter = (uint32_t)input->tilingparameter();
}

#endif
#ifdef VK_GOOGLE_sized_descriptor_update_template
#endif
#ifdef VK_GOOGLE_async_command_buffers
#endif
VkStructureType extension_proto_to_struct_type(
    const goldfish_vk_proto::VkExtensionStruct* input)
{
#ifdef VK_VERSION_1_1
    if (input->has_extension_vkphysicaldevicesubgroupproperties()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES; }
    if (input->has_extension_vkphysicaldevice16bitstoragefeatures()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES; }
    if (input->has_extension_vkmemorydedicatedrequirements()) { return VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS; }
    if (input->has_extension_vkmemorydedicatedallocateinfo()) { return VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO; }
    if (input->has_extension_vkmemoryallocateflagsinfo()) { return VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO; }
    if (input->has_extension_vkdevicegrouprenderpassbegininfo()) { return VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO; }
    if (input->has_extension_vkdevicegroupcommandbufferbegininfo()) { return VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO; }
    if (input->has_extension_vkdevicegroupsubmitinfo()) { return VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO; }
    if (input->has_extension_vkdevicegroupbindsparseinfo()) { return VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO; }
    if (input->has_extension_vkbindbuffermemorydevicegroupinfo()) { return VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO; }
    if (input->has_extension_vkbindimagememorydevicegroupinfo()) { return VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO; }
    if (input->has_extension_vkdevicegroupdevicecreateinfo()) { return VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO; }
    if (input->has_extension_vkphysicaldevicefeatures2()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; }
    if (input->has_extension_vkphysicaldevicepointclippingproperties()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES; }
    if (input->has_extension_vkrenderpassinputattachmentaspectcreateinfo()) { return VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO; }
    if (input->has_extension_vkimageviewusagecreateinfo()) { return VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO; }
    if (input->has_extension_vkpipelinetessellationdomainoriginstatecreateinfo()) { return VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO; }
    if (input->has_extension_vkrenderpassmultiviewcreateinfo()) { return VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO; }
    if (input->has_extension_vkphysicaldevicemultiviewfeatures()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES; }
    if (input->has_extension_vkphysicaldevicemultiviewproperties()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES; }
    if (input->has_extension_vkphysicaldevicevariablepointerfeatures()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES; }
    if (input->has_extension_vkphysicaldeviceprotectedmemoryfeatures()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES; }
    if (input->has_extension_vkphysicaldeviceprotectedmemoryproperties()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES; }
    if (input->has_extension_vkprotectedsubmitinfo()) { return VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO; }
    if (input->has_extension_vksamplerycbcrconversioninfo()) { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO; }
    if (input->has_extension_vkbindimageplanememoryinfo()) { return VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO; }
    if (input->has_extension_vkimageplanememoryrequirementsinfo()) { return VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO; }
    if (input->has_extension_vkphysicaldevicesamplerycbcrconversionfeatures()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES; }
    if (input->has_extension_vksamplerycbcrconversionimageformatproperties()) { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES; }
    if (input->has_extension_vkphysicaldeviceexternalimageformatinfo()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO; }
    if (input->has_extension_vkexternalimageformatproperties()) { return VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES; }
    if (input->has_extension_vkphysicaldeviceidproperties()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES; }
    if (input->has_extension_vkexternalmemoryimagecreateinfo()) { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO; }
    if (input->has_extension_vkexternalmemorybuffercreateinfo()) { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO; }
    if (input->has_extension_vkexportmemoryallocateinfo()) { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO; }
    if (input->has_extension_vkexportfencecreateinfo()) { return VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO; }
    if (input->has_extension_vkexportsemaphorecreateinfo()) { return VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO; }
    if (input->has_extension_vkphysicaldevicemaintenance3properties()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES; }
    if (input->has_extension_vkphysicaldeviceshaderdrawparameterfeatures()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES; }
#endif
#ifdef VK_KHR_swapchain
    if (input->has_extension_vkimageswapchaincreateinfokhr()) { return VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR; }
    if (input->has_extension_vkbindimagememoryswapchaininfokhr()) { return VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR; }
    if (input->has_extension_vkdevicegrouppresentinfokhr()) { return VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR; }
    if (input->has_extension_vkdevicegroupswapchaincreateinfokhr()) { return VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR; }
#endif
#ifdef VK_KHR_display_swapchain
    if (input->has_extension_vkdisplaypresentinfokhr()) { return VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR; }
#endif
#ifdef VK_KHR_external_memory_win32
    if (input->has_extension_vkimportmemorywin32handleinfokhr()) { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR; }
    if (input->has_extension_vkexportmemorywin32handleinfokhr()) { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR; }
#endif
#ifdef VK_KHR_external_memory_fd
    if (input->has_extension_vkimportmemoryfdinfokhr()) { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR; }
#endif
#ifdef VK_KHR_win32_keyed_mutex
    if (input->has_extension_vkwin32keyedmutexacquirereleaseinfokhr()) { return VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR; }
#endif
#ifdef VK_KHR_external_semaphore_win32
    if (input->has_extension_vkexportsemaphorewin32handleinfokhr()) { return VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR; }
    if (input->has_extension_vkd3d12fencesubmitinfokhr()) { return VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR; }
#endif
#ifdef VK_KHR_push_descriptor
    if (input->has_extension_vkphysicaldevicepushdescriptorpropertieskhr()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR; }
#endif
#ifdef VK_KHR_incremental_present
    if (input->has_extension_vkpresentregionskhr()) { return VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR; }
#endif
#ifdef VK_KHR_shared_presentable_image
    if (input->has_extension_vksharedpresentsurfacecapabilitieskhr()) { return VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR; }
#endif
#ifdef VK_KHR_external_fence_win32
    if (input->has_extension_vkexportfencewin32handleinfokhr()) { return VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR; }
#endif
#ifdef VK_KHR_image_format_list
    if (input->has_extension_vkimageformatlistcreateinfokhr()) { return VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR; }
#endif
#ifdef VK_KHR_8bit_storage
    if (input->has_extension_vkphysicaldevice8bitstoragefeatureskhr()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR; }
#endif
#ifdef VK_ANDROID_native_buffer
    if (input->has_extension_vknativebufferandroid()) { return VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID; }
#endif
#ifdef VK_EXT_debug_report
    if (input->has_extension_vkdebugreportcallbackcreateinfoext()) { return VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT; }
#endif
#ifdef VK_AMD_rasterization_order
    if (input->has_extension_vkpipelinerasterizationstaterasterizationorderamd()) { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD; }
#endif
#ifdef VK_NV_dedicated_allocation
    if (input->has_extension_vkdedicatedallocationimagecreateinfonv()) { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV; }
    if (input->has_extension_vkdedicatedallocationbuffercreateinfonv()) { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV; }
    if (input->has_extension_vkdedicatedallocationmemoryallocateinfonv()) { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV; }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
    if (input->has_extension_vktexturelodgatherformatpropertiesamd()) { return VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD; }
#endif
#ifdef VK_NV_external_memory
    if (input->has_extension_vkexternalmemoryimagecreateinfonv()) { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV; }
    if (input->has_extension_vkexportmemoryallocateinfonv()) { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV; }
#endif
#ifdef VK_NV_external_memory_win32
    if (input->has_extension_vkimportmemorywin32handleinfonv()) { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV; }
    if (input->has_extension_vkexportmemorywin32handleinfonv()) { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV; }
#endif
#ifdef VK_NV_win32_keyed_mutex
    if (input->has_extension_vkwin32keyedmutexacquirereleaseinfonv()) { return VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV; }
#endif
#ifdef VK_EXT_validation_flags
    if (input->has_extension_vkvalidationflagsext()) { return VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT; }
#endif
#ifdef VK_EXT_conditional_rendering
    if (input->has_extension_vkphysicaldeviceconditionalrenderingfeaturesext()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT; }
    if (input->has_extension_vkcommandbufferinheritanceconditionalrenderinginfoext()) { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT; }
#endif
#ifdef VK_NV_clip_space_w_scaling
    if (input->has_extension_vkpipelineviewportwscalingstatecreateinfonv()) { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV; }
#endif
#ifdef VK_EXT_display_control
    if (input->has_extension_vkswapchaincountercreateinfoext()) { return VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT; }
#endif
#ifdef VK_GOOGLE_display_timing
    if (input->has_extension_vkpresenttimesinfogoogle()) { return VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE; }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
    if (input->has_extension_vkphysicaldevicemultiviewperviewattributespropertiesnvx()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX; }
#endif
#ifdef VK_NV_viewport_swizzle
    if (input->has_extension_vkpipelineviewportswizzlestatecreateinfonv()) { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV; }
#endif
#ifdef VK_EXT_discard_rectangles
    if (input->has_extension_vkphysicaldevicediscardrectanglepropertiesext()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT; }
    if (input->has_extension_vkpipelinediscardrectanglestatecreateinfoext()) { return VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT; }
#endif
#ifdef VK_EXT_conservative_rasterization
    if (input->has_extension_vkphysicaldeviceconservativerasterizationpropertiesext()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT; }
    if (input->has_extension_vkpipelinerasterizationconservativestatecreateinfoext()) { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT; }
#endif
#ifdef VK_EXT_debug_utils
    if (input->has_extension_vkdebugutilsmessengercreateinfoext()) { return VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT; }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    if (input->has_extension_vkandroidhardwarebufferusageandroid()) { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID; }
    if (input->has_extension_vkandroidhardwarebufferformatpropertiesandroid()) { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID; }
    if (input->has_extension_vkimportandroidhardwarebufferinfoandroid()) { return VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID; }
    if (input->has_extension_vkexternalformatandroid()) { return VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID; }
#endif
#ifdef VK_EXT_sampler_filter_minmax
    if (input->has_extension_vksamplerreductionmodecreateinfoext()) { return VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT; }
    if (input->has_extension_vkphysicaldevicesamplerfilterminmaxpropertiesext()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT; }
#endif
#ifdef VK_EXT_sample_locations
    if (input->has_extension_vksamplelocationsinfoext()) { return VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT; }
    if (input->has_extension_vkrenderpasssamplelocationsbegininfoext()) { return VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT; }
    if (input->has_extension_vkpipelinesamplelocationsstatecreateinfoext()) { return VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT; }
    if (input->has_extension_vkphysicaldevicesamplelocationspropertiesext()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT; }
#endif
#ifdef VK_EXT_blend_operation_advanced
    if (input->has_extension_vkphysicaldeviceblendoperationadvancedfeaturesext()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT; }
    if (input->has_extension_vkphysicaldeviceblendoperationadvancedpropertiesext()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT; }
    if (input->has_extension_vkpipelinecolorblendadvancedstatecreateinfoext()) { return VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT; }
#endif
#ifdef VK_NV_fragment_coverage_to_color
    if (input->has_extension_vkpipelinecoveragetocolorstatecreateinfonv()) { return VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV; }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
    if (input->has_extension_vkpipelinecoveragemodulationstatecreateinfonv()) { return VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV; }
#endif
#ifdef VK_EXT_validation_cache
    if (input->has_extension_vkshadermodulevalidationcachecreateinfoext()) { return VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT; }
#endif
#ifdef VK_EXT_descriptor_indexing
    if (input->has_extension_vkdescriptorsetlayoutbindingflagscreateinfoext()) { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT; }
    if (input->has_extension_vkphysicaldevicedescriptorindexingfeaturesext()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT; }
    if (input->has_extension_vkphysicaldevicedescriptorindexingpropertiesext()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT; }
    if (input->has_extension_vkdescriptorsetvariabledescriptorcountallocateinfoext()) { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT; }
    if (input->has_extension_vkdescriptorsetvariabledescriptorcountlayoutsupportext()) { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT; }
#endif
#ifdef VK_EXT_global_priority
    if (input->has_extension_vkdevicequeueglobalprioritycreateinfoext()) { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT; }
#endif
#ifdef VK_EXT_external_memory_host
    if (input->has_extension_vkimportmemoryhostpointerinfoext()) { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT; }
    if (input->has_extension_vkphysicaldeviceexternalmemoryhostpropertiesext()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT; }
#endif
#ifdef VK_AMD_shader_core_properties
    if (input->has_extension_vkphysicaldeviceshadercorepropertiesamd()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD; }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
    if (input->has_extension_vkphysicaldevicevertexattributedivisorpropertiesext()) { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT; }
    if (input->has_extension_vkpipelinevertexinputdivisorstatecreateinfoext()) { return VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT; }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    if (input->has_extension_vkqueuefamilycheckpointpropertiesnv()) { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV; }
#endif
#ifdef VK_GOOGLE_color_buffer
    if (input->has_extension_vkimportcolorbuffergoogle()) { return VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE; }
    if (input->has_extension_vkimportphysicaladdressgoogle()) { return VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE; }
#endif
}

void to_proto_extension_struct(
    VulkanHandleMapping* handleMapping,
    const void* structExtension,
    void* output)
{
    if (!structExtension)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            to_proto_VkPhysicalDeviceSubgroupProperties(handleMapping, reinterpret_cast<const VkPhysicalDeviceSubgroupProperties*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicesubgroupproperties());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            to_proto_VkPhysicalDevice16BitStorageFeatures(handleMapping, reinterpret_cast<const VkPhysicalDevice16BitStorageFeatures*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevice16bitstoragefeatures());
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            to_proto_VkMemoryDedicatedRequirements(handleMapping, reinterpret_cast<const VkMemoryDedicatedRequirements*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkmemorydedicatedrequirements());
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            to_proto_VkMemoryDedicatedAllocateInfo(handleMapping, reinterpret_cast<const VkMemoryDedicatedAllocateInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkmemorydedicatedallocateinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            to_proto_VkMemoryAllocateFlagsInfo(handleMapping, reinterpret_cast<const VkMemoryAllocateFlagsInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkmemoryallocateflagsinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            to_proto_VkDeviceGroupRenderPassBeginInfo(handleMapping, reinterpret_cast<const VkDeviceGroupRenderPassBeginInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdevicegrouprenderpassbegininfo());
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            to_proto_VkDeviceGroupCommandBufferBeginInfo(handleMapping, reinterpret_cast<const VkDeviceGroupCommandBufferBeginInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdevicegroupcommandbufferbegininfo());
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            to_proto_VkDeviceGroupSubmitInfo(handleMapping, reinterpret_cast<const VkDeviceGroupSubmitInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdevicegroupsubmitinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            to_proto_VkDeviceGroupBindSparseInfo(handleMapping, reinterpret_cast<const VkDeviceGroupBindSparseInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdevicegroupbindsparseinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            to_proto_VkBindBufferMemoryDeviceGroupInfo(handleMapping, reinterpret_cast<const VkBindBufferMemoryDeviceGroupInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkbindbuffermemorydevicegroupinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            to_proto_VkBindImageMemoryDeviceGroupInfo(handleMapping, reinterpret_cast<const VkBindImageMemoryDeviceGroupInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkbindimagememorydevicegroupinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            to_proto_VkDeviceGroupDeviceCreateInfo(handleMapping, reinterpret_cast<const VkDeviceGroupDeviceCreateInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdevicegroupdevicecreateinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            to_proto_VkPhysicalDeviceFeatures2(handleMapping, reinterpret_cast<const VkPhysicalDeviceFeatures2*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicefeatures2());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            to_proto_VkPhysicalDevicePointClippingProperties(handleMapping, reinterpret_cast<const VkPhysicalDevicePointClippingProperties*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicepointclippingproperties());
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            to_proto_VkRenderPassInputAttachmentAspectCreateInfo(handleMapping, reinterpret_cast<const VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkrenderpassinputattachmentaspectcreateinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            to_proto_VkImageViewUsageCreateInfo(handleMapping, reinterpret_cast<const VkImageViewUsageCreateInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkimageviewusagecreateinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            to_proto_VkPipelineTessellationDomainOriginStateCreateInfo(handleMapping, reinterpret_cast<const VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkpipelinetessellationdomainoriginstatecreateinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            to_proto_VkRenderPassMultiviewCreateInfo(handleMapping, reinterpret_cast<const VkRenderPassMultiviewCreateInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkrenderpassmultiviewcreateinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            to_proto_VkPhysicalDeviceMultiviewFeatures(handleMapping, reinterpret_cast<const VkPhysicalDeviceMultiviewFeatures*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicemultiviewfeatures());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            to_proto_VkPhysicalDeviceMultiviewProperties(handleMapping, reinterpret_cast<const VkPhysicalDeviceMultiviewProperties*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicemultiviewproperties());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES:
        {
            to_proto_VkPhysicalDeviceVariablePointerFeatures(handleMapping, reinterpret_cast<const VkPhysicalDeviceVariablePointerFeatures*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicevariablepointerfeatures());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            to_proto_VkPhysicalDeviceProtectedMemoryFeatures(handleMapping, reinterpret_cast<const VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldeviceprotectedmemoryfeatures());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            to_proto_VkPhysicalDeviceProtectedMemoryProperties(handleMapping, reinterpret_cast<const VkPhysicalDeviceProtectedMemoryProperties*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldeviceprotectedmemoryproperties());
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            to_proto_VkProtectedSubmitInfo(handleMapping, reinterpret_cast<const VkProtectedSubmitInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkprotectedsubmitinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            to_proto_VkSamplerYcbcrConversionInfo(handleMapping, reinterpret_cast<const VkSamplerYcbcrConversionInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vksamplerycbcrconversioninfo());
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            to_proto_VkBindImagePlaneMemoryInfo(handleMapping, reinterpret_cast<const VkBindImagePlaneMemoryInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkbindimageplanememoryinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            to_proto_VkImagePlaneMemoryRequirementsInfo(handleMapping, reinterpret_cast<const VkImagePlaneMemoryRequirementsInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkimageplanememoryrequirementsinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            to_proto_VkPhysicalDeviceSamplerYcbcrConversionFeatures(handleMapping, reinterpret_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicesamplerycbcrconversionfeatures());
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            to_proto_VkSamplerYcbcrConversionImageFormatProperties(handleMapping, reinterpret_cast<const VkSamplerYcbcrConversionImageFormatProperties*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vksamplerycbcrconversionimageformatproperties());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            to_proto_VkPhysicalDeviceExternalImageFormatInfo(handleMapping, reinterpret_cast<const VkPhysicalDeviceExternalImageFormatInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldeviceexternalimageformatinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            to_proto_VkExternalImageFormatProperties(handleMapping, reinterpret_cast<const VkExternalImageFormatProperties*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkexternalimageformatproperties());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            to_proto_VkPhysicalDeviceIDProperties(handleMapping, reinterpret_cast<const VkPhysicalDeviceIDProperties*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldeviceidproperties());
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            to_proto_VkExternalMemoryImageCreateInfo(handleMapping, reinterpret_cast<const VkExternalMemoryImageCreateInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkexternalmemoryimagecreateinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            to_proto_VkExternalMemoryBufferCreateInfo(handleMapping, reinterpret_cast<const VkExternalMemoryBufferCreateInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkexternalmemorybuffercreateinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            to_proto_VkExportMemoryAllocateInfo(handleMapping, reinterpret_cast<const VkExportMemoryAllocateInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkexportmemoryallocateinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            to_proto_VkExportFenceCreateInfo(handleMapping, reinterpret_cast<const VkExportFenceCreateInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkexportfencecreateinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            to_proto_VkExportSemaphoreCreateInfo(handleMapping, reinterpret_cast<const VkExportSemaphoreCreateInfo*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkexportsemaphorecreateinfo());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            to_proto_VkPhysicalDeviceMaintenance3Properties(handleMapping, reinterpret_cast<const VkPhysicalDeviceMaintenance3Properties*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicemaintenance3properties());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES:
        {
            to_proto_VkPhysicalDeviceShaderDrawParameterFeatures(handleMapping, reinterpret_cast<const VkPhysicalDeviceShaderDrawParameterFeatures*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldeviceshaderdrawparameterfeatures());
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            to_proto_VkImageSwapchainCreateInfoKHR(handleMapping, reinterpret_cast<const VkImageSwapchainCreateInfoKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkimageswapchaincreateinfokhr());
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            to_proto_VkBindImageMemorySwapchainInfoKHR(handleMapping, reinterpret_cast<const VkBindImageMemorySwapchainInfoKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkbindimagememoryswapchaininfokhr());
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            to_proto_VkDeviceGroupPresentInfoKHR(handleMapping, reinterpret_cast<const VkDeviceGroupPresentInfoKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdevicegrouppresentinfokhr());
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            to_proto_VkDeviceGroupSwapchainCreateInfoKHR(handleMapping, reinterpret_cast<const VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdevicegroupswapchaincreateinfokhr());
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            to_proto_VkDisplayPresentInfoKHR(handleMapping, reinterpret_cast<const VkDisplayPresentInfoKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdisplaypresentinfokhr());
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            to_proto_VkImportMemoryWin32HandleInfoKHR(handleMapping, reinterpret_cast<const VkImportMemoryWin32HandleInfoKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkimportmemorywin32handleinfokhr());
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            to_proto_VkExportMemoryWin32HandleInfoKHR(handleMapping, reinterpret_cast<const VkExportMemoryWin32HandleInfoKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkexportmemorywin32handleinfokhr());
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            to_proto_VkImportMemoryFdInfoKHR(handleMapping, reinterpret_cast<const VkImportMemoryFdInfoKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkimportmemoryfdinfokhr());
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            to_proto_VkWin32KeyedMutexAcquireReleaseInfoKHR(handleMapping, reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkwin32keyedmutexacquirereleaseinfokhr());
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            to_proto_VkExportSemaphoreWin32HandleInfoKHR(handleMapping, reinterpret_cast<const VkExportSemaphoreWin32HandleInfoKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkexportsemaphorewin32handleinfokhr());
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            to_proto_VkD3D12FenceSubmitInfoKHR(handleMapping, reinterpret_cast<const VkD3D12FenceSubmitInfoKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkd3d12fencesubmitinfokhr());
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            to_proto_VkPhysicalDevicePushDescriptorPropertiesKHR(handleMapping, reinterpret_cast<const VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicepushdescriptorpropertieskhr());
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            to_proto_VkPresentRegionsKHR(handleMapping, reinterpret_cast<const VkPresentRegionsKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkpresentregionskhr());
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            to_proto_VkSharedPresentSurfaceCapabilitiesKHR(handleMapping, reinterpret_cast<const VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vksharedpresentsurfacecapabilitieskhr());
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            to_proto_VkExportFenceWin32HandleInfoKHR(handleMapping, reinterpret_cast<const VkExportFenceWin32HandleInfoKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkexportfencewin32handleinfokhr());
            break;
        }
#endif
#ifdef VK_KHR_image_format_list
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR:
        {
            to_proto_VkImageFormatListCreateInfoKHR(handleMapping, reinterpret_cast<const VkImageFormatListCreateInfoKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkimageformatlistcreateinfokhr());
            break;
        }
#endif
#ifdef VK_KHR_8bit_storage
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
        {
            to_proto_VkPhysicalDevice8BitStorageFeaturesKHR(handleMapping, reinterpret_cast<const VkPhysicalDevice8BitStorageFeaturesKHR*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevice8bitstoragefeatureskhr());
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            to_proto_VkNativeBufferANDROID(handleMapping, reinterpret_cast<const VkNativeBufferANDROID*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vknativebufferandroid());
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            to_proto_VkDebugReportCallbackCreateInfoEXT(handleMapping, reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdebugreportcallbackcreateinfoext());
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            to_proto_VkPipelineRasterizationStateRasterizationOrderAMD(handleMapping, reinterpret_cast<const VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkpipelinerasterizationstaterasterizationorderamd());
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            to_proto_VkDedicatedAllocationImageCreateInfoNV(handleMapping, reinterpret_cast<const VkDedicatedAllocationImageCreateInfoNV*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdedicatedallocationimagecreateinfonv());
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            to_proto_VkDedicatedAllocationBufferCreateInfoNV(handleMapping, reinterpret_cast<const VkDedicatedAllocationBufferCreateInfoNV*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdedicatedallocationbuffercreateinfonv());
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            to_proto_VkDedicatedAllocationMemoryAllocateInfoNV(handleMapping, reinterpret_cast<const VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdedicatedallocationmemoryallocateinfonv());
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            to_proto_VkTextureLODGatherFormatPropertiesAMD(handleMapping, reinterpret_cast<const VkTextureLODGatherFormatPropertiesAMD*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vktexturelodgatherformatpropertiesamd());
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            to_proto_VkExternalMemoryImageCreateInfoNV(handleMapping, reinterpret_cast<const VkExternalMemoryImageCreateInfoNV*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkexternalmemoryimagecreateinfonv());
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            to_proto_VkExportMemoryAllocateInfoNV(handleMapping, reinterpret_cast<const VkExportMemoryAllocateInfoNV*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkexportmemoryallocateinfonv());
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            to_proto_VkImportMemoryWin32HandleInfoNV(handleMapping, reinterpret_cast<const VkImportMemoryWin32HandleInfoNV*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkimportmemorywin32handleinfonv());
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            to_proto_VkExportMemoryWin32HandleInfoNV(handleMapping, reinterpret_cast<const VkExportMemoryWin32HandleInfoNV*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkexportmemorywin32handleinfonv());
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            to_proto_VkWin32KeyedMutexAcquireReleaseInfoNV(handleMapping, reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkwin32keyedmutexacquirereleaseinfonv());
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            to_proto_VkValidationFlagsEXT(handleMapping, reinterpret_cast<const VkValidationFlagsEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkvalidationflagsext());
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            to_proto_VkPhysicalDeviceConditionalRenderingFeaturesEXT(handleMapping, reinterpret_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldeviceconditionalrenderingfeaturesext());
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            to_proto_VkCommandBufferInheritanceConditionalRenderingInfoEXT(handleMapping, reinterpret_cast<const VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkcommandbufferinheritanceconditionalrenderinginfoext());
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            to_proto_VkPipelineViewportWScalingStateCreateInfoNV(handleMapping, reinterpret_cast<const VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkpipelineviewportwscalingstatecreateinfonv());
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            to_proto_VkSwapchainCounterCreateInfoEXT(handleMapping, reinterpret_cast<const VkSwapchainCounterCreateInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkswapchaincountercreateinfoext());
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            to_proto_VkPresentTimesInfoGOOGLE(handleMapping, reinterpret_cast<const VkPresentTimesInfoGOOGLE*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkpresenttimesinfogoogle());
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            to_proto_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(handleMapping, reinterpret_cast<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicemultiviewperviewattributespropertiesnvx());
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            to_proto_VkPipelineViewportSwizzleStateCreateInfoNV(handleMapping, reinterpret_cast<const VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkpipelineviewportswizzlestatecreateinfonv());
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            to_proto_VkPhysicalDeviceDiscardRectanglePropertiesEXT(handleMapping, reinterpret_cast<const VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicediscardrectanglepropertiesext());
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            to_proto_VkPipelineDiscardRectangleStateCreateInfoEXT(handleMapping, reinterpret_cast<const VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkpipelinediscardrectanglestatecreateinfoext());
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            to_proto_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(handleMapping, reinterpret_cast<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldeviceconservativerasterizationpropertiesext());
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            to_proto_VkPipelineRasterizationConservativeStateCreateInfoEXT(handleMapping, reinterpret_cast<const VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkpipelinerasterizationconservativestatecreateinfoext());
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            to_proto_VkDebugUtilsMessengerCreateInfoEXT(handleMapping, reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdebugutilsmessengercreateinfoext());
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            to_proto_VkAndroidHardwareBufferUsageANDROID(handleMapping, reinterpret_cast<const VkAndroidHardwareBufferUsageANDROID*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkandroidhardwarebufferusageandroid());
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            to_proto_VkAndroidHardwareBufferFormatPropertiesANDROID(handleMapping, reinterpret_cast<const VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkandroidhardwarebufferformatpropertiesandroid());
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            to_proto_VkImportAndroidHardwareBufferInfoANDROID(handleMapping, reinterpret_cast<const VkImportAndroidHardwareBufferInfoANDROID*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkimportandroidhardwarebufferinfoandroid());
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            to_proto_VkExternalFormatANDROID(handleMapping, reinterpret_cast<const VkExternalFormatANDROID*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkexternalformatandroid());
            break;
        }
#endif
#ifdef VK_EXT_sampler_filter_minmax
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
        {
            to_proto_VkSamplerReductionModeCreateInfoEXT(handleMapping, reinterpret_cast<const VkSamplerReductionModeCreateInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vksamplerreductionmodecreateinfoext());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
        {
            to_proto_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(handleMapping, reinterpret_cast<const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicesamplerfilterminmaxpropertiesext());
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            to_proto_VkSampleLocationsInfoEXT(handleMapping, reinterpret_cast<const VkSampleLocationsInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vksamplelocationsinfoext());
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            to_proto_VkRenderPassSampleLocationsBeginInfoEXT(handleMapping, reinterpret_cast<const VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkrenderpasssamplelocationsbegininfoext());
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            to_proto_VkPipelineSampleLocationsStateCreateInfoEXT(handleMapping, reinterpret_cast<const VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkpipelinesamplelocationsstatecreateinfoext());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            to_proto_VkPhysicalDeviceSampleLocationsPropertiesEXT(handleMapping, reinterpret_cast<const VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicesamplelocationspropertiesext());
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            to_proto_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(handleMapping, reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldeviceblendoperationadvancedfeaturesext());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            to_proto_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(handleMapping, reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldeviceblendoperationadvancedpropertiesext());
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            to_proto_VkPipelineColorBlendAdvancedStateCreateInfoEXT(handleMapping, reinterpret_cast<const VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkpipelinecolorblendadvancedstatecreateinfoext());
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            to_proto_VkPipelineCoverageToColorStateCreateInfoNV(handleMapping, reinterpret_cast<const VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkpipelinecoveragetocolorstatecreateinfonv());
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            to_proto_VkPipelineCoverageModulationStateCreateInfoNV(handleMapping, reinterpret_cast<const VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkpipelinecoveragemodulationstatecreateinfonv());
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            to_proto_VkShaderModuleValidationCacheCreateInfoEXT(handleMapping, reinterpret_cast<const VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkshadermodulevalidationcachecreateinfoext());
            break;
        }
#endif
#ifdef VK_EXT_descriptor_indexing
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
        {
            to_proto_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(handleMapping, reinterpret_cast<const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdescriptorsetlayoutbindingflagscreateinfoext());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
        {
            to_proto_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(handleMapping, reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingFeaturesEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicedescriptorindexingfeaturesext());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
        {
            to_proto_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(handleMapping, reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingPropertiesEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicedescriptorindexingpropertiesext());
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT:
        {
            to_proto_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(handleMapping, reinterpret_cast<const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdescriptorsetvariabledescriptorcountallocateinfoext());
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT:
        {
            to_proto_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(handleMapping, reinterpret_cast<const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdescriptorsetvariabledescriptorcountlayoutsupportext());
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            to_proto_VkDeviceQueueGlobalPriorityCreateInfoEXT(handleMapping, reinterpret_cast<const VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkdevicequeueglobalprioritycreateinfoext());
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            to_proto_VkImportMemoryHostPointerInfoEXT(handleMapping, reinterpret_cast<const VkImportMemoryHostPointerInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkimportmemoryhostpointerinfoext());
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            to_proto_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(handleMapping, reinterpret_cast<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldeviceexternalmemoryhostpropertiesext());
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            to_proto_VkPhysicalDeviceShaderCorePropertiesAMD(handleMapping, reinterpret_cast<const VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldeviceshadercorepropertiesamd());
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            to_proto_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(handleMapping, reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkphysicaldevicevertexattributedivisorpropertiesext());
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            to_proto_VkPipelineVertexInputDivisorStateCreateInfoEXT(handleMapping, reinterpret_cast<const VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkpipelinevertexinputdivisorstatecreateinfoext());
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            to_proto_VkQueueFamilyCheckpointPropertiesNV(handleMapping, reinterpret_cast<const VkQueueFamilyCheckpointPropertiesNV*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkqueuefamilycheckpointpropertiesnv());
            break;
        }
#endif
#ifdef VK_GOOGLE_color_buffer
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE:
        {
            to_proto_VkImportColorBufferGOOGLE(handleMapping, reinterpret_cast<const VkImportColorBufferGOOGLE*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkimportcolorbuffergoogle());
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE:
        {
            to_proto_VkImportPhysicalAddressGOOGLE(handleMapping, reinterpret_cast<const VkImportPhysicalAddressGOOGLE*>(structExtension), reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(output)->mutable_extension_vkimportphysicaladdressgoogle());
            break;
        }
#endif
        default:
        {
            return;
        }
    }
}

void from_proto_extension_struct(
    Pool* pool,
    VulkanHandleMapping* handleMapping,
    void* input,
    void* structExtension_out)
{
    if (!structExtension_out)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension_out);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            from_proto_VkPhysicalDeviceSubgroupProperties(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicesubgroupproperties(), reinterpret_cast<VkPhysicalDeviceSubgroupProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            from_proto_VkPhysicalDevice16BitStorageFeatures(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevice16bitstoragefeatures(), reinterpret_cast<VkPhysicalDevice16BitStorageFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            from_proto_VkMemoryDedicatedRequirements(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkmemorydedicatedrequirements(), reinterpret_cast<VkMemoryDedicatedRequirements*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            from_proto_VkMemoryDedicatedAllocateInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkmemorydedicatedallocateinfo(), reinterpret_cast<VkMemoryDedicatedAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            from_proto_VkMemoryAllocateFlagsInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkmemoryallocateflagsinfo(), reinterpret_cast<VkMemoryAllocateFlagsInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            from_proto_VkDeviceGroupRenderPassBeginInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdevicegrouprenderpassbegininfo(), reinterpret_cast<VkDeviceGroupRenderPassBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            from_proto_VkDeviceGroupCommandBufferBeginInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdevicegroupcommandbufferbegininfo(), reinterpret_cast<VkDeviceGroupCommandBufferBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            from_proto_VkDeviceGroupSubmitInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdevicegroupsubmitinfo(), reinterpret_cast<VkDeviceGroupSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            from_proto_VkDeviceGroupBindSparseInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdevicegroupbindsparseinfo(), reinterpret_cast<VkDeviceGroupBindSparseInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            from_proto_VkBindBufferMemoryDeviceGroupInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkbindbuffermemorydevicegroupinfo(), reinterpret_cast<VkBindBufferMemoryDeviceGroupInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            from_proto_VkBindImageMemoryDeviceGroupInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkbindimagememorydevicegroupinfo(), reinterpret_cast<VkBindImageMemoryDeviceGroupInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            from_proto_VkDeviceGroupDeviceCreateInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdevicegroupdevicecreateinfo(), reinterpret_cast<VkDeviceGroupDeviceCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            from_proto_VkPhysicalDeviceFeatures2(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicefeatures2(), reinterpret_cast<VkPhysicalDeviceFeatures2*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            from_proto_VkPhysicalDevicePointClippingProperties(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicepointclippingproperties(), reinterpret_cast<VkPhysicalDevicePointClippingProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            from_proto_VkRenderPassInputAttachmentAspectCreateInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkrenderpassinputattachmentaspectcreateinfo(), reinterpret_cast<VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            from_proto_VkImageViewUsageCreateInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkimageviewusagecreateinfo(), reinterpret_cast<VkImageViewUsageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            from_proto_VkPipelineTessellationDomainOriginStateCreateInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkpipelinetessellationdomainoriginstatecreateinfo(), reinterpret_cast<VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            from_proto_VkRenderPassMultiviewCreateInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkrenderpassmultiviewcreateinfo(), reinterpret_cast<VkRenderPassMultiviewCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            from_proto_VkPhysicalDeviceMultiviewFeatures(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicemultiviewfeatures(), reinterpret_cast<VkPhysicalDeviceMultiviewFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            from_proto_VkPhysicalDeviceMultiviewProperties(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicemultiviewproperties(), reinterpret_cast<VkPhysicalDeviceMultiviewProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES:
        {
            from_proto_VkPhysicalDeviceVariablePointerFeatures(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicevariablepointerfeatures(), reinterpret_cast<VkPhysicalDeviceVariablePointerFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            from_proto_VkPhysicalDeviceProtectedMemoryFeatures(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldeviceprotectedmemoryfeatures(), reinterpret_cast<VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            from_proto_VkPhysicalDeviceProtectedMemoryProperties(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldeviceprotectedmemoryproperties(), reinterpret_cast<VkPhysicalDeviceProtectedMemoryProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            from_proto_VkProtectedSubmitInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkprotectedsubmitinfo(), reinterpret_cast<VkProtectedSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            from_proto_VkSamplerYcbcrConversionInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vksamplerycbcrconversioninfo(), reinterpret_cast<VkSamplerYcbcrConversionInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            from_proto_VkBindImagePlaneMemoryInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkbindimageplanememoryinfo(), reinterpret_cast<VkBindImagePlaneMemoryInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            from_proto_VkImagePlaneMemoryRequirementsInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkimageplanememoryrequirementsinfo(), reinterpret_cast<VkImagePlaneMemoryRequirementsInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            from_proto_VkPhysicalDeviceSamplerYcbcrConversionFeatures(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicesamplerycbcrconversionfeatures(), reinterpret_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            from_proto_VkSamplerYcbcrConversionImageFormatProperties(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vksamplerycbcrconversionimageformatproperties(), reinterpret_cast<VkSamplerYcbcrConversionImageFormatProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            from_proto_VkPhysicalDeviceExternalImageFormatInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldeviceexternalimageformatinfo(), reinterpret_cast<VkPhysicalDeviceExternalImageFormatInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            from_proto_VkExternalImageFormatProperties(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkexternalimageformatproperties(), reinterpret_cast<VkExternalImageFormatProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            from_proto_VkPhysicalDeviceIDProperties(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldeviceidproperties(), reinterpret_cast<VkPhysicalDeviceIDProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            from_proto_VkExternalMemoryImageCreateInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkexternalmemoryimagecreateinfo(), reinterpret_cast<VkExternalMemoryImageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            from_proto_VkExternalMemoryBufferCreateInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkexternalmemorybuffercreateinfo(), reinterpret_cast<VkExternalMemoryBufferCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            from_proto_VkExportMemoryAllocateInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkexportmemoryallocateinfo(), reinterpret_cast<VkExportMemoryAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            from_proto_VkExportFenceCreateInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkexportfencecreateinfo(), reinterpret_cast<VkExportFenceCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            from_proto_VkExportSemaphoreCreateInfo(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkexportsemaphorecreateinfo(), reinterpret_cast<VkExportSemaphoreCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            from_proto_VkPhysicalDeviceMaintenance3Properties(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicemaintenance3properties(), reinterpret_cast<VkPhysicalDeviceMaintenance3Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES:
        {
            from_proto_VkPhysicalDeviceShaderDrawParameterFeatures(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldeviceshaderdrawparameterfeatures(), reinterpret_cast<VkPhysicalDeviceShaderDrawParameterFeatures*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            from_proto_VkImageSwapchainCreateInfoKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkimageswapchaincreateinfokhr(), reinterpret_cast<VkImageSwapchainCreateInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            from_proto_VkBindImageMemorySwapchainInfoKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkbindimagememoryswapchaininfokhr(), reinterpret_cast<VkBindImageMemorySwapchainInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            from_proto_VkDeviceGroupPresentInfoKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdevicegrouppresentinfokhr(), reinterpret_cast<VkDeviceGroupPresentInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            from_proto_VkDeviceGroupSwapchainCreateInfoKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdevicegroupswapchaincreateinfokhr(), reinterpret_cast<VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            from_proto_VkDisplayPresentInfoKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdisplaypresentinfokhr(), reinterpret_cast<VkDisplayPresentInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            from_proto_VkImportMemoryWin32HandleInfoKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkimportmemorywin32handleinfokhr(), reinterpret_cast<VkImportMemoryWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            from_proto_VkExportMemoryWin32HandleInfoKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkexportmemorywin32handleinfokhr(), reinterpret_cast<VkExportMemoryWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            from_proto_VkImportMemoryFdInfoKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkimportmemoryfdinfokhr(), reinterpret_cast<VkImportMemoryFdInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            from_proto_VkWin32KeyedMutexAcquireReleaseInfoKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkwin32keyedmutexacquirereleaseinfokhr(), reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            from_proto_VkExportSemaphoreWin32HandleInfoKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkexportsemaphorewin32handleinfokhr(), reinterpret_cast<VkExportSemaphoreWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            from_proto_VkD3D12FenceSubmitInfoKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkd3d12fencesubmitinfokhr(), reinterpret_cast<VkD3D12FenceSubmitInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            from_proto_VkPhysicalDevicePushDescriptorPropertiesKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicepushdescriptorpropertieskhr(), reinterpret_cast<VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            from_proto_VkPresentRegionsKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkpresentregionskhr(), reinterpret_cast<VkPresentRegionsKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            from_proto_VkSharedPresentSurfaceCapabilitiesKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vksharedpresentsurfacecapabilitieskhr(), reinterpret_cast<VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            from_proto_VkExportFenceWin32HandleInfoKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkexportfencewin32handleinfokhr(), reinterpret_cast<VkExportFenceWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_image_format_list
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR:
        {
            from_proto_VkImageFormatListCreateInfoKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkimageformatlistcreateinfokhr(), reinterpret_cast<VkImageFormatListCreateInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_8bit_storage
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
        {
            from_proto_VkPhysicalDevice8BitStorageFeaturesKHR(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevice8bitstoragefeatureskhr(), reinterpret_cast<VkPhysicalDevice8BitStorageFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            from_proto_VkNativeBufferANDROID(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vknativebufferandroid(), reinterpret_cast<VkNativeBufferANDROID*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            from_proto_VkDebugReportCallbackCreateInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdebugreportcallbackcreateinfoext(), reinterpret_cast<VkDebugReportCallbackCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            from_proto_VkPipelineRasterizationStateRasterizationOrderAMD(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkpipelinerasterizationstaterasterizationorderamd(), reinterpret_cast<VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            from_proto_VkDedicatedAllocationImageCreateInfoNV(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdedicatedallocationimagecreateinfonv(), reinterpret_cast<VkDedicatedAllocationImageCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            from_proto_VkDedicatedAllocationBufferCreateInfoNV(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdedicatedallocationbuffercreateinfonv(), reinterpret_cast<VkDedicatedAllocationBufferCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            from_proto_VkDedicatedAllocationMemoryAllocateInfoNV(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdedicatedallocationmemoryallocateinfonv(), reinterpret_cast<VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            from_proto_VkTextureLODGatherFormatPropertiesAMD(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vktexturelodgatherformatpropertiesamd(), reinterpret_cast<VkTextureLODGatherFormatPropertiesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            from_proto_VkExternalMemoryImageCreateInfoNV(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkexternalmemoryimagecreateinfonv(), reinterpret_cast<VkExternalMemoryImageCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            from_proto_VkExportMemoryAllocateInfoNV(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkexportmemoryallocateinfonv(), reinterpret_cast<VkExportMemoryAllocateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            from_proto_VkImportMemoryWin32HandleInfoNV(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkimportmemorywin32handleinfonv(), reinterpret_cast<VkImportMemoryWin32HandleInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            from_proto_VkExportMemoryWin32HandleInfoNV(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkexportmemorywin32handleinfonv(), reinterpret_cast<VkExportMemoryWin32HandleInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            from_proto_VkWin32KeyedMutexAcquireReleaseInfoNV(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkwin32keyedmutexacquirereleaseinfonv(), reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            from_proto_VkValidationFlagsEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkvalidationflagsext(), reinterpret_cast<VkValidationFlagsEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            from_proto_VkPhysicalDeviceConditionalRenderingFeaturesEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldeviceconditionalrenderingfeaturesext(), reinterpret_cast<VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            from_proto_VkCommandBufferInheritanceConditionalRenderingInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkcommandbufferinheritanceconditionalrenderinginfoext(), reinterpret_cast<VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            from_proto_VkPipelineViewportWScalingStateCreateInfoNV(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkpipelineviewportwscalingstatecreateinfonv(), reinterpret_cast<VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            from_proto_VkSwapchainCounterCreateInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkswapchaincountercreateinfoext(), reinterpret_cast<VkSwapchainCounterCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            from_proto_VkPresentTimesInfoGOOGLE(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkpresenttimesinfogoogle(), reinterpret_cast<VkPresentTimesInfoGOOGLE*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            from_proto_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicemultiviewperviewattributespropertiesnvx(), reinterpret_cast<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            from_proto_VkPipelineViewportSwizzleStateCreateInfoNV(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkpipelineviewportswizzlestatecreateinfonv(), reinterpret_cast<VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            from_proto_VkPhysicalDeviceDiscardRectanglePropertiesEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicediscardrectanglepropertiesext(), reinterpret_cast<VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            from_proto_VkPipelineDiscardRectangleStateCreateInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkpipelinediscardrectanglestatecreateinfoext(), reinterpret_cast<VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            from_proto_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldeviceconservativerasterizationpropertiesext(), reinterpret_cast<VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            from_proto_VkPipelineRasterizationConservativeStateCreateInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkpipelinerasterizationconservativestatecreateinfoext(), reinterpret_cast<VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            from_proto_VkDebugUtilsMessengerCreateInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdebugutilsmessengercreateinfoext(), reinterpret_cast<VkDebugUtilsMessengerCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            from_proto_VkAndroidHardwareBufferUsageANDROID(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkandroidhardwarebufferusageandroid(), reinterpret_cast<VkAndroidHardwareBufferUsageANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            from_proto_VkAndroidHardwareBufferFormatPropertiesANDROID(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkandroidhardwarebufferformatpropertiesandroid(), reinterpret_cast<VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            from_proto_VkImportAndroidHardwareBufferInfoANDROID(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkimportandroidhardwarebufferinfoandroid(), reinterpret_cast<VkImportAndroidHardwareBufferInfoANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            from_proto_VkExternalFormatANDROID(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkexternalformatandroid(), reinterpret_cast<VkExternalFormatANDROID*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_sampler_filter_minmax
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
        {
            from_proto_VkSamplerReductionModeCreateInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vksamplerreductionmodecreateinfoext(), reinterpret_cast<VkSamplerReductionModeCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
        {
            from_proto_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicesamplerfilterminmaxpropertiesext(), reinterpret_cast<VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            from_proto_VkSampleLocationsInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vksamplelocationsinfoext(), reinterpret_cast<VkSampleLocationsInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            from_proto_VkRenderPassSampleLocationsBeginInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkrenderpasssamplelocationsbegininfoext(), reinterpret_cast<VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            from_proto_VkPipelineSampleLocationsStateCreateInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkpipelinesamplelocationsstatecreateinfoext(), reinterpret_cast<VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            from_proto_VkPhysicalDeviceSampleLocationsPropertiesEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicesamplelocationspropertiesext(), reinterpret_cast<VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            from_proto_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldeviceblendoperationadvancedfeaturesext(), reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            from_proto_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldeviceblendoperationadvancedpropertiesext(), reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            from_proto_VkPipelineColorBlendAdvancedStateCreateInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkpipelinecolorblendadvancedstatecreateinfoext(), reinterpret_cast<VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            from_proto_VkPipelineCoverageToColorStateCreateInfoNV(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkpipelinecoveragetocolorstatecreateinfonv(), reinterpret_cast<VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            from_proto_VkPipelineCoverageModulationStateCreateInfoNV(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkpipelinecoveragemodulationstatecreateinfonv(), reinterpret_cast<VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            from_proto_VkShaderModuleValidationCacheCreateInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkshadermodulevalidationcachecreateinfoext(), reinterpret_cast<VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_descriptor_indexing
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
        {
            from_proto_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdescriptorsetlayoutbindingflagscreateinfoext(), reinterpret_cast<VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
        {
            from_proto_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicedescriptorindexingfeaturesext(), reinterpret_cast<VkPhysicalDeviceDescriptorIndexingFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
        {
            from_proto_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicedescriptorindexingpropertiesext(), reinterpret_cast<VkPhysicalDeviceDescriptorIndexingPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT:
        {
            from_proto_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdescriptorsetvariabledescriptorcountallocateinfoext(), reinterpret_cast<VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT:
        {
            from_proto_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdescriptorsetvariabledescriptorcountlayoutsupportext(), reinterpret_cast<VkDescriptorSetVariableDescriptorCountLayoutSupportEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            from_proto_VkDeviceQueueGlobalPriorityCreateInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkdevicequeueglobalprioritycreateinfoext(), reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            from_proto_VkImportMemoryHostPointerInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkimportmemoryhostpointerinfoext(), reinterpret_cast<VkImportMemoryHostPointerInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            from_proto_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldeviceexternalmemoryhostpropertiesext(), reinterpret_cast<VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            from_proto_VkPhysicalDeviceShaderCorePropertiesAMD(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldeviceshadercorepropertiesamd(), reinterpret_cast<VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            from_proto_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkphysicaldevicevertexattributedivisorpropertiesext(), reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            from_proto_VkPipelineVertexInputDivisorStateCreateInfoEXT(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkpipelinevertexinputdivisorstatecreateinfoext(), reinterpret_cast<VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            from_proto_VkQueueFamilyCheckpointPropertiesNV(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkqueuefamilycheckpointpropertiesnv(), reinterpret_cast<VkQueueFamilyCheckpointPropertiesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_GOOGLE_color_buffer
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE:
        {
            from_proto_VkImportColorBufferGOOGLE(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkimportcolorbuffergoogle(), reinterpret_cast<VkImportColorBufferGOOGLE*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE:
        {
            from_proto_VkImportPhysicalAddressGOOGLE(pool, handleMapping, reinterpret_cast<goldfish_vk_proto::VkExtensionStruct*>(input)->mutable_extension_vkimportphysicaladdressgoogle(), reinterpret_cast<VkImportPhysicalAddressGOOGLE*>(structExtension_out));
            break;
        }
#endif
        default:
        {
            return;
        }
    }
}


} // namespace goldfish_vk
