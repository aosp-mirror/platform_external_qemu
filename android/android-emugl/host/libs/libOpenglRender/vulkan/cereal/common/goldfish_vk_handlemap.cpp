// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_handlemap
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "goldfish_vk_handlemap.h"


#include "goldfish_vk_extension_structs.h"
#include "goldfish_vk_private_defs.h"


namespace goldfish_vk {

void handlemap_extension_struct(
    VulkanHandleMapping* handlemap,
    void* structExtension_out);

#ifdef VK_VERSION_1_0
void handlemap_VkExtent2D(
    VulkanHandleMapping* handlemap,
    VkExtent2D* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkExtent3D(
    VulkanHandleMapping* handlemap,
    VkExtent3D* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkOffset2D(
    VulkanHandleMapping* handlemap,
    VkOffset2D* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkOffset3D(
    VulkanHandleMapping* handlemap,
    VkOffset3D* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkRect2D(
    VulkanHandleMapping* handlemap,
    VkRect2D* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->offset));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->extent));
}

void handlemap_VkBaseInStructure(
    VulkanHandleMapping* handlemap,
    VkBaseInStructure* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBaseOutStructure(
    VulkanHandleMapping* handlemap,
    VkBaseOutStructure* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferMemoryBarrier(
    VulkanHandleMapping* handlemap,
    VkBufferMemoryBarrier* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkDispatchIndirectCommand(
    VulkanHandleMapping* handlemap,
    VkDispatchIndirectCommand* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDrawIndexedIndirectCommand(
    VulkanHandleMapping* handlemap,
    VkDrawIndexedIndirectCommand* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDrawIndirectCommand(
    VulkanHandleMapping* handlemap,
    VkDrawIndirectCommand* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageSubresourceRange(
    VulkanHandleMapping* handlemap,
    VkImageSubresourceRange* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageMemoryBarrier(
    VulkanHandleMapping* handlemap,
    VkImageMemoryBarrier* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap_VkImageSubresourceRange(handlemap, (VkImageSubresourceRange*)(&toMap->subresourceRange));
}

void handlemap_VkMemoryBarrier(
    VulkanHandleMapping* handlemap,
    VkMemoryBarrier* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAllocationCallbacks(
    VulkanHandleMapping* handlemap,
    VkAllocationCallbacks* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkApplicationInfo(
    VulkanHandleMapping* handlemap,
    VkApplicationInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFormatProperties(
    VulkanHandleMapping* handlemap,
    VkFormatProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageFormatProperties(
    VulkanHandleMapping* handlemap,
    VkImageFormatProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->maxExtent));
}

void handlemap_VkInstanceCreateInfo(
    VulkanHandleMapping* handlemap,
    VkInstanceCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pApplicationInfo)
    {
        handlemap_VkApplicationInfo(handlemap, (VkApplicationInfo*)(toMap->pApplicationInfo));
    }
}

void handlemap_VkMemoryHeap(
    VulkanHandleMapping* handlemap,
    VkMemoryHeap* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkMemoryType(
    VulkanHandleMapping* handlemap,
    VkMemoryType* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceLimits(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceLimits* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceMemoryProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceMemoryProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        handlemap_VkMemoryType(handlemap, (VkMemoryType*)(toMap->memoryTypes + i));
    }
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        handlemap_VkMemoryHeap(handlemap, (VkMemoryHeap*)(toMap->memoryHeaps + i));
    }
}

void handlemap_VkPhysicalDeviceSparseProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceSparseProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkPhysicalDeviceLimits(handlemap, (VkPhysicalDeviceLimits*)(&toMap->limits));
    handlemap_VkPhysicalDeviceSparseProperties(handlemap, (VkPhysicalDeviceSparseProperties*)(&toMap->sparseProperties));
}

void handlemap_VkQueueFamilyProperties(
    VulkanHandleMapping* handlemap,
    VkQueueFamilyProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->minImageTransferGranularity));
}

void handlemap_VkDeviceQueueCreateInfo(
    VulkanHandleMapping* handlemap,
    VkDeviceQueueCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceCreateInfo(
    VulkanHandleMapping* handlemap,
    VkDeviceCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pQueueCreateInfos)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->queueCreateInfoCount; ++i)
            {
                handlemap_VkDeviceQueueCreateInfo(handlemap, (VkDeviceQueueCreateInfo*)(toMap->pQueueCreateInfos + i));
            }
        }
    }
    if (toMap->pEnabledFeatures)
    {
        handlemap_VkPhysicalDeviceFeatures(handlemap, (VkPhysicalDeviceFeatures*)(toMap->pEnabledFeatures));
    }
}

void handlemap_VkExtensionProperties(
    VulkanHandleMapping* handlemap,
    VkExtensionProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkLayerProperties(
    VulkanHandleMapping* handlemap,
    VkLayerProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSubmitInfo(
    VulkanHandleMapping* handlemap,
    VkSubmitInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pWaitSemaphores)
    {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pWaitSemaphores, toMap->waitSemaphoreCount);
    }
    if (toMap->pCommandBuffers)
    {
        handlemap->mapHandles_VkCommandBuffer((VkCommandBuffer*)toMap->pCommandBuffers, toMap->commandBufferCount);
    }
    if (toMap->pSignalSemaphores)
    {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pSignalSemaphores, toMap->signalSemaphoreCount);
    }
}

void handlemap_VkMappedMemoryRange(
    VulkanHandleMapping* handlemap,
    VkMappedMemoryRange* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkMemoryAllocateInfo(
    VulkanHandleMapping* handlemap,
    VkMemoryAllocateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryRequirements(
    VulkanHandleMapping* handlemap,
    VkMemoryRequirements* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSparseMemoryBind(
    VulkanHandleMapping* handlemap,
    VkSparseMemoryBind* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkSparseBufferMemoryBindInfo(
    VulkanHandleMapping* handlemap,
    VkSparseBufferMemoryBindInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
    if (toMap)
    {
        if (toMap->pBinds)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->bindCount; ++i)
            {
                handlemap_VkSparseMemoryBind(handlemap, (VkSparseMemoryBind*)(toMap->pBinds + i));
            }
        }
    }
}

void handlemap_VkSparseImageOpaqueMemoryBindInfo(
    VulkanHandleMapping* handlemap,
    VkSparseImageOpaqueMemoryBindInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    if (toMap)
    {
        if (toMap->pBinds)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->bindCount; ++i)
            {
                handlemap_VkSparseMemoryBind(handlemap, (VkSparseMemoryBind*)(toMap->pBinds + i));
            }
        }
    }
}

void handlemap_VkImageSubresource(
    VulkanHandleMapping* handlemap,
    VkImageSubresource* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSparseImageMemoryBind(
    VulkanHandleMapping* handlemap,
    VkSparseImageMemoryBind* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresource(handlemap, (VkImageSubresource*)(&toMap->subresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->offset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkSparseImageMemoryBindInfo(
    VulkanHandleMapping* handlemap,
    VkSparseImageMemoryBindInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    if (toMap)
    {
        if (toMap->pBinds)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->bindCount; ++i)
            {
                handlemap_VkSparseImageMemoryBind(handlemap, (VkSparseImageMemoryBind*)(toMap->pBinds + i));
            }
        }
    }
}

void handlemap_VkBindSparseInfo(
    VulkanHandleMapping* handlemap,
    VkBindSparseInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pWaitSemaphores)
    {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pWaitSemaphores, toMap->waitSemaphoreCount);
    }
    if (toMap)
    {
        if (toMap->pBufferBinds)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->bufferBindCount; ++i)
            {
                handlemap_VkSparseBufferMemoryBindInfo(handlemap, (VkSparseBufferMemoryBindInfo*)(toMap->pBufferBinds + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pImageOpaqueBinds)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->imageOpaqueBindCount; ++i)
            {
                handlemap_VkSparseImageOpaqueMemoryBindInfo(handlemap, (VkSparseImageOpaqueMemoryBindInfo*)(toMap->pImageOpaqueBinds + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pImageBinds)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->imageBindCount; ++i)
            {
                handlemap_VkSparseImageMemoryBindInfo(handlemap, (VkSparseImageMemoryBindInfo*)(toMap->pImageBinds + i));
            }
        }
    }
    if (toMap->pSignalSemaphores)
    {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pSignalSemaphores, toMap->signalSemaphoreCount);
    }
}

void handlemap_VkSparseImageFormatProperties(
    VulkanHandleMapping* handlemap,
    VkSparseImageFormatProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->imageGranularity));
}

void handlemap_VkSparseImageMemoryRequirements(
    VulkanHandleMapping* handlemap,
    VkSparseImageMemoryRequirements* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkSparseImageFormatProperties(handlemap, (VkSparseImageFormatProperties*)(&toMap->formatProperties));
}

void handlemap_VkFenceCreateInfo(
    VulkanHandleMapping* handlemap,
    VkFenceCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSemaphoreCreateInfo(
    VulkanHandleMapping* handlemap,
    VkSemaphoreCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkEventCreateInfo(
    VulkanHandleMapping* handlemap,
    VkEventCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkQueryPoolCreateInfo(
    VulkanHandleMapping* handlemap,
    VkQueryPoolCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferCreateInfo(
    VulkanHandleMapping* handlemap,
    VkBufferCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferViewCreateInfo(
    VulkanHandleMapping* handlemap,
    VkBufferViewCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkImageCreateInfo(
    VulkanHandleMapping* handlemap,
    VkImageCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkSubresourceLayout(
    VulkanHandleMapping* handlemap,
    VkSubresourceLayout* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkComponentMapping(
    VulkanHandleMapping* handlemap,
    VkComponentMapping* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageViewCreateInfo(
    VulkanHandleMapping* handlemap,
    VkImageViewCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap_VkComponentMapping(handlemap, (VkComponentMapping*)(&toMap->components));
    handlemap_VkImageSubresourceRange(handlemap, (VkImageSubresourceRange*)(&toMap->subresourceRange));
}

void handlemap_VkShaderModuleCreateInfo(
    VulkanHandleMapping* handlemap,
    VkShaderModuleCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineCacheCreateInfo(
    VulkanHandleMapping* handlemap,
    VkPipelineCacheCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSpecializationMapEntry(
    VulkanHandleMapping* handlemap,
    VkSpecializationMapEntry* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSpecializationInfo(
    VulkanHandleMapping* handlemap,
    VkSpecializationInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap)
    {
        if (toMap->pMapEntries)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->mapEntryCount; ++i)
            {
                handlemap_VkSpecializationMapEntry(handlemap, (VkSpecializationMapEntry*)(toMap->pMapEntries + i));
            }
        }
    }
}

void handlemap_VkPipelineShaderStageCreateInfo(
    VulkanHandleMapping* handlemap,
    VkPipelineShaderStageCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkShaderModule((VkShaderModule*)&toMap->module);
    if (toMap->pSpecializationInfo)
    {
        handlemap_VkSpecializationInfo(handlemap, (VkSpecializationInfo*)(toMap->pSpecializationInfo));
    }
}

void handlemap_VkComputePipelineCreateInfo(
    VulkanHandleMapping* handlemap,
    VkComputePipelineCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPipelineShaderStageCreateInfo(handlemap, (VkPipelineShaderStageCreateInfo*)(&toMap->stage));
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->layout);
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->basePipelineHandle);
}

void handlemap_VkVertexInputBindingDescription(
    VulkanHandleMapping* handlemap,
    VkVertexInputBindingDescription* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkVertexInputAttributeDescription(
    VulkanHandleMapping* handlemap,
    VkVertexInputAttributeDescription* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineVertexInputStateCreateInfo(
    VulkanHandleMapping* handlemap,
    VkPipelineVertexInputStateCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pVertexBindingDescriptions)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->vertexBindingDescriptionCount; ++i)
            {
                handlemap_VkVertexInputBindingDescription(handlemap, (VkVertexInputBindingDescription*)(toMap->pVertexBindingDescriptions + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pVertexAttributeDescriptions)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->vertexAttributeDescriptionCount; ++i)
            {
                handlemap_VkVertexInputAttributeDescription(handlemap, (VkVertexInputAttributeDescription*)(toMap->pVertexAttributeDescriptions + i));
            }
        }
    }
}

void handlemap_VkPipelineInputAssemblyStateCreateInfo(
    VulkanHandleMapping* handlemap,
    VkPipelineInputAssemblyStateCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineTessellationStateCreateInfo(
    VulkanHandleMapping* handlemap,
    VkPipelineTessellationStateCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkViewport(
    VulkanHandleMapping* handlemap,
    VkViewport* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineViewportStateCreateInfo(
    VulkanHandleMapping* handlemap,
    VkPipelineViewportStateCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pViewports)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->viewportCount; ++i)
            {
                handlemap_VkViewport(handlemap, (VkViewport*)(toMap->pViewports + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pScissors)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->scissorCount; ++i)
            {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pScissors + i));
            }
        }
    }
}

void handlemap_VkPipelineRasterizationStateCreateInfo(
    VulkanHandleMapping* handlemap,
    VkPipelineRasterizationStateCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineMultisampleStateCreateInfo(
    VulkanHandleMapping* handlemap,
    VkPipelineMultisampleStateCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkStencilOpState(
    VulkanHandleMapping* handlemap,
    VkStencilOpState* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineDepthStencilStateCreateInfo(
    VulkanHandleMapping* handlemap,
    VkPipelineDepthStencilStateCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkStencilOpState(handlemap, (VkStencilOpState*)(&toMap->front));
    handlemap_VkStencilOpState(handlemap, (VkStencilOpState*)(&toMap->back));
}

void handlemap_VkPipelineColorBlendAttachmentState(
    VulkanHandleMapping* handlemap,
    VkPipelineColorBlendAttachmentState* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineColorBlendStateCreateInfo(
    VulkanHandleMapping* handlemap,
    VkPipelineColorBlendStateCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pAttachments)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->attachmentCount; ++i)
            {
                handlemap_VkPipelineColorBlendAttachmentState(handlemap, (VkPipelineColorBlendAttachmentState*)(toMap->pAttachments + i));
            }
        }
    }
}

void handlemap_VkPipelineDynamicStateCreateInfo(
    VulkanHandleMapping* handlemap,
    VkPipelineDynamicStateCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkGraphicsPipelineCreateInfo(
    VulkanHandleMapping* handlemap,
    VkGraphicsPipelineCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pStages)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->stageCount; ++i)
            {
                handlemap_VkPipelineShaderStageCreateInfo(handlemap, (VkPipelineShaderStageCreateInfo*)(toMap->pStages + i));
            }
        }
    }
    if (toMap->pVertexInputState)
    {
        handlemap_VkPipelineVertexInputStateCreateInfo(handlemap, (VkPipelineVertexInputStateCreateInfo*)(toMap->pVertexInputState));
    }
    if (toMap->pInputAssemblyState)
    {
        handlemap_VkPipelineInputAssemblyStateCreateInfo(handlemap, (VkPipelineInputAssemblyStateCreateInfo*)(toMap->pInputAssemblyState));
    }
    if (toMap->pTessellationState)
    {
        handlemap_VkPipelineTessellationStateCreateInfo(handlemap, (VkPipelineTessellationStateCreateInfo*)(toMap->pTessellationState));
    }
    if (toMap->pViewportState)
    {
        handlemap_VkPipelineViewportStateCreateInfo(handlemap, (VkPipelineViewportStateCreateInfo*)(toMap->pViewportState));
    }
    if (toMap->pRasterizationState)
    {
        handlemap_VkPipelineRasterizationStateCreateInfo(handlemap, (VkPipelineRasterizationStateCreateInfo*)(toMap->pRasterizationState));
    }
    if (toMap->pMultisampleState)
    {
        handlemap_VkPipelineMultisampleStateCreateInfo(handlemap, (VkPipelineMultisampleStateCreateInfo*)(toMap->pMultisampleState));
    }
    if (toMap->pDepthStencilState)
    {
        handlemap_VkPipelineDepthStencilStateCreateInfo(handlemap, (VkPipelineDepthStencilStateCreateInfo*)(toMap->pDepthStencilState));
    }
    if (toMap->pColorBlendState)
    {
        handlemap_VkPipelineColorBlendStateCreateInfo(handlemap, (VkPipelineColorBlendStateCreateInfo*)(toMap->pColorBlendState));
    }
    if (toMap->pDynamicState)
    {
        handlemap_VkPipelineDynamicStateCreateInfo(handlemap, (VkPipelineDynamicStateCreateInfo*)(toMap->pDynamicState));
    }
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->layout);
    handlemap->mapHandles_VkRenderPass((VkRenderPass*)&toMap->renderPass);
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->basePipelineHandle);
}

void handlemap_VkPushConstantRange(
    VulkanHandleMapping* handlemap,
    VkPushConstantRange* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineLayoutCreateInfo(
    VulkanHandleMapping* handlemap,
    VkPipelineLayoutCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pSetLayouts)
    {
        handlemap->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)toMap->pSetLayouts, toMap->setLayoutCount);
    }
    if (toMap)
    {
        if (toMap->pPushConstantRanges)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->pushConstantRangeCount; ++i)
            {
                handlemap_VkPushConstantRange(handlemap, (VkPushConstantRange*)(toMap->pPushConstantRanges + i));
            }
        }
    }
}

void handlemap_VkSamplerCreateInfo(
    VulkanHandleMapping* handlemap,
    VkSamplerCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCopyDescriptorSet(
    VulkanHandleMapping* handlemap,
    VkCopyDescriptorSet* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDescriptorSet((VkDescriptorSet*)&toMap->srcSet);
    handlemap->mapHandles_VkDescriptorSet((VkDescriptorSet*)&toMap->dstSet);
}

void handlemap_VkDescriptorBufferInfo(
    VulkanHandleMapping* handlemap,
    VkDescriptorBufferInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkDescriptorImageInfo(
    VulkanHandleMapping* handlemap,
    VkDescriptorImageInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkSampler((VkSampler*)&toMap->sampler);
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->imageView);
}

void handlemap_VkDescriptorPoolSize(
    VulkanHandleMapping* handlemap,
    VkDescriptorPoolSize* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDescriptorPoolCreateInfo(
    VulkanHandleMapping* handlemap,
    VkDescriptorPoolCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pPoolSizes)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->poolSizeCount; ++i)
            {
                handlemap_VkDescriptorPoolSize(handlemap, (VkDescriptorPoolSize*)(toMap->pPoolSizes + i));
            }
        }
    }
}

void handlemap_VkDescriptorSetAllocateInfo(
    VulkanHandleMapping* handlemap,
    VkDescriptorSetAllocateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDescriptorPool((VkDescriptorPool*)&toMap->descriptorPool);
    if (toMap->pSetLayouts)
    {
        handlemap->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)toMap->pSetLayouts, toMap->descriptorSetCount);
    }
}

void handlemap_VkDescriptorSetLayoutBinding(
    VulkanHandleMapping* handlemap,
    VkDescriptorSetLayoutBinding* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pImmutableSamplers)
    {
        handlemap->mapHandles_VkSampler((VkSampler*)toMap->pImmutableSamplers, toMap->descriptorCount);
    }
}

void handlemap_VkDescriptorSetLayoutCreateInfo(
    VulkanHandleMapping* handlemap,
    VkDescriptorSetLayoutCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pBindings)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->bindingCount; ++i)
            {
                handlemap_VkDescriptorSetLayoutBinding(handlemap, (VkDescriptorSetLayoutBinding*)(toMap->pBindings + i));
            }
        }
    }
}

void handlemap_VkWriteDescriptorSet(
    VulkanHandleMapping* handlemap,
    VkWriteDescriptorSet* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDescriptorSet((VkDescriptorSet*)&toMap->dstSet);
    if (toMap)
    {
        if (toMap->pImageInfo)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->descriptorCount; ++i)
            {
                handlemap_VkDescriptorImageInfo(handlemap, (VkDescriptorImageInfo*)(toMap->pImageInfo + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pBufferInfo)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->descriptorCount; ++i)
            {
                handlemap_VkDescriptorBufferInfo(handlemap, (VkDescriptorBufferInfo*)(toMap->pBufferInfo + i));
            }
        }
    }
    if (toMap->pTexelBufferView)
    {
        handlemap->mapHandles_VkBufferView((VkBufferView*)toMap->pTexelBufferView, toMap->descriptorCount);
    }
}

void handlemap_VkAttachmentDescription(
    VulkanHandleMapping* handlemap,
    VkAttachmentDescription* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAttachmentReference(
    VulkanHandleMapping* handlemap,
    VkAttachmentReference* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkFramebufferCreateInfo(
    VulkanHandleMapping* handlemap,
    VkFramebufferCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkRenderPass((VkRenderPass*)&toMap->renderPass);
    if (toMap->pAttachments)
    {
        handlemap->mapHandles_VkImageView((VkImageView*)toMap->pAttachments, toMap->attachmentCount);
    }
}

void handlemap_VkSubpassDescription(
    VulkanHandleMapping* handlemap,
    VkSubpassDescription* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap)
    {
        if (toMap->pInputAttachments)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->inputAttachmentCount; ++i)
            {
                handlemap_VkAttachmentReference(handlemap, (VkAttachmentReference*)(toMap->pInputAttachments + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pColorAttachments)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorAttachmentCount; ++i)
            {
                handlemap_VkAttachmentReference(handlemap, (VkAttachmentReference*)(toMap->pColorAttachments + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pResolveAttachments)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorAttachmentCount; ++i)
            {
                handlemap_VkAttachmentReference(handlemap, (VkAttachmentReference*)(toMap->pResolveAttachments + i));
            }
        }
    }
    if (toMap->pDepthStencilAttachment)
    {
        handlemap_VkAttachmentReference(handlemap, (VkAttachmentReference*)(toMap->pDepthStencilAttachment));
    }
}

void handlemap_VkSubpassDependency(
    VulkanHandleMapping* handlemap,
    VkSubpassDependency* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkRenderPassCreateInfo(
    VulkanHandleMapping* handlemap,
    VkRenderPassCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pAttachments)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->attachmentCount; ++i)
            {
                handlemap_VkAttachmentDescription(handlemap, (VkAttachmentDescription*)(toMap->pAttachments + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pSubpasses)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->subpassCount; ++i)
            {
                handlemap_VkSubpassDescription(handlemap, (VkSubpassDescription*)(toMap->pSubpasses + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pDependencies)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->dependencyCount; ++i)
            {
                handlemap_VkSubpassDependency(handlemap, (VkSubpassDependency*)(toMap->pDependencies + i));
            }
        }
    }
}

void handlemap_VkCommandPoolCreateInfo(
    VulkanHandleMapping* handlemap,
    VkCommandPoolCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCommandBufferAllocateInfo(
    VulkanHandleMapping* handlemap,
    VkCommandBufferAllocateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkCommandPool((VkCommandPool*)&toMap->commandPool);
}

void handlemap_VkCommandBufferInheritanceInfo(
    VulkanHandleMapping* handlemap,
    VkCommandBufferInheritanceInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkRenderPass((VkRenderPass*)&toMap->renderPass);
    handlemap->mapHandles_VkFramebuffer((VkFramebuffer*)&toMap->framebuffer);
}

void handlemap_VkCommandBufferBeginInfo(
    VulkanHandleMapping* handlemap,
    VkCommandBufferBeginInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pInheritanceInfo)
    {
        handlemap_VkCommandBufferInheritanceInfo(handlemap, (VkCommandBufferInheritanceInfo*)(toMap->pInheritanceInfo));
    }
}

void handlemap_VkBufferCopy(
    VulkanHandleMapping* handlemap,
    VkBufferCopy* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageSubresourceLayers(
    VulkanHandleMapping* handlemap,
    VkImageSubresourceLayers* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkBufferImageCopy(
    VulkanHandleMapping* handlemap,
    VkBufferImageCopy* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresourceLayers(handlemap, (VkImageSubresourceLayers*)(&toMap->imageSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->imageOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->imageExtent));
}

void handlemap_VkClearColorValue(
    VulkanHandleMapping* handlemap,
    VkClearColorValue* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkClearDepthStencilValue(
    VulkanHandleMapping* handlemap,
    VkClearDepthStencilValue* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkClearValue(
    VulkanHandleMapping* handlemap,
    VkClearValue* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkClearColorValue(handlemap, (VkClearColorValue*)(&toMap->color));
    handlemap_VkClearDepthStencilValue(handlemap, (VkClearDepthStencilValue*)(&toMap->depthStencil));
}

void handlemap_VkClearAttachment(
    VulkanHandleMapping* handlemap,
    VkClearAttachment* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkClearValue(handlemap, (VkClearValue*)(&toMap->clearValue));
}

void handlemap_VkClearRect(
    VulkanHandleMapping* handlemap,
    VkClearRect* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkRect2D(handlemap, (VkRect2D*)(&toMap->rect));
}

void handlemap_VkImageBlit(
    VulkanHandleMapping* handlemap,
    VkImageBlit* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresourceLayers(handlemap, (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        handlemap_VkOffset3D(handlemap, (VkOffset3D*)(toMap->srcOffsets + i));
    }
    handlemap_VkImageSubresourceLayers(handlemap, (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        handlemap_VkOffset3D(handlemap, (VkOffset3D*)(toMap->dstOffsets + i));
    }
}

void handlemap_VkImageCopy(
    VulkanHandleMapping* handlemap,
    VkImageCopy* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresourceLayers(handlemap, (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->srcOffset));
    handlemap_VkImageSubresourceLayers(handlemap, (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->dstOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkImageResolve(
    VulkanHandleMapping* handlemap,
    VkImageResolve* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresourceLayers(handlemap, (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->srcOffset));
    handlemap_VkImageSubresourceLayers(handlemap, (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->dstOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkRenderPassBeginInfo(
    VulkanHandleMapping* handlemap,
    VkRenderPassBeginInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkRenderPass((VkRenderPass*)&toMap->renderPass);
    handlemap->mapHandles_VkFramebuffer((VkFramebuffer*)&toMap->framebuffer);
    handlemap_VkRect2D(handlemap, (VkRect2D*)(&toMap->renderArea));
    if (toMap)
    {
        if (toMap->pClearValues)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->clearValueCount; ++i)
            {
                handlemap_VkClearValue(handlemap, (VkClearValue*)(toMap->pClearValues + i));
            }
        }
    }
}

#endif
#ifdef VK_VERSION_1_1
void handlemap_VkPhysicalDeviceSubgroupProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceSubgroupProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBindBufferMemoryInfo(
    VulkanHandleMapping* handlemap,
    VkBindBufferMemoryInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkBindImageMemoryInfo(
    VulkanHandleMapping* handlemap,
    VkBindImageMemoryInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkPhysicalDevice16BitStorageFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevice16BitStorageFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryDedicatedRequirements(
    VulkanHandleMapping* handlemap,
    VkMemoryDedicatedRequirements* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryDedicatedAllocateInfo(
    VulkanHandleMapping* handlemap,
    VkMemoryDedicatedAllocateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkMemoryAllocateFlagsInfo(
    VulkanHandleMapping* handlemap,
    VkMemoryAllocateFlagsInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupRenderPassBeginInfo(
    VulkanHandleMapping* handlemap,
    VkDeviceGroupRenderPassBeginInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pDeviceRenderAreas)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->deviceRenderAreaCount; ++i)
            {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pDeviceRenderAreas + i));
            }
        }
    }
}

void handlemap_VkDeviceGroupCommandBufferBeginInfo(
    VulkanHandleMapping* handlemap,
    VkDeviceGroupCommandBufferBeginInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupSubmitInfo(
    VulkanHandleMapping* handlemap,
    VkDeviceGroupSubmitInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupBindSparseInfo(
    VulkanHandleMapping* handlemap,
    VkDeviceGroupBindSparseInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBindBufferMemoryDeviceGroupInfo(
    VulkanHandleMapping* handlemap,
    VkBindBufferMemoryDeviceGroupInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBindImageMemoryDeviceGroupInfo(
    VulkanHandleMapping* handlemap,
    VkBindImageMemoryDeviceGroupInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pSplitInstanceBindRegions)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->splitInstanceBindRegionCount; ++i)
            {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pSplitInstanceBindRegions + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceGroupProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceGroupProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPhysicalDevice((VkPhysicalDevice*)toMap->physicalDevices, VK_MAX_DEVICE_GROUP_SIZE);
}

void handlemap_VkDeviceGroupDeviceCreateInfo(
    VulkanHandleMapping* handlemap,
    VkDeviceGroupDeviceCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pPhysicalDevices)
    {
        handlemap->mapHandles_VkPhysicalDevice((VkPhysicalDevice*)toMap->pPhysicalDevices, toMap->physicalDeviceCount);
    }
}

void handlemap_VkBufferMemoryRequirementsInfo2(
    VulkanHandleMapping* handlemap,
    VkBufferMemoryRequirementsInfo2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkImageMemoryRequirementsInfo2(
    VulkanHandleMapping* handlemap,
    VkImageMemoryRequirementsInfo2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
}

void handlemap_VkImageSparseMemoryRequirementsInfo2(
    VulkanHandleMapping* handlemap,
    VkImageSparseMemoryRequirementsInfo2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
}

void handlemap_VkMemoryRequirements2(
    VulkanHandleMapping* handlemap,
    VkMemoryRequirements2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkMemoryRequirements(handlemap, (VkMemoryRequirements*)(&toMap->memoryRequirements));
}

void handlemap_VkSparseImageMemoryRequirements2(
    VulkanHandleMapping* handlemap,
    VkSparseImageMemoryRequirements2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSparseImageMemoryRequirements(handlemap, (VkSparseImageMemoryRequirements*)(&toMap->memoryRequirements));
}

void handlemap_VkPhysicalDeviceFeatures2(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceFeatures2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPhysicalDeviceFeatures(handlemap, (VkPhysicalDeviceFeatures*)(&toMap->features));
}

void handlemap_VkPhysicalDeviceProperties2(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceProperties2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPhysicalDeviceProperties(handlemap, (VkPhysicalDeviceProperties*)(&toMap->properties));
}

void handlemap_VkFormatProperties2(
    VulkanHandleMapping* handlemap,
    VkFormatProperties2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkFormatProperties(handlemap, (VkFormatProperties*)(&toMap->formatProperties));
}

void handlemap_VkImageFormatProperties2(
    VulkanHandleMapping* handlemap,
    VkImageFormatProperties2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageFormatProperties(handlemap, (VkImageFormatProperties*)(&toMap->imageFormatProperties));
}

void handlemap_VkPhysicalDeviceImageFormatInfo2(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceImageFormatInfo2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkQueueFamilyProperties2(
    VulkanHandleMapping* handlemap,
    VkQueueFamilyProperties2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkQueueFamilyProperties(handlemap, (VkQueueFamilyProperties*)(&toMap->queueFamilyProperties));
}

void handlemap_VkPhysicalDeviceMemoryProperties2(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceMemoryProperties2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPhysicalDeviceMemoryProperties(handlemap, (VkPhysicalDeviceMemoryProperties*)(&toMap->memoryProperties));
}

void handlemap_VkSparseImageFormatProperties2(
    VulkanHandleMapping* handlemap,
    VkSparseImageFormatProperties2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSparseImageFormatProperties(handlemap, (VkSparseImageFormatProperties*)(&toMap->properties));
}

void handlemap_VkPhysicalDeviceSparseImageFormatInfo2(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceSparseImageFormatInfo2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePointClippingProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevicePointClippingProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkInputAttachmentAspectReference(
    VulkanHandleMapping* handlemap,
    VkInputAttachmentAspectReference* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkRenderPassInputAttachmentAspectCreateInfo(
    VulkanHandleMapping* handlemap,
    VkRenderPassInputAttachmentAspectCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pAspectReferences)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->aspectReferenceCount; ++i)
            {
                handlemap_VkInputAttachmentAspectReference(handlemap, (VkInputAttachmentAspectReference*)(toMap->pAspectReferences + i));
            }
        }
    }
}

void handlemap_VkImageViewUsageCreateInfo(
    VulkanHandleMapping* handlemap,
    VkImageViewUsageCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineTessellationDomainOriginStateCreateInfo(
    VulkanHandleMapping* handlemap,
    VkPipelineTessellationDomainOriginStateCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRenderPassMultiviewCreateInfo(
    VulkanHandleMapping* handlemap,
    VkRenderPassMultiviewCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMultiviewFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceMultiviewFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMultiviewProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceMultiviewProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceVariablePointersFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceVariablePointersFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceProtectedMemoryFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceProtectedMemoryFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceProtectedMemoryProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceProtectedMemoryProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceQueueInfo2(
    VulkanHandleMapping* handlemap,
    VkDeviceQueueInfo2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkProtectedSubmitInfo(
    VulkanHandleMapping* handlemap,
    VkProtectedSubmitInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSamplerYcbcrConversionCreateInfo(
    VulkanHandleMapping* handlemap,
    VkSamplerYcbcrConversionCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkComponentMapping(handlemap, (VkComponentMapping*)(&toMap->components));
}

void handlemap_VkSamplerYcbcrConversionInfo(
    VulkanHandleMapping* handlemap,
    VkSamplerYcbcrConversionInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)&toMap->conversion);
}

void handlemap_VkBindImagePlaneMemoryInfo(
    VulkanHandleMapping* handlemap,
    VkBindImagePlaneMemoryInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImagePlaneMemoryRequirementsInfo(
    VulkanHandleMapping* handlemap,
    VkImagePlaneMemoryRequirementsInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceSamplerYcbcrConversionFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSamplerYcbcrConversionImageFormatProperties(
    VulkanHandleMapping* handlemap,
    VkSamplerYcbcrConversionImageFormatProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorUpdateTemplateEntry(
    VulkanHandleMapping* handlemap,
    VkDescriptorUpdateTemplateEntry* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDescriptorUpdateTemplateCreateInfo(
    VulkanHandleMapping* handlemap,
    VkDescriptorUpdateTemplateCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pDescriptorUpdateEntries)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->descriptorUpdateEntryCount; ++i)
            {
                handlemap_VkDescriptorUpdateTemplateEntry(handlemap, (VkDescriptorUpdateTemplateEntry*)(toMap->pDescriptorUpdateEntries + i));
            }
        }
    }
    handlemap->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)&toMap->descriptorSetLayout);
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->pipelineLayout);
}

void handlemap_VkExternalMemoryProperties(
    VulkanHandleMapping* handlemap,
    VkExternalMemoryProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceExternalImageFormatInfo(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceExternalImageFormatInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalImageFormatProperties(
    VulkanHandleMapping* handlemap,
    VkExternalImageFormatProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExternalMemoryProperties(handlemap, (VkExternalMemoryProperties*)(&toMap->externalMemoryProperties));
}

void handlemap_VkPhysicalDeviceExternalBufferInfo(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceExternalBufferInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalBufferProperties(
    VulkanHandleMapping* handlemap,
    VkExternalBufferProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExternalMemoryProperties(handlemap, (VkExternalMemoryProperties*)(&toMap->externalMemoryProperties));
}

void handlemap_VkPhysicalDeviceIDProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceIDProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalMemoryImageCreateInfo(
    VulkanHandleMapping* handlemap,
    VkExternalMemoryImageCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalMemoryBufferCreateInfo(
    VulkanHandleMapping* handlemap,
    VkExternalMemoryBufferCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMemoryAllocateInfo(
    VulkanHandleMapping* handlemap,
    VkExportMemoryAllocateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceExternalFenceInfo(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceExternalFenceInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalFenceProperties(
    VulkanHandleMapping* handlemap,
    VkExternalFenceProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportFenceCreateInfo(
    VulkanHandleMapping* handlemap,
    VkExportFenceCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportSemaphoreCreateInfo(
    VulkanHandleMapping* handlemap,
    VkExportSemaphoreCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceExternalSemaphoreInfo(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceExternalSemaphoreInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalSemaphoreProperties(
    VulkanHandleMapping* handlemap,
    VkExternalSemaphoreProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMaintenance3Properties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceMaintenance3Properties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorSetLayoutSupport(
    VulkanHandleMapping* handlemap,
    VkDescriptorSetLayoutSupport* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderDrawParametersFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderDrawParametersFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_VERSION_1_2
void handlemap_VkPhysicalDeviceVulkan11Features(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceVulkan11Features* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceVulkan11Properties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceVulkan11Properties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceVulkan12Features(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceVulkan12Features* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkConformanceVersion(
    VulkanHandleMapping* handlemap,
    VkConformanceVersion* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceVulkan12Properties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceVulkan12Properties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkConformanceVersion(handlemap, (VkConformanceVersion*)(&toMap->conformanceVersion));
}

void handlemap_VkImageFormatListCreateInfo(
    VulkanHandleMapping* handlemap,
    VkImageFormatListCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAttachmentDescription2(
    VulkanHandleMapping* handlemap,
    VkAttachmentDescription2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAttachmentReference2(
    VulkanHandleMapping* handlemap,
    VkAttachmentReference2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSubpassDescription2(
    VulkanHandleMapping* handlemap,
    VkSubpassDescription2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pInputAttachments)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->inputAttachmentCount; ++i)
            {
                handlemap_VkAttachmentReference2(handlemap, (VkAttachmentReference2*)(toMap->pInputAttachments + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pColorAttachments)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorAttachmentCount; ++i)
            {
                handlemap_VkAttachmentReference2(handlemap, (VkAttachmentReference2*)(toMap->pColorAttachments + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pResolveAttachments)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorAttachmentCount; ++i)
            {
                handlemap_VkAttachmentReference2(handlemap, (VkAttachmentReference2*)(toMap->pResolveAttachments + i));
            }
        }
    }
    if (toMap->pDepthStencilAttachment)
    {
        handlemap_VkAttachmentReference2(handlemap, (VkAttachmentReference2*)(toMap->pDepthStencilAttachment));
    }
}

void handlemap_VkSubpassDependency2(
    VulkanHandleMapping* handlemap,
    VkSubpassDependency2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRenderPassCreateInfo2(
    VulkanHandleMapping* handlemap,
    VkRenderPassCreateInfo2* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pAttachments)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->attachmentCount; ++i)
            {
                handlemap_VkAttachmentDescription2(handlemap, (VkAttachmentDescription2*)(toMap->pAttachments + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pSubpasses)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->subpassCount; ++i)
            {
                handlemap_VkSubpassDescription2(handlemap, (VkSubpassDescription2*)(toMap->pSubpasses + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pDependencies)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->dependencyCount; ++i)
            {
                handlemap_VkSubpassDependency2(handlemap, (VkSubpassDependency2*)(toMap->pDependencies + i));
            }
        }
    }
}

void handlemap_VkSubpassBeginInfo(
    VulkanHandleMapping* handlemap,
    VkSubpassBeginInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSubpassEndInfo(
    VulkanHandleMapping* handlemap,
    VkSubpassEndInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevice8BitStorageFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevice8BitStorageFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDriverProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceDriverProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkConformanceVersion(handlemap, (VkConformanceVersion*)(&toMap->conformanceVersion));
}

void handlemap_VkPhysicalDeviceShaderAtomicInt64Features(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderAtomicInt64Features* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderFloat16Int8Features(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderFloat16Int8Features* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceFloatControlsProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceFloatControlsProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorSetLayoutBindingFlagsCreateInfo(
    VulkanHandleMapping* handlemap,
    VkDescriptorSetLayoutBindingFlagsCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDescriptorIndexingFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceDescriptorIndexingFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDescriptorIndexingProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceDescriptorIndexingProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorSetVariableDescriptorCountAllocateInfo(
    VulkanHandleMapping* handlemap,
    VkDescriptorSetVariableDescriptorCountAllocateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorSetVariableDescriptorCountLayoutSupport(
    VulkanHandleMapping* handlemap,
    VkDescriptorSetVariableDescriptorCountLayoutSupport* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSubpassDescriptionDepthStencilResolve(
    VulkanHandleMapping* handlemap,
    VkSubpassDescriptionDepthStencilResolve* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pDepthStencilResolveAttachment)
    {
        handlemap_VkAttachmentReference2(handlemap, (VkAttachmentReference2*)(toMap->pDepthStencilResolveAttachment));
    }
}

void handlemap_VkPhysicalDeviceDepthStencilResolveProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceDepthStencilResolveProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceScalarBlockLayoutFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceScalarBlockLayoutFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImageStencilUsageCreateInfo(
    VulkanHandleMapping* handlemap,
    VkImageStencilUsageCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSamplerReductionModeCreateInfo(
    VulkanHandleMapping* handlemap,
    VkSamplerReductionModeCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceSamplerFilterMinmaxProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceSamplerFilterMinmaxProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceVulkanMemoryModelFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceVulkanMemoryModelFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceImagelessFramebufferFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceImagelessFramebufferFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFramebufferAttachmentImageInfo(
    VulkanHandleMapping* handlemap,
    VkFramebufferAttachmentImageInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFramebufferAttachmentsCreateInfo(
    VulkanHandleMapping* handlemap,
    VkFramebufferAttachmentsCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pAttachmentImageInfos)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->attachmentImageInfoCount; ++i)
            {
                handlemap_VkFramebufferAttachmentImageInfo(handlemap, (VkFramebufferAttachmentImageInfo*)(toMap->pAttachmentImageInfos + i));
            }
        }
    }
}

void handlemap_VkRenderPassAttachmentBeginInfo(
    VulkanHandleMapping* handlemap,
    VkRenderPassAttachmentBeginInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pAttachments)
    {
        handlemap->mapHandles_VkImageView((VkImageView*)toMap->pAttachments, toMap->attachmentCount);
    }
}

void handlemap_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceUniformBufferStandardLayoutFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAttachmentReferenceStencilLayout(
    VulkanHandleMapping* handlemap,
    VkAttachmentReferenceStencilLayout* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAttachmentDescriptionStencilLayout(
    VulkanHandleMapping* handlemap,
    VkAttachmentDescriptionStencilLayout* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceHostQueryResetFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceHostQueryResetFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceTimelineSemaphoreFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceTimelineSemaphoreFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceTimelineSemaphoreProperties(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceTimelineSemaphoreProperties* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSemaphoreTypeCreateInfo(
    VulkanHandleMapping* handlemap,
    VkSemaphoreTypeCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkTimelineSemaphoreSubmitInfo(
    VulkanHandleMapping* handlemap,
    VkTimelineSemaphoreSubmitInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSemaphoreWaitInfo(
    VulkanHandleMapping* handlemap,
    VkSemaphoreWaitInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pSemaphores)
    {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pSemaphores, toMap->semaphoreCount);
    }
}

void handlemap_VkSemaphoreSignalInfo(
    VulkanHandleMapping* handlemap,
    VkSemaphoreSignalInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

void handlemap_VkPhysicalDeviceBufferDeviceAddressFeatures(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceBufferDeviceAddressFeatures* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferDeviceAddressInfo(
    VulkanHandleMapping* handlemap,
    VkBufferDeviceAddressInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkBufferOpaqueCaptureAddressCreateInfo(
    VulkanHandleMapping* handlemap,
    VkBufferOpaqueCaptureAddressCreateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryOpaqueCaptureAddressAllocateInfo(
    VulkanHandleMapping* handlemap,
    VkMemoryOpaqueCaptureAddressAllocateInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceMemoryOpaqueCaptureAddressInfo(
    VulkanHandleMapping* handlemap,
    VkDeviceMemoryOpaqueCaptureAddressInfo* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

#endif
#ifdef VK_KHR_surface
void handlemap_VkSurfaceCapabilitiesKHR(
    VulkanHandleMapping* handlemap,
    VkSurfaceCapabilitiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->currentExtent));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->minImageExtent));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxImageExtent));
}

void handlemap_VkSurfaceFormatKHR(
    VulkanHandleMapping* handlemap,
    VkSurfaceFormatKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
}

#endif
#ifdef VK_KHR_swapchain
void handlemap_VkSwapchainCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkSwapchainCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSurfaceKHR((VkSurfaceKHR*)&toMap->surface);
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->imageExtent));
    handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&toMap->oldSwapchain);
}

void handlemap_VkPresentInfoKHR(
    VulkanHandleMapping* handlemap,
    VkPresentInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pWaitSemaphores)
    {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pWaitSemaphores, toMap->waitSemaphoreCount);
    }
    if (toMap->pSwapchains)
    {
        handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)toMap->pSwapchains, toMap->swapchainCount);
    }
}

void handlemap_VkImageSwapchainCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkImageSwapchainCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&toMap->swapchain);
}

void handlemap_VkBindImageMemorySwapchainInfoKHR(
    VulkanHandleMapping* handlemap,
    VkBindImageMemorySwapchainInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&toMap->swapchain);
}

void handlemap_VkAcquireNextImageInfoKHR(
    VulkanHandleMapping* handlemap,
    VkAcquireNextImageInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&toMap->swapchain);
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
    handlemap->mapHandles_VkFence((VkFence*)&toMap->fence);
}

void handlemap_VkDeviceGroupPresentCapabilitiesKHR(
    VulkanHandleMapping* handlemap,
    VkDeviceGroupPresentCapabilitiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupPresentInfoKHR(
    VulkanHandleMapping* handlemap,
    VkDeviceGroupPresentInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupSwapchainCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkDeviceGroupSwapchainCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_display
void handlemap_VkDisplayModeParametersKHR(
    VulkanHandleMapping* handlemap,
    VkDisplayModeParametersKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->visibleRegion));
}

void handlemap_VkDisplayModeCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkDisplayModeCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDisplayModeParametersKHR(handlemap, (VkDisplayModeParametersKHR*)(&toMap->parameters));
}

void handlemap_VkDisplayModePropertiesKHR(
    VulkanHandleMapping* handlemap,
    VkDisplayModePropertiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkDisplayModeKHR((VkDisplayModeKHR*)&toMap->displayMode);
    handlemap_VkDisplayModeParametersKHR(handlemap, (VkDisplayModeParametersKHR*)(&toMap->parameters));
}

void handlemap_VkDisplayPlaneCapabilitiesKHR(
    VulkanHandleMapping* handlemap,
    VkDisplayPlaneCapabilitiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->minSrcPosition));
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->maxSrcPosition));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->minSrcExtent));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxSrcExtent));
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->minDstPosition));
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->maxDstPosition));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->minDstExtent));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxDstExtent));
}

void handlemap_VkDisplayPlanePropertiesKHR(
    VulkanHandleMapping* handlemap,
    VkDisplayPlanePropertiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkDisplayKHR((VkDisplayKHR*)&toMap->currentDisplay);
}

void handlemap_VkDisplayPropertiesKHR(
    VulkanHandleMapping* handlemap,
    VkDisplayPropertiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkDisplayKHR((VkDisplayKHR*)&toMap->display);
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->physicalDimensions));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->physicalResolution));
}

void handlemap_VkDisplaySurfaceCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkDisplaySurfaceCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDisplayModeKHR((VkDisplayModeKHR*)&toMap->displayMode);
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->imageExtent));
}

#endif
#ifdef VK_KHR_display_swapchain
void handlemap_VkDisplayPresentInfoKHR(
    VulkanHandleMapping* handlemap,
    VkDisplayPresentInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkRect2D(handlemap, (VkRect2D*)(&toMap->srcRect));
    handlemap_VkRect2D(handlemap, (VkRect2D*)(&toMap->dstRect));
}

#endif
#ifdef VK_KHR_xlib_surface
void handlemap_VkXlibSurfaceCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkXlibSurfaceCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_xcb_surface
void handlemap_VkXcbSurfaceCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkXcbSurfaceCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_wayland_surface
void handlemap_VkWaylandSurfaceCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkWaylandSurfaceCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_android_surface
void handlemap_VkAndroidSurfaceCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkAndroidSurfaceCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_win32_surface
void handlemap_VkWin32SurfaceCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkWin32SurfaceCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_device_group
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_device_group_creation
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void handlemap_VkImportMemoryWin32HandleInfoKHR(
    VulkanHandleMapping* handlemap,
    VkImportMemoryWin32HandleInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMemoryWin32HandleInfoKHR(
    VulkanHandleMapping* handlemap,
    VkExportMemoryWin32HandleInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryWin32HandlePropertiesKHR(
    VulkanHandleMapping* handlemap,
    VkMemoryWin32HandlePropertiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryGetWin32HandleInfoKHR(
    VulkanHandleMapping* handlemap,
    VkMemoryGetWin32HandleInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

#endif
#ifdef VK_KHR_external_memory_fd
void handlemap_VkImportMemoryFdInfoKHR(
    VulkanHandleMapping* handlemap,
    VkImportMemoryFdInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryFdPropertiesKHR(
    VulkanHandleMapping* handlemap,
    VkMemoryFdPropertiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryGetFdInfoKHR(
    VulkanHandleMapping* handlemap,
    VkMemoryGetFdInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void handlemap_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    VulkanHandleMapping* handlemap,
    VkWin32KeyedMutexAcquireReleaseInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pAcquireSyncs)
    {
        handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)toMap->pAcquireSyncs, toMap->acquireCount);
    }
    if (toMap->pReleaseSyncs)
    {
        handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)toMap->pReleaseSyncs, toMap->releaseCount);
    }
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void handlemap_VkImportSemaphoreWin32HandleInfoKHR(
    VulkanHandleMapping* handlemap,
    VkImportSemaphoreWin32HandleInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

void handlemap_VkExportSemaphoreWin32HandleInfoKHR(
    VulkanHandleMapping* handlemap,
    VkExportSemaphoreWin32HandleInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkD3D12FenceSubmitInfoKHR(
    VulkanHandleMapping* handlemap,
    VkD3D12FenceSubmitInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSemaphoreGetWin32HandleInfoKHR(
    VulkanHandleMapping* handlemap,
    VkSemaphoreGetWin32HandleInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void handlemap_VkImportSemaphoreFdInfoKHR(
    VulkanHandleMapping* handlemap,
    VkImportSemaphoreFdInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

void handlemap_VkSemaphoreGetFdInfoKHR(
    VulkanHandleMapping* handlemap,
    VkSemaphoreGetFdInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

#endif
#ifdef VK_KHR_push_descriptor
void handlemap_VkPhysicalDevicePushDescriptorPropertiesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevicePushDescriptorPropertiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void handlemap_VkRectLayerKHR(
    VulkanHandleMapping* handlemap,
    VkRectLayerKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->offset));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->extent));
}

void handlemap_VkPresentRegionKHR(
    VulkanHandleMapping* handlemap,
    VkPresentRegionKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap)
    {
        if (toMap->pRectangles)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->rectangleCount; ++i)
            {
                handlemap_VkRectLayerKHR(handlemap, (VkRectLayerKHR*)(toMap->pRectangles + i));
            }
        }
    }
}

void handlemap_VkPresentRegionsKHR(
    VulkanHandleMapping* handlemap,
    VkPresentRegionsKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pRegions)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->swapchainCount; ++i)
            {
                handlemap_VkPresentRegionKHR(handlemap, (VkPresentRegionKHR*)(toMap->pRegions + i));
            }
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_imageless_framebuffer
#endif
#ifdef VK_KHR_create_renderpass2
#endif
#ifdef VK_KHR_shared_presentable_image
void handlemap_VkSharedPresentSurfaceCapabilitiesKHR(
    VulkanHandleMapping* handlemap,
    VkSharedPresentSurfaceCapabilitiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void handlemap_VkImportFenceWin32HandleInfoKHR(
    VulkanHandleMapping* handlemap,
    VkImportFenceWin32HandleInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkFence((VkFence*)&toMap->fence);
}

void handlemap_VkExportFenceWin32HandleInfoKHR(
    VulkanHandleMapping* handlemap,
    VkExportFenceWin32HandleInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFenceGetWin32HandleInfoKHR(
    VulkanHandleMapping* handlemap,
    VkFenceGetWin32HandleInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkFence((VkFence*)&toMap->fence);
}

#endif
#ifdef VK_KHR_external_fence_fd
void handlemap_VkImportFenceFdInfoKHR(
    VulkanHandleMapping* handlemap,
    VkImportFenceFdInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkFence((VkFence*)&toMap->fence);
}

void handlemap_VkFenceGetFdInfoKHR(
    VulkanHandleMapping* handlemap,
    VkFenceGetFdInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkFence((VkFence*)&toMap->fence);
}

#endif
#ifdef VK_KHR_performance_query
void handlemap_VkPhysicalDevicePerformanceQueryFeaturesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevicePerformanceQueryFeaturesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePerformanceQueryPropertiesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevicePerformanceQueryPropertiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceCounterKHR(
    VulkanHandleMapping* handlemap,
    VkPerformanceCounterKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceCounterDescriptionKHR(
    VulkanHandleMapping* handlemap,
    VkPerformanceCounterDescriptionKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkQueryPoolPerformanceCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkQueryPoolPerformanceCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceCounterResultKHR(
    VulkanHandleMapping* handlemap,
    VkPerformanceCounterResultKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAcquireProfilingLockInfoKHR(
    VulkanHandleMapping* handlemap,
    VkAcquireProfilingLockInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceQuerySubmitInfoKHR(
    VulkanHandleMapping* handlemap,
    VkPerformanceQuerySubmitInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void handlemap_VkPhysicalDeviceSurfaceInfo2KHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceSurfaceInfo2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSurfaceKHR((VkSurfaceKHR*)&toMap->surface);
}

void handlemap_VkSurfaceCapabilities2KHR(
    VulkanHandleMapping* handlemap,
    VkSurfaceCapabilities2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSurfaceCapabilitiesKHR(handlemap, (VkSurfaceCapabilitiesKHR*)(&toMap->surfaceCapabilities));
}

void handlemap_VkSurfaceFormat2KHR(
    VulkanHandleMapping* handlemap,
    VkSurfaceFormat2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSurfaceFormatKHR(handlemap, (VkSurfaceFormatKHR*)(&toMap->surfaceFormat));
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void handlemap_VkDisplayProperties2KHR(
    VulkanHandleMapping* handlemap,
    VkDisplayProperties2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDisplayPropertiesKHR(handlemap, (VkDisplayPropertiesKHR*)(&toMap->displayProperties));
}

void handlemap_VkDisplayPlaneProperties2KHR(
    VulkanHandleMapping* handlemap,
    VkDisplayPlaneProperties2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDisplayPlanePropertiesKHR(handlemap, (VkDisplayPlanePropertiesKHR*)(&toMap->displayPlaneProperties));
}

void handlemap_VkDisplayModeProperties2KHR(
    VulkanHandleMapping* handlemap,
    VkDisplayModeProperties2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDisplayModePropertiesKHR(handlemap, (VkDisplayModePropertiesKHR*)(&toMap->displayModeProperties));
}

void handlemap_VkDisplayPlaneInfo2KHR(
    VulkanHandleMapping* handlemap,
    VkDisplayPlaneInfo2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDisplayModeKHR((VkDisplayModeKHR*)&toMap->mode);
}

void handlemap_VkDisplayPlaneCapabilities2KHR(
    VulkanHandleMapping* handlemap,
    VkDisplayPlaneCapabilities2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDisplayPlaneCapabilitiesKHR(handlemap, (VkDisplayPlaneCapabilitiesKHR*)(&toMap->capabilities));
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_portability_subset
void handlemap_VkPhysicalDevicePortabilitySubsetFeaturesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevicePortabilitySubsetFeaturesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePortabilitySubsetPropertiesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevicePortabilitySubsetPropertiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_draw_indirect_count
#endif
#ifdef VK_KHR_shader_subgroup_extended_types
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_KHR_shader_atomic_int64
#endif
#ifdef VK_KHR_shader_clock
void handlemap_VkPhysicalDeviceShaderClockFeaturesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderClockFeaturesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_driver_properties
#endif
#ifdef VK_KHR_shader_float_controls
#endif
#ifdef VK_KHR_depth_stencil_resolve
#endif
#ifdef VK_KHR_swapchain_mutable_format
#endif
#ifdef VK_KHR_timeline_semaphore
#endif
#ifdef VK_KHR_vulkan_memory_model
#endif
#ifdef VK_KHR_shader_terminate_invocation
void handlemap_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_fragment_shading_rate
void handlemap_VkFragmentShadingRateAttachmentInfoKHR(
    VulkanHandleMapping* handlemap,
    VkFragmentShadingRateAttachmentInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pFragmentShadingRateAttachment)
    {
        handlemap_VkAttachmentReference2(handlemap, (VkAttachmentReference2*)(toMap->pFragmentShadingRateAttachment));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->shadingRateAttachmentTexelSize));
}

void handlemap_VkPipelineFragmentShadingRateStateCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkPipelineFragmentShadingRateStateCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->fragmentSize));
}

void handlemap_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceFragmentShadingRateFeaturesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceFragmentShadingRatePropertiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->minFragmentShadingRateAttachmentTexelSize));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxFragmentShadingRateAttachmentTexelSize));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxFragmentSize));
}

void handlemap_VkPhysicalDeviceFragmentShadingRateKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceFragmentShadingRateKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->fragmentSize));
}

#endif
#ifdef VK_KHR_spirv_1_4
#endif
#ifdef VK_KHR_surface_protected_capabilities
void handlemap_VkSurfaceProtectedCapabilitiesKHR(
    VulkanHandleMapping* handlemap,
    VkSurfaceProtectedCapabilitiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_separate_depth_stencil_layouts
#endif
#ifdef VK_KHR_uniform_buffer_standard_layout
#endif
#ifdef VK_KHR_buffer_device_address
#endif
#ifdef VK_KHR_deferred_host_operations
#endif
#ifdef VK_KHR_pipeline_executable_properties
void handlemap_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineInfoKHR(
    VulkanHandleMapping* handlemap,
    VkPipelineInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->pipeline);
}

void handlemap_VkPipelineExecutablePropertiesKHR(
    VulkanHandleMapping* handlemap,
    VkPipelineExecutablePropertiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineExecutableInfoKHR(
    VulkanHandleMapping* handlemap,
    VkPipelineExecutableInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->pipeline);
}

void handlemap_VkPipelineExecutableStatisticValueKHR(
    VulkanHandleMapping* handlemap,
    VkPipelineExecutableStatisticValueKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineExecutableStatisticKHR(
    VulkanHandleMapping* handlemap,
    VkPipelineExecutableStatisticKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPipelineExecutableStatisticValueKHR(handlemap, (VkPipelineExecutableStatisticValueKHR*)(&toMap->value));
}

void handlemap_VkPipelineExecutableInternalRepresentationKHR(
    VulkanHandleMapping* handlemap,
    VkPipelineExecutableInternalRepresentationKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_pipeline_library
void handlemap_VkPipelineLibraryCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkPipelineLibraryCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pLibraries)
    {
        handlemap->mapHandles_VkPipeline((VkPipeline*)toMap->pLibraries, toMap->libraryCount);
    }
}

#endif
#ifdef VK_KHR_shader_non_semantic_info
#endif
#ifdef VK_KHR_copy_commands2
void handlemap_VkBufferCopy2KHR(
    VulkanHandleMapping* handlemap,
    VkBufferCopy2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCopyBufferInfo2KHR(
    VulkanHandleMapping* handlemap,
    VkCopyBufferInfo2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->srcBuffer);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->dstBuffer);
    if (toMap)
    {
        if (toMap->pRegions)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i)
            {
                handlemap_VkBufferCopy2KHR(handlemap, (VkBufferCopy2KHR*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkImageCopy2KHR(
    VulkanHandleMapping* handlemap,
    VkImageCopy2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresourceLayers(handlemap, (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->srcOffset));
    handlemap_VkImageSubresourceLayers(handlemap, (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->dstOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkCopyImageInfo2KHR(
    VulkanHandleMapping* handlemap,
    VkCopyImageInfo2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->srcImage);
    handlemap->mapHandles_VkImage((VkImage*)&toMap->dstImage);
    if (toMap)
    {
        if (toMap->pRegions)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i)
            {
                handlemap_VkImageCopy2KHR(handlemap, (VkImageCopy2KHR*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkBufferImageCopy2KHR(
    VulkanHandleMapping* handlemap,
    VkBufferImageCopy2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresourceLayers(handlemap, (VkImageSubresourceLayers*)(&toMap->imageSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->imageOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->imageExtent));
}

void handlemap_VkCopyBufferToImageInfo2KHR(
    VulkanHandleMapping* handlemap,
    VkCopyBufferToImageInfo2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->srcBuffer);
    handlemap->mapHandles_VkImage((VkImage*)&toMap->dstImage);
    if (toMap)
    {
        if (toMap->pRegions)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i)
            {
                handlemap_VkBufferImageCopy2KHR(handlemap, (VkBufferImageCopy2KHR*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkCopyImageToBufferInfo2KHR(
    VulkanHandleMapping* handlemap,
    VkCopyImageToBufferInfo2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->srcImage);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->dstBuffer);
    if (toMap)
    {
        if (toMap->pRegions)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i)
            {
                handlemap_VkBufferImageCopy2KHR(handlemap, (VkBufferImageCopy2KHR*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkImageBlit2KHR(
    VulkanHandleMapping* handlemap,
    VkImageBlit2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresourceLayers(handlemap, (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        handlemap_VkOffset3D(handlemap, (VkOffset3D*)(toMap->srcOffsets + i));
    }
    handlemap_VkImageSubresourceLayers(handlemap, (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        handlemap_VkOffset3D(handlemap, (VkOffset3D*)(toMap->dstOffsets + i));
    }
}

void handlemap_VkBlitImageInfo2KHR(
    VulkanHandleMapping* handlemap,
    VkBlitImageInfo2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->srcImage);
    handlemap->mapHandles_VkImage((VkImage*)&toMap->dstImage);
    if (toMap)
    {
        if (toMap->pRegions)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i)
            {
                handlemap_VkImageBlit2KHR(handlemap, (VkImageBlit2KHR*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkImageResolve2KHR(
    VulkanHandleMapping* handlemap,
    VkImageResolve2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresourceLayers(handlemap, (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->srcOffset));
    handlemap_VkImageSubresourceLayers(handlemap, (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->dstOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkResolveImageInfo2KHR(
    VulkanHandleMapping* handlemap,
    VkResolveImageInfo2KHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->srcImage);
    handlemap->mapHandles_VkImage((VkImage*)&toMap->dstImage);
    if (toMap)
    {
        if (toMap->pRegions)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i)
            {
                handlemap_VkImageResolve2KHR(handlemap, (VkImageResolve2KHR*)(toMap->pRegions + i));
            }
        }
    }
}

#endif
#ifdef VK_ANDROID_native_buffer
void handlemap_VkNativeBufferANDROID(
    VulkanHandleMapping* handlemap,
    VkNativeBufferANDROID* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_debug_report
void handlemap_VkDebugReportCallbackCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDebugReportCallbackCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void handlemap_VkPipelineRasterizationStateRasterizationOrderAMD(
    VulkanHandleMapping* handlemap,
    VkPipelineRasterizationStateRasterizationOrderAMD* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void handlemap_VkDebugMarkerObjectNameInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDebugMarkerObjectNameInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDebugMarkerObjectTagInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDebugMarkerObjectTagInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDebugMarkerMarkerInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDebugMarkerMarkerInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void handlemap_VkDedicatedAllocationImageCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkDedicatedAllocationImageCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDedicatedAllocationBufferCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkDedicatedAllocationBufferCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDedicatedAllocationMemoryAllocateInfoNV(
    VulkanHandleMapping* handlemap,
    VkDedicatedAllocationMemoryAllocateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

#endif
#ifdef VK_EXT_transform_feedback
void handlemap_VkPhysicalDeviceTransformFeedbackFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceTransformFeedbackFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceTransformFeedbackPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceTransformFeedbackPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRasterizationStateStreamCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPipelineRasterizationStateStreamCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NVX_image_view_handle
void handlemap_VkImageViewHandleInfoNVX(
    VulkanHandleMapping* handlemap,
    VkImageViewHandleInfoNVX* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->imageView);
    handlemap->mapHandles_VkSampler((VkSampler*)&toMap->sampler);
}

void handlemap_VkImageViewAddressPropertiesNVX(
    VulkanHandleMapping* handlemap,
    VkImageViewAddressPropertiesNVX* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_draw_indirect_count
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
void handlemap_VkTextureLODGatherFormatPropertiesAMD(
    VulkanHandleMapping* handlemap,
    VkTextureLODGatherFormatPropertiesAMD* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_shader_info
void handlemap_VkShaderResourceUsageAMD(
    VulkanHandleMapping* handlemap,
    VkShaderResourceUsageAMD* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkShaderStatisticsInfoAMD(
    VulkanHandleMapping* handlemap,
    VkShaderStatisticsInfoAMD* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkShaderResourceUsageAMD(handlemap, (VkShaderResourceUsageAMD*)(&toMap->resourceUsage));
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_GGP_stream_descriptor_surface
void handlemap_VkStreamDescriptorSurfaceCreateInfoGGP(
    VulkanHandleMapping* handlemap,
    VkStreamDescriptorSurfaceCreateInfoGGP* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_corner_sampled_image
void handlemap_VkPhysicalDeviceCornerSampledImageFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceCornerSampledImageFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void handlemap_VkExternalImageFormatPropertiesNV(
    VulkanHandleMapping* handlemap,
    VkExternalImageFormatPropertiesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageFormatProperties(handlemap, (VkImageFormatProperties*)(&toMap->imageFormatProperties));
}

#endif
#ifdef VK_NV_external_memory
void handlemap_VkExternalMemoryImageCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkExternalMemoryImageCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMemoryAllocateInfoNV(
    VulkanHandleMapping* handlemap,
    VkExportMemoryAllocateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_external_memory_win32
void handlemap_VkImportMemoryWin32HandleInfoNV(
    VulkanHandleMapping* handlemap,
    VkImportMemoryWin32HandleInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMemoryWin32HandleInfoNV(
    VulkanHandleMapping* handlemap,
    VkExportMemoryWin32HandleInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void handlemap_VkWin32KeyedMutexAcquireReleaseInfoNV(
    VulkanHandleMapping* handlemap,
    VkWin32KeyedMutexAcquireReleaseInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pAcquireSyncs)
    {
        handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)toMap->pAcquireSyncs, toMap->acquireCount);
    }
    if (toMap->pReleaseSyncs)
    {
        handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)toMap->pReleaseSyncs, toMap->releaseCount);
    }
}

#endif
#ifdef VK_EXT_validation_flags
void handlemap_VkValidationFlagsEXT(
    VulkanHandleMapping* handlemap,
    VkValidationFlagsEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NN_vi_surface
void handlemap_VkViSurfaceCreateInfoNN(
    VulkanHandleMapping* handlemap,
    VkViSurfaceCreateInfoNN* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
void handlemap_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_astc_decode_mode
void handlemap_VkImageViewASTCDecodeModeEXT(
    VulkanHandleMapping* handlemap,
    VkImageViewASTCDecodeModeEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceASTCDecodeFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceASTCDecodeFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_conditional_rendering
void handlemap_VkConditionalRenderingBeginInfoEXT(
    VulkanHandleMapping* handlemap,
    VkConditionalRenderingBeginInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceConditionalRenderingFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    VulkanHandleMapping* handlemap,
    VkCommandBufferInheritanceConditionalRenderingInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void handlemap_VkViewportWScalingNV(
    VulkanHandleMapping* handlemap,
    VkViewportWScalingNV* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineViewportWScalingStateCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkPipelineViewportWScalingStateCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pViewportWScalings)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->viewportCount; ++i)
            {
                handlemap_VkViewportWScalingNV(handlemap, (VkViewportWScalingNV*)(toMap->pViewportWScalings + i));
            }
        }
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
#endif
#ifdef VK_EXT_acquire_xlib_display
#endif
#ifdef VK_EXT_display_surface_counter
void handlemap_VkSurfaceCapabilities2EXT(
    VulkanHandleMapping* handlemap,
    VkSurfaceCapabilities2EXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->currentExtent));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->minImageExtent));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxImageExtent));
}

#endif
#ifdef VK_EXT_display_control
void handlemap_VkDisplayPowerInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDisplayPowerInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceEventInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDeviceEventInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDisplayEventInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDisplayEventInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSwapchainCounterCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkSwapchainCounterCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_GOOGLE_display_timing
void handlemap_VkRefreshCycleDurationGOOGLE(
    VulkanHandleMapping* handlemap,
    VkRefreshCycleDurationGOOGLE* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPastPresentationTimingGOOGLE(
    VulkanHandleMapping* handlemap,
    VkPastPresentationTimingGOOGLE* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPresentTimeGOOGLE(
    VulkanHandleMapping* handlemap,
    VkPresentTimeGOOGLE* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPresentTimesInfoGOOGLE(
    VulkanHandleMapping* handlemap,
    VkPresentTimesInfoGOOGLE* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pTimes)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->swapchainCount; ++i)
            {
                handlemap_VkPresentTimeGOOGLE(handlemap, (VkPresentTimeGOOGLE*)(toMap->pTimes + i));
            }
        }
    }
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void handlemap_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_viewport_swizzle
void handlemap_VkViewportSwizzleNV(
    VulkanHandleMapping* handlemap,
    VkViewportSwizzleNV* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineViewportSwizzleStateCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkPipelineViewportSwizzleStateCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pViewportSwizzles)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->viewportCount; ++i)
            {
                handlemap_VkViewportSwizzleNV(handlemap, (VkViewportSwizzleNV*)(toMap->pViewportSwizzles + i));
            }
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void handlemap_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceDiscardRectanglePropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineDiscardRectangleStateCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPipelineDiscardRectangleStateCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pDiscardRectangles)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->discardRectangleCount; ++i)
            {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pDiscardRectangles + i));
            }
        }
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void handlemap_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceConservativeRasterizationPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPipelineRasterizationConservativeStateCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_depth_clip_enable
void handlemap_VkPhysicalDeviceDepthClipEnableFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceDepthClipEnableFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRasterizationDepthClipStateCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPipelineRasterizationDepthClipStateCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void handlemap_VkXYColorEXT(
    VulkanHandleMapping* handlemap,
    VkXYColorEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkHdrMetadataEXT(
    VulkanHandleMapping* handlemap,
    VkHdrMetadataEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkXYColorEXT(handlemap, (VkXYColorEXT*)(&toMap->displayPrimaryRed));
    handlemap_VkXYColorEXT(handlemap, (VkXYColorEXT*)(&toMap->displayPrimaryGreen));
    handlemap_VkXYColorEXT(handlemap, (VkXYColorEXT*)(&toMap->displayPrimaryBlue));
    handlemap_VkXYColorEXT(handlemap, (VkXYColorEXT*)(&toMap->whitePoint));
}

#endif
#ifdef VK_MVK_ios_surface
void handlemap_VkIOSSurfaceCreateInfoMVK(
    VulkanHandleMapping* handlemap,
    VkIOSSurfaceCreateInfoMVK* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_MVK_macos_surface
void handlemap_VkMacOSSurfaceCreateInfoMVK(
    VulkanHandleMapping* handlemap,
    VkMacOSSurfaceCreateInfoMVK* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_MVK_moltenvk
#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void handlemap_VkDebugUtilsLabelEXT(
    VulkanHandleMapping* handlemap,
    VkDebugUtilsLabelEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDebugUtilsObjectNameInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDebugUtilsObjectNameInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDebugUtilsMessengerCallbackDataEXT(
    VulkanHandleMapping* handlemap,
    VkDebugUtilsMessengerCallbackDataEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pQueueLabels)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->queueLabelCount; ++i)
            {
                handlemap_VkDebugUtilsLabelEXT(handlemap, (VkDebugUtilsLabelEXT*)(toMap->pQueueLabels + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pCmdBufLabels)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->cmdBufLabelCount; ++i)
            {
                handlemap_VkDebugUtilsLabelEXT(handlemap, (VkDebugUtilsLabelEXT*)(toMap->pCmdBufLabels + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pObjects)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->objectCount; ++i)
            {
                handlemap_VkDebugUtilsObjectNameInfoEXT(handlemap, (VkDebugUtilsObjectNameInfoEXT*)(toMap->pObjects + i));
            }
        }
    }
}

void handlemap_VkDebugUtilsMessengerCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDebugUtilsMessengerCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDebugUtilsObjectTagInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDebugUtilsObjectTagInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void handlemap_VkAndroidHardwareBufferUsageANDROID(
    VulkanHandleMapping* handlemap,
    VkAndroidHardwareBufferUsageANDROID* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAndroidHardwareBufferPropertiesANDROID(
    VulkanHandleMapping* handlemap,
    VkAndroidHardwareBufferPropertiesANDROID* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAndroidHardwareBufferFormatPropertiesANDROID(
    VulkanHandleMapping* handlemap,
    VkAndroidHardwareBufferFormatPropertiesANDROID* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkComponentMapping(handlemap, (VkComponentMapping*)(&toMap->samplerYcbcrConversionComponents));
}

void handlemap_VkImportAndroidHardwareBufferInfoANDROID(
    VulkanHandleMapping* handlemap,
    VkImportAndroidHardwareBufferInfoANDROID* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    VulkanHandleMapping* handlemap,
    VkMemoryGetAndroidHardwareBufferInfoANDROID* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkExternalFormatANDROID(
    VulkanHandleMapping* handlemap,
    VkExternalFormatANDROID* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_inline_uniform_block
void handlemap_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceInlineUniformBlockFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceInlineUniformBlockPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkWriteDescriptorSetInlineUniformBlockEXT(
    VulkanHandleMapping* handlemap,
    VkWriteDescriptorSetInlineUniformBlockEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDescriptorPoolInlineUniformBlockCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void handlemap_VkSampleLocationEXT(
    VulkanHandleMapping* handlemap,
    VkSampleLocationEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSampleLocationsInfoEXT(
    VulkanHandleMapping* handlemap,
    VkSampleLocationsInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->sampleLocationGridSize));
    if (toMap)
    {
        if (toMap->pSampleLocations)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->sampleLocationsCount; ++i)
            {
                handlemap_VkSampleLocationEXT(handlemap, (VkSampleLocationEXT*)(toMap->pSampleLocations + i));
            }
        }
    }
}

void handlemap_VkAttachmentSampleLocationsEXT(
    VulkanHandleMapping* handlemap,
    VkAttachmentSampleLocationsEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkSampleLocationsInfoEXT(handlemap, (VkSampleLocationsInfoEXT*)(&toMap->sampleLocationsInfo));
}

void handlemap_VkSubpassSampleLocationsEXT(
    VulkanHandleMapping* handlemap,
    VkSubpassSampleLocationsEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkSampleLocationsInfoEXT(handlemap, (VkSampleLocationsInfoEXT*)(&toMap->sampleLocationsInfo));
}

void handlemap_VkRenderPassSampleLocationsBeginInfoEXT(
    VulkanHandleMapping* handlemap,
    VkRenderPassSampleLocationsBeginInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pAttachmentInitialSampleLocations)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->attachmentInitialSampleLocationsCount; ++i)
            {
                handlemap_VkAttachmentSampleLocationsEXT(handlemap, (VkAttachmentSampleLocationsEXT*)(toMap->pAttachmentInitialSampleLocations + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pPostSubpassSampleLocations)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->postSubpassSampleLocationsCount; ++i)
            {
                handlemap_VkSubpassSampleLocationsEXT(handlemap, (VkSubpassSampleLocationsEXT*)(toMap->pPostSubpassSampleLocations + i));
            }
        }
    }
}

void handlemap_VkPipelineSampleLocationsStateCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPipelineSampleLocationsStateCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSampleLocationsInfoEXT(handlemap, (VkSampleLocationsInfoEXT*)(&toMap->sampleLocationsInfo));
}

void handlemap_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceSampleLocationsPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxSampleLocationGridSize));
}

void handlemap_VkMultisamplePropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkMultisamplePropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxSampleLocationGridSize));
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void handlemap_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPipelineColorBlendAdvancedStateCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void handlemap_VkPipelineCoverageToColorStateCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkPipelineCoverageToColorStateCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void handlemap_VkPipelineCoverageModulationStateCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkPipelineCoverageModulationStateCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_NV_shader_sm_builtins
void handlemap_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_image_drm_format_modifier
void handlemap_VkDrmFormatModifierPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkDrmFormatModifierPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDrmFormatModifierPropertiesListEXT(
    VulkanHandleMapping* handlemap,
    VkDrmFormatModifierPropertiesListEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pDrmFormatModifierProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->drmFormatModifierCount; ++i)
            {
                handlemap_VkDrmFormatModifierPropertiesEXT(handlemap, (VkDrmFormatModifierPropertiesEXT*)(toMap->pDrmFormatModifierProperties + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceImageDrmFormatModifierInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImageDrmFormatModifierListCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkImageDrmFormatModifierListCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImageDrmFormatModifierExplicitCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkImageDrmFormatModifierExplicitCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pPlaneLayouts)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->drmFormatModifierPlaneCount; ++i)
            {
                handlemap_VkSubresourceLayout(handlemap, (VkSubresourceLayout*)(toMap->pPlaneLayouts + i));
            }
        }
    }
}

void handlemap_VkImageDrmFormatModifierPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkImageDrmFormatModifierPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_validation_cache
void handlemap_VkValidationCacheCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkValidationCacheCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkShaderModuleValidationCacheCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkShaderModuleValidationCacheCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkValidationCacheEXT((VkValidationCacheEXT*)&toMap->validationCache);
}

#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_NV_shading_rate_image
void handlemap_VkShadingRatePaletteNV(
    VulkanHandleMapping* handlemap,
    VkShadingRatePaletteNV* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineViewportShadingRateImageStateCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkPipelineViewportShadingRateImageStateCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pShadingRatePalettes)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->viewportCount; ++i)
            {
                handlemap_VkShadingRatePaletteNV(handlemap, (VkShadingRatePaletteNV*)(toMap->pShadingRatePalettes + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceShadingRateImageFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShadingRateImageFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShadingRateImagePropertiesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShadingRateImagePropertiesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->shadingRateTexelSize));
}

void handlemap_VkCoarseSampleLocationNV(
    VulkanHandleMapping* handlemap,
    VkCoarseSampleLocationNV* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkCoarseSampleOrderCustomNV(
    VulkanHandleMapping* handlemap,
    VkCoarseSampleOrderCustomNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap)
    {
        if (toMap->pSampleLocations)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->sampleLocationCount; ++i)
            {
                handlemap_VkCoarseSampleLocationNV(handlemap, (VkCoarseSampleLocationNV*)(toMap->pSampleLocations + i));
            }
        }
    }
}

void handlemap_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pCustomSampleOrders)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->customSampleOrderCount; ++i)
            {
                handlemap_VkCoarseSampleOrderCustomNV(handlemap, (VkCoarseSampleOrderCustomNV*)(toMap->pCustomSampleOrders + i));
            }
        }
    }
}

#endif
#ifdef VK_NV_ray_tracing
void handlemap_VkRayTracingShaderGroupCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkRayTracingShaderGroupCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRayTracingPipelineCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkRayTracingPipelineCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pStages)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->stageCount; ++i)
            {
                handlemap_VkPipelineShaderStageCreateInfo(handlemap, (VkPipelineShaderStageCreateInfo*)(toMap->pStages + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pGroups)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->groupCount; ++i)
            {
                handlemap_VkRayTracingShaderGroupCreateInfoNV(handlemap, (VkRayTracingShaderGroupCreateInfoNV*)(toMap->pGroups + i));
            }
        }
    }
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->layout);
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->basePipelineHandle);
}

void handlemap_VkGeometryTrianglesNV(
    VulkanHandleMapping* handlemap,
    VkGeometryTrianglesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->vertexData);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->indexData);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->transformData);
}

void handlemap_VkGeometryAABBNV(
    VulkanHandleMapping* handlemap,
    VkGeometryAABBNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->aabbData);
}

void handlemap_VkGeometryDataNV(
    VulkanHandleMapping* handlemap,
    VkGeometryDataNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkGeometryTrianglesNV(handlemap, (VkGeometryTrianglesNV*)(&toMap->triangles));
    handlemap_VkGeometryAABBNV(handlemap, (VkGeometryAABBNV*)(&toMap->aabbs));
}

void handlemap_VkGeometryNV(
    VulkanHandleMapping* handlemap,
    VkGeometryNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkGeometryDataNV(handlemap, (VkGeometryDataNV*)(&toMap->geometry));
}

void handlemap_VkAccelerationStructureInfoNV(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pGeometries)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->geometryCount; ++i)
            {
                handlemap_VkGeometryNV(handlemap, (VkGeometryNV*)(toMap->pGeometries + i));
            }
        }
    }
}

void handlemap_VkAccelerationStructureCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkAccelerationStructureInfoNV(handlemap, (VkAccelerationStructureInfoNV*)(&toMap->info));
}

void handlemap_VkBindAccelerationStructureMemoryInfoNV(
    VulkanHandleMapping* handlemap,
    VkBindAccelerationStructureMemoryInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkAccelerationStructureNV((VkAccelerationStructureNV*)&toMap->accelerationStructure);
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkWriteDescriptorSetAccelerationStructureNV(
    VulkanHandleMapping* handlemap,
    VkWriteDescriptorSetAccelerationStructureNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pAccelerationStructures)
    {
        handlemap->mapHandles_VkAccelerationStructureNV((VkAccelerationStructureNV*)toMap->pAccelerationStructures, toMap->accelerationStructureCount);
    }
}

void handlemap_VkAccelerationStructureMemoryRequirementsInfoNV(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureMemoryRequirementsInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkAccelerationStructureNV((VkAccelerationStructureNV*)&toMap->accelerationStructure);
}

void handlemap_VkPhysicalDeviceRayTracingPropertiesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceRayTracingPropertiesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkTransformMatrixKHR(
    VulkanHandleMapping* handlemap,
    VkTransformMatrixKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAabbPositionsKHR(
    VulkanHandleMapping* handlemap,
    VkAabbPositionsKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAccelerationStructureInstanceKHR(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureInstanceKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkTransformMatrixKHR(handlemap, (VkTransformMatrixKHR*)(&toMap->transform));
}

#endif
#ifdef VK_NV_representative_fragment_test
void handlemap_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkPipelineRepresentativeFragmentTestStateCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_filter_cubic
void handlemap_VkPhysicalDeviceImageViewImageFormatInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceImageViewImageFormatInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFilterCubicImageViewImageFormatPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkFilterCubicImageViewImageFormatPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_QCOM_render_pass_shader_resolve
#endif
#ifdef VK_EXT_global_priority
void handlemap_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDeviceQueueGlobalPriorityCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_external_memory_host
void handlemap_VkImportMemoryHostPointerInfoEXT(
    VulkanHandleMapping* handlemap,
    VkImportMemoryHostPointerInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryHostPointerPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkMemoryHostPointerPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceExternalMemoryHostPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_buffer_marker
#endif
#ifdef VK_AMD_pipeline_compiler_control
void handlemap_VkPipelineCompilerControlCreateInfoAMD(
    VulkanHandleMapping* handlemap,
    VkPipelineCompilerControlCreateInfoAMD* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_calibrated_timestamps
void handlemap_VkCalibratedTimestampInfoEXT(
    VulkanHandleMapping* handlemap,
    VkCalibratedTimestampInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_shader_core_properties
void handlemap_VkPhysicalDeviceShaderCorePropertiesAMD(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderCorePropertiesAMD* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_memory_overallocation_behavior
void handlemap_VkDeviceMemoryOverallocationCreateInfoAMD(
    VulkanHandleMapping* handlemap,
    VkDeviceMemoryOverallocationCreateInfoAMD* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void handlemap_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVertexInputBindingDivisorDescriptionEXT(
    VulkanHandleMapping* handlemap,
    VkVertexInputBindingDivisorDescriptionEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPipelineVertexInputDivisorStateCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pVertexBindingDivisors)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->vertexBindingDivisorCount; ++i)
            {
                handlemap_VkVertexInputBindingDivisorDescriptionEXT(handlemap, (VkVertexInputBindingDivisorDescriptionEXT*)(toMap->pVertexBindingDivisors + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_GGP_frame_token
void handlemap_VkPresentFrameTokenGGP(
    VulkanHandleMapping* handlemap,
    VkPresentFrameTokenGGP* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_pipeline_creation_feedback
void handlemap_VkPipelineCreationFeedbackEXT(
    VulkanHandleMapping* handlemap,
    VkPipelineCreationFeedbackEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineCreationFeedbackCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPipelineCreationFeedbackCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pPipelineCreationFeedback)
    {
        handlemap_VkPipelineCreationFeedbackEXT(handlemap, (VkPipelineCreationFeedbackEXT*)(toMap->pPipelineCreationFeedback));
    }
    if (toMap)
    {
        if (toMap->pPipelineStageCreationFeedbacks)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->pipelineStageCreationFeedbackCount; ++i)
            {
                handlemap_VkPipelineCreationFeedbackEXT(handlemap, (VkPipelineCreationFeedbackEXT*)(toMap->pPipelineStageCreationFeedbacks + i));
            }
        }
    }
}

#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_compute_shader_derivatives
void handlemap_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_mesh_shader
void handlemap_VkPhysicalDeviceMeshShaderFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceMeshShaderFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMeshShaderPropertiesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceMeshShaderPropertiesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDrawMeshTasksIndirectCommandNV(
    VulkanHandleMapping* handlemap,
    VkDrawMeshTasksIndirectCommandNV* toMap)
{
    (void)handlemap;
    (void)toMap;
}

#endif
#ifdef VK_NV_fragment_shader_barycentric
void handlemap_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_shader_image_footprint
void handlemap_VkPhysicalDeviceShaderImageFootprintFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderImageFootprintFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_scissor_exclusive
void handlemap_VkPipelineViewportExclusiveScissorStateCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkPipelineViewportExclusiveScissorStateCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pExclusiveScissors)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->exclusiveScissorCount; ++i)
            {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pExclusiveScissors + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceExclusiveScissorFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceExclusiveScissorFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void handlemap_VkQueueFamilyCheckpointPropertiesNV(
    VulkanHandleMapping* handlemap,
    VkQueueFamilyCheckpointPropertiesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCheckpointDataNV(
    VulkanHandleMapping* handlemap,
    VkCheckpointDataNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_INTEL_shader_integer_functions2
void handlemap_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_INTEL_performance_query
void handlemap_VkPerformanceValueDataINTEL(
    VulkanHandleMapping* handlemap,
    VkPerformanceValueDataINTEL* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPerformanceValueINTEL(
    VulkanHandleMapping* handlemap,
    VkPerformanceValueINTEL* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkPerformanceValueDataINTEL(handlemap, (VkPerformanceValueDataINTEL*)(&toMap->data));
}

void handlemap_VkInitializePerformanceApiInfoINTEL(
    VulkanHandleMapping* handlemap,
    VkInitializePerformanceApiInfoINTEL* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkQueryPoolPerformanceQueryCreateInfoINTEL(
    VulkanHandleMapping* handlemap,
    VkQueryPoolPerformanceQueryCreateInfoINTEL* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceMarkerInfoINTEL(
    VulkanHandleMapping* handlemap,
    VkPerformanceMarkerInfoINTEL* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceStreamMarkerInfoINTEL(
    VulkanHandleMapping* handlemap,
    VkPerformanceStreamMarkerInfoINTEL* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceOverrideInfoINTEL(
    VulkanHandleMapping* handlemap,
    VkPerformanceOverrideInfoINTEL* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceConfigurationAcquireInfoINTEL(
    VulkanHandleMapping* handlemap,
    VkPerformanceConfigurationAcquireInfoINTEL* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_pci_bus_info
void handlemap_VkPhysicalDevicePCIBusInfoPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevicePCIBusInfoPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_display_native_hdr
void handlemap_VkDisplayNativeHdrSurfaceCapabilitiesAMD(
    VulkanHandleMapping* handlemap,
    VkDisplayNativeHdrSurfaceCapabilitiesAMD* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSwapchainDisplayNativeHdrCreateInfoAMD(
    VulkanHandleMapping* handlemap,
    VkSwapchainDisplayNativeHdrCreateInfoAMD* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_FUCHSIA_imagepipe_surface
void handlemap_VkImagePipeSurfaceCreateInfoFUCHSIA(
    VulkanHandleMapping* handlemap,
    VkImagePipeSurfaceCreateInfoFUCHSIA* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_metal_surface
void handlemap_VkMetalSurfaceCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkMetalSurfaceCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_fragment_density_map
void handlemap_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceFragmentDensityMapFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceFragmentDensityMapPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->minFragmentDensityTexelSize));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxFragmentDensityTexelSize));
}

void handlemap_VkRenderPassFragmentDensityMapCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkRenderPassFragmentDensityMapCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkAttachmentReference(handlemap, (VkAttachmentReference*)(&toMap->fragmentDensityMapAttachment));
}

#endif
#ifdef VK_EXT_scalar_block_layout
#endif
#ifdef VK_GOOGLE_hlsl_functionality1
#endif
#ifdef VK_GOOGLE_decorate_string
#endif
#ifdef VK_EXT_subgroup_size_control
void handlemap_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceSubgroupSizeControlFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceSubgroupSizeControlPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_shader_core_properties2
void handlemap_VkPhysicalDeviceShaderCoreProperties2AMD(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderCoreProperties2AMD* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_device_coherent_memory
void handlemap_VkPhysicalDeviceCoherentMemoryFeaturesAMD(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceCoherentMemoryFeaturesAMD* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_shader_image_atomic_int64
void handlemap_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_memory_budget
void handlemap_VkPhysicalDeviceMemoryBudgetPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceMemoryBudgetPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_memory_priority
void handlemap_VkPhysicalDeviceMemoryPriorityFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceMemoryPriorityFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryPriorityAllocateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkMemoryPriorityAllocateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
void handlemap_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_buffer_device_address
void handlemap_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferDeviceAddressCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkBufferDeviceAddressCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_tooling_info
void handlemap_VkPhysicalDeviceToolPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceToolPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_separate_stencil_usage
#endif
#ifdef VK_EXT_validation_features
void handlemap_VkValidationFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkValidationFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_cooperative_matrix
void handlemap_VkCooperativeMatrixPropertiesNV(
    VulkanHandleMapping* handlemap,
    VkCooperativeMatrixPropertiesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceCooperativeMatrixFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceCooperativeMatrixFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceCooperativeMatrixPropertiesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceCooperativeMatrixPropertiesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_coverage_reduction_mode
void handlemap_VkPhysicalDeviceCoverageReductionModeFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceCoverageReductionModeFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineCoverageReductionStateCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkPipelineCoverageReductionStateCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFramebufferMixedSamplesCombinationNV(
    VulkanHandleMapping* handlemap,
    VkFramebufferMixedSamplesCombinationNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_fragment_shader_interlock
void handlemap_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_ycbcr_image_arrays
void handlemap_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_full_screen_exclusive
void handlemap_VkSurfaceFullScreenExclusiveInfoEXT(
    VulkanHandleMapping* handlemap,
    VkSurfaceFullScreenExclusiveInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSurfaceCapabilitiesFullScreenExclusiveEXT(
    VulkanHandleMapping* handlemap,
    VkSurfaceCapabilitiesFullScreenExclusiveEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSurfaceFullScreenExclusiveWin32InfoEXT(
    VulkanHandleMapping* handlemap,
    VkSurfaceFullScreenExclusiveWin32InfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_headless_surface
void handlemap_VkHeadlessSurfaceCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkHeadlessSurfaceCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_line_rasterization
void handlemap_VkPhysicalDeviceLineRasterizationFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceLineRasterizationFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceLineRasterizationPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceLineRasterizationPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRasterizationLineStateCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPipelineRasterizationLineStateCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_shader_atomic_float
void handlemap_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_host_query_reset
#endif
#ifdef VK_EXT_index_type_uint8
void handlemap_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceIndexTypeUint8FeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_extended_dynamic_state
void handlemap_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
void handlemap_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_device_generated_commands
void handlemap_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkGraphicsShaderGroupCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkGraphicsShaderGroupCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pStages)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->stageCount; ++i)
            {
                handlemap_VkPipelineShaderStageCreateInfo(handlemap, (VkPipelineShaderStageCreateInfo*)(toMap->pStages + i));
            }
        }
    }
    if (toMap->pVertexInputState)
    {
        handlemap_VkPipelineVertexInputStateCreateInfo(handlemap, (VkPipelineVertexInputStateCreateInfo*)(toMap->pVertexInputState));
    }
    if (toMap->pTessellationState)
    {
        handlemap_VkPipelineTessellationStateCreateInfo(handlemap, (VkPipelineTessellationStateCreateInfo*)(toMap->pTessellationState));
    }
}

void handlemap_VkGraphicsPipelineShaderGroupsCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkGraphicsPipelineShaderGroupsCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pGroups)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->groupCount; ++i)
            {
                handlemap_VkGraphicsShaderGroupCreateInfoNV(handlemap, (VkGraphicsShaderGroupCreateInfoNV*)(toMap->pGroups + i));
            }
        }
    }
    if (toMap->pPipelines)
    {
        handlemap->mapHandles_VkPipeline((VkPipeline*)toMap->pPipelines, toMap->pipelineCount);
    }
}

void handlemap_VkBindShaderGroupIndirectCommandNV(
    VulkanHandleMapping* handlemap,
    VkBindShaderGroupIndirectCommandNV* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkBindIndexBufferIndirectCommandNV(
    VulkanHandleMapping* handlemap,
    VkBindIndexBufferIndirectCommandNV* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkBindVertexBufferIndirectCommandNV(
    VulkanHandleMapping* handlemap,
    VkBindVertexBufferIndirectCommandNV* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSetStateFlagsIndirectCommandNV(
    VulkanHandleMapping* handlemap,
    VkSetStateFlagsIndirectCommandNV* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkIndirectCommandsStreamNV(
    VulkanHandleMapping* handlemap,
    VkIndirectCommandsStreamNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkIndirectCommandsLayoutTokenNV(
    VulkanHandleMapping* handlemap,
    VkIndirectCommandsLayoutTokenNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->pushconstantPipelineLayout);
}

void handlemap_VkIndirectCommandsLayoutCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkIndirectCommandsLayoutCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pTokens)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->tokenCount; ++i)
            {
                handlemap_VkIndirectCommandsLayoutTokenNV(handlemap, (VkIndirectCommandsLayoutTokenNV*)(toMap->pTokens + i));
            }
        }
    }
}

void handlemap_VkGeneratedCommandsInfoNV(
    VulkanHandleMapping* handlemap,
    VkGeneratedCommandsInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->pipeline);
    handlemap->mapHandles_VkIndirectCommandsLayoutNV((VkIndirectCommandsLayoutNV*)&toMap->indirectCommandsLayout);
    if (toMap)
    {
        if (toMap->pStreams)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->streamCount; ++i)
            {
                handlemap_VkIndirectCommandsStreamNV(handlemap, (VkIndirectCommandsStreamNV*)(toMap->pStreams + i));
            }
        }
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->preprocessBuffer);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->sequencesCountBuffer);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->sequencesIndexBuffer);
}

void handlemap_VkGeneratedCommandsMemoryRequirementsInfoNV(
    VulkanHandleMapping* handlemap,
    VkGeneratedCommandsMemoryRequirementsInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->pipeline);
    handlemap->mapHandles_VkIndirectCommandsLayoutNV((VkIndirectCommandsLayoutNV*)&toMap->indirectCommandsLayout);
}

#endif
#ifdef VK_EXT_texel_buffer_alignment
void handlemap_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_QCOM_render_pass_transform
void handlemap_VkRenderPassTransformBeginInfoQCOM(
    VulkanHandleMapping* handlemap,
    VkRenderPassTransformBeginInfoQCOM* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(
    VulkanHandleMapping* handlemap,
    VkCommandBufferInheritanceRenderPassTransformInfoQCOM* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkRect2D(handlemap, (VkRect2D*)(&toMap->renderArea));
}

#endif
#ifdef VK_EXT_device_memory_report
void handlemap_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceMemoryReportCallbackDataEXT(
    VulkanHandleMapping* handlemap,
    VkDeviceMemoryReportCallbackDataEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceDeviceMemoryReportCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDeviceDeviceMemoryReportCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_robustness2
void handlemap_VkPhysicalDeviceRobustness2FeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceRobustness2FeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceRobustness2PropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceRobustness2PropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_custom_border_color
void handlemap_VkSamplerCustomBorderColorCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkSamplerCustomBorderColorCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkClearColorValue(handlemap, (VkClearColorValue*)(&toMap->customBorderColor));
}

void handlemap_VkPhysicalDeviceCustomBorderColorPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceCustomBorderColorPropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceCustomBorderColorFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceCustomBorderColorFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_GOOGLE_user_type
#endif
#ifdef VK_EXT_private_data
void handlemap_VkPhysicalDevicePrivateDataFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevicePrivateDataFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDevicePrivateDataCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDevicePrivateDataCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPrivateDataSlotCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPrivateDataSlotCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_pipeline_creation_cache_control
void handlemap_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_device_diagnostics_config
void handlemap_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceDiagnosticsConfigFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceDiagnosticsConfigCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkDeviceDiagnosticsConfigCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_QCOM_render_pass_store_ops
#endif
#ifdef VK_NV_fragment_shading_rate_enums
void handlemap_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(
    VulkanHandleMapping* handlemap,
    VkPipelineFragmentShadingRateEnumStateCreateInfoNV* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_fragment_density_map2
void handlemap_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_QCOM_rotated_copy_commands
void handlemap_VkCopyCommandTransformInfoQCOM(
    VulkanHandleMapping* handlemap,
    VkCopyCommandTransformInfoQCOM* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_image_robustness
void handlemap_VkPhysicalDeviceImageRobustnessFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceImageRobustnessFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_4444_formats
void handlemap_VkPhysicalDevice4444FormatsFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevice4444FormatsFeaturesEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_directfb_surface
void handlemap_VkDirectFBSurfaceCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkDirectFBSurfaceCreateInfoEXT* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_GOOGLE_gfxstream
void handlemap_VkImportColorBufferGOOGLE(
    VulkanHandleMapping* handlemap,
    VkImportColorBufferGOOGLE* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImportBufferGOOGLE(
    VulkanHandleMapping* handlemap,
    VkImportBufferGOOGLE* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImportPhysicalAddressGOOGLE(
    VulkanHandleMapping* handlemap,
    VkImportPhysicalAddressGOOGLE* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_acceleration_structure
void handlemap_VkDeviceOrHostAddressKHR(
    VulkanHandleMapping* handlemap,
    VkDeviceOrHostAddressKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDeviceOrHostAddressConstKHR(
    VulkanHandleMapping* handlemap,
    VkDeviceOrHostAddressConstKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAccelerationStructureBuildRangeInfoKHR(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureBuildRangeInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAccelerationStructureGeometryTrianglesDataKHR(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureGeometryTrianglesDataKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap, (VkDeviceOrHostAddressConstKHR*)(&toMap->vertexData));
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap, (VkDeviceOrHostAddressConstKHR*)(&toMap->indexData));
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap, (VkDeviceOrHostAddressConstKHR*)(&toMap->transformData));
}

void handlemap_VkAccelerationStructureGeometryAabbsDataKHR(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureGeometryAabbsDataKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap, (VkDeviceOrHostAddressConstKHR*)(&toMap->data));
}

void handlemap_VkAccelerationStructureGeometryInstancesDataKHR(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureGeometryInstancesDataKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap, (VkDeviceOrHostAddressConstKHR*)(&toMap->data));
}

void handlemap_VkAccelerationStructureGeometryDataKHR(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureGeometryDataKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    handlemap_VkAccelerationStructureGeometryTrianglesDataKHR(handlemap, (VkAccelerationStructureGeometryTrianglesDataKHR*)(&toMap->triangles));
    handlemap_VkAccelerationStructureGeometryAabbsDataKHR(handlemap, (VkAccelerationStructureGeometryAabbsDataKHR*)(&toMap->aabbs));
    handlemap_VkAccelerationStructureGeometryInstancesDataKHR(handlemap, (VkAccelerationStructureGeometryInstancesDataKHR*)(&toMap->instances));
}

void handlemap_VkAccelerationStructureGeometryKHR(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureGeometryKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkAccelerationStructureGeometryDataKHR(handlemap, (VkAccelerationStructureGeometryDataKHR*)(&toMap->geometry));
}

void handlemap_VkAccelerationStructureBuildGeometryInfoKHR(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureBuildGeometryInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkAccelerationStructureKHR((VkAccelerationStructureKHR*)&toMap->srcAccelerationStructure);
    handlemap->mapHandles_VkAccelerationStructureKHR((VkAccelerationStructureKHR*)&toMap->dstAccelerationStructure);
    if (toMap)
    {
        if (toMap->pGeometries)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->geometryCount; ++i)
            {
                handlemap_VkAccelerationStructureGeometryKHR(handlemap, (VkAccelerationStructureGeometryKHR*)(toMap->pGeometries + i));
            }
        }
    }
    handlemap_VkDeviceOrHostAddressKHR(handlemap, (VkDeviceOrHostAddressKHR*)(&toMap->scratchData));
}

void handlemap_VkAccelerationStructureCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkWriteDescriptorSetAccelerationStructureKHR(
    VulkanHandleMapping* handlemap,
    VkWriteDescriptorSetAccelerationStructureKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pAccelerationStructures)
    {
        handlemap->mapHandles_VkAccelerationStructureKHR((VkAccelerationStructureKHR*)toMap->pAccelerationStructures, toMap->accelerationStructureCount);
    }
}

void handlemap_VkPhysicalDeviceAccelerationStructureFeaturesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceAccelerationStructureFeaturesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceAccelerationStructurePropertiesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceAccelerationStructurePropertiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAccelerationStructureDeviceAddressInfoKHR(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureDeviceAddressInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkAccelerationStructureKHR((VkAccelerationStructureKHR*)&toMap->accelerationStructure);
}

void handlemap_VkAccelerationStructureVersionInfoKHR(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureVersionInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCopyAccelerationStructureToMemoryInfoKHR(
    VulkanHandleMapping* handlemap,
    VkCopyAccelerationStructureToMemoryInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkAccelerationStructureKHR((VkAccelerationStructureKHR*)&toMap->src);
    handlemap_VkDeviceOrHostAddressKHR(handlemap, (VkDeviceOrHostAddressKHR*)(&toMap->dst));
}

void handlemap_VkCopyMemoryToAccelerationStructureInfoKHR(
    VulkanHandleMapping* handlemap,
    VkCopyMemoryToAccelerationStructureInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap, (VkDeviceOrHostAddressConstKHR*)(&toMap->src));
    handlemap->mapHandles_VkAccelerationStructureKHR((VkAccelerationStructureKHR*)&toMap->dst);
}

void handlemap_VkCopyAccelerationStructureInfoKHR(
    VulkanHandleMapping* handlemap,
    VkCopyAccelerationStructureInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkAccelerationStructureKHR((VkAccelerationStructureKHR*)&toMap->src);
    handlemap->mapHandles_VkAccelerationStructureKHR((VkAccelerationStructureKHR*)&toMap->dst);
}

void handlemap_VkAccelerationStructureBuildSizesInfoKHR(
    VulkanHandleMapping* handlemap,
    VkAccelerationStructureBuildSizesInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_ray_tracing_pipeline
void handlemap_VkRayTracingShaderGroupCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkRayTracingShaderGroupCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRayTracingPipelineInterfaceCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkRayTracingPipelineInterfaceCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRayTracingPipelineCreateInfoKHR(
    VulkanHandleMapping* handlemap,
    VkRayTracingPipelineCreateInfoKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap)
    {
        if (toMap->pStages)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->stageCount; ++i)
            {
                handlemap_VkPipelineShaderStageCreateInfo(handlemap, (VkPipelineShaderStageCreateInfo*)(toMap->pStages + i));
            }
        }
    }
    if (toMap)
    {
        if (toMap->pGroups)
        {
            for (uint32_t i = 0; i < (uint32_t)toMap->groupCount; ++i)
            {
                handlemap_VkRayTracingShaderGroupCreateInfoKHR(handlemap, (VkRayTracingShaderGroupCreateInfoKHR*)(toMap->pGroups + i));
            }
        }
    }
    if (toMap->pLibraryInfo)
    {
        handlemap_VkPipelineLibraryCreateInfoKHR(handlemap, (VkPipelineLibraryCreateInfoKHR*)(toMap->pLibraryInfo));
    }
    if (toMap->pLibraryInterface)
    {
        handlemap_VkRayTracingPipelineInterfaceCreateInfoKHR(handlemap, (VkRayTracingPipelineInterfaceCreateInfoKHR*)(toMap->pLibraryInterface));
    }
    if (toMap->pDynamicState)
    {
        handlemap_VkPipelineDynamicStateCreateInfo(handlemap, (VkPipelineDynamicStateCreateInfo*)(toMap->pDynamicState));
    }
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->layout);
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->basePipelineHandle);
}

void handlemap_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceRayTracingPipelineFeaturesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceRayTracingPipelinePropertiesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkStridedDeviceAddressRegionKHR(
    VulkanHandleMapping* handlemap,
    VkStridedDeviceAddressRegionKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkTraceRaysIndirectCommandKHR(
    VulkanHandleMapping* handlemap,
    VkTraceRaysIndirectCommandKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
}

#endif
#ifdef VK_KHR_ray_query
void handlemap_VkPhysicalDeviceRayQueryFeaturesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceRayQueryFeaturesKHR* toMap)
{
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext)
    {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
void handlemap_extension_struct(
    VulkanHandleMapping* handlemap,
    void* structExtension_out)
{
    if (!structExtension_out)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension_out);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            handlemap_VkPhysicalDeviceSubgroupProperties(handlemap, reinterpret_cast<VkPhysicalDeviceSubgroupProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            handlemap_VkPhysicalDevice16BitStorageFeatures(handlemap, reinterpret_cast<VkPhysicalDevice16BitStorageFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            handlemap_VkMemoryDedicatedRequirements(handlemap, reinterpret_cast<VkMemoryDedicatedRequirements*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            handlemap_VkMemoryDedicatedAllocateInfo(handlemap, reinterpret_cast<VkMemoryDedicatedAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            handlemap_VkMemoryAllocateFlagsInfo(handlemap, reinterpret_cast<VkMemoryAllocateFlagsInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            handlemap_VkDeviceGroupRenderPassBeginInfo(handlemap, reinterpret_cast<VkDeviceGroupRenderPassBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            handlemap_VkDeviceGroupCommandBufferBeginInfo(handlemap, reinterpret_cast<VkDeviceGroupCommandBufferBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            handlemap_VkDeviceGroupSubmitInfo(handlemap, reinterpret_cast<VkDeviceGroupSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            handlemap_VkDeviceGroupBindSparseInfo(handlemap, reinterpret_cast<VkDeviceGroupBindSparseInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            handlemap_VkBindBufferMemoryDeviceGroupInfo(handlemap, reinterpret_cast<VkBindBufferMemoryDeviceGroupInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            handlemap_VkBindImageMemoryDeviceGroupInfo(handlemap, reinterpret_cast<VkBindImageMemoryDeviceGroupInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            handlemap_VkDeviceGroupDeviceCreateInfo(handlemap, reinterpret_cast<VkDeviceGroupDeviceCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            handlemap_VkPhysicalDeviceFeatures2(handlemap, reinterpret_cast<VkPhysicalDeviceFeatures2*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            handlemap_VkPhysicalDevicePointClippingProperties(handlemap, reinterpret_cast<VkPhysicalDevicePointClippingProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            handlemap_VkRenderPassInputAttachmentAspectCreateInfo(handlemap, reinterpret_cast<VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            handlemap_VkImageViewUsageCreateInfo(handlemap, reinterpret_cast<VkImageViewUsageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            handlemap_VkPipelineTessellationDomainOriginStateCreateInfo(handlemap, reinterpret_cast<VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            handlemap_VkRenderPassMultiviewCreateInfo(handlemap, reinterpret_cast<VkRenderPassMultiviewCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            handlemap_VkPhysicalDeviceMultiviewFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceMultiviewFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            handlemap_VkPhysicalDeviceMultiviewProperties(handlemap, reinterpret_cast<VkPhysicalDeviceMultiviewProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            handlemap_VkPhysicalDeviceVariablePointersFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceVariablePointersFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            handlemap_VkPhysicalDeviceProtectedMemoryFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            handlemap_VkPhysicalDeviceProtectedMemoryProperties(handlemap, reinterpret_cast<VkPhysicalDeviceProtectedMemoryProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            handlemap_VkProtectedSubmitInfo(handlemap, reinterpret_cast<VkProtectedSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            handlemap_VkSamplerYcbcrConversionInfo(handlemap, reinterpret_cast<VkSamplerYcbcrConversionInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            handlemap_VkBindImagePlaneMemoryInfo(handlemap, reinterpret_cast<VkBindImagePlaneMemoryInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            handlemap_VkImagePlaneMemoryRequirementsInfo(handlemap, reinterpret_cast<VkImagePlaneMemoryRequirementsInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            handlemap_VkPhysicalDeviceSamplerYcbcrConversionFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            handlemap_VkSamplerYcbcrConversionImageFormatProperties(handlemap, reinterpret_cast<VkSamplerYcbcrConversionImageFormatProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            handlemap_VkPhysicalDeviceExternalImageFormatInfo(handlemap, reinterpret_cast<VkPhysicalDeviceExternalImageFormatInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            handlemap_VkExternalImageFormatProperties(handlemap, reinterpret_cast<VkExternalImageFormatProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            handlemap_VkPhysicalDeviceIDProperties(handlemap, reinterpret_cast<VkPhysicalDeviceIDProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            handlemap_VkExternalMemoryImageCreateInfo(handlemap, reinterpret_cast<VkExternalMemoryImageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            handlemap_VkExternalMemoryBufferCreateInfo(handlemap, reinterpret_cast<VkExternalMemoryBufferCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            handlemap_VkExportMemoryAllocateInfo(handlemap, reinterpret_cast<VkExportMemoryAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            handlemap_VkExportFenceCreateInfo(handlemap, reinterpret_cast<VkExportFenceCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            handlemap_VkExportSemaphoreCreateInfo(handlemap, reinterpret_cast<VkExportSemaphoreCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            handlemap_VkPhysicalDeviceMaintenance3Properties(handlemap, reinterpret_cast<VkPhysicalDeviceMaintenance3Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            handlemap_VkPhysicalDeviceShaderDrawParametersFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceShaderDrawParametersFeatures*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_VERSION_1_2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            handlemap_VkPhysicalDeviceVulkan11Features(handlemap, reinterpret_cast<VkPhysicalDeviceVulkan11Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {
            handlemap_VkPhysicalDeviceVulkan11Properties(handlemap, reinterpret_cast<VkPhysicalDeviceVulkan11Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            handlemap_VkPhysicalDeviceVulkan12Features(handlemap, reinterpret_cast<VkPhysicalDeviceVulkan12Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {
            handlemap_VkPhysicalDeviceVulkan12Properties(handlemap, reinterpret_cast<VkPhysicalDeviceVulkan12Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            handlemap_VkImageFormatListCreateInfo(handlemap, reinterpret_cast<VkImageFormatListCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            handlemap_VkPhysicalDevice8BitStorageFeatures(handlemap, reinterpret_cast<VkPhysicalDevice8BitStorageFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
            handlemap_VkPhysicalDeviceDriverProperties(handlemap, reinterpret_cast<VkPhysicalDeviceDriverProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            handlemap_VkPhysicalDeviceShaderAtomicInt64Features(handlemap, reinterpret_cast<VkPhysicalDeviceShaderAtomicInt64Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            handlemap_VkPhysicalDeviceShaderFloat16Int8Features(handlemap, reinterpret_cast<VkPhysicalDeviceShaderFloat16Int8Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
            handlemap_VkPhysicalDeviceFloatControlsProperties(handlemap, reinterpret_cast<VkPhysicalDeviceFloatControlsProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
        {
            handlemap_VkDescriptorSetLayoutBindingFlagsCreateInfo(handlemap, reinterpret_cast<VkDescriptorSetLayoutBindingFlagsCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            handlemap_VkPhysicalDeviceDescriptorIndexingFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceDescriptorIndexingFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
            handlemap_VkPhysicalDeviceDescriptorIndexingProperties(handlemap, reinterpret_cast<VkPhysicalDeviceDescriptorIndexingProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
        {
            handlemap_VkDescriptorSetVariableDescriptorCountAllocateInfo(handlemap, reinterpret_cast<VkDescriptorSetVariableDescriptorCountAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
            handlemap_VkDescriptorSetVariableDescriptorCountLayoutSupport(handlemap, reinterpret_cast<VkDescriptorSetVariableDescriptorCountLayoutSupport*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
        {
            handlemap_VkSubpassDescriptionDepthStencilResolve(handlemap, reinterpret_cast<VkSubpassDescriptionDepthStencilResolve*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
            handlemap_VkPhysicalDeviceDepthStencilResolveProperties(handlemap, reinterpret_cast<VkPhysicalDeviceDepthStencilResolveProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            handlemap_VkPhysicalDeviceScalarBlockLayoutFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceScalarBlockLayoutFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            handlemap_VkImageStencilUsageCreateInfo(handlemap, reinterpret_cast<VkImageStencilUsageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
        {
            handlemap_VkSamplerReductionModeCreateInfo(handlemap, reinterpret_cast<VkSamplerReductionModeCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
            handlemap_VkPhysicalDeviceSamplerFilterMinmaxProperties(handlemap, reinterpret_cast<VkPhysicalDeviceSamplerFilterMinmaxProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            handlemap_VkPhysicalDeviceVulkanMemoryModelFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceVulkanMemoryModelFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            handlemap_VkPhysicalDeviceImagelessFramebufferFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceImagelessFramebufferFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
        {
            handlemap_VkFramebufferAttachmentsCreateInfo(handlemap, reinterpret_cast<VkFramebufferAttachmentsCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
        {
            handlemap_VkRenderPassAttachmentBeginInfo(handlemap, reinterpret_cast<VkRenderPassAttachmentBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            handlemap_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            handlemap_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            handlemap_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
        {
            handlemap_VkAttachmentReferenceStencilLayout(handlemap, reinterpret_cast<VkAttachmentReferenceStencilLayout*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
        {
            handlemap_VkAttachmentDescriptionStencilLayout(handlemap, reinterpret_cast<VkAttachmentDescriptionStencilLayout*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            handlemap_VkPhysicalDeviceHostQueryResetFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceHostQueryResetFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            handlemap_VkPhysicalDeviceTimelineSemaphoreFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
            handlemap_VkPhysicalDeviceTimelineSemaphoreProperties(handlemap, reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
            handlemap_VkSemaphoreTypeCreateInfo(handlemap, reinterpret_cast<VkSemaphoreTypeCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            handlemap_VkTimelineSemaphoreSubmitInfo(handlemap, reinterpret_cast<VkTimelineSemaphoreSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            handlemap_VkPhysicalDeviceBufferDeviceAddressFeatures(handlemap, reinterpret_cast<VkPhysicalDeviceBufferDeviceAddressFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
            handlemap_VkBufferOpaqueCaptureAddressCreateInfo(handlemap, reinterpret_cast<VkBufferOpaqueCaptureAddressCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
            handlemap_VkMemoryOpaqueCaptureAddressAllocateInfo(handlemap, reinterpret_cast<VkMemoryOpaqueCaptureAddressAllocateInfo*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            handlemap_VkImageSwapchainCreateInfoKHR(handlemap, reinterpret_cast<VkImageSwapchainCreateInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            handlemap_VkBindImageMemorySwapchainInfoKHR(handlemap, reinterpret_cast<VkBindImageMemorySwapchainInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            handlemap_VkDeviceGroupPresentInfoKHR(handlemap, reinterpret_cast<VkDeviceGroupPresentInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            handlemap_VkDeviceGroupSwapchainCreateInfoKHR(handlemap, reinterpret_cast<VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            handlemap_VkDisplayPresentInfoKHR(handlemap, reinterpret_cast<VkDisplayPresentInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            handlemap_VkImportMemoryWin32HandleInfoKHR(handlemap, reinterpret_cast<VkImportMemoryWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            handlemap_VkExportMemoryWin32HandleInfoKHR(handlemap, reinterpret_cast<VkExportMemoryWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            handlemap_VkImportMemoryFdInfoKHR(handlemap, reinterpret_cast<VkImportMemoryFdInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            handlemap_VkWin32KeyedMutexAcquireReleaseInfoKHR(handlemap, reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            handlemap_VkExportSemaphoreWin32HandleInfoKHR(handlemap, reinterpret_cast<VkExportSemaphoreWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            handlemap_VkD3D12FenceSubmitInfoKHR(handlemap, reinterpret_cast<VkD3D12FenceSubmitInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            handlemap_VkPhysicalDevicePushDescriptorPropertiesKHR(handlemap, reinterpret_cast<VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            handlemap_VkPresentRegionsKHR(handlemap, reinterpret_cast<VkPresentRegionsKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            handlemap_VkSharedPresentSurfaceCapabilitiesKHR(handlemap, reinterpret_cast<VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            handlemap_VkExportFenceWin32HandleInfoKHR(handlemap, reinterpret_cast<VkExportFenceWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_performance_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            handlemap_VkPhysicalDevicePerformanceQueryFeaturesKHR(handlemap, reinterpret_cast<VkPhysicalDevicePerformanceQueryFeaturesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {
            handlemap_VkPhysicalDevicePerformanceQueryPropertiesKHR(handlemap, reinterpret_cast<VkPhysicalDevicePerformanceQueryPropertiesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
        {
            handlemap_VkQueryPoolPerformanceCreateInfoKHR(handlemap, reinterpret_cast<VkQueryPoolPerformanceCreateInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            handlemap_VkPerformanceQuerySubmitInfoKHR(handlemap, reinterpret_cast<VkPerformanceQuerySubmitInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_portability_subset
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR:
        {
            handlemap_VkPhysicalDevicePortabilitySubsetFeaturesKHR(handlemap, reinterpret_cast<VkPhysicalDevicePortabilitySubsetFeaturesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR:
        {
            handlemap_VkPhysicalDevicePortabilitySubsetPropertiesKHR(handlemap, reinterpret_cast<VkPhysicalDevicePortabilitySubsetPropertiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_shader_clock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            handlemap_VkPhysicalDeviceShaderClockFeaturesKHR(handlemap, reinterpret_cast<VkPhysicalDeviceShaderClockFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_shader_terminate_invocation
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR:
        {
            handlemap_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(handlemap, reinterpret_cast<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_fragment_shading_rate
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
            handlemap_VkFragmentShadingRateAttachmentInfoKHR(handlemap, reinterpret_cast<VkFragmentShadingRateAttachmentInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {
            handlemap_VkPipelineFragmentShadingRateStateCreateInfoKHR(handlemap, reinterpret_cast<VkPipelineFragmentShadingRateStateCreateInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            handlemap_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(handlemap, reinterpret_cast<VkPhysicalDeviceFragmentShadingRateFeaturesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {
            handlemap_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(handlemap, reinterpret_cast<VkPhysicalDeviceFragmentShadingRatePropertiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_surface_protected_capabilities
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
        {
            handlemap_VkSurfaceProtectedCapabilitiesKHR(handlemap, reinterpret_cast<VkSurfaceProtectedCapabilitiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_pipeline_executable_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            handlemap_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(handlemap, reinterpret_cast<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            handlemap_VkNativeBufferANDROID(handlemap, reinterpret_cast<VkNativeBufferANDROID*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            handlemap_VkDebugReportCallbackCreateInfoEXT(handlemap, reinterpret_cast<VkDebugReportCallbackCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            handlemap_VkPipelineRasterizationStateRasterizationOrderAMD(handlemap, reinterpret_cast<VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            handlemap_VkDedicatedAllocationImageCreateInfoNV(handlemap, reinterpret_cast<VkDedicatedAllocationImageCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            handlemap_VkDedicatedAllocationBufferCreateInfoNV(handlemap, reinterpret_cast<VkDedicatedAllocationBufferCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            handlemap_VkDedicatedAllocationMemoryAllocateInfoNV(handlemap, reinterpret_cast<VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_transform_feedback
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceTransformFeedbackFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceTransformFeedbackPropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
        {
            handlemap_VkPipelineRasterizationStateStreamCreateInfoEXT(handlemap, reinterpret_cast<VkPipelineRasterizationStateStreamCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            handlemap_VkTextureLODGatherFormatPropertiesAMD(handlemap, reinterpret_cast<VkTextureLODGatherFormatPropertiesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_corner_sampled_image
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceCornerSampledImageFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceCornerSampledImageFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            handlemap_VkExternalMemoryImageCreateInfoNV(handlemap, reinterpret_cast<VkExternalMemoryImageCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            handlemap_VkExportMemoryAllocateInfoNV(handlemap, reinterpret_cast<VkExportMemoryAllocateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            handlemap_VkImportMemoryWin32HandleInfoNV(handlemap, reinterpret_cast<VkImportMemoryWin32HandleInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            handlemap_VkExportMemoryWin32HandleInfoNV(handlemap, reinterpret_cast<VkExportMemoryWin32HandleInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            handlemap_VkWin32KeyedMutexAcquireReleaseInfoNV(handlemap, reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            handlemap_VkValidationFlagsEXT(handlemap, reinterpret_cast<VkValidationFlagsEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_astc_decode_mode
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
        {
            handlemap_VkImageViewASTCDecodeModeEXT(handlemap, reinterpret_cast<VkImageViewASTCDecodeModeEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceASTCDecodeFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceASTCDecodeFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceConditionalRenderingFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            handlemap_VkCommandBufferInheritanceConditionalRenderingInfoEXT(handlemap, reinterpret_cast<VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            handlemap_VkPipelineViewportWScalingStateCreateInfoNV(handlemap, reinterpret_cast<VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            handlemap_VkSwapchainCounterCreateInfoEXT(handlemap, reinterpret_cast<VkSwapchainCounterCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            handlemap_VkPresentTimesInfoGOOGLE(handlemap, reinterpret_cast<VkPresentTimesInfoGOOGLE*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            handlemap_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(handlemap, reinterpret_cast<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            handlemap_VkPipelineViewportSwizzleStateCreateInfoNV(handlemap, reinterpret_cast<VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceDiscardRectanglePropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            handlemap_VkPipelineDiscardRectangleStateCreateInfoEXT(handlemap, reinterpret_cast<VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            handlemap_VkPipelineRasterizationConservativeStateCreateInfoEXT(handlemap, reinterpret_cast<VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_depth_clip_enable
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceDepthClipEnableFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
        {
            handlemap_VkPipelineRasterizationDepthClipStateCreateInfoEXT(handlemap, reinterpret_cast<VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            handlemap_VkDebugUtilsMessengerCreateInfoEXT(handlemap, reinterpret_cast<VkDebugUtilsMessengerCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            handlemap_VkAndroidHardwareBufferUsageANDROID(handlemap, reinterpret_cast<VkAndroidHardwareBufferUsageANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            handlemap_VkAndroidHardwareBufferFormatPropertiesANDROID(handlemap, reinterpret_cast<VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            handlemap_VkImportAndroidHardwareBufferInfoANDROID(handlemap, reinterpret_cast<VkImportAndroidHardwareBufferInfoANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            handlemap_VkExternalFormatANDROID(handlemap, reinterpret_cast<VkExternalFormatANDROID*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_inline_uniform_block
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceInlineUniformBlockFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceInlineUniformBlockPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
        {
            handlemap_VkWriteDescriptorSetInlineUniformBlockEXT(handlemap, reinterpret_cast<VkWriteDescriptorSetInlineUniformBlockEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
        {
            handlemap_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(handlemap, reinterpret_cast<VkDescriptorPoolInlineUniformBlockCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            handlemap_VkSampleLocationsInfoEXT(handlemap, reinterpret_cast<VkSampleLocationsInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            handlemap_VkRenderPassSampleLocationsBeginInfoEXT(handlemap, reinterpret_cast<VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            handlemap_VkPipelineSampleLocationsStateCreateInfoEXT(handlemap, reinterpret_cast<VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceSampleLocationsPropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            handlemap_VkPipelineColorBlendAdvancedStateCreateInfoEXT(handlemap, reinterpret_cast<VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            handlemap_VkPipelineCoverageToColorStateCreateInfoNV(handlemap, reinterpret_cast<VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            handlemap_VkPipelineCoverageModulationStateCreateInfoNV(handlemap, reinterpret_cast<VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_shader_sm_builtins
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {
            handlemap_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(handlemap, reinterpret_cast<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_image_drm_format_modifier
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
        {
            handlemap_VkDrmFormatModifierPropertiesListEXT(handlemap, reinterpret_cast<VkDrmFormatModifierPropertiesListEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
        {
            handlemap_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(handlemap, reinterpret_cast<VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
        {
            handlemap_VkImageDrmFormatModifierListCreateInfoEXT(handlemap, reinterpret_cast<VkImageDrmFormatModifierListCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
        {
            handlemap_VkImageDrmFormatModifierExplicitCreateInfoEXT(handlemap, reinterpret_cast<VkImageDrmFormatModifierExplicitCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            handlemap_VkShaderModuleValidationCacheCreateInfoEXT(handlemap, reinterpret_cast<VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_shading_rate_image
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
        {
            handlemap_VkPipelineViewportShadingRateImageStateCreateInfoNV(handlemap, reinterpret_cast<VkPipelineViewportShadingRateImageStateCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceShadingRateImageFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceShadingRateImageFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {
            handlemap_VkPhysicalDeviceShadingRateImagePropertiesNV(handlemap, reinterpret_cast<VkPhysicalDeviceShadingRateImagePropertiesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
        {
            handlemap_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(handlemap, reinterpret_cast<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_ray_tracing
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
        {
            handlemap_VkWriteDescriptorSetAccelerationStructureNV(handlemap, reinterpret_cast<VkWriteDescriptorSetAccelerationStructureNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {
            handlemap_VkPhysicalDeviceRayTracingPropertiesNV(handlemap, reinterpret_cast<VkPhysicalDeviceRayTracingPropertiesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_representative_fragment_test
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {
            handlemap_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(handlemap, reinterpret_cast<VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_filter_cubic
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {
            handlemap_VkPhysicalDeviceImageViewImageFormatInfoEXT(handlemap, reinterpret_cast<VkPhysicalDeviceImageViewImageFormatInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {
            handlemap_VkFilterCubicImageViewImageFormatPropertiesEXT(handlemap, reinterpret_cast<VkFilterCubicImageViewImageFormatPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            handlemap_VkDeviceQueueGlobalPriorityCreateInfoEXT(handlemap, reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            handlemap_VkImportMemoryHostPointerInfoEXT(handlemap, reinterpret_cast<VkImportMemoryHostPointerInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_pipeline_compiler_control
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
            handlemap_VkPipelineCompilerControlCreateInfoAMD(handlemap, reinterpret_cast<VkPipelineCompilerControlCreateInfoAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            handlemap_VkPhysicalDeviceShaderCorePropertiesAMD(handlemap, reinterpret_cast<VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_memory_overallocation_behavior
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {
            handlemap_VkDeviceMemoryOverallocationCreateInfoAMD(handlemap, reinterpret_cast<VkDeviceMemoryOverallocationCreateInfoAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            handlemap_VkPipelineVertexInputDivisorStateCreateInfoEXT(handlemap, reinterpret_cast<VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_GGP_frame_token
        case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
        {
            handlemap_VkPresentFrameTokenGGP(handlemap, reinterpret_cast<VkPresentFrameTokenGGP*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_pipeline_creation_feedback
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
        {
            handlemap_VkPipelineCreationFeedbackCreateInfoEXT(handlemap, reinterpret_cast<VkPipelineCreationFeedbackCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_compute_shader_derivatives
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_mesh_shader
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceMeshShaderFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceMeshShaderFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {
            handlemap_VkPhysicalDeviceMeshShaderPropertiesNV(handlemap, reinterpret_cast<VkPhysicalDeviceMeshShaderPropertiesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_fragment_shader_barycentric
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_shader_image_footprint
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceShaderImageFootprintFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_scissor_exclusive
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
        {
            handlemap_VkPipelineViewportExclusiveScissorStateCreateInfoNV(handlemap, reinterpret_cast<VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceExclusiveScissorFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceExclusiveScissorFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            handlemap_VkQueueFamilyCheckpointPropertiesNV(handlemap, reinterpret_cast<VkQueueFamilyCheckpointPropertiesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_INTEL_shader_integer_functions2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            handlemap_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(handlemap, reinterpret_cast<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_INTEL_performance_query
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
        {
            handlemap_VkQueryPoolPerformanceQueryCreateInfoINTEL(handlemap, reinterpret_cast<VkQueryPoolPerformanceQueryCreateInfoINTEL*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_pci_bus_info
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDevicePCIBusInfoPropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDevicePCIBusInfoPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_display_native_hdr
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
        {
            handlemap_VkDisplayNativeHdrSurfaceCapabilitiesAMD(handlemap, reinterpret_cast<VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
        {
            handlemap_VkSwapchainDisplayNativeHdrCreateInfoAMD(handlemap, reinterpret_cast<VkSwapchainDisplayNativeHdrCreateInfoAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_fragment_density_map
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
        {
            handlemap_VkRenderPassFragmentDensityMapCreateInfoEXT(handlemap, reinterpret_cast<VkRenderPassFragmentDensityMapCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_subgroup_size_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT:
        {
            handlemap_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(handlemap, reinterpret_cast<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {
            handlemap_VkPhysicalDeviceShaderCoreProperties2AMD(handlemap, reinterpret_cast<VkPhysicalDeviceShaderCoreProperties2AMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_device_coherent_memory
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            handlemap_VkPhysicalDeviceCoherentMemoryFeaturesAMD(handlemap, reinterpret_cast<VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_shader_image_atomic_int64
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_memory_budget
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceMemoryBudgetPropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_memory_priority
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceMemoryPriorityFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {
            handlemap_VkMemoryPriorityAllocateInfoEXT(handlemap, reinterpret_cast<VkMemoryPriorityAllocateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_buffer_device_address
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {
            handlemap_VkBufferDeviceAddressCreateInfoEXT(handlemap, reinterpret_cast<VkBufferDeviceAddressCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_features
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
            handlemap_VkValidationFeaturesEXT(handlemap, reinterpret_cast<VkValidationFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_cooperative_matrix
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceCooperativeMatrixFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
            handlemap_VkPhysicalDeviceCooperativeMatrixPropertiesNV(handlemap, reinterpret_cast<VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_coverage_reduction_mode
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceCoverageReductionModeFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
        {
            handlemap_VkPipelineCoverageReductionStateCreateInfoNV(handlemap, reinterpret_cast<VkPipelineCoverageReductionStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_fragment_shader_interlock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_ycbcr_image_arrays
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_full_screen_exclusive
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
        {
            handlemap_VkSurfaceFullScreenExclusiveInfoEXT(handlemap, reinterpret_cast<VkSurfaceFullScreenExclusiveInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
        {
            handlemap_VkSurfaceCapabilitiesFullScreenExclusiveEXT(handlemap, reinterpret_cast<VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
        {
            handlemap_VkSurfaceFullScreenExclusiveWin32InfoEXT(handlemap, reinterpret_cast<VkSurfaceFullScreenExclusiveWin32InfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_line_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceLineRasterizationFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceLineRasterizationPropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
        {
            handlemap_VkPipelineRasterizationLineStateCreateInfoEXT(handlemap, reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_shader_atomic_float
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_index_type_uint8
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceIndexTypeUint8FeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_device_generated_commands
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {
            handlemap_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(handlemap, reinterpret_cast<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {
            handlemap_VkGraphicsPipelineShaderGroupsCreateInfoNV(handlemap, reinterpret_cast<VkGraphicsPipelineShaderGroupsCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_texel_buffer_alignment
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_QCOM_render_pass_transform
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
        {
            handlemap_VkRenderPassTransformBeginInfoQCOM(handlemap, reinterpret_cast<VkRenderPassTransformBeginInfoQCOM*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
        {
            handlemap_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(handlemap, reinterpret_cast<VkCommandBufferInheritanceRenderPassTransformInfoQCOM*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_device_memory_report
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
        {
            handlemap_VkDeviceDeviceMemoryReportCreateInfoEXT(handlemap, reinterpret_cast<VkDeviceDeviceMemoryReportCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_robustness2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceRobustness2FeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceRobustness2FeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceRobustness2PropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceRobustness2PropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_custom_border_color
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
        {
            handlemap_VkSamplerCustomBorderColorCreateInfoEXT(handlemap, reinterpret_cast<VkSamplerCustomBorderColorCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceCustomBorderColorPropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceCustomBorderColorPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceCustomBorderColorFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_private_data
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT:
        {
            handlemap_VkPhysicalDevicePrivateDataFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDevicePrivateDataFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT:
        {
            handlemap_VkDevicePrivateDataCreateInfoEXT(handlemap, reinterpret_cast<VkDevicePrivateDataCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_pipeline_creation_cache_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT:
        {
            handlemap_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_device_diagnostics_config
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceDiagnosticsConfigFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {
            handlemap_VkDeviceDiagnosticsConfigCreateInfoNV(handlemap, reinterpret_cast<VkDeviceDiagnosticsConfigCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_fragment_shading_rate_enums
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            handlemap_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(handlemap, reinterpret_cast<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {
            handlemap_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(handlemap, reinterpret_cast<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {
            handlemap_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(handlemap, reinterpret_cast<VkPipelineFragmentShadingRateEnumStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_fragment_density_map2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {
            handlemap_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_QCOM_rotated_copy_commands
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {
            handlemap_VkCopyCommandTransformInfoQCOM(handlemap, reinterpret_cast<VkCopyCommandTransformInfoQCOM*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_image_robustness
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT:
        {
            handlemap_VkPhysicalDeviceImageRobustnessFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDeviceImageRobustnessFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_4444_formats
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            handlemap_VkPhysicalDevice4444FormatsFeaturesEXT(handlemap, reinterpret_cast<VkPhysicalDevice4444FormatsFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_GOOGLE_gfxstream
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE:
        {
            handlemap_VkImportColorBufferGOOGLE(handlemap, reinterpret_cast<VkImportColorBufferGOOGLE*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_BUFFER_GOOGLE:
        {
            handlemap_VkImportBufferGOOGLE(handlemap, reinterpret_cast<VkImportBufferGOOGLE*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE:
        {
            handlemap_VkImportPhysicalAddressGOOGLE(handlemap, reinterpret_cast<VkImportPhysicalAddressGOOGLE*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
        {
            handlemap_VkWriteDescriptorSetAccelerationStructureKHR(handlemap, reinterpret_cast<VkWriteDescriptorSetAccelerationStructureKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            handlemap_VkPhysicalDeviceAccelerationStructureFeaturesKHR(handlemap, reinterpret_cast<VkPhysicalDeviceAccelerationStructureFeaturesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {
            handlemap_VkPhysicalDeviceAccelerationStructurePropertiesKHR(handlemap, reinterpret_cast<VkPhysicalDeviceAccelerationStructurePropertiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            handlemap_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(handlemap, reinterpret_cast<VkPhysicalDeviceRayTracingPipelineFeaturesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {
            handlemap_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(handlemap, reinterpret_cast<VkPhysicalDeviceRayTracingPipelinePropertiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_ray_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            handlemap_VkPhysicalDeviceRayQueryFeaturesKHR(handlemap, reinterpret_cast<VkPhysicalDeviceRayQueryFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
        default:
        {
            return;
        }
    }
}


} // namespace goldfish_vk
