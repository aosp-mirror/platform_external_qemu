// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_reserved_marshaling
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "goldfish_vk_reserved_marshaling.h"


#include "goldfish_vk_extension_structs.h"
#include "goldfish_vk_private_defs.h"


namespace goldfish_vk {

void reservedmarshal_extension_struct(
    VulkanStream* vkStream,
    VkStructureType rootType,
    const void* structExtension,
    uint8_t** ptr);

void reservedunmarshal_extension_struct(
    VulkanStream* vkStream,
    VkStructureType rootType,
    void* structExtension_out,
    uint8_t** ptr);

#ifdef VK_VERSION_1_0
void reservedunmarshal_VkExtent2D(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExtent2D* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->width, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->height, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkExtent3D(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExtent3D* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->width, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->height, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->depth, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkOffset2D(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkOffset2D* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((int32_t*)&forUnmarshaling->x, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy((int32_t*)&forUnmarshaling->y, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedunmarshal_VkOffset3D(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkOffset3D* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((int32_t*)&forUnmarshaling->x, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy((int32_t*)&forUnmarshaling->y, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy((int32_t*)&forUnmarshaling->z, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedunmarshal_VkRect2D(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRect2D* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkOffset2D(vkStream, rootType, (VkOffset2D*)(&forUnmarshaling->offset), ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->extent), ptr);
}

void reservedunmarshal_VkBaseInStructure(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBaseInStructure* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((VkBaseInStructure*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
}

void reservedunmarshal_VkBaseOutStructure(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBaseOutStructure* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((VkBaseOutStructure*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
}

void reservedunmarshal_VkBufferMemoryBarrier(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBufferMemoryBarrier* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAccessFlags*)&forUnmarshaling->srcAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkAccessFlags*)&forUnmarshaling->dstAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((uint32_t*)&forUnmarshaling->srcQueueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dstQueueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkDispatchIndirectCommand(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDispatchIndirectCommand* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->x, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->y, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->z, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDrawIndexedIndirectCommand(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDrawIndexedIndirectCommand* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->indexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->instanceCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->firstIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((int32_t*)&forUnmarshaling->vertexOffset, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy((uint32_t*)&forUnmarshaling->firstInstance, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDrawIndirectCommand(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDrawIndirectCommand* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->vertexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->instanceCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->firstVertex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->firstInstance, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkImageSubresourceRange(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageSubresourceRange* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkImageAspectFlags*)&forUnmarshaling->aspectMask, *ptr, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy((uint32_t*)&forUnmarshaling->baseMipLevel, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->levelCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->baseArrayLayer, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->layerCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkImageMemoryBarrier(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageMemoryBarrier* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAccessFlags*)&forUnmarshaling->srcAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkAccessFlags*)&forUnmarshaling->dstAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkImageLayout*)&forUnmarshaling->oldLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((VkImageLayout*)&forUnmarshaling->newLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((uint32_t*)&forUnmarshaling->srcQueueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dstQueueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    reservedunmarshal_VkImageSubresourceRange(vkStream, rootType, (VkImageSubresourceRange*)(&forUnmarshaling->subresourceRange), ptr);
}

void reservedunmarshal_VkMemoryBarrier(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryBarrier* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAccessFlags*)&forUnmarshaling->srcAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkAccessFlags*)&forUnmarshaling->dstAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
}

void reservedunmarshal_VkAllocationCallbacks(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAllocationCallbacks* forUnmarshaling,
    uint8_t** ptr)
{
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pUserData, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pUserData);
    *ptr += 8;
    if (forUnmarshaling->pUserData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
        memcpy((void*)forUnmarshaling->pUserData, *ptr, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
    memcpy((PFN_vkAllocationFunction*)&forUnmarshaling->pfnAllocation, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnAllocation);
    *ptr += 8;
    memcpy((PFN_vkReallocationFunction*)&forUnmarshaling->pfnReallocation, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnReallocation);
    *ptr += 8;
    memcpy((PFN_vkFreeFunction*)&forUnmarshaling->pfnFree, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnFree);
    *ptr += 8;
    memcpy((PFN_vkInternalAllocationNotification*)&forUnmarshaling->pfnInternalAllocation, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnInternalAllocation);
    *ptr += 8;
    memcpy((PFN_vkInternalFreeNotification*)&forUnmarshaling->pfnInternalFree, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnInternalFree);
    *ptr += 8;
}

void reservedunmarshal_VkApplicationInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkApplicationInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        memcpy((char**)&forUnmarshaling->pApplicationName, (*ptr), 8);
        android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pApplicationName);
        *ptr += 8;
        if (forUnmarshaling->pApplicationName)
        {
            vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pApplicationName, ptr);
        }
    }
    else
    {
        vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pApplicationName, ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->applicationVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        memcpy((char**)&forUnmarshaling->pEngineName, (*ptr), 8);
        android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pEngineName);
        *ptr += 8;
        if (forUnmarshaling->pEngineName)
        {
            vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pEngineName, ptr);
        }
    }
    else
    {
        vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pEngineName, ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->engineVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->apiVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkFormatProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkFormatProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkFormatFeatureFlags*)&forUnmarshaling->linearTilingFeatures, *ptr, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
    memcpy((VkFormatFeatureFlags*)&forUnmarshaling->optimalTilingFeatures, *ptr, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
    memcpy((VkFormatFeatureFlags*)&forUnmarshaling->bufferFeatures, *ptr, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
}

void reservedunmarshal_VkImageFormatProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageFormatProperties* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forUnmarshaling->maxExtent), ptr);
    memcpy((uint32_t*)&forUnmarshaling->maxMipLevels, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxArrayLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->sampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkDeviceSize*)&forUnmarshaling->maxResourceSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkInstanceCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkInstanceCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkInstanceCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkInstanceCreateFlags));
    *ptr += sizeof(VkInstanceCreateFlags);
    // WARNING PTR CHECK
    memcpy((VkApplicationInfo**)&forUnmarshaling->pApplicationInfo, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pApplicationInfo);
    *ptr += 8;
    if (forUnmarshaling->pApplicationInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pApplicationInfo, sizeof(const VkApplicationInfo));
        reservedunmarshal_VkApplicationInfo(vkStream, rootType, (VkApplicationInfo*)(forUnmarshaling->pApplicationInfo), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->enabledLayerCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->loadStringArrayInPlaceWithStreamPtr((char***)&forUnmarshaling->ppEnabledLayerNames, ptr);
    memcpy((uint32_t*)&forUnmarshaling->enabledExtensionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->loadStringArrayInPlaceWithStreamPtr((char***)&forUnmarshaling->ppEnabledExtensionNames, ptr);
}

void reservedunmarshal_VkMemoryHeap(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryHeap* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkMemoryHeapFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkMemoryHeapFlags));
    *ptr += sizeof(VkMemoryHeapFlags);
}

void reservedunmarshal_VkMemoryType(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryType* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkMemoryPropertyFlags*)&forUnmarshaling->propertyFlags, *ptr, sizeof(VkMemoryPropertyFlags));
    *ptr += sizeof(VkMemoryPropertyFlags);
    memcpy((uint32_t*)&forUnmarshaling->heapIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPhysicalDeviceFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkBool32*)&forUnmarshaling->robustBufferAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fullDrawIndexUint32, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->imageCubeArray, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->independentBlend, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->geometryShader, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->tessellationShader, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sampleRateShading, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->dualSrcBlend, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->logicOp, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->multiDrawIndirect, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->drawIndirectFirstInstance, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->depthClamp, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->depthBiasClamp, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fillModeNonSolid, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->depthBounds, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->wideLines, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->largePoints, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->alphaToOne, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->multiViewport, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->samplerAnisotropy, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->textureCompressionETC2, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->textureCompressionASTC_LDR, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->textureCompressionBC, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->occlusionQueryPrecise, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->pipelineStatisticsQuery, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->vertexPipelineStoresAndAtomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fragmentStoresAndAtomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderTessellationAndGeometryPointSize, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderImageGatherExtended, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageExtendedFormats, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageMultisample, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageReadWithoutFormat, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageWriteWithoutFormat, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSampledImageArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderClipDistance, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderCullDistance, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderFloat64, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderInt64, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderInt16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderResourceResidency, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderResourceMinLod, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseBinding, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidencyBuffer, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidencyImage2D, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidencyImage3D, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidency2Samples, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidency4Samples, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidency8Samples, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidency16Samples, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidencyAliased, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->variableMultisampleRate, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->inheritedQueries, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceLimits(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceLimits* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->maxImageDimension1D, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxImageDimension2D, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxImageDimension3D, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxImageDimensionCube, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxImageArrayLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTexelBufferElements, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxUniformBufferRange, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxStorageBufferRange, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPushConstantsSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxMemoryAllocationCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxSamplerAllocationCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDeviceSize*)&forUnmarshaling->bufferImageGranularity, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->sparseAddressSpaceSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->maxBoundDescriptorSets, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorSamplers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUniformBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorStorageBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorSampledImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorStorageImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorInputAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageResources, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetSamplers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUniformBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUniformBuffersDynamic, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageBuffersDynamic, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetSampledImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetInputAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxVertexInputAttributes, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxVertexInputBindings, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxVertexInputAttributeOffset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxVertexInputBindingStride, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxVertexOutputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationGenerationLevel, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationPatchSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationControlPerVertexInputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationControlPerVertexOutputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationControlPerPatchOutputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationControlTotalOutputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationEvaluationInputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationEvaluationOutputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxGeometryShaderInvocations, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxGeometryInputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxGeometryOutputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxGeometryOutputVertices, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxGeometryTotalOutputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFragmentInputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFragmentOutputAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFragmentDualSrcAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFragmentCombinedOutputResources, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxComputeSharedMemorySize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)forUnmarshaling->maxComputeWorkGroupCount, *ptr, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxComputeWorkGroupInvocations, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)forUnmarshaling->maxComputeWorkGroupSize, *ptr, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->subPixelPrecisionBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->subTexelPrecisionBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->mipmapPrecisionBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDrawIndexedIndexValue, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDrawIndirectCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((float*)&forUnmarshaling->maxSamplerLodBias, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxSamplerAnisotropy, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((uint32_t*)&forUnmarshaling->maxViewports, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)forUnmarshaling->maxViewportDimensions, *ptr, 2 * sizeof(uint32_t));
    *ptr += 2 * sizeof(uint32_t);
    memcpy((float*)forUnmarshaling->viewportBoundsRange, *ptr, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy((uint32_t*)&forUnmarshaling->viewportSubPixelBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((size_t*)&forUnmarshaling->minMemoryMapAlignment, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->minMemoryMapAlignment);
    *ptr += 8;
    memcpy((VkDeviceSize*)&forUnmarshaling->minTexelBufferOffsetAlignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->minUniformBufferOffsetAlignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->minStorageBufferOffsetAlignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((int32_t*)&forUnmarshaling->minTexelOffset, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTexelOffset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((int32_t*)&forUnmarshaling->minTexelGatherOffset, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTexelGatherOffset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((float*)&forUnmarshaling->minInterpolationOffset, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxInterpolationOffset, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((uint32_t*)&forUnmarshaling->subPixelInterpolationOffsetBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFramebufferWidth, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFramebufferHeight, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFramebufferLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->framebufferColorSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->framebufferDepthSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->framebufferStencilSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->framebufferNoAttachmentsSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((uint32_t*)&forUnmarshaling->maxColorAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->sampledImageColorSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->sampledImageIntegerSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->sampledImageDepthSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->sampledImageStencilSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->storageImageSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((uint32_t*)&forUnmarshaling->maxSampleMaskWords, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->timestampComputeAndGraphics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((float*)&forUnmarshaling->timestampPeriod, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((uint32_t*)&forUnmarshaling->maxClipDistances, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxCullDistances, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxCombinedClipAndCullDistances, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->discreteQueuePriorities, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((float*)forUnmarshaling->pointSizeRange, *ptr, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy((float*)forUnmarshaling->lineWidthRange, *ptr, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy((float*)&forUnmarshaling->pointSizeGranularity, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->lineWidthGranularity, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((VkBool32*)&forUnmarshaling->strictLines, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->standardSampleLocations, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkDeviceSize*)&forUnmarshaling->optimalBufferCopyOffsetAlignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->optimalBufferCopyRowPitchAlignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->nonCoherentAtomSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkPhysicalDeviceMemoryProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceMemoryProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->memoryTypeCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        reservedunmarshal_VkMemoryType(vkStream, rootType, (VkMemoryType*)(forUnmarshaling->memoryTypes + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->memoryHeapCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        reservedunmarshal_VkMemoryHeap(vkStream, rootType, (VkMemoryHeap*)(forUnmarshaling->memoryHeaps + i), ptr);
    }
}

void reservedunmarshal_VkPhysicalDeviceSparseProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceSparseProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkBool32*)&forUnmarshaling->residencyStandard2DBlockShape, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->residencyStandard2DMultisampleBlockShape, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->residencyStandard3DBlockShape, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->residencyAlignedMipSize, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->residencyNonResidentStrict, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->apiVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->driverVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->vendorID, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->deviceID, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkPhysicalDeviceType*)&forUnmarshaling->deviceType, *ptr, sizeof(VkPhysicalDeviceType));
    *ptr += sizeof(VkPhysicalDeviceType);
    memcpy((char*)forUnmarshaling->deviceName, *ptr, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char);
    memcpy((uint8_t*)forUnmarshaling->pipelineCacheUUID, *ptr, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    reservedunmarshal_VkPhysicalDeviceLimits(vkStream, rootType, (VkPhysicalDeviceLimits*)(&forUnmarshaling->limits), ptr);
    reservedunmarshal_VkPhysicalDeviceSparseProperties(vkStream, rootType, (VkPhysicalDeviceSparseProperties*)(&forUnmarshaling->sparseProperties), ptr);
}

void reservedunmarshal_VkQueueFamilyProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkQueueFamilyProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkQueueFlags*)&forUnmarshaling->queueFlags, *ptr, sizeof(VkQueueFlags));
    *ptr += sizeof(VkQueueFlags);
    memcpy((uint32_t*)&forUnmarshaling->queueCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->timestampValidBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forUnmarshaling->minImageTransferGranularity), ptr);
}

void reservedunmarshal_VkDeviceQueueCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceQueueCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceQueueCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkDeviceQueueCreateFlags));
    *ptr += sizeof(VkDeviceQueueCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->queueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->queueCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pQueuePriorities, forUnmarshaling->queueCount * sizeof(const float));
    memcpy((float*)forUnmarshaling->pQueuePriorities, *ptr, forUnmarshaling->queueCount * sizeof(const float));
    *ptr += forUnmarshaling->queueCount * sizeof(const float);
}

void reservedunmarshal_VkDeviceCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkDeviceCreateFlags));
    *ptr += sizeof(VkDeviceCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->queueCreateInfoCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pQueueCreateInfos, forUnmarshaling->queueCreateInfoCount * sizeof(const VkDeviceQueueCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->queueCreateInfoCount; ++i)
    {
        reservedunmarshal_VkDeviceQueueCreateInfo(vkStream, rootType, (VkDeviceQueueCreateInfo*)(forUnmarshaling->pQueueCreateInfos + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->enabledLayerCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->loadStringArrayInPlaceWithStreamPtr((char***)&forUnmarshaling->ppEnabledLayerNames, ptr);
    memcpy((uint32_t*)&forUnmarshaling->enabledExtensionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->loadStringArrayInPlaceWithStreamPtr((char***)&forUnmarshaling->ppEnabledExtensionNames, ptr);
    // WARNING PTR CHECK
    memcpy((VkPhysicalDeviceFeatures**)&forUnmarshaling->pEnabledFeatures, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pEnabledFeatures);
    *ptr += 8;
    if (forUnmarshaling->pEnabledFeatures)
    {
        vkStream->alloc((void**)&forUnmarshaling->pEnabledFeatures, sizeof(const VkPhysicalDeviceFeatures));
        reservedunmarshal_VkPhysicalDeviceFeatures(vkStream, rootType, (VkPhysicalDeviceFeatures*)(forUnmarshaling->pEnabledFeatures), ptr);
    }
}

void reservedunmarshal_VkExtensionProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExtensionProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((char*)forUnmarshaling->extensionName, *ptr, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    memcpy((uint32_t*)&forUnmarshaling->specVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkLayerProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkLayerProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((char*)forUnmarshaling->layerName, *ptr, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    memcpy((uint32_t*)&forUnmarshaling->specVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->implementationVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((char*)forUnmarshaling->description, *ptr, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
}

void reservedunmarshal_VkSubmitInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSubmitInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->waitSemaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->waitSemaphoreCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->waitSemaphoreCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->waitSemaphoreCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                *(((VkSemaphore*)forUnmarshaling->pWaitSemaphores) + k) = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)tmpval);
            }
        }
    }
    vkStream->alloc((void**)&forUnmarshaling->pWaitDstStageMask, forUnmarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    memcpy((VkPipelineStageFlags*)forUnmarshaling->pWaitDstStageMask, *ptr, forUnmarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    *ptr += forUnmarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags);
    memcpy((uint32_t*)&forUnmarshaling->commandBufferCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pCommandBuffers, forUnmarshaling->commandBufferCount * sizeof(const VkCommandBuffer));
    if (forUnmarshaling->commandBufferCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->commandBufferCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->commandBufferCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                *(((VkCommandBuffer*)forUnmarshaling->pCommandBuffers) + k) = (VkCommandBuffer)unbox_VkCommandBuffer((VkCommandBuffer)tmpval);
            }
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->signalSemaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphores, forUnmarshaling->signalSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->signalSemaphoreCount)
    {
        uint8_t* cgen_var_2_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->signalSemaphoreCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->signalSemaphoreCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_2_ptr + k * 8, sizeof(uint64_t));
                *(((VkSemaphore*)forUnmarshaling->pSignalSemaphores) + k) = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)tmpval);
            }
        }
    }
}

void reservedunmarshal_VkMappedMemoryRange(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMappedMemoryRange* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkMemoryAllocateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryAllocateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceSize*)&forUnmarshaling->allocationSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->memoryTypeIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkMemoryRequirements(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryRequirements* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->alignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->memoryTypeBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkSparseMemoryBind(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSparseMemoryBind* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceSize*)&forUnmarshaling->resourceOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->memoryOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkSparseMemoryBindFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSparseMemoryBindFlags));
    *ptr += sizeof(VkSparseMemoryBindFlags);
}

void reservedunmarshal_VkSparseBufferMemoryBindInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSparseBufferMemoryBindInfo* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->bindCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pBinds, forUnmarshaling->bindCount * sizeof(const VkSparseMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        reservedunmarshal_VkSparseMemoryBind(vkStream, rootType, (VkSparseMemoryBind*)(forUnmarshaling->pBinds + i), ptr);
    }
}

void reservedunmarshal_VkSparseImageOpaqueMemoryBindInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSparseImageOpaqueMemoryBindInfo* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->bindCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pBinds, forUnmarshaling->bindCount * sizeof(const VkSparseMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        reservedunmarshal_VkSparseMemoryBind(vkStream, rootType, (VkSparseMemoryBind*)(forUnmarshaling->pBinds + i), ptr);
    }
}

void reservedunmarshal_VkImageSubresource(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageSubresource* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkImageAspectFlags*)&forUnmarshaling->aspectMask, *ptr, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy((uint32_t*)&forUnmarshaling->mipLevel, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->arrayLayer, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkSparseImageMemoryBind(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSparseImageMemoryBind* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkImageSubresource(vkStream, rootType, (VkImageSubresource*)(&forUnmarshaling->subresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forUnmarshaling->offset), ptr);
    reservedunmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forUnmarshaling->extent), ptr);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->memoryOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkSparseMemoryBindFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSparseMemoryBindFlags));
    *ptr += sizeof(VkSparseMemoryBindFlags);
}

void reservedunmarshal_VkSparseImageMemoryBindInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSparseImageMemoryBindInfo* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->bindCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pBinds, forUnmarshaling->bindCount * sizeof(const VkSparseImageMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        reservedunmarshal_VkSparseImageMemoryBind(vkStream, rootType, (VkSparseImageMemoryBind*)(forUnmarshaling->pBinds + i), ptr);
    }
}

void reservedunmarshal_VkBindSparseInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBindSparseInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->waitSemaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->waitSemaphoreCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->waitSemaphoreCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->waitSemaphoreCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                *(((VkSemaphore*)forUnmarshaling->pWaitSemaphores) + k) = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)tmpval);
            }
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->bufferBindCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pBufferBinds, forUnmarshaling->bufferBindCount * sizeof(const VkSparseBufferMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bufferBindCount; ++i)
    {
        reservedunmarshal_VkSparseBufferMemoryBindInfo(vkStream, rootType, (VkSparseBufferMemoryBindInfo*)(forUnmarshaling->pBufferBinds + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->imageOpaqueBindCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pImageOpaqueBinds, forUnmarshaling->imageOpaqueBindCount * sizeof(const VkSparseImageOpaqueMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->imageOpaqueBindCount; ++i)
    {
        reservedunmarshal_VkSparseImageOpaqueMemoryBindInfo(vkStream, rootType, (VkSparseImageOpaqueMemoryBindInfo*)(forUnmarshaling->pImageOpaqueBinds + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->imageBindCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pImageBinds, forUnmarshaling->imageBindCount * sizeof(const VkSparseImageMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->imageBindCount; ++i)
    {
        reservedunmarshal_VkSparseImageMemoryBindInfo(vkStream, rootType, (VkSparseImageMemoryBindInfo*)(forUnmarshaling->pImageBinds + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->signalSemaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphores, forUnmarshaling->signalSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->signalSemaphoreCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->signalSemaphoreCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->signalSemaphoreCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                *(((VkSemaphore*)forUnmarshaling->pSignalSemaphores) + k) = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)tmpval);
            }
        }
    }
}

void reservedunmarshal_VkSparseImageFormatProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSparseImageFormatProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkImageAspectFlags*)&forUnmarshaling->aspectMask, *ptr, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    reservedunmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forUnmarshaling->imageGranularity), ptr);
    memcpy((VkSparseImageFormatFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSparseImageFormatFlags));
    *ptr += sizeof(VkSparseImageFormatFlags);
}

void reservedunmarshal_VkSparseImageMemoryRequirements(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSparseImageMemoryRequirements* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkSparseImageFormatProperties(vkStream, rootType, (VkSparseImageFormatProperties*)(&forUnmarshaling->formatProperties), ptr);
    memcpy((uint32_t*)&forUnmarshaling->imageMipTailFirstLod, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDeviceSize*)&forUnmarshaling->imageMipTailSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->imageMipTailOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->imageMipTailStride, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkFenceCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkFenceCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFenceCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkFenceCreateFlags));
    *ptr += sizeof(VkFenceCreateFlags);
}

void reservedunmarshal_VkSemaphoreCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSemaphoreCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSemaphoreCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSemaphoreCreateFlags));
    *ptr += sizeof(VkSemaphoreCreateFlags);
}

void reservedunmarshal_VkEventCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkEventCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkEventCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkEventCreateFlags));
    *ptr += sizeof(VkEventCreateFlags);
}

void reservedunmarshal_VkQueryPoolCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkQueryPoolCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkQueryPoolCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkQueryPoolCreateFlags));
    *ptr += sizeof(VkQueryPoolCreateFlags);
    memcpy((VkQueryType*)&forUnmarshaling->queryType, *ptr, sizeof(VkQueryType));
    *ptr += sizeof(VkQueryType);
    memcpy((uint32_t*)&forUnmarshaling->queryCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkQueryPipelineStatisticFlags*)&forUnmarshaling->pipelineStatistics, *ptr, sizeof(VkQueryPipelineStatisticFlags));
    *ptr += sizeof(VkQueryPipelineStatisticFlags);
}

void reservedunmarshal_VkBufferCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBufferCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBufferCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkBufferCreateFlags));
    *ptr += sizeof(VkBufferCreateFlags);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkBufferUsageFlags*)&forUnmarshaling->usage, *ptr, sizeof(VkBufferUsageFlags));
    *ptr += sizeof(VkBufferUsageFlags);
    memcpy((VkSharingMode*)&forUnmarshaling->sharingMode, *ptr, sizeof(VkSharingMode));
    *ptr += sizeof(VkSharingMode);
    memcpy((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((uint32_t**)&forUnmarshaling->pQueueFamilyIndices, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pQueueFamilyIndices);
    *ptr += 8;
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        memcpy((uint32_t*)forUnmarshaling->pQueueFamilyIndices, *ptr, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        *ptr += forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t);
    }
}

void reservedunmarshal_VkBufferViewCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBufferViewCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBufferViewCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkBufferViewCreateFlags));
    *ptr += sizeof(VkBufferViewCreateFlags);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->range, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkImageCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkImageCreateFlags));
    *ptr += sizeof(VkImageCreateFlags);
    memcpy((VkImageType*)&forUnmarshaling->imageType, *ptr, sizeof(VkImageType));
    *ptr += sizeof(VkImageType);
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    reservedunmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forUnmarshaling->extent), ptr);
    memcpy((uint32_t*)&forUnmarshaling->mipLevels, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->arrayLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->samples, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy((VkImageTiling*)&forUnmarshaling->tiling, *ptr, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
    memcpy((VkImageUsageFlags*)&forUnmarshaling->usage, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy((VkSharingMode*)&forUnmarshaling->sharingMode, *ptr, sizeof(VkSharingMode));
    *ptr += sizeof(VkSharingMode);
    memcpy((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((uint32_t**)&forUnmarshaling->pQueueFamilyIndices, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pQueueFamilyIndices);
    *ptr += 8;
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        memcpy((uint32_t*)forUnmarshaling->pQueueFamilyIndices, *ptr, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        *ptr += forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t);
    }
    memcpy((VkImageLayout*)&forUnmarshaling->initialLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedunmarshal_VkSubresourceLayout(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSubresourceLayout* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->rowPitch, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->arrayPitch, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->depthPitch, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkComponentMapping(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkComponentMapping* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkComponentSwizzle*)&forUnmarshaling->r, *ptr, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
    memcpy((VkComponentSwizzle*)&forUnmarshaling->g, *ptr, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
    memcpy((VkComponentSwizzle*)&forUnmarshaling->b, *ptr, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
    memcpy((VkComponentSwizzle*)&forUnmarshaling->a, *ptr, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
}

void reservedunmarshal_VkImageViewCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageViewCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageViewCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkImageViewCreateFlags));
    *ptr += sizeof(VkImageViewCreateFlags);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    memcpy((VkImageViewType*)&forUnmarshaling->viewType, *ptr, sizeof(VkImageViewType));
    *ptr += sizeof(VkImageViewType);
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    reservedunmarshal_VkComponentMapping(vkStream, rootType, (VkComponentMapping*)(&forUnmarshaling->components), ptr);
    reservedunmarshal_VkImageSubresourceRange(vkStream, rootType, (VkImageSubresourceRange*)(&forUnmarshaling->subresourceRange), ptr);
}

void reservedunmarshal_VkShaderModuleCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkShaderModuleCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkShaderModuleCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkShaderModuleCreateFlags));
    *ptr += sizeof(VkShaderModuleCreateFlags);
    memcpy((size_t*)&forUnmarshaling->codeSize, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->codeSize);
    *ptr += 8;
    vkStream->alloc((void**)&forUnmarshaling->pCode, (forUnmarshaling->codeSize / 4) * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pCode, *ptr, (forUnmarshaling->codeSize / 4) * sizeof(const uint32_t));
    *ptr += (forUnmarshaling->codeSize / 4) * sizeof(const uint32_t);
}

void reservedunmarshal_VkPipelineCacheCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineCacheCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineCacheCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineCacheCreateFlags));
    *ptr += sizeof(VkPipelineCacheCreateFlags);
    memcpy((size_t*)&forUnmarshaling->initialDataSize, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->initialDataSize);
    *ptr += 8;
    vkStream->alloc((void**)&forUnmarshaling->pInitialData, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
    memcpy((void*)forUnmarshaling->pInitialData, *ptr, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
    *ptr += forUnmarshaling->initialDataSize * sizeof(const uint8_t);
}

void reservedunmarshal_VkSpecializationMapEntry(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSpecializationMapEntry* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->constantID, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->offset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((size_t*)&forUnmarshaling->size, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->size);
    *ptr += 8;
}

void reservedunmarshal_VkSpecializationInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSpecializationInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->mapEntryCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pMapEntries, forUnmarshaling->mapEntryCount * sizeof(const VkSpecializationMapEntry));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->mapEntryCount; ++i)
    {
        reservedunmarshal_VkSpecializationMapEntry(vkStream, rootType, (VkSpecializationMapEntry*)(forUnmarshaling->pMapEntries + i), ptr);
    }
    memcpy((size_t*)&forUnmarshaling->dataSize, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->dataSize);
    *ptr += 8;
    vkStream->alloc((void**)&forUnmarshaling->pData, forUnmarshaling->dataSize * sizeof(const uint8_t));
    memcpy((void*)forUnmarshaling->pData, *ptr, forUnmarshaling->dataSize * sizeof(const uint8_t));
    *ptr += forUnmarshaling->dataSize * sizeof(const uint8_t);
}

void reservedunmarshal_VkPipelineShaderStageCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineShaderStageCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineShaderStageCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineShaderStageCreateFlags));
    *ptr += sizeof(VkPipelineShaderStageCreateFlags);
    memcpy((VkShaderStageFlagBits*)&forUnmarshaling->stage, *ptr, sizeof(VkShaderStageFlagBits));
    *ptr += sizeof(VkShaderStageFlagBits);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkShaderModule*)&forUnmarshaling->module = (VkShaderModule)unbox_VkShaderModule((VkShaderModule)(*&cgen_var_0));
    vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pName, ptr);
    // WARNING PTR CHECK
    memcpy((VkSpecializationInfo**)&forUnmarshaling->pSpecializationInfo, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pSpecializationInfo);
    *ptr += 8;
    if (forUnmarshaling->pSpecializationInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pSpecializationInfo, sizeof(const VkSpecializationInfo));
        reservedunmarshal_VkSpecializationInfo(vkStream, rootType, (VkSpecializationInfo*)(forUnmarshaling->pSpecializationInfo), ptr);
    }
}

void reservedunmarshal_VkComputePipelineCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkComputePipelineCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineCreateFlags));
    *ptr += sizeof(VkPipelineCreateFlags);
    reservedunmarshal_VkPipelineShaderStageCreateInfo(vkStream, rootType, (VkPipelineShaderStageCreateInfo*)(&forUnmarshaling->stage), ptr);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipelineLayout*)&forUnmarshaling->layout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipeline*)&forUnmarshaling->basePipelineHandle = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_1));
    memcpy((int32_t*)&forUnmarshaling->basePipelineIndex, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedunmarshal_VkVertexInputBindingDescription(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkVertexInputBindingDescription* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->binding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->stride, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkVertexInputRate*)&forUnmarshaling->inputRate, *ptr, sizeof(VkVertexInputRate));
    *ptr += sizeof(VkVertexInputRate);
}

void reservedunmarshal_VkVertexInputAttributeDescription(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkVertexInputAttributeDescription* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->location, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->binding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((uint32_t*)&forUnmarshaling->offset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPipelineVertexInputStateCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineVertexInputStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineVertexInputStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineVertexInputStateCreateFlags));
    *ptr += sizeof(VkPipelineVertexInputStateCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->vertexBindingDescriptionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pVertexBindingDescriptions, forUnmarshaling->vertexBindingDescriptionCount * sizeof(const VkVertexInputBindingDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexBindingDescriptionCount; ++i)
    {
        reservedunmarshal_VkVertexInputBindingDescription(vkStream, rootType, (VkVertexInputBindingDescription*)(forUnmarshaling->pVertexBindingDescriptions + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->vertexAttributeDescriptionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pVertexAttributeDescriptions, forUnmarshaling->vertexAttributeDescriptionCount * sizeof(const VkVertexInputAttributeDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexAttributeDescriptionCount; ++i)
    {
        reservedunmarshal_VkVertexInputAttributeDescription(vkStream, rootType, (VkVertexInputAttributeDescription*)(forUnmarshaling->pVertexAttributeDescriptions + i), ptr);
    }
}

void reservedunmarshal_VkPipelineInputAssemblyStateCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineInputAssemblyStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineInputAssemblyStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineInputAssemblyStateCreateFlags));
    *ptr += sizeof(VkPipelineInputAssemblyStateCreateFlags);
    memcpy((VkPrimitiveTopology*)&forUnmarshaling->topology, *ptr, sizeof(VkPrimitiveTopology));
    *ptr += sizeof(VkPrimitiveTopology);
    memcpy((VkBool32*)&forUnmarshaling->primitiveRestartEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPipelineTessellationStateCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineTessellationStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineTessellationStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineTessellationStateCreateFlags));
    *ptr += sizeof(VkPipelineTessellationStateCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->patchControlPoints, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkViewport(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkViewport* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((float*)&forUnmarshaling->x, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->y, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->width, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->height, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->minDepth, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxDepth, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

void reservedunmarshal_VkPipelineViewportStateCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineViewportStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineViewportStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineViewportStateCreateFlags));
    *ptr += sizeof(VkPipelineViewportStateCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->viewportCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkViewport**)&forUnmarshaling->pViewports, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pViewports);
    *ptr += 8;
    if (forUnmarshaling->pViewports)
    {
        vkStream->alloc((void**)&forUnmarshaling->pViewports, forUnmarshaling->viewportCount * sizeof(const VkViewport));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            reservedunmarshal_VkViewport(vkStream, rootType, (VkViewport*)(forUnmarshaling->pViewports + i), ptr);
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->scissorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkRect2D**)&forUnmarshaling->pScissors, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pScissors);
    *ptr += 8;
    if (forUnmarshaling->pScissors)
    {
        vkStream->alloc((void**)&forUnmarshaling->pScissors, forUnmarshaling->scissorCount * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->scissorCount; ++i)
        {
            reservedunmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(forUnmarshaling->pScissors + i), ptr);
        }
    }
}

void reservedunmarshal_VkPipelineRasterizationStateCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineRasterizationStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineRasterizationStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineRasterizationStateCreateFlags));
    *ptr += sizeof(VkPipelineRasterizationStateCreateFlags);
    memcpy((VkBool32*)&forUnmarshaling->depthClampEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->rasterizerDiscardEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkPolygonMode*)&forUnmarshaling->polygonMode, *ptr, sizeof(VkPolygonMode));
    *ptr += sizeof(VkPolygonMode);
    memcpy((VkCullModeFlags*)&forUnmarshaling->cullMode, *ptr, sizeof(VkCullModeFlags));
    *ptr += sizeof(VkCullModeFlags);
    memcpy((VkFrontFace*)&forUnmarshaling->frontFace, *ptr, sizeof(VkFrontFace));
    *ptr += sizeof(VkFrontFace);
    memcpy((VkBool32*)&forUnmarshaling->depthBiasEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((float*)&forUnmarshaling->depthBiasConstantFactor, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->depthBiasClamp, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->depthBiasSlopeFactor, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->lineWidth, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

void reservedunmarshal_VkPipelineMultisampleStateCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineMultisampleStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineMultisampleStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineMultisampleStateCreateFlags));
    *ptr += sizeof(VkPipelineMultisampleStateCreateFlags);
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->rasterizationSamples, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy((VkBool32*)&forUnmarshaling->sampleShadingEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((float*)&forUnmarshaling->minSampleShading, *ptr, sizeof(float));
    *ptr += sizeof(float);
    // WARNING PTR CHECK
    memcpy((VkSampleMask**)&forUnmarshaling->pSampleMask, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pSampleMask);
    *ptr += 8;
    if (forUnmarshaling->pSampleMask)
    {
        vkStream->alloc((void**)&forUnmarshaling->pSampleMask, (((forUnmarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
        memcpy((VkSampleMask*)forUnmarshaling->pSampleMask, *ptr, (((forUnmarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
        *ptr += (((forUnmarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask);
    }
    memcpy((VkBool32*)&forUnmarshaling->alphaToCoverageEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->alphaToOneEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkStencilOpState(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkStencilOpState* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStencilOp*)&forUnmarshaling->failOp, *ptr, sizeof(VkStencilOp));
    *ptr += sizeof(VkStencilOp);
    memcpy((VkStencilOp*)&forUnmarshaling->passOp, *ptr, sizeof(VkStencilOp));
    *ptr += sizeof(VkStencilOp);
    memcpy((VkStencilOp*)&forUnmarshaling->depthFailOp, *ptr, sizeof(VkStencilOp));
    *ptr += sizeof(VkStencilOp);
    memcpy((VkCompareOp*)&forUnmarshaling->compareOp, *ptr, sizeof(VkCompareOp));
    *ptr += sizeof(VkCompareOp);
    memcpy((uint32_t*)&forUnmarshaling->compareMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->writeMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->reference, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPipelineDepthStencilStateCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineDepthStencilStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineDepthStencilStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineDepthStencilStateCreateFlags));
    *ptr += sizeof(VkPipelineDepthStencilStateCreateFlags);
    memcpy((VkBool32*)&forUnmarshaling->depthTestEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->depthWriteEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkCompareOp*)&forUnmarshaling->depthCompareOp, *ptr, sizeof(VkCompareOp));
    *ptr += sizeof(VkCompareOp);
    memcpy((VkBool32*)&forUnmarshaling->depthBoundsTestEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->stencilTestEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    reservedunmarshal_VkStencilOpState(vkStream, rootType, (VkStencilOpState*)(&forUnmarshaling->front), ptr);
    reservedunmarshal_VkStencilOpState(vkStream, rootType, (VkStencilOpState*)(&forUnmarshaling->back), ptr);
    memcpy((float*)&forUnmarshaling->minDepthBounds, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxDepthBounds, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

void reservedunmarshal_VkPipelineColorBlendAttachmentState(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineColorBlendAttachmentState* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkBool32*)&forUnmarshaling->blendEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBlendFactor*)&forUnmarshaling->srcColorBlendFactor, *ptr, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy((VkBlendFactor*)&forUnmarshaling->dstColorBlendFactor, *ptr, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy((VkBlendOp*)&forUnmarshaling->colorBlendOp, *ptr, sizeof(VkBlendOp));
    *ptr += sizeof(VkBlendOp);
    memcpy((VkBlendFactor*)&forUnmarshaling->srcAlphaBlendFactor, *ptr, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy((VkBlendFactor*)&forUnmarshaling->dstAlphaBlendFactor, *ptr, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy((VkBlendOp*)&forUnmarshaling->alphaBlendOp, *ptr, sizeof(VkBlendOp));
    *ptr += sizeof(VkBlendOp);
    memcpy((VkColorComponentFlags*)&forUnmarshaling->colorWriteMask, *ptr, sizeof(VkColorComponentFlags));
    *ptr += sizeof(VkColorComponentFlags);
}

void reservedunmarshal_VkPipelineColorBlendStateCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineColorBlendStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineColorBlendStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineColorBlendStateCreateFlags));
    *ptr += sizeof(VkPipelineColorBlendStateCreateFlags);
    memcpy((VkBool32*)&forUnmarshaling->logicOpEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkLogicOp*)&forUnmarshaling->logicOp, *ptr, sizeof(VkLogicOp));
    *ptr += sizeof(VkLogicOp);
    memcpy((uint32_t*)&forUnmarshaling->attachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkPipelineColorBlendAttachmentState));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        reservedunmarshal_VkPipelineColorBlendAttachmentState(vkStream, rootType, (VkPipelineColorBlendAttachmentState*)(forUnmarshaling->pAttachments + i), ptr);
    }
    memcpy((float*)forUnmarshaling->blendConstants, *ptr, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

void reservedunmarshal_VkPipelineDynamicStateCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineDynamicStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineDynamicStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineDynamicStateCreateFlags));
    *ptr += sizeof(VkPipelineDynamicStateCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->dynamicStateCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDynamicStates, forUnmarshaling->dynamicStateCount * sizeof(const VkDynamicState));
    memcpy((VkDynamicState*)forUnmarshaling->pDynamicStates, *ptr, forUnmarshaling->dynamicStateCount * sizeof(const VkDynamicState));
    *ptr += forUnmarshaling->dynamicStateCount * sizeof(const VkDynamicState);
}

void reservedunmarshal_VkGraphicsPipelineCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkGraphicsPipelineCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    uint32_t hasRasterization = 1;
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        memcpy((uint32_t*)&hasRasterization, (*ptr), 4);
        android::base::Stream::fromBe32((uint8_t*)&hasRasterization);
        *ptr += 4;
    }
    uint32_t hasTessellation = 1;
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        memcpy((uint32_t*)&hasTessellation, (*ptr), 4);
        android::base::Stream::fromBe32((uint8_t*)&hasTessellation);
        *ptr += 4;
    }
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineCreateFlags));
    *ptr += sizeof(VkPipelineCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->stageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pStages, forUnmarshaling->stageCount * sizeof(const VkPipelineShaderStageCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->stageCount; ++i)
    {
        reservedunmarshal_VkPipelineShaderStageCreateInfo(vkStream, rootType, (VkPipelineShaderStageCreateInfo*)(forUnmarshaling->pStages + i), ptr);
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        memcpy((VkPipelineVertexInputStateCreateInfo**)&forUnmarshaling->pVertexInputState, (*ptr), 8);
        android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pVertexInputState);
        *ptr += 8;
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forUnmarshaling->pVertexInputState))
    {
        vkStream->alloc((void**)&forUnmarshaling->pVertexInputState, sizeof(const VkPipelineVertexInputStateCreateInfo));
        reservedunmarshal_VkPipelineVertexInputStateCreateInfo(vkStream, rootType, (VkPipelineVertexInputStateCreateInfo*)(forUnmarshaling->pVertexInputState), ptr);
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        memcpy((VkPipelineInputAssemblyStateCreateInfo**)&forUnmarshaling->pInputAssemblyState, (*ptr), 8);
        android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pInputAssemblyState);
        *ptr += 8;
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forUnmarshaling->pInputAssemblyState))
    {
        vkStream->alloc((void**)&forUnmarshaling->pInputAssemblyState, sizeof(const VkPipelineInputAssemblyStateCreateInfo));
        reservedunmarshal_VkPipelineInputAssemblyStateCreateInfo(vkStream, rootType, (VkPipelineInputAssemblyStateCreateInfo*)(forUnmarshaling->pInputAssemblyState), ptr);
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineTessellationStateCreateInfo**)&forUnmarshaling->pTessellationState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pTessellationState);
    *ptr += 8;
    if (forUnmarshaling->pTessellationState)
    {
        if (hasTessellation)
        {
            vkStream->alloc((void**)&forUnmarshaling->pTessellationState, sizeof(const VkPipelineTessellationStateCreateInfo));
            reservedunmarshal_VkPipelineTessellationStateCreateInfo(vkStream, rootType, (VkPipelineTessellationStateCreateInfo*)(forUnmarshaling->pTessellationState), ptr);
        }
        else
        {
            forUnmarshaling->pTessellationState = 0;
        }
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineViewportStateCreateInfo**)&forUnmarshaling->pViewportState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pViewportState);
    *ptr += 8;
    if (forUnmarshaling->pViewportState)
    {
        if (hasRasterization)
        {
            vkStream->alloc((void**)&forUnmarshaling->pViewportState, sizeof(const VkPipelineViewportStateCreateInfo));
            reservedunmarshal_VkPipelineViewportStateCreateInfo(vkStream, rootType, (VkPipelineViewportStateCreateInfo*)(forUnmarshaling->pViewportState), ptr);
        }
        else
        {
            forUnmarshaling->pViewportState = 0;
        }
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        memcpy((VkPipelineRasterizationStateCreateInfo**)&forUnmarshaling->pRasterizationState, (*ptr), 8);
        android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pRasterizationState);
        *ptr += 8;
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forUnmarshaling->pRasterizationState))
    {
        vkStream->alloc((void**)&forUnmarshaling->pRasterizationState, sizeof(const VkPipelineRasterizationStateCreateInfo));
        reservedunmarshal_VkPipelineRasterizationStateCreateInfo(vkStream, rootType, (VkPipelineRasterizationStateCreateInfo*)(forUnmarshaling->pRasterizationState), ptr);
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineMultisampleStateCreateInfo**)&forUnmarshaling->pMultisampleState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pMultisampleState);
    *ptr += 8;
    if (forUnmarshaling->pMultisampleState)
    {
        if (hasRasterization)
        {
            vkStream->alloc((void**)&forUnmarshaling->pMultisampleState, sizeof(const VkPipelineMultisampleStateCreateInfo));
            reservedunmarshal_VkPipelineMultisampleStateCreateInfo(vkStream, rootType, (VkPipelineMultisampleStateCreateInfo*)(forUnmarshaling->pMultisampleState), ptr);
        }
        else
        {
            forUnmarshaling->pMultisampleState = 0;
        }
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineDepthStencilStateCreateInfo**)&forUnmarshaling->pDepthStencilState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pDepthStencilState);
    *ptr += 8;
    if (forUnmarshaling->pDepthStencilState)
    {
        if (hasRasterization)
        {
            vkStream->alloc((void**)&forUnmarshaling->pDepthStencilState, sizeof(const VkPipelineDepthStencilStateCreateInfo));
            reservedunmarshal_VkPipelineDepthStencilStateCreateInfo(vkStream, rootType, (VkPipelineDepthStencilStateCreateInfo*)(forUnmarshaling->pDepthStencilState), ptr);
        }
        else
        {
            forUnmarshaling->pDepthStencilState = 0;
        }
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineColorBlendStateCreateInfo**)&forUnmarshaling->pColorBlendState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pColorBlendState);
    *ptr += 8;
    if (forUnmarshaling->pColorBlendState)
    {
        if (hasRasterization)
        {
            vkStream->alloc((void**)&forUnmarshaling->pColorBlendState, sizeof(const VkPipelineColorBlendStateCreateInfo));
            reservedunmarshal_VkPipelineColorBlendStateCreateInfo(vkStream, rootType, (VkPipelineColorBlendStateCreateInfo*)(forUnmarshaling->pColorBlendState), ptr);
        }
        else
        {
            forUnmarshaling->pColorBlendState = 0;
        }
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineDynamicStateCreateInfo**)&forUnmarshaling->pDynamicState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pDynamicState);
    *ptr += 8;
    if (forUnmarshaling->pDynamicState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDynamicState, sizeof(const VkPipelineDynamicStateCreateInfo));
        reservedunmarshal_VkPipelineDynamicStateCreateInfo(vkStream, rootType, (VkPipelineDynamicStateCreateInfo*)(forUnmarshaling->pDynamicState), ptr);
    }
    uint64_t cgen_var_6;
    memcpy((uint64_t*)&cgen_var_6, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipelineLayout*)&forUnmarshaling->layout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_6));
    uint64_t cgen_var_7;
    memcpy((uint64_t*)&cgen_var_7, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkRenderPass*)&forUnmarshaling->renderPass = (VkRenderPass)unbox_VkRenderPass((VkRenderPass)(*&cgen_var_7));
    memcpy((uint32_t*)&forUnmarshaling->subpass, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_8;
    memcpy((uint64_t*)&cgen_var_8, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipeline*)&forUnmarshaling->basePipelineHandle = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_8));
    memcpy((int32_t*)&forUnmarshaling->basePipelineIndex, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedunmarshal_VkPushConstantRange(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPushConstantRange* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkShaderStageFlags*)&forUnmarshaling->stageFlags, *ptr, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    memcpy((uint32_t*)&forUnmarshaling->offset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->size, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPipelineLayoutCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineLayoutCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineLayoutCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineLayoutCreateFlags));
    *ptr += sizeof(VkPipelineLayoutCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->setLayoutCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSetLayouts, forUnmarshaling->setLayoutCount * sizeof(const VkDescriptorSetLayout));
    if (forUnmarshaling->setLayoutCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->setLayoutCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->setLayoutCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                *(((VkDescriptorSetLayout*)forUnmarshaling->pSetLayouts) + k) = (VkDescriptorSetLayout)unbox_VkDescriptorSetLayout((VkDescriptorSetLayout)tmpval);
            }
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->pushConstantRangeCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPushConstantRanges, forUnmarshaling->pushConstantRangeCount * sizeof(const VkPushConstantRange));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->pushConstantRangeCount; ++i)
    {
        reservedunmarshal_VkPushConstantRange(vkStream, rootType, (VkPushConstantRange*)(forUnmarshaling->pPushConstantRanges + i), ptr);
    }
}

void reservedunmarshal_VkSamplerCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSamplerCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSamplerCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSamplerCreateFlags));
    *ptr += sizeof(VkSamplerCreateFlags);
    memcpy((VkFilter*)&forUnmarshaling->magFilter, *ptr, sizeof(VkFilter));
    *ptr += sizeof(VkFilter);
    memcpy((VkFilter*)&forUnmarshaling->minFilter, *ptr, sizeof(VkFilter));
    *ptr += sizeof(VkFilter);
    memcpy((VkSamplerMipmapMode*)&forUnmarshaling->mipmapMode, *ptr, sizeof(VkSamplerMipmapMode));
    *ptr += sizeof(VkSamplerMipmapMode);
    memcpy((VkSamplerAddressMode*)&forUnmarshaling->addressModeU, *ptr, sizeof(VkSamplerAddressMode));
    *ptr += sizeof(VkSamplerAddressMode);
    memcpy((VkSamplerAddressMode*)&forUnmarshaling->addressModeV, *ptr, sizeof(VkSamplerAddressMode));
    *ptr += sizeof(VkSamplerAddressMode);
    memcpy((VkSamplerAddressMode*)&forUnmarshaling->addressModeW, *ptr, sizeof(VkSamplerAddressMode));
    *ptr += sizeof(VkSamplerAddressMode);
    memcpy((float*)&forUnmarshaling->mipLodBias, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((VkBool32*)&forUnmarshaling->anisotropyEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((float*)&forUnmarshaling->maxAnisotropy, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((VkBool32*)&forUnmarshaling->compareEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkCompareOp*)&forUnmarshaling->compareOp, *ptr, sizeof(VkCompareOp));
    *ptr += sizeof(VkCompareOp);
    memcpy((float*)&forUnmarshaling->minLod, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxLod, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((VkBorderColor*)&forUnmarshaling->borderColor, *ptr, sizeof(VkBorderColor));
    *ptr += sizeof(VkBorderColor);
    memcpy((VkBool32*)&forUnmarshaling->unnormalizedCoordinates, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkCopyDescriptorSet(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCopyDescriptorSet* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDescriptorSet*)&forUnmarshaling->srcSet = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->srcBinding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->srcArrayElement, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDescriptorSet*)&forUnmarshaling->dstSet = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)(*&cgen_var_1));
    memcpy((uint32_t*)&forUnmarshaling->dstBinding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dstArrayElement, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->descriptorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDescriptorBufferInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDescriptorBufferInfo* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->range, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkDescriptorImageInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDescriptorImageInfo* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSampler*)&forUnmarshaling->sampler = (VkSampler)unbox_VkSampler((VkSampler)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImageView*)&forUnmarshaling->imageView = (VkImageView)unbox_VkImageView((VkImageView)(*&cgen_var_1));
    memcpy((VkImageLayout*)&forUnmarshaling->imageLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedunmarshal_VkDescriptorPoolSize(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDescriptorPoolSize* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDescriptorType*)&forUnmarshaling->type, *ptr, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    memcpy((uint32_t*)&forUnmarshaling->descriptorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDescriptorPoolCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDescriptorPoolCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDescriptorPoolCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkDescriptorPoolCreateFlags));
    *ptr += sizeof(VkDescriptorPoolCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->maxSets, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->poolSizeCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPoolSizes, forUnmarshaling->poolSizeCount * sizeof(const VkDescriptorPoolSize));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->poolSizeCount; ++i)
    {
        reservedunmarshal_VkDescriptorPoolSize(vkStream, rootType, (VkDescriptorPoolSize*)(forUnmarshaling->pPoolSizes + i), ptr);
    }
}

void reservedunmarshal_VkDescriptorSetAllocateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDescriptorSetAllocateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDescriptorPool*)&forUnmarshaling->descriptorPool = (VkDescriptorPool)unbox_VkDescriptorPool((VkDescriptorPool)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->descriptorSetCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSetLayouts, forUnmarshaling->descriptorSetCount * sizeof(const VkDescriptorSetLayout));
    if (forUnmarshaling->descriptorSetCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->descriptorSetCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->descriptorSetCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                *(((VkDescriptorSetLayout*)forUnmarshaling->pSetLayouts) + k) = (VkDescriptorSetLayout)unbox_VkDescriptorSetLayout((VkDescriptorSetLayout)tmpval);
            }
        }
    }
}

void reservedunmarshal_VkDescriptorSetLayoutBinding(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDescriptorSetLayoutBinding* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->binding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDescriptorType*)&forUnmarshaling->descriptorType, *ptr, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    memcpy((uint32_t*)&forUnmarshaling->descriptorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkShaderStageFlags*)&forUnmarshaling->stageFlags, *ptr, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    // WARNING PTR CHECK
    memcpy((VkSampler**)&forUnmarshaling->pImmutableSamplers, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pImmutableSamplers);
    *ptr += 8;
    if (forUnmarshaling->pImmutableSamplers)
    {
        vkStream->alloc((void**)&forUnmarshaling->pImmutableSamplers, forUnmarshaling->descriptorCount * sizeof(const VkSampler));
        if (forUnmarshaling->descriptorCount)
        {
            uint8_t* cgen_var_0_0_ptr = (uint8_t*)(*ptr);
            *ptr += 8 * forUnmarshaling->descriptorCount;
            if (forUnmarshaling)
            {
                for (uint32_t k = 0; k < forUnmarshaling->descriptorCount; ++k)
                {
                    uint64_t tmpval; memcpy(&tmpval, cgen_var_0_0_ptr + k * 8, sizeof(uint64_t));
                    *(((VkSampler*)forUnmarshaling->pImmutableSamplers) + k) = (VkSampler)unbox_VkSampler((VkSampler)tmpval);
                }
            }
        }
    }
}

void reservedunmarshal_VkDescriptorSetLayoutCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDescriptorSetLayoutCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDescriptorSetLayoutCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkDescriptorSetLayoutCreateFlags));
    *ptr += sizeof(VkDescriptorSetLayoutCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->bindingCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pBindings, forUnmarshaling->bindingCount * sizeof(const VkDescriptorSetLayoutBinding));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindingCount; ++i)
    {
        reservedunmarshal_VkDescriptorSetLayoutBinding(vkStream, rootType, (VkDescriptorSetLayoutBinding*)(forUnmarshaling->pBindings + i), ptr);
    }
}

void reservedunmarshal_VkWriteDescriptorSet(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkWriteDescriptorSet* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDescriptorSet*)&forUnmarshaling->dstSet = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->dstBinding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dstArrayElement, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->descriptorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDescriptorType*)&forUnmarshaling->descriptorType, *ptr, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    // WARNING PTR CHECK
    memcpy((VkDescriptorImageInfo**)&forUnmarshaling->pImageInfo, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pImageInfo);
    *ptr += 8;
    if (forUnmarshaling->pImageInfo)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_SAMPLER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_IMAGE == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT == forUnmarshaling->descriptorType))))
        {
            vkStream->alloc((void**)&forUnmarshaling->pImageInfo, forUnmarshaling->descriptorCount * sizeof(const VkDescriptorImageInfo));
            for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorCount; ++i)
            {
                reservedunmarshal_VkDescriptorImageInfo(vkStream, rootType, (VkDescriptorImageInfo*)(forUnmarshaling->pImageInfo + i), ptr);
            }
        }
        else
        {
            forUnmarshaling->pImageInfo = 0;
        }
    }
    // WARNING PTR CHECK
    memcpy((VkDescriptorBufferInfo**)&forUnmarshaling->pBufferInfo, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pBufferInfo);
    *ptr += 8;
    if (forUnmarshaling->pBufferInfo)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC == forUnmarshaling->descriptorType))))
        {
            vkStream->alloc((void**)&forUnmarshaling->pBufferInfo, forUnmarshaling->descriptorCount * sizeof(const VkDescriptorBufferInfo));
            for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorCount; ++i)
            {
                reservedunmarshal_VkDescriptorBufferInfo(vkStream, rootType, (VkDescriptorBufferInfo*)(forUnmarshaling->pBufferInfo + i), ptr);
            }
        }
        else
        {
            forUnmarshaling->pBufferInfo = 0;
        }
    }
    // WARNING PTR CHECK
    memcpy((VkBufferView**)&forUnmarshaling->pTexelBufferView, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pTexelBufferView);
    *ptr += 8;
    if (forUnmarshaling->pTexelBufferView)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER == forUnmarshaling->descriptorType))))
        {
            vkStream->alloc((void**)&forUnmarshaling->pTexelBufferView, forUnmarshaling->descriptorCount * sizeof(const VkBufferView));
            if (forUnmarshaling->descriptorCount)
            {
                uint8_t* cgen_var_3_0_ptr = (uint8_t*)(*ptr);
                *ptr += 8 * forUnmarshaling->descriptorCount;
                if (forUnmarshaling)
                {
                    for (uint32_t k = 0; k < forUnmarshaling->descriptorCount; ++k)
                    {
                        uint64_t tmpval; memcpy(&tmpval, cgen_var_3_0_ptr + k * 8, sizeof(uint64_t));
                        *(((VkBufferView*)forUnmarshaling->pTexelBufferView) + k) = (VkBufferView)unbox_VkBufferView((VkBufferView)tmpval);
                    }
                }
            }
        }
        else
        {
            forUnmarshaling->pTexelBufferView = 0;
        }
    }
}

void reservedunmarshal_VkAttachmentDescription(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAttachmentDescription* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkAttachmentDescriptionFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkAttachmentDescriptionFlags));
    *ptr += sizeof(VkAttachmentDescriptionFlags);
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->samples, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy((VkAttachmentLoadOp*)&forUnmarshaling->loadOp, *ptr, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy((VkAttachmentStoreOp*)&forUnmarshaling->storeOp, *ptr, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy((VkAttachmentLoadOp*)&forUnmarshaling->stencilLoadOp, *ptr, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy((VkAttachmentStoreOp*)&forUnmarshaling->stencilStoreOp, *ptr, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy((VkImageLayout*)&forUnmarshaling->initialLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((VkImageLayout*)&forUnmarshaling->finalLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedunmarshal_VkAttachmentReference(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAttachmentReference* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->attachment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkImageLayout*)&forUnmarshaling->layout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedunmarshal_VkFramebufferCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkFramebufferCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFramebufferCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkFramebufferCreateFlags));
    *ptr += sizeof(VkFramebufferCreateFlags);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkRenderPass*)&forUnmarshaling->renderPass = (VkRenderPass)unbox_VkRenderPass((VkRenderPass)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->attachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkImageView));
    if (forUnmarshaling->attachmentCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->attachmentCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->attachmentCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                *(((VkImageView*)forUnmarshaling->pAttachments) + k) = (VkImageView)unbox_VkImageView((VkImageView)tmpval);
            }
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->width, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->height, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->layers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkSubpassDescription(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSubpassDescription* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkSubpassDescriptionFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSubpassDescriptionFlags));
    *ptr += sizeof(VkSubpassDescriptionFlags);
    memcpy((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, *ptr, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    memcpy((uint32_t*)&forUnmarshaling->inputAttachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pInputAttachments, forUnmarshaling->inputAttachmentCount * sizeof(const VkAttachmentReference));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->inputAttachmentCount; ++i)
    {
        reservedunmarshal_VkAttachmentReference(vkStream, rootType, (VkAttachmentReference*)(forUnmarshaling->pInputAttachments + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->colorAttachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pColorAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
    {
        reservedunmarshal_VkAttachmentReference(vkStream, rootType, (VkAttachmentReference*)(forUnmarshaling->pColorAttachments + i), ptr);
    }
    // WARNING PTR CHECK
    memcpy((VkAttachmentReference**)&forUnmarshaling->pResolveAttachments, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pResolveAttachments);
    *ptr += 8;
    if (forUnmarshaling->pResolveAttachments)
    {
        vkStream->alloc((void**)&forUnmarshaling->pResolveAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
        {
            reservedunmarshal_VkAttachmentReference(vkStream, rootType, (VkAttachmentReference*)(forUnmarshaling->pResolveAttachments + i), ptr);
        }
    }
    // WARNING PTR CHECK
    memcpy((VkAttachmentReference**)&forUnmarshaling->pDepthStencilAttachment, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pDepthStencilAttachment);
    *ptr += 8;
    if (forUnmarshaling->pDepthStencilAttachment)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDepthStencilAttachment, sizeof(const VkAttachmentReference));
        reservedunmarshal_VkAttachmentReference(vkStream, rootType, (VkAttachmentReference*)(forUnmarshaling->pDepthStencilAttachment), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->preserveAttachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPreserveAttachments, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pPreserveAttachments, *ptr, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkSubpassDependency(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSubpassDependency* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->srcSubpass, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dstSubpass, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkPipelineStageFlags*)&forUnmarshaling->srcStageMask, *ptr, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy((VkPipelineStageFlags*)&forUnmarshaling->dstStageMask, *ptr, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy((VkAccessFlags*)&forUnmarshaling->srcAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkAccessFlags*)&forUnmarshaling->dstAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkDependencyFlags*)&forUnmarshaling->dependencyFlags, *ptr, sizeof(VkDependencyFlags));
    *ptr += sizeof(VkDependencyFlags);
}

void reservedunmarshal_VkRenderPassCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRenderPassCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkRenderPassCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkRenderPassCreateFlags));
    *ptr += sizeof(VkRenderPassCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->attachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkAttachmentDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        reservedunmarshal_VkAttachmentDescription(vkStream, rootType, (VkAttachmentDescription*)(forUnmarshaling->pAttachments + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->subpassCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSubpasses, forUnmarshaling->subpassCount * sizeof(const VkSubpassDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->subpassCount; ++i)
    {
        reservedunmarshal_VkSubpassDescription(vkStream, rootType, (VkSubpassDescription*)(forUnmarshaling->pSubpasses + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->dependencyCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDependencies, forUnmarshaling->dependencyCount * sizeof(const VkSubpassDependency));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->dependencyCount; ++i)
    {
        reservedunmarshal_VkSubpassDependency(vkStream, rootType, (VkSubpassDependency*)(forUnmarshaling->pDependencies + i), ptr);
    }
}

void reservedunmarshal_VkCommandPoolCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCommandPoolCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkCommandPoolCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkCommandPoolCreateFlags));
    *ptr += sizeof(VkCommandPoolCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->queueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkCommandBufferAllocateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCommandBufferAllocateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkCommandPool*)&forUnmarshaling->commandPool = (VkCommandPool)unbox_VkCommandPool((VkCommandPool)(*&cgen_var_0));
    memcpy((VkCommandBufferLevel*)&forUnmarshaling->level, *ptr, sizeof(VkCommandBufferLevel));
    *ptr += sizeof(VkCommandBufferLevel);
    memcpy((uint32_t*)&forUnmarshaling->commandBufferCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkCommandBufferInheritanceInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCommandBufferInheritanceInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkRenderPass*)&forUnmarshaling->renderPass = (VkRenderPass)unbox_VkRenderPass((VkRenderPass)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->subpass, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkFramebuffer*)&forUnmarshaling->framebuffer = (VkFramebuffer)unbox_VkFramebuffer((VkFramebuffer)(*&cgen_var_1));
    memcpy((VkBool32*)&forUnmarshaling->occlusionQueryEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkQueryControlFlags*)&forUnmarshaling->queryFlags, *ptr, sizeof(VkQueryControlFlags));
    *ptr += sizeof(VkQueryControlFlags);
    memcpy((VkQueryPipelineStatisticFlags*)&forUnmarshaling->pipelineStatistics, *ptr, sizeof(VkQueryPipelineStatisticFlags));
    *ptr += sizeof(VkQueryPipelineStatisticFlags);
}

void reservedunmarshal_VkCommandBufferBeginInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCommandBufferBeginInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkCommandBufferUsageFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkCommandBufferUsageFlags));
    *ptr += sizeof(VkCommandBufferUsageFlags);
    // WARNING PTR CHECK
    memcpy((VkCommandBufferInheritanceInfo**)&forUnmarshaling->pInheritanceInfo, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pInheritanceInfo);
    *ptr += 8;
    if (forUnmarshaling->pInheritanceInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pInheritanceInfo, sizeof(const VkCommandBufferInheritanceInfo));
        reservedunmarshal_VkCommandBufferInheritanceInfo(vkStream, rootType, (VkCommandBufferInheritanceInfo*)(forUnmarshaling->pInheritanceInfo), ptr);
    }
}

void reservedunmarshal_VkBufferCopy(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBufferCopy* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceSize*)&forUnmarshaling->srcOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->dstOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkImageSubresourceLayers(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageSubresourceLayers* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkImageAspectFlags*)&forUnmarshaling->aspectMask, *ptr, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy((uint32_t*)&forUnmarshaling->mipLevel, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->baseArrayLayer, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->layerCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkBufferImageCopy(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBufferImageCopy* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceSize*)&forUnmarshaling->bufferOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->bufferRowLength, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->bufferImageHeight, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forUnmarshaling->imageSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forUnmarshaling->imageOffset), ptr);
    reservedunmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forUnmarshaling->imageExtent), ptr);
}

void reservedunmarshal_VkClearColorValue(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkClearColorValue* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((float*)forUnmarshaling->float32, *ptr, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

void reservedunmarshal_VkClearDepthStencilValue(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkClearDepthStencilValue* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((float*)&forUnmarshaling->depth, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((uint32_t*)&forUnmarshaling->stencil, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkClearValue(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkClearValue* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkClearColorValue(vkStream, rootType, (VkClearColorValue*)(&forUnmarshaling->color), ptr);
}

void reservedunmarshal_VkClearAttachment(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkClearAttachment* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkImageAspectFlags*)&forUnmarshaling->aspectMask, *ptr, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy((uint32_t*)&forUnmarshaling->colorAttachment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkClearValue(vkStream, rootType, (VkClearValue*)(&forUnmarshaling->clearValue), ptr);
}

void reservedunmarshal_VkClearRect(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkClearRect* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(&forUnmarshaling->rect), ptr);
    memcpy((uint32_t*)&forUnmarshaling->baseArrayLayer, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->layerCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkImageBlit(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageBlit* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource), ptr);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(forUnmarshaling->srcOffsets + i), ptr);
    }
    reservedunmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource), ptr);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(forUnmarshaling->dstOffsets + i), ptr);
    }
}

void reservedunmarshal_VkImageCopy(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageCopy* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forUnmarshaling->srcOffset), ptr);
    reservedunmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forUnmarshaling->dstOffset), ptr);
    reservedunmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forUnmarshaling->extent), ptr);
}

void reservedunmarshal_VkImageResolve(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageResolve* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forUnmarshaling->srcOffset), ptr);
    reservedunmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forUnmarshaling->dstOffset), ptr);
    reservedunmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forUnmarshaling->extent), ptr);
}

void reservedunmarshal_VkRenderPassBeginInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRenderPassBeginInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkRenderPass*)&forUnmarshaling->renderPass = (VkRenderPass)unbox_VkRenderPass((VkRenderPass)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkFramebuffer*)&forUnmarshaling->framebuffer = (VkFramebuffer)unbox_VkFramebuffer((VkFramebuffer)(*&cgen_var_1));
    reservedunmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(&forUnmarshaling->renderArea), ptr);
    memcpy((uint32_t*)&forUnmarshaling->clearValueCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkClearValue**)&forUnmarshaling->pClearValues, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pClearValues);
    *ptr += 8;
    if (forUnmarshaling->pClearValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pClearValues, forUnmarshaling->clearValueCount * sizeof(const VkClearValue));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->clearValueCount; ++i)
        {
            reservedunmarshal_VkClearValue(vkStream, rootType, (VkClearValue*)(forUnmarshaling->pClearValues + i), ptr);
        }
    }
}

#endif
#ifdef VK_VERSION_1_1
void reservedunmarshal_VkPhysicalDeviceSubgroupProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceSubgroupProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->subgroupSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkShaderStageFlags*)&forUnmarshaling->supportedStages, *ptr, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    memcpy((VkSubgroupFeatureFlags*)&forUnmarshaling->supportedOperations, *ptr, sizeof(VkSubgroupFeatureFlags));
    *ptr += sizeof(VkSubgroupFeatureFlags);
    memcpy((VkBool32*)&forUnmarshaling->quadOperationsInAllStages, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkBindBufferMemoryInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBindBufferMemoryInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_1));
    memcpy((VkDeviceSize*)&forUnmarshaling->memoryOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkBindImageMemoryInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBindImageMemoryInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_1));
    memcpy((VkDeviceSize*)&forUnmarshaling->memoryOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkPhysicalDevice16BitStorageFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDevice16BitStorageFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->storageBuffer16BitAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->uniformAndStorageBuffer16BitAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->storagePushConstant16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->storageInputOutput16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkMemoryDedicatedRequirements(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryDedicatedRequirements* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->prefersDedicatedAllocation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->requiresDedicatedAllocation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkMemoryDedicatedAllocateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryDedicatedAllocateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
}

void reservedunmarshal_VkMemoryAllocateFlagsInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryAllocateFlagsInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkMemoryAllocateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkMemoryAllocateFlags));
    *ptr += sizeof(VkMemoryAllocateFlags);
    memcpy((uint32_t*)&forUnmarshaling->deviceMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDeviceGroupRenderPassBeginInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceGroupRenderPassBeginInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->deviceMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->deviceRenderAreaCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDeviceRenderAreas, forUnmarshaling->deviceRenderAreaCount * sizeof(const VkRect2D));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->deviceRenderAreaCount; ++i)
    {
        reservedunmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(forUnmarshaling->pDeviceRenderAreas + i), ptr);
    }
}

void reservedunmarshal_VkDeviceGroupCommandBufferBeginInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceGroupCommandBufferBeginInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->deviceMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDeviceGroupSubmitInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceGroupSubmitInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->waitSemaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphoreDeviceIndices, forUnmarshaling->waitSemaphoreCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pWaitSemaphoreDeviceIndices, *ptr, forUnmarshaling->waitSemaphoreCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->waitSemaphoreCount * sizeof(const uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->commandBufferCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pCommandBufferDeviceMasks, forUnmarshaling->commandBufferCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pCommandBufferDeviceMasks, *ptr, forUnmarshaling->commandBufferCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->commandBufferCount * sizeof(const uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->signalSemaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphoreDeviceIndices, forUnmarshaling->signalSemaphoreCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pSignalSemaphoreDeviceIndices, *ptr, forUnmarshaling->signalSemaphoreCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->signalSemaphoreCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkDeviceGroupBindSparseInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceGroupBindSparseInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->resourceDeviceIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->memoryDeviceIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkBindBufferMemoryDeviceGroupInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBindBufferMemoryDeviceGroupInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->deviceIndexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pDeviceIndices, *ptr, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->deviceIndexCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkBindImageMemoryDeviceGroupInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBindImageMemoryDeviceGroupInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->deviceIndexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pDeviceIndices, *ptr, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->deviceIndexCount * sizeof(const uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->splitInstanceBindRegionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSplitInstanceBindRegions, forUnmarshaling->splitInstanceBindRegionCount * sizeof(const VkRect2D));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->splitInstanceBindRegionCount; ++i)
    {
        reservedunmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(forUnmarshaling->pSplitInstanceBindRegions + i), ptr);
    }
}

void reservedunmarshal_VkPhysicalDeviceGroupProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceGroupProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->physicalDeviceCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkPhysicalDevice*)forUnmarshaling->physicalDevices, *ptr, VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice));
    *ptr += VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice);
    memcpy((VkBool32*)&forUnmarshaling->subsetAllocation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDeviceGroupDeviceCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceGroupDeviceCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->physicalDeviceCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPhysicalDevices, forUnmarshaling->physicalDeviceCount * sizeof(const VkPhysicalDevice));
    if (forUnmarshaling->physicalDeviceCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->physicalDeviceCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->physicalDeviceCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                *(((VkPhysicalDevice*)forUnmarshaling->pPhysicalDevices) + k) = (VkPhysicalDevice)unbox_VkPhysicalDevice((VkPhysicalDevice)tmpval);
            }
        }
    }
}

void reservedunmarshal_VkBufferMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBufferMemoryRequirementsInfo2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
}

void reservedunmarshal_VkImageMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageMemoryRequirementsInfo2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
}

void reservedunmarshal_VkImageSparseMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageSparseMemoryRequirementsInfo2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
}

void reservedunmarshal_VkMemoryRequirements2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryRequirements2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkMemoryRequirements(vkStream, rootType, (VkMemoryRequirements*)(&forUnmarshaling->memoryRequirements), ptr);
}

void reservedunmarshal_VkSparseImageMemoryRequirements2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSparseImageMemoryRequirements2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkSparseImageMemoryRequirements(vkStream, rootType, (VkSparseImageMemoryRequirements*)(&forUnmarshaling->memoryRequirements), ptr);
}

void reservedunmarshal_VkPhysicalDeviceFeatures2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceFeatures2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkPhysicalDeviceFeatures(vkStream, rootType, (VkPhysicalDeviceFeatures*)(&forUnmarshaling->features), ptr);
}

void reservedunmarshal_VkPhysicalDeviceProperties2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceProperties2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkPhysicalDeviceProperties(vkStream, rootType, (VkPhysicalDeviceProperties*)(&forUnmarshaling->properties), ptr);
}

void reservedunmarshal_VkFormatProperties2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkFormatProperties2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkFormatProperties(vkStream, rootType, (VkFormatProperties*)(&forUnmarshaling->formatProperties), ptr);
}

void reservedunmarshal_VkImageFormatProperties2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageFormatProperties2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkImageFormatProperties(vkStream, rootType, (VkImageFormatProperties*)(&forUnmarshaling->imageFormatProperties), ptr);
}

void reservedunmarshal_VkPhysicalDeviceImageFormatInfo2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceImageFormatInfo2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkImageType*)&forUnmarshaling->type, *ptr, sizeof(VkImageType));
    *ptr += sizeof(VkImageType);
    memcpy((VkImageTiling*)&forUnmarshaling->tiling, *ptr, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
    memcpy((VkImageUsageFlags*)&forUnmarshaling->usage, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy((VkImageCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkImageCreateFlags));
    *ptr += sizeof(VkImageCreateFlags);
}

void reservedunmarshal_VkQueueFamilyProperties2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkQueueFamilyProperties2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkQueueFamilyProperties(vkStream, rootType, (VkQueueFamilyProperties*)(&forUnmarshaling->queueFamilyProperties), ptr);
}

void reservedunmarshal_VkPhysicalDeviceMemoryProperties2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceMemoryProperties2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkPhysicalDeviceMemoryProperties(vkStream, rootType, (VkPhysicalDeviceMemoryProperties*)(&forUnmarshaling->memoryProperties), ptr);
}

void reservedunmarshal_VkSparseImageFormatProperties2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSparseImageFormatProperties2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkSparseImageFormatProperties(vkStream, rootType, (VkSparseImageFormatProperties*)(&forUnmarshaling->properties), ptr);
}

void reservedunmarshal_VkPhysicalDeviceSparseImageFormatInfo2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceSparseImageFormatInfo2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkImageType*)&forUnmarshaling->type, *ptr, sizeof(VkImageType));
    *ptr += sizeof(VkImageType);
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->samples, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy((VkImageUsageFlags*)&forUnmarshaling->usage, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy((VkImageTiling*)&forUnmarshaling->tiling, *ptr, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
}

void reservedunmarshal_VkPhysicalDevicePointClippingProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDevicePointClippingProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPointClippingBehavior*)&forUnmarshaling->pointClippingBehavior, *ptr, sizeof(VkPointClippingBehavior));
    *ptr += sizeof(VkPointClippingBehavior);
}

void reservedunmarshal_VkInputAttachmentAspectReference(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkInputAttachmentAspectReference* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->subpass, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->inputAttachmentIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkImageAspectFlags*)&forUnmarshaling->aspectMask, *ptr, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
}

void reservedunmarshal_VkRenderPassInputAttachmentAspectCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRenderPassInputAttachmentAspectCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->aspectReferenceCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAspectReferences, forUnmarshaling->aspectReferenceCount * sizeof(const VkInputAttachmentAspectReference));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->aspectReferenceCount; ++i)
    {
        reservedunmarshal_VkInputAttachmentAspectReference(vkStream, rootType, (VkInputAttachmentAspectReference*)(forUnmarshaling->pAspectReferences + i), ptr);
    }
}

void reservedunmarshal_VkImageViewUsageCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageViewUsageCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageUsageFlags*)&forUnmarshaling->usage, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
}

void reservedunmarshal_VkPipelineTessellationDomainOriginStateCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineTessellationDomainOriginStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkTessellationDomainOrigin*)&forUnmarshaling->domainOrigin, *ptr, sizeof(VkTessellationDomainOrigin));
    *ptr += sizeof(VkTessellationDomainOrigin);
}

void reservedunmarshal_VkRenderPassMultiviewCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRenderPassMultiviewCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->subpassCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pViewMasks, forUnmarshaling->subpassCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pViewMasks, *ptr, forUnmarshaling->subpassCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->subpassCount * sizeof(const uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dependencyCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pViewOffsets, forUnmarshaling->dependencyCount * sizeof(const int32_t));
    memcpy((int32_t*)forUnmarshaling->pViewOffsets, *ptr, forUnmarshaling->dependencyCount * sizeof(const int32_t));
    *ptr += forUnmarshaling->dependencyCount * sizeof(const int32_t);
    memcpy((uint32_t*)&forUnmarshaling->correlationMaskCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pCorrelationMasks, forUnmarshaling->correlationMaskCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pCorrelationMasks, *ptr, forUnmarshaling->correlationMaskCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->correlationMaskCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkPhysicalDeviceMultiviewFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceMultiviewFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->multiview, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->multiviewGeometryShader, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->multiviewTessellationShader, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceMultiviewProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceMultiviewProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxMultiviewViewCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxMultiviewInstanceIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPhysicalDeviceVariablePointersFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceVariablePointersFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->variablePointersStorageBuffer, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->variablePointers, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceProtectedMemoryFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceProtectedMemoryFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->protectedMemory, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceProtectedMemoryProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceProtectedMemoryProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->protectedNoFault, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDeviceQueueInfo2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceQueueInfo2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceQueueCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkDeviceQueueCreateFlags));
    *ptr += sizeof(VkDeviceQueueCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->queueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->queueIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkProtectedSubmitInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkProtectedSubmitInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->protectedSubmit, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkSamplerYcbcrConversionCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSamplerYcbcrConversionCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkSamplerYcbcrModelConversion*)&forUnmarshaling->ycbcrModel, *ptr, sizeof(VkSamplerYcbcrModelConversion));
    *ptr += sizeof(VkSamplerYcbcrModelConversion);
    memcpy((VkSamplerYcbcrRange*)&forUnmarshaling->ycbcrRange, *ptr, sizeof(VkSamplerYcbcrRange));
    *ptr += sizeof(VkSamplerYcbcrRange);
    reservedunmarshal_VkComponentMapping(vkStream, rootType, (VkComponentMapping*)(&forUnmarshaling->components), ptr);
    memcpy((VkChromaLocation*)&forUnmarshaling->xChromaOffset, *ptr, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
    memcpy((VkChromaLocation*)&forUnmarshaling->yChromaOffset, *ptr, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
    memcpy((VkFilter*)&forUnmarshaling->chromaFilter, *ptr, sizeof(VkFilter));
    *ptr += sizeof(VkFilter);
    memcpy((VkBool32*)&forUnmarshaling->forceExplicitReconstruction, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkSamplerYcbcrConversionInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSamplerYcbcrConversionInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSamplerYcbcrConversion*)&forUnmarshaling->conversion = (VkSamplerYcbcrConversion)unbox_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion)(*&cgen_var_0));
}

void reservedunmarshal_VkBindImagePlaneMemoryInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBindImagePlaneMemoryInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageAspectFlagBits*)&forUnmarshaling->planeAspect, *ptr, sizeof(VkImageAspectFlagBits));
    *ptr += sizeof(VkImageAspectFlagBits);
}

void reservedunmarshal_VkImagePlaneMemoryRequirementsInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImagePlaneMemoryRequirementsInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageAspectFlagBits*)&forUnmarshaling->planeAspect, *ptr, sizeof(VkImageAspectFlagBits));
    *ptr += sizeof(VkImageAspectFlagBits);
}

void reservedunmarshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceSamplerYcbcrConversionFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->samplerYcbcrConversion, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkSamplerYcbcrConversionImageFormatProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSamplerYcbcrConversionImageFormatProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->combinedImageSamplerDescriptorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDescriptorUpdateTemplateEntry(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDescriptorUpdateTemplateEntry* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->dstBinding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dstArrayElement, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->descriptorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDescriptorType*)&forUnmarshaling->descriptorType, *ptr, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    memcpy((size_t*)&forUnmarshaling->offset, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->offset);
    *ptr += 8;
    memcpy((size_t*)&forUnmarshaling->stride, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->stride);
    *ptr += 8;
}

void reservedunmarshal_VkDescriptorUpdateTemplateCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDescriptorUpdateTemplateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDescriptorUpdateTemplateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkDescriptorUpdateTemplateCreateFlags));
    *ptr += sizeof(VkDescriptorUpdateTemplateCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->descriptorUpdateEntryCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDescriptorUpdateEntries, forUnmarshaling->descriptorUpdateEntryCount * sizeof(const VkDescriptorUpdateTemplateEntry));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorUpdateEntryCount; ++i)
    {
        reservedunmarshal_VkDescriptorUpdateTemplateEntry(vkStream, rootType, (VkDescriptorUpdateTemplateEntry*)(forUnmarshaling->pDescriptorUpdateEntries + i), ptr);
    }
    memcpy((VkDescriptorUpdateTemplateType*)&forUnmarshaling->templateType, *ptr, sizeof(VkDescriptorUpdateTemplateType));
    *ptr += sizeof(VkDescriptorUpdateTemplateType);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDescriptorSetLayout*)&forUnmarshaling->descriptorSetLayout = (VkDescriptorSetLayout)unbox_VkDescriptorSetLayout((VkDescriptorSetLayout)(*&cgen_var_0));
    memcpy((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, *ptr, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipelineLayout*)&forUnmarshaling->pipelineLayout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_1));
    memcpy((uint32_t*)&forUnmarshaling->set, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkExternalMemoryProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExternalMemoryProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkExternalMemoryFeatureFlags*)&forUnmarshaling->externalMemoryFeatures, *ptr, sizeof(VkExternalMemoryFeatureFlags));
    *ptr += sizeof(VkExternalMemoryFeatureFlags);
    memcpy((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
    memcpy((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedunmarshal_VkPhysicalDeviceExternalImageFormatInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceExternalImageFormatInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

void reservedunmarshal_VkExternalImageFormatProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExternalImageFormatProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkExternalMemoryProperties(vkStream, rootType, (VkExternalMemoryProperties*)(&forUnmarshaling->externalMemoryProperties), ptr);
}

void reservedunmarshal_VkPhysicalDeviceExternalBufferInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceExternalBufferInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBufferCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkBufferCreateFlags));
    *ptr += sizeof(VkBufferCreateFlags);
    memcpy((VkBufferUsageFlags*)&forUnmarshaling->usage, *ptr, sizeof(VkBufferUsageFlags));
    *ptr += sizeof(VkBufferUsageFlags);
    memcpy((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

void reservedunmarshal_VkExternalBufferProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExternalBufferProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkExternalMemoryProperties(vkStream, rootType, (VkExternalMemoryProperties*)(&forUnmarshaling->externalMemoryProperties), ptr);
}

void reservedunmarshal_VkPhysicalDeviceIDProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceIDProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint8_t*)forUnmarshaling->deviceUUID, *ptr, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    memcpy((uint8_t*)forUnmarshaling->driverUUID, *ptr, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    memcpy((uint8_t*)forUnmarshaling->deviceLUID, *ptr, VK_LUID_SIZE * sizeof(uint8_t));
    *ptr += VK_LUID_SIZE * sizeof(uint8_t);
    memcpy((uint32_t*)&forUnmarshaling->deviceNodeMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->deviceLUIDValid, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkExternalMemoryImageCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExternalMemoryImageCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedunmarshal_VkExternalMemoryBufferCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExternalMemoryBufferCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedunmarshal_VkExportMemoryAllocateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExportMemoryAllocateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedunmarshal_VkPhysicalDeviceExternalFenceInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceExternalFenceInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
}

void reservedunmarshal_VkExternalFenceProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExternalFenceProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, *ptr, sizeof(VkExternalFenceHandleTypeFlags));
    *ptr += sizeof(VkExternalFenceHandleTypeFlags);
    memcpy((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, *ptr, sizeof(VkExternalFenceHandleTypeFlags));
    *ptr += sizeof(VkExternalFenceHandleTypeFlags);
    memcpy((VkExternalFenceFeatureFlags*)&forUnmarshaling->externalFenceFeatures, *ptr, sizeof(VkExternalFenceFeatureFlags));
    *ptr += sizeof(VkExternalFenceFeatureFlags);
}

void reservedunmarshal_VkExportFenceCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExportFenceCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->handleTypes, *ptr, sizeof(VkExternalFenceHandleTypeFlags));
    *ptr += sizeof(VkExternalFenceHandleTypeFlags);
}

void reservedunmarshal_VkExportSemaphoreCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExportSemaphoreCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->handleTypes, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlags));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlags);
}

void reservedunmarshal_VkPhysicalDeviceExternalSemaphoreInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceExternalSemaphoreInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

void reservedunmarshal_VkExternalSemaphoreProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExternalSemaphoreProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlags));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlags);
    memcpy((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlags));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlags);
    memcpy((VkExternalSemaphoreFeatureFlags*)&forUnmarshaling->externalSemaphoreFeatures, *ptr, sizeof(VkExternalSemaphoreFeatureFlags));
    *ptr += sizeof(VkExternalSemaphoreFeatureFlags);
}

void reservedunmarshal_VkPhysicalDeviceMaintenance3Properties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceMaintenance3Properties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxPerSetDescriptors, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDeviceSize*)&forUnmarshaling->maxMemoryAllocationSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkDescriptorSetLayoutSupport(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDescriptorSetLayoutSupport* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->supported, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceShaderDrawParametersFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderDrawParametersFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderDrawParameters, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_VERSION_1_2
void reservedunmarshal_VkPhysicalDeviceVulkan11Features(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceVulkan11Features* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->storageBuffer16BitAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->uniformAndStorageBuffer16BitAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->storagePushConstant16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->storageInputOutput16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->multiview, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->multiviewGeometryShader, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->multiviewTessellationShader, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->variablePointersStorageBuffer, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->variablePointers, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->protectedMemory, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->samplerYcbcrConversion, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderDrawParameters, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceVulkan11Properties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceVulkan11Properties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint8_t*)forUnmarshaling->deviceUUID, *ptr, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    memcpy((uint8_t*)forUnmarshaling->driverUUID, *ptr, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    memcpy((uint8_t*)forUnmarshaling->deviceLUID, *ptr, VK_LUID_SIZE * sizeof(uint8_t));
    *ptr += VK_LUID_SIZE * sizeof(uint8_t);
    memcpy((uint32_t*)&forUnmarshaling->deviceNodeMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->deviceLUIDValid, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->subgroupSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkShaderStageFlags*)&forUnmarshaling->subgroupSupportedStages, *ptr, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    memcpy((VkSubgroupFeatureFlags*)&forUnmarshaling->subgroupSupportedOperations, *ptr, sizeof(VkSubgroupFeatureFlags));
    *ptr += sizeof(VkSubgroupFeatureFlags);
    memcpy((VkBool32*)&forUnmarshaling->subgroupQuadOperationsInAllStages, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkPointClippingBehavior*)&forUnmarshaling->pointClippingBehavior, *ptr, sizeof(VkPointClippingBehavior));
    *ptr += sizeof(VkPointClippingBehavior);
    memcpy((uint32_t*)&forUnmarshaling->maxMultiviewViewCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxMultiviewInstanceIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->protectedNoFault, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->maxPerSetDescriptors, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDeviceSize*)&forUnmarshaling->maxMemoryAllocationSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkPhysicalDeviceVulkan12Features(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceVulkan12Features* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->samplerMirrorClampToEdge, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->drawIndirectCount, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->storageBuffer8BitAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->uniformAndStorageBuffer8BitAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->storagePushConstant8, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderBufferInt64Atomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSharedInt64Atomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderFloat16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderInt8, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderUniformTexelBufferArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageTexelBufferArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSampledImageArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderUniformTexelBufferArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageTexelBufferArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingUniformBufferUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingSampledImageUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingStorageImageUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingStorageBufferUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingUniformTexelBufferUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingStorageTexelBufferUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingUpdateUnusedWhilePending, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingPartiallyBound, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingVariableDescriptorCount, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->runtimeDescriptorArray, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->samplerFilterMinmax, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->scalarBlockLayout, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->imagelessFramebuffer, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->uniformBufferStandardLayout, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSubgroupExtendedTypes, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->separateDepthStencilLayouts, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->hostQueryReset, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->timelineSemaphore, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->bufferDeviceAddress, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->bufferDeviceAddressCaptureReplay, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->bufferDeviceAddressMultiDevice, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->vulkanMemoryModel, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->vulkanMemoryModelDeviceScope, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->vulkanMemoryModelAvailabilityVisibilityChains, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderOutputViewportIndex, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderOutputLayer, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->subgroupBroadcastDynamicId, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkConformanceVersion(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkConformanceVersion* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint8_t*)&forUnmarshaling->major, *ptr, sizeof(uint8_t));
    *ptr += sizeof(uint8_t);
    memcpy((uint8_t*)&forUnmarshaling->minor, *ptr, sizeof(uint8_t));
    *ptr += sizeof(uint8_t);
    memcpy((uint8_t*)&forUnmarshaling->subminor, *ptr, sizeof(uint8_t));
    *ptr += sizeof(uint8_t);
    memcpy((uint8_t*)&forUnmarshaling->patch, *ptr, sizeof(uint8_t));
    *ptr += sizeof(uint8_t);
}

void reservedunmarshal_VkPhysicalDeviceVulkan12Properties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceVulkan12Properties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDriverId*)&forUnmarshaling->driverID, *ptr, sizeof(VkDriverId));
    *ptr += sizeof(VkDriverId);
    memcpy((char*)forUnmarshaling->driverName, *ptr, VK_MAX_DRIVER_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_DRIVER_NAME_SIZE * sizeof(char);
    memcpy((char*)forUnmarshaling->driverInfo, *ptr, VK_MAX_DRIVER_INFO_SIZE * sizeof(char));
    *ptr += VK_MAX_DRIVER_INFO_SIZE * sizeof(char);
    reservedunmarshal_VkConformanceVersion(vkStream, rootType, (VkConformanceVersion*)(&forUnmarshaling->conformanceVersion), ptr);
    memcpy((VkShaderFloatControlsIndependence*)&forUnmarshaling->denormBehaviorIndependence, *ptr, sizeof(VkShaderFloatControlsIndependence));
    *ptr += sizeof(VkShaderFloatControlsIndependence);
    memcpy((VkShaderFloatControlsIndependence*)&forUnmarshaling->roundingModeIndependence, *ptr, sizeof(VkShaderFloatControlsIndependence));
    *ptr += sizeof(VkShaderFloatControlsIndependence);
    memcpy((VkBool32*)&forUnmarshaling->shaderSignedZeroInfNanPreserveFloat16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSignedZeroInfNanPreserveFloat32, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSignedZeroInfNanPreserveFloat64, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderDenormPreserveFloat16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderDenormPreserveFloat32, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderDenormPreserveFloat64, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderDenormFlushToZeroFloat16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderDenormFlushToZeroFloat32, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderDenormFlushToZeroFloat64, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderRoundingModeRTEFloat16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderRoundingModeRTEFloat32, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderRoundingModeRTEFloat64, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderRoundingModeRTZFloat16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderRoundingModeRTZFloat32, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderRoundingModeRTZFloat64, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->maxUpdateAfterBindDescriptorsInAllPools, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSampledImageArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->robustBufferAccessUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->quadDivergentImplicitLod, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindSamplers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindUniformBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindStorageBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindSampledImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindStorageImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindInputAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageUpdateAfterBindResources, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindSamplers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindUniformBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindSampledImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindInputAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkResolveModeFlags*)&forUnmarshaling->supportedDepthResolveModes, *ptr, sizeof(VkResolveModeFlags));
    *ptr += sizeof(VkResolveModeFlags);
    memcpy((VkResolveModeFlags*)&forUnmarshaling->supportedStencilResolveModes, *ptr, sizeof(VkResolveModeFlags));
    *ptr += sizeof(VkResolveModeFlags);
    memcpy((VkBool32*)&forUnmarshaling->independentResolveNone, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->independentResolve, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->filterMinmaxSingleComponentFormats, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->filterMinmaxImageComponentMapping, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint64_t*)&forUnmarshaling->maxTimelineSemaphoreValueDifference, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->framebufferIntegerColorSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
}

void reservedunmarshal_VkImageFormatListCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageFormatListCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->viewFormatCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pViewFormats, forUnmarshaling->viewFormatCount * sizeof(const VkFormat));
    memcpy((VkFormat*)forUnmarshaling->pViewFormats, *ptr, forUnmarshaling->viewFormatCount * sizeof(const VkFormat));
    *ptr += forUnmarshaling->viewFormatCount * sizeof(const VkFormat);
}

void reservedunmarshal_VkAttachmentDescription2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAttachmentDescription2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAttachmentDescriptionFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkAttachmentDescriptionFlags));
    *ptr += sizeof(VkAttachmentDescriptionFlags);
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->samples, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy((VkAttachmentLoadOp*)&forUnmarshaling->loadOp, *ptr, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy((VkAttachmentStoreOp*)&forUnmarshaling->storeOp, *ptr, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy((VkAttachmentLoadOp*)&forUnmarshaling->stencilLoadOp, *ptr, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy((VkAttachmentStoreOp*)&forUnmarshaling->stencilStoreOp, *ptr, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy((VkImageLayout*)&forUnmarshaling->initialLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((VkImageLayout*)&forUnmarshaling->finalLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedunmarshal_VkAttachmentReference2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAttachmentReference2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->attachment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkImageLayout*)&forUnmarshaling->layout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((VkImageAspectFlags*)&forUnmarshaling->aspectMask, *ptr, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
}

void reservedunmarshal_VkSubpassDescription2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSubpassDescription2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSubpassDescriptionFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSubpassDescriptionFlags));
    *ptr += sizeof(VkSubpassDescriptionFlags);
    memcpy((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, *ptr, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    memcpy((uint32_t*)&forUnmarshaling->viewMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->inputAttachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pInputAttachments, forUnmarshaling->inputAttachmentCount * sizeof(const VkAttachmentReference2));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->inputAttachmentCount; ++i)
    {
        reservedunmarshal_VkAttachmentReference2(vkStream, rootType, (VkAttachmentReference2*)(forUnmarshaling->pInputAttachments + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->colorAttachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pColorAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference2));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
    {
        reservedunmarshal_VkAttachmentReference2(vkStream, rootType, (VkAttachmentReference2*)(forUnmarshaling->pColorAttachments + i), ptr);
    }
    // WARNING PTR CHECK
    memcpy((VkAttachmentReference2**)&forUnmarshaling->pResolveAttachments, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pResolveAttachments);
    *ptr += 8;
    if (forUnmarshaling->pResolveAttachments)
    {
        vkStream->alloc((void**)&forUnmarshaling->pResolveAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference2));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
        {
            reservedunmarshal_VkAttachmentReference2(vkStream, rootType, (VkAttachmentReference2*)(forUnmarshaling->pResolveAttachments + i), ptr);
        }
    }
    // WARNING PTR CHECK
    memcpy((VkAttachmentReference2**)&forUnmarshaling->pDepthStencilAttachment, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pDepthStencilAttachment);
    *ptr += 8;
    if (forUnmarshaling->pDepthStencilAttachment)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDepthStencilAttachment, sizeof(const VkAttachmentReference2));
        reservedunmarshal_VkAttachmentReference2(vkStream, rootType, (VkAttachmentReference2*)(forUnmarshaling->pDepthStencilAttachment), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->preserveAttachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPreserveAttachments, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pPreserveAttachments, *ptr, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkSubpassDependency2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSubpassDependency2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->srcSubpass, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dstSubpass, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkPipelineStageFlags*)&forUnmarshaling->srcStageMask, *ptr, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy((VkPipelineStageFlags*)&forUnmarshaling->dstStageMask, *ptr, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy((VkAccessFlags*)&forUnmarshaling->srcAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkAccessFlags*)&forUnmarshaling->dstAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkDependencyFlags*)&forUnmarshaling->dependencyFlags, *ptr, sizeof(VkDependencyFlags));
    *ptr += sizeof(VkDependencyFlags);
    memcpy((int32_t*)&forUnmarshaling->viewOffset, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedunmarshal_VkRenderPassCreateInfo2(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRenderPassCreateInfo2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkRenderPassCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkRenderPassCreateFlags));
    *ptr += sizeof(VkRenderPassCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->attachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkAttachmentDescription2));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        reservedunmarshal_VkAttachmentDescription2(vkStream, rootType, (VkAttachmentDescription2*)(forUnmarshaling->pAttachments + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->subpassCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSubpasses, forUnmarshaling->subpassCount * sizeof(const VkSubpassDescription2));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->subpassCount; ++i)
    {
        reservedunmarshal_VkSubpassDescription2(vkStream, rootType, (VkSubpassDescription2*)(forUnmarshaling->pSubpasses + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->dependencyCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDependencies, forUnmarshaling->dependencyCount * sizeof(const VkSubpassDependency2));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->dependencyCount; ++i)
    {
        reservedunmarshal_VkSubpassDependency2(vkStream, rootType, (VkSubpassDependency2*)(forUnmarshaling->pDependencies + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->correlatedViewMaskCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pCorrelatedViewMasks, forUnmarshaling->correlatedViewMaskCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pCorrelatedViewMasks, *ptr, forUnmarshaling->correlatedViewMaskCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->correlatedViewMaskCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkSubpassBeginInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSubpassBeginInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSubpassContents*)&forUnmarshaling->contents, *ptr, sizeof(VkSubpassContents));
    *ptr += sizeof(VkSubpassContents);
}

void reservedunmarshal_VkSubpassEndInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSubpassEndInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
}

void reservedunmarshal_VkPhysicalDevice8BitStorageFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDevice8BitStorageFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->storageBuffer8BitAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->uniformAndStorageBuffer8BitAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->storagePushConstant8, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceDriverProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceDriverProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDriverId*)&forUnmarshaling->driverID, *ptr, sizeof(VkDriverId));
    *ptr += sizeof(VkDriverId);
    memcpy((char*)forUnmarshaling->driverName, *ptr, VK_MAX_DRIVER_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_DRIVER_NAME_SIZE * sizeof(char);
    memcpy((char*)forUnmarshaling->driverInfo, *ptr, VK_MAX_DRIVER_INFO_SIZE * sizeof(char));
    *ptr += VK_MAX_DRIVER_INFO_SIZE * sizeof(char);
    reservedunmarshal_VkConformanceVersion(vkStream, rootType, (VkConformanceVersion*)(&forUnmarshaling->conformanceVersion), ptr);
}

void reservedunmarshal_VkPhysicalDeviceShaderAtomicInt64Features(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderAtomicInt64Features* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderBufferInt64Atomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSharedInt64Atomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceShaderFloat16Int8Features(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderFloat16Int8Features* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderFloat16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderInt8, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceFloatControlsProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceFloatControlsProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkShaderFloatControlsIndependence*)&forUnmarshaling->denormBehaviorIndependence, *ptr, sizeof(VkShaderFloatControlsIndependence));
    *ptr += sizeof(VkShaderFloatControlsIndependence);
    memcpy((VkShaderFloatControlsIndependence*)&forUnmarshaling->roundingModeIndependence, *ptr, sizeof(VkShaderFloatControlsIndependence));
    *ptr += sizeof(VkShaderFloatControlsIndependence);
    memcpy((VkBool32*)&forUnmarshaling->shaderSignedZeroInfNanPreserveFloat16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSignedZeroInfNanPreserveFloat32, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSignedZeroInfNanPreserveFloat64, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderDenormPreserveFloat16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderDenormPreserveFloat32, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderDenormPreserveFloat64, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderDenormFlushToZeroFloat16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderDenormFlushToZeroFloat32, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderDenormFlushToZeroFloat64, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderRoundingModeRTEFloat16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderRoundingModeRTEFloat32, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderRoundingModeRTEFloat64, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderRoundingModeRTZFloat16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderRoundingModeRTZFloat32, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderRoundingModeRTZFloat64, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDescriptorSetLayoutBindingFlagsCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDescriptorSetLayoutBindingFlagsCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->bindingCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkDescriptorBindingFlags**)&forUnmarshaling->pBindingFlags, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pBindingFlags);
    *ptr += 8;
    if (forUnmarshaling->pBindingFlags)
    {
        vkStream->alloc((void**)&forUnmarshaling->pBindingFlags, forUnmarshaling->bindingCount * sizeof(const VkDescriptorBindingFlags));
        memcpy((VkDescriptorBindingFlags*)forUnmarshaling->pBindingFlags, *ptr, forUnmarshaling->bindingCount * sizeof(const VkDescriptorBindingFlags));
        *ptr += forUnmarshaling->bindingCount * sizeof(const VkDescriptorBindingFlags);
    }
}

void reservedunmarshal_VkPhysicalDeviceDescriptorIndexingFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceDescriptorIndexingFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderUniformTexelBufferArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageTexelBufferArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSampledImageArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderUniformTexelBufferArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageTexelBufferArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingUniformBufferUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingSampledImageUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingStorageImageUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingStorageBufferUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingUniformTexelBufferUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingStorageTexelBufferUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingUpdateUnusedWhilePending, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingPartiallyBound, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingVariableDescriptorCount, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->runtimeDescriptorArray, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceDescriptorIndexingProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceDescriptorIndexingProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxUpdateAfterBindDescriptorsInAllPools, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSampledImageArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->robustBufferAccessUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->quadDivergentImplicitLod, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindSamplers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindUniformBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindStorageBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindSampledImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindStorageImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindInputAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageUpdateAfterBindResources, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindSamplers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindUniformBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindSampledImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindInputAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDescriptorSetVariableDescriptorCountAllocateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDescriptorSetVariableDescriptorCountAllocateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->descriptorSetCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDescriptorCounts, forUnmarshaling->descriptorSetCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pDescriptorCounts, *ptr, forUnmarshaling->descriptorSetCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->descriptorSetCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkDescriptorSetVariableDescriptorCountLayoutSupport(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDescriptorSetVariableDescriptorCountLayoutSupport* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxVariableDescriptorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkSubpassDescriptionDepthStencilResolve(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSubpassDescriptionDepthStencilResolve* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkResolveModeFlagBits*)&forUnmarshaling->depthResolveMode, *ptr, sizeof(VkResolveModeFlagBits));
    *ptr += sizeof(VkResolveModeFlagBits);
    memcpy((VkResolveModeFlagBits*)&forUnmarshaling->stencilResolveMode, *ptr, sizeof(VkResolveModeFlagBits));
    *ptr += sizeof(VkResolveModeFlagBits);
    // WARNING PTR CHECK
    memcpy((VkAttachmentReference2**)&forUnmarshaling->pDepthStencilResolveAttachment, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pDepthStencilResolveAttachment);
    *ptr += 8;
    if (forUnmarshaling->pDepthStencilResolveAttachment)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDepthStencilResolveAttachment, sizeof(const VkAttachmentReference2));
        reservedunmarshal_VkAttachmentReference2(vkStream, rootType, (VkAttachmentReference2*)(forUnmarshaling->pDepthStencilResolveAttachment), ptr);
    }
}

void reservedunmarshal_VkPhysicalDeviceDepthStencilResolveProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceDepthStencilResolveProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkResolveModeFlags*)&forUnmarshaling->supportedDepthResolveModes, *ptr, sizeof(VkResolveModeFlags));
    *ptr += sizeof(VkResolveModeFlags);
    memcpy((VkResolveModeFlags*)&forUnmarshaling->supportedStencilResolveModes, *ptr, sizeof(VkResolveModeFlags));
    *ptr += sizeof(VkResolveModeFlags);
    memcpy((VkBool32*)&forUnmarshaling->independentResolveNone, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->independentResolve, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceScalarBlockLayoutFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceScalarBlockLayoutFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->scalarBlockLayout, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkImageStencilUsageCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageStencilUsageCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageUsageFlags*)&forUnmarshaling->stencilUsage, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
}

void reservedunmarshal_VkSamplerReductionModeCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSamplerReductionModeCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSamplerReductionMode*)&forUnmarshaling->reductionMode, *ptr, sizeof(VkSamplerReductionMode));
    *ptr += sizeof(VkSamplerReductionMode);
}

void reservedunmarshal_VkPhysicalDeviceSamplerFilterMinmaxProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceSamplerFilterMinmaxProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->filterMinmaxSingleComponentFormats, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->filterMinmaxImageComponentMapping, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceVulkanMemoryModelFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceVulkanMemoryModelFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->vulkanMemoryModel, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->vulkanMemoryModelDeviceScope, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->vulkanMemoryModelAvailabilityVisibilityChains, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceImagelessFramebufferFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceImagelessFramebufferFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->imagelessFramebuffer, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkFramebufferAttachmentImageInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkFramebufferAttachmentImageInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkImageCreateFlags));
    *ptr += sizeof(VkImageCreateFlags);
    memcpy((VkImageUsageFlags*)&forUnmarshaling->usage, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy((uint32_t*)&forUnmarshaling->width, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->height, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->layerCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->viewFormatCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pViewFormats, forUnmarshaling->viewFormatCount * sizeof(const VkFormat));
    memcpy((VkFormat*)forUnmarshaling->pViewFormats, *ptr, forUnmarshaling->viewFormatCount * sizeof(const VkFormat));
    *ptr += forUnmarshaling->viewFormatCount * sizeof(const VkFormat);
}

void reservedunmarshal_VkFramebufferAttachmentsCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkFramebufferAttachmentsCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->attachmentImageInfoCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAttachmentImageInfos, forUnmarshaling->attachmentImageInfoCount * sizeof(const VkFramebufferAttachmentImageInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentImageInfoCount; ++i)
    {
        reservedunmarshal_VkFramebufferAttachmentImageInfo(vkStream, rootType, (VkFramebufferAttachmentImageInfo*)(forUnmarshaling->pAttachmentImageInfos + i), ptr);
    }
}

void reservedunmarshal_VkRenderPassAttachmentBeginInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRenderPassAttachmentBeginInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->attachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkImageView));
    if (forUnmarshaling->attachmentCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->attachmentCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->attachmentCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                *(((VkImageView*)forUnmarshaling->pAttachments) + k) = (VkImageView)unbox_VkImageView((VkImageView)tmpval);
            }
        }
    }
}

void reservedunmarshal_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceUniformBufferStandardLayoutFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->uniformBufferStandardLayout, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderSubgroupExtendedTypes, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->separateDepthStencilLayouts, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkAttachmentReferenceStencilLayout(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAttachmentReferenceStencilLayout* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageLayout*)&forUnmarshaling->stencilLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedunmarshal_VkAttachmentDescriptionStencilLayout(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAttachmentDescriptionStencilLayout* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageLayout*)&forUnmarshaling->stencilInitialLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((VkImageLayout*)&forUnmarshaling->stencilFinalLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedunmarshal_VkPhysicalDeviceHostQueryResetFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceHostQueryResetFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->hostQueryReset, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceTimelineSemaphoreFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceTimelineSemaphoreFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->timelineSemaphore, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceTimelineSemaphoreProperties(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceTimelineSemaphoreProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint64_t*)&forUnmarshaling->maxTimelineSemaphoreValueDifference, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkSemaphoreTypeCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSemaphoreTypeCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSemaphoreType*)&forUnmarshaling->semaphoreType, *ptr, sizeof(VkSemaphoreType));
    *ptr += sizeof(VkSemaphoreType);
    memcpy((uint64_t*)&forUnmarshaling->initialValue, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkTimelineSemaphoreSubmitInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkTimelineSemaphoreSubmitInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->waitSemaphoreValueCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((uint64_t**)&forUnmarshaling->pWaitSemaphoreValues, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pWaitSemaphoreValues);
    *ptr += 8;
    if (forUnmarshaling->pWaitSemaphoreValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphoreValues, forUnmarshaling->waitSemaphoreValueCount * sizeof(const uint64_t));
        memcpy((uint64_t*)forUnmarshaling->pWaitSemaphoreValues, *ptr, forUnmarshaling->waitSemaphoreValueCount * sizeof(const uint64_t));
        *ptr += forUnmarshaling->waitSemaphoreValueCount * sizeof(const uint64_t);
    }
    memcpy((uint32_t*)&forUnmarshaling->signalSemaphoreValueCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((uint64_t**)&forUnmarshaling->pSignalSemaphoreValues, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pSignalSemaphoreValues);
    *ptr += 8;
    if (forUnmarshaling->pSignalSemaphoreValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphoreValues, forUnmarshaling->signalSemaphoreValueCount * sizeof(const uint64_t));
        memcpy((uint64_t*)forUnmarshaling->pSignalSemaphoreValues, *ptr, forUnmarshaling->signalSemaphoreValueCount * sizeof(const uint64_t));
        *ptr += forUnmarshaling->signalSemaphoreValueCount * sizeof(const uint64_t);
    }
}

void reservedunmarshal_VkSemaphoreWaitInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSemaphoreWaitInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSemaphoreWaitFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSemaphoreWaitFlags));
    *ptr += sizeof(VkSemaphoreWaitFlags);
    memcpy((uint32_t*)&forUnmarshaling->semaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSemaphores, forUnmarshaling->semaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->semaphoreCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->semaphoreCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->semaphoreCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                *(((VkSemaphore*)forUnmarshaling->pSemaphores) + k) = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)tmpval);
            }
        }
    }
    vkStream->alloc((void**)&forUnmarshaling->pValues, forUnmarshaling->semaphoreCount * sizeof(const uint64_t));
    memcpy((uint64_t*)forUnmarshaling->pValues, *ptr, forUnmarshaling->semaphoreCount * sizeof(const uint64_t));
    *ptr += forUnmarshaling->semaphoreCount * sizeof(const uint64_t);
}

void reservedunmarshal_VkSemaphoreSignalInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSemaphoreSignalInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSemaphore*)&forUnmarshaling->semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_0));
    memcpy((uint64_t*)&forUnmarshaling->value, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkPhysicalDeviceBufferDeviceAddressFeatures(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceBufferDeviceAddressFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->bufferDeviceAddress, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->bufferDeviceAddressCaptureReplay, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->bufferDeviceAddressMultiDevice, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkBufferDeviceAddressInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBufferDeviceAddressInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
}

void reservedunmarshal_VkBufferOpaqueCaptureAddressCreateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBufferOpaqueCaptureAddressCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint64_t*)&forUnmarshaling->opaqueCaptureAddress, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkMemoryOpaqueCaptureAddressAllocateInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryOpaqueCaptureAddressAllocateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint64_t*)&forUnmarshaling->opaqueCaptureAddress, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkDeviceMemoryOpaqueCaptureAddressInfo(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceMemoryOpaqueCaptureAddressInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_0));
}

#endif
#ifdef VK_KHR_surface
void reservedunmarshal_VkSurfaceCapabilitiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSurfaceCapabilitiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->minImageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxImageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->currentExtent), ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->minImageExtent), ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->maxImageExtent), ptr);
    memcpy((uint32_t*)&forUnmarshaling->maxImageArrayLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, *ptr, sizeof(VkSurfaceTransformFlagsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagsKHR);
    memcpy((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->currentTransform, *ptr, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy((VkCompositeAlphaFlagsKHR*)&forUnmarshaling->supportedCompositeAlpha, *ptr, sizeof(VkCompositeAlphaFlagsKHR));
    *ptr += sizeof(VkCompositeAlphaFlagsKHR);
    memcpy((VkImageUsageFlags*)&forUnmarshaling->supportedUsageFlags, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
}

void reservedunmarshal_VkSurfaceFormatKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSurfaceFormatKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkColorSpaceKHR*)&forUnmarshaling->colorSpace, *ptr, sizeof(VkColorSpaceKHR));
    *ptr += sizeof(VkColorSpaceKHR);
}

#endif
#ifdef VK_KHR_swapchain
void reservedunmarshal_VkSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSwapchainCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSwapchainCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkSwapchainCreateFlagsKHR));
    *ptr += sizeof(VkSwapchainCreateFlagsKHR);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSurfaceKHR*)&forUnmarshaling->surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->minImageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkFormat*)&forUnmarshaling->imageFormat, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkColorSpaceKHR*)&forUnmarshaling->imageColorSpace, *ptr, sizeof(VkColorSpaceKHR));
    *ptr += sizeof(VkColorSpaceKHR);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->imageExtent), ptr);
    memcpy((uint32_t*)&forUnmarshaling->imageArrayLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkImageUsageFlags*)&forUnmarshaling->imageUsage, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy((VkSharingMode*)&forUnmarshaling->imageSharingMode, *ptr, sizeof(VkSharingMode));
    *ptr += sizeof(VkSharingMode);
    memcpy((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((uint32_t**)&forUnmarshaling->pQueueFamilyIndices, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pQueueFamilyIndices);
    *ptr += 8;
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        memcpy((uint32_t*)forUnmarshaling->pQueueFamilyIndices, *ptr, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        *ptr += forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t);
    }
    memcpy((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->preTransform, *ptr, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy((VkCompositeAlphaFlagBitsKHR*)&forUnmarshaling->compositeAlpha, *ptr, sizeof(VkCompositeAlphaFlagBitsKHR));
    *ptr += sizeof(VkCompositeAlphaFlagBitsKHR);
    memcpy((VkPresentModeKHR*)&forUnmarshaling->presentMode, *ptr, sizeof(VkPresentModeKHR));
    *ptr += sizeof(VkPresentModeKHR);
    memcpy((VkBool32*)&forUnmarshaling->clipped, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    uint64_t cgen_var_2;
    memcpy((uint64_t*)&cgen_var_2, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSwapchainKHR*)&forUnmarshaling->oldSwapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_2));
}

void reservedunmarshal_VkPresentInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPresentInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->waitSemaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->waitSemaphoreCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->waitSemaphoreCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->waitSemaphoreCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                *(((VkSemaphore*)forUnmarshaling->pWaitSemaphores) + k) = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)tmpval);
            }
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->swapchainCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSwapchains, forUnmarshaling->swapchainCount * sizeof(const VkSwapchainKHR));
    if (forUnmarshaling->swapchainCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->swapchainCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->swapchainCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                *(((VkSwapchainKHR*)forUnmarshaling->pSwapchains) + k) = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)tmpval);
            }
        }
    }
    vkStream->alloc((void**)&forUnmarshaling->pImageIndices, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pImageIndices, *ptr, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->swapchainCount * sizeof(const uint32_t);
    // WARNING PTR CHECK
    memcpy((VkResult**)&forUnmarshaling->pResults, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pResults);
    *ptr += 8;
    if (forUnmarshaling->pResults)
    {
        vkStream->alloc((void**)&forUnmarshaling->pResults, forUnmarshaling->swapchainCount * sizeof(VkResult));
        memcpy((VkResult*)forUnmarshaling->pResults, *ptr, forUnmarshaling->swapchainCount * sizeof(VkResult));
        *ptr += forUnmarshaling->swapchainCount * sizeof(VkResult);
    }
}

void reservedunmarshal_VkImageSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageSwapchainCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSwapchainKHR*)&forUnmarshaling->swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_0));
}

void reservedunmarshal_VkBindImageMemorySwapchainInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBindImageMemorySwapchainInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSwapchainKHR*)&forUnmarshaling->swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->imageIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkAcquireNextImageInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAcquireNextImageInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSwapchainKHR*)&forUnmarshaling->swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_0));
    memcpy((uint64_t*)&forUnmarshaling->timeout, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSemaphore*)&forUnmarshaling->semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_1));
    uint64_t cgen_var_2;
    memcpy((uint64_t*)&cgen_var_2, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkFence*)&forUnmarshaling->fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_2));
    memcpy((uint32_t*)&forUnmarshaling->deviceMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDeviceGroupPresentCapabilitiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceGroupPresentCapabilitiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)forUnmarshaling->presentMask, *ptr, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t));
    *ptr += VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t);
    memcpy((VkDeviceGroupPresentModeFlagsKHR*)&forUnmarshaling->modes, *ptr, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    *ptr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
}

void reservedunmarshal_VkDeviceGroupPresentInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceGroupPresentInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->swapchainCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDeviceMasks, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pDeviceMasks, *ptr, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->swapchainCount * sizeof(const uint32_t);
    memcpy((VkDeviceGroupPresentModeFlagBitsKHR*)&forUnmarshaling->mode, *ptr, sizeof(VkDeviceGroupPresentModeFlagBitsKHR));
    *ptr += sizeof(VkDeviceGroupPresentModeFlagBitsKHR);
}

void reservedunmarshal_VkDeviceGroupSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceGroupSwapchainCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceGroupPresentModeFlagsKHR*)&forUnmarshaling->modes, *ptr, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    *ptr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
}

#endif
#ifdef VK_KHR_display
void reservedunmarshal_VkDisplayModeParametersKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayModeParametersKHR* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->visibleRegion), ptr);
    memcpy((uint32_t*)&forUnmarshaling->refreshRate, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDisplayModeCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayModeCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDisplayModeCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkDisplayModeCreateFlagsKHR));
    *ptr += sizeof(VkDisplayModeCreateFlagsKHR);
    reservedunmarshal_VkDisplayModeParametersKHR(vkStream, rootType, (VkDisplayModeParametersKHR*)(&forUnmarshaling->parameters), ptr);
}

void reservedunmarshal_VkDisplayModePropertiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayModePropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDisplayModeKHR*)&forUnmarshaling->displayMode = (VkDisplayModeKHR)unbox_VkDisplayModeKHR((VkDisplayModeKHR)(*&cgen_var_0));
    reservedunmarshal_VkDisplayModeParametersKHR(vkStream, rootType, (VkDisplayModeParametersKHR*)(&forUnmarshaling->parameters), ptr);
}

void reservedunmarshal_VkDisplayPlaneCapabilitiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayPlaneCapabilitiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDisplayPlaneAlphaFlagsKHR*)&forUnmarshaling->supportedAlpha, *ptr, sizeof(VkDisplayPlaneAlphaFlagsKHR));
    *ptr += sizeof(VkDisplayPlaneAlphaFlagsKHR);
    reservedunmarshal_VkOffset2D(vkStream, rootType, (VkOffset2D*)(&forUnmarshaling->minSrcPosition), ptr);
    reservedunmarshal_VkOffset2D(vkStream, rootType, (VkOffset2D*)(&forUnmarshaling->maxSrcPosition), ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->minSrcExtent), ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->maxSrcExtent), ptr);
    reservedunmarshal_VkOffset2D(vkStream, rootType, (VkOffset2D*)(&forUnmarshaling->minDstPosition), ptr);
    reservedunmarshal_VkOffset2D(vkStream, rootType, (VkOffset2D*)(&forUnmarshaling->maxDstPosition), ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->minDstExtent), ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->maxDstExtent), ptr);
}

void reservedunmarshal_VkDisplayPlanePropertiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayPlanePropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDisplayKHR*)&forUnmarshaling->currentDisplay = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->currentStackIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDisplayPropertiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayPropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDisplayKHR*)&forUnmarshaling->display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_0));
    vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->displayName, ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->physicalDimensions), ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->physicalResolution), ptr);
    memcpy((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, *ptr, sizeof(VkSurfaceTransformFlagsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagsKHR);
    memcpy((VkBool32*)&forUnmarshaling->planeReorderPossible, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->persistentContent, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDisplaySurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplaySurfaceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDisplaySurfaceCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkDisplaySurfaceCreateFlagsKHR));
    *ptr += sizeof(VkDisplaySurfaceCreateFlagsKHR);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDisplayModeKHR*)&forUnmarshaling->displayMode = (VkDisplayModeKHR)unbox_VkDisplayModeKHR((VkDisplayModeKHR)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->planeIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->planeStackIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->transform, *ptr, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy((float*)&forUnmarshaling->globalAlpha, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((VkDisplayPlaneAlphaFlagBitsKHR*)&forUnmarshaling->alphaMode, *ptr, sizeof(VkDisplayPlaneAlphaFlagBitsKHR));
    *ptr += sizeof(VkDisplayPlaneAlphaFlagBitsKHR);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->imageExtent), ptr);
}

#endif
#ifdef VK_KHR_display_swapchain
void reservedunmarshal_VkDisplayPresentInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayPresentInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(&forUnmarshaling->srcRect), ptr);
    reservedunmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(&forUnmarshaling->dstRect), ptr);
    memcpy((VkBool32*)&forUnmarshaling->persistent, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_xlib_surface
void reservedunmarshal_VkXlibSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkXlibSurfaceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkXlibSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkXlibSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkXlibSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    memcpy((Display**)&forUnmarshaling->dpy, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->dpy);
    *ptr += 8;
    if (forUnmarshaling->dpy)
    {
        vkStream->alloc((void**)&forUnmarshaling->dpy, sizeof(Display));
        memcpy((Display*)forUnmarshaling->dpy, *ptr, sizeof(Display));
        *ptr += sizeof(Display);
    }
    memcpy((Window*)&forUnmarshaling->window, *ptr, sizeof(Window));
    *ptr += sizeof(Window);
}

#endif
#ifdef VK_KHR_xcb_surface
void reservedunmarshal_VkXcbSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkXcbSurfaceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    
    // This struct should never be marshaled / unmarshaled.
    __builtin_trap();
    
}

#endif
#ifdef VK_KHR_wayland_surface
void reservedunmarshal_VkWaylandSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkWaylandSurfaceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkWaylandSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkWaylandSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkWaylandSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    memcpy((wl_display**)&forUnmarshaling->display, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->display);
    *ptr += 8;
    if (forUnmarshaling->display)
    {
        vkStream->alloc((void**)&forUnmarshaling->display, sizeof(wl_display));
        memcpy((wl_display*)forUnmarshaling->display, *ptr, sizeof(wl_display));
        *ptr += sizeof(wl_display);
    }
    // WARNING PTR CHECK
    memcpy((wl_surface**)&forUnmarshaling->surface, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->surface);
    *ptr += 8;
    if (forUnmarshaling->surface)
    {
        vkStream->alloc((void**)&forUnmarshaling->surface, sizeof(wl_surface));
        memcpy((wl_surface*)forUnmarshaling->surface, *ptr, sizeof(wl_surface));
        *ptr += sizeof(wl_surface);
    }
}

#endif
#ifdef VK_KHR_android_surface
void reservedunmarshal_VkAndroidSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAndroidSurfaceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAndroidSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkAndroidSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkAndroidSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    memcpy((ANativeWindow**)&forUnmarshaling->window, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->window);
    *ptr += 8;
    if (forUnmarshaling->window)
    {
        vkStream->alloc((void**)&forUnmarshaling->window, sizeof(ANativeWindow));
        memcpy((ANativeWindow*)forUnmarshaling->window, *ptr, sizeof(ANativeWindow));
        *ptr += sizeof(ANativeWindow);
    }
}

#endif
#ifdef VK_KHR_win32_surface
void reservedunmarshal_VkWin32SurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkWin32SurfaceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkWin32SurfaceCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkWin32SurfaceCreateFlagsKHR));
    *ptr += sizeof(VkWin32SurfaceCreateFlagsKHR);
    memcpy((HINSTANCE*)&forUnmarshaling->hinstance, *ptr, sizeof(HINSTANCE));
    *ptr += sizeof(HINSTANCE);
    memcpy((HWND*)&forUnmarshaling->hwnd, *ptr, sizeof(HWND));
    *ptr += sizeof(HWND);
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_device_group
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_device_group_creation
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void reservedunmarshal_VkImportMemoryWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImportMemoryWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    memcpy((HANDLE*)&forUnmarshaling->handle, *ptr, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
    memcpy((LPCWSTR*)&forUnmarshaling->name, *ptr, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedunmarshal_VkExportMemoryWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExportMemoryWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    // WARNING PTR CHECK
    memcpy((SECURITY_ATTRIBUTES**)&forUnmarshaling->pAttributes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pAttributes);
    *ptr += 8;
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        memcpy((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, *ptr, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy((DWORD*)&forUnmarshaling->dwAccess, *ptr, sizeof(DWORD));
    *ptr += sizeof(DWORD);
    memcpy((LPCWSTR*)&forUnmarshaling->name, *ptr, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedunmarshal_VkMemoryWin32HandlePropertiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryWin32HandlePropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->memoryTypeBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkMemoryGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryGetWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_0));
    memcpy((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_memory_fd
void reservedunmarshal_VkImportMemoryFdInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImportMemoryFdInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    memcpy((int*)&forUnmarshaling->fd, *ptr, sizeof(int));
    *ptr += sizeof(int);
}

void reservedunmarshal_VkMemoryFdPropertiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryFdPropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->memoryTypeBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkMemoryGetFdInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryGetFdInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_0));
    memcpy((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void reservedunmarshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkWin32KeyedMutexAcquireReleaseInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->acquireCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAcquireSyncs, forUnmarshaling->acquireCount * sizeof(const VkDeviceMemory));
    if (forUnmarshaling->acquireCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->acquireCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->acquireCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                *(((VkDeviceMemory*)forUnmarshaling->pAcquireSyncs) + k) = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)tmpval);
            }
        }
    }
    vkStream->alloc((void**)&forUnmarshaling->pAcquireKeys, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    memcpy((uint64_t*)forUnmarshaling->pAcquireKeys, *ptr, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    *ptr += forUnmarshaling->acquireCount * sizeof(const uint64_t);
    vkStream->alloc((void**)&forUnmarshaling->pAcquireTimeouts, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pAcquireTimeouts, *ptr, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->acquireCount * sizeof(const uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->releaseCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pReleaseSyncs, forUnmarshaling->releaseCount * sizeof(const VkDeviceMemory));
    if (forUnmarshaling->releaseCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->releaseCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->releaseCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                *(((VkDeviceMemory*)forUnmarshaling->pReleaseSyncs) + k) = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)tmpval);
            }
        }
    }
    vkStream->alloc((void**)&forUnmarshaling->pReleaseKeys, forUnmarshaling->releaseCount * sizeof(const uint64_t));
    memcpy((uint64_t*)forUnmarshaling->pReleaseKeys, *ptr, forUnmarshaling->releaseCount * sizeof(const uint64_t));
    *ptr += forUnmarshaling->releaseCount * sizeof(const uint64_t);
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void reservedunmarshal_VkImportSemaphoreWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImportSemaphoreWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSemaphore*)&forUnmarshaling->semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_0));
    memcpy((VkSemaphoreImportFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSemaphoreImportFlags));
    *ptr += sizeof(VkSemaphoreImportFlags);
    memcpy((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
    memcpy((HANDLE*)&forUnmarshaling->handle, *ptr, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
    memcpy((LPCWSTR*)&forUnmarshaling->name, *ptr, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedunmarshal_VkExportSemaphoreWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExportSemaphoreWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    // WARNING PTR CHECK
    memcpy((SECURITY_ATTRIBUTES**)&forUnmarshaling->pAttributes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pAttributes);
    *ptr += 8;
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        memcpy((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, *ptr, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy((DWORD*)&forUnmarshaling->dwAccess, *ptr, sizeof(DWORD));
    *ptr += sizeof(DWORD);
    memcpy((LPCWSTR*)&forUnmarshaling->name, *ptr, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedunmarshal_VkD3D12FenceSubmitInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkD3D12FenceSubmitInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->waitSemaphoreValuesCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((uint64_t**)&forUnmarshaling->pWaitSemaphoreValues, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pWaitSemaphoreValues);
    *ptr += 8;
    if (forUnmarshaling->pWaitSemaphoreValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphoreValues, forUnmarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t));
        memcpy((uint64_t*)forUnmarshaling->pWaitSemaphoreValues, *ptr, forUnmarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t));
        *ptr += forUnmarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t);
    }
    memcpy((uint32_t*)&forUnmarshaling->signalSemaphoreValuesCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((uint64_t**)&forUnmarshaling->pSignalSemaphoreValues, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pSignalSemaphoreValues);
    *ptr += 8;
    if (forUnmarshaling->pSignalSemaphoreValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphoreValues, forUnmarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t));
        memcpy((uint64_t*)forUnmarshaling->pSignalSemaphoreValues, *ptr, forUnmarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t));
        *ptr += forUnmarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t);
    }
}

void reservedunmarshal_VkSemaphoreGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSemaphoreGetWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSemaphore*)&forUnmarshaling->semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_0));
    memcpy((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void reservedunmarshal_VkImportSemaphoreFdInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImportSemaphoreFdInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSemaphore*)&forUnmarshaling->semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_0));
    memcpy((VkSemaphoreImportFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSemaphoreImportFlags));
    *ptr += sizeof(VkSemaphoreImportFlags);
    memcpy((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
    memcpy((int*)&forUnmarshaling->fd, *ptr, sizeof(int));
    *ptr += sizeof(int);
}

void reservedunmarshal_VkSemaphoreGetFdInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSemaphoreGetFdInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSemaphore*)&forUnmarshaling->semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_0));
    memcpy((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_push_descriptor
void reservedunmarshal_VkPhysicalDevicePushDescriptorPropertiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDevicePushDescriptorPropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxPushDescriptors, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void reservedunmarshal_VkRectLayerKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRectLayerKHR* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkOffset2D(vkStream, rootType, (VkOffset2D*)(&forUnmarshaling->offset), ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->extent), ptr);
    memcpy((uint32_t*)&forUnmarshaling->layer, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPresentRegionKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPresentRegionKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->rectangleCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkRectLayerKHR**)&forUnmarshaling->pRectangles, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pRectangles);
    *ptr += 8;
    if (forUnmarshaling->pRectangles)
    {
        vkStream->alloc((void**)&forUnmarshaling->pRectangles, forUnmarshaling->rectangleCount * sizeof(const VkRectLayerKHR));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->rectangleCount; ++i)
        {
            reservedunmarshal_VkRectLayerKHR(vkStream, rootType, (VkRectLayerKHR*)(forUnmarshaling->pRectangles + i), ptr);
        }
    }
}

void reservedunmarshal_VkPresentRegionsKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPresentRegionsKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->swapchainCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkPresentRegionKHR**)&forUnmarshaling->pRegions, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pRegions);
    *ptr += 8;
    if (forUnmarshaling->pRegions)
    {
        vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->swapchainCount * sizeof(const VkPresentRegionKHR));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->swapchainCount; ++i)
        {
            reservedunmarshal_VkPresentRegionKHR(vkStream, rootType, (VkPresentRegionKHR*)(forUnmarshaling->pRegions + i), ptr);
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_imageless_framebuffer
#endif
#ifdef VK_KHR_create_renderpass2
#endif
#ifdef VK_KHR_shared_presentable_image
void reservedunmarshal_VkSharedPresentSurfaceCapabilitiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSharedPresentSurfaceCapabilitiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageUsageFlags*)&forUnmarshaling->sharedPresentSupportedUsageFlags, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
}

#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void reservedunmarshal_VkImportFenceWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImportFenceWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkFence*)&forUnmarshaling->fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_0));
    memcpy((VkFenceImportFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkFenceImportFlags));
    *ptr += sizeof(VkFenceImportFlags);
    memcpy((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
    memcpy((HANDLE*)&forUnmarshaling->handle, *ptr, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
    memcpy((LPCWSTR*)&forUnmarshaling->name, *ptr, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedunmarshal_VkExportFenceWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExportFenceWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    // WARNING PTR CHECK
    memcpy((SECURITY_ATTRIBUTES**)&forUnmarshaling->pAttributes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pAttributes);
    *ptr += 8;
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        memcpy((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, *ptr, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy((DWORD*)&forUnmarshaling->dwAccess, *ptr, sizeof(DWORD));
    *ptr += sizeof(DWORD);
    memcpy((LPCWSTR*)&forUnmarshaling->name, *ptr, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedunmarshal_VkFenceGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkFenceGetWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkFence*)&forUnmarshaling->fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_0));
    memcpy((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_fence_fd
void reservedunmarshal_VkImportFenceFdInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImportFenceFdInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkFence*)&forUnmarshaling->fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_0));
    memcpy((VkFenceImportFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkFenceImportFlags));
    *ptr += sizeof(VkFenceImportFlags);
    memcpy((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
    memcpy((int*)&forUnmarshaling->fd, *ptr, sizeof(int));
    *ptr += sizeof(int);
}

void reservedunmarshal_VkFenceGetFdInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkFenceGetFdInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkFence*)&forUnmarshaling->fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_0));
    memcpy((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_performance_query
void reservedunmarshal_VkPhysicalDevicePerformanceQueryFeaturesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDevicePerformanceQueryFeaturesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->performanceCounterQueryPools, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->performanceCounterMultipleQueryPools, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDevicePerformanceQueryPropertiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDevicePerformanceQueryPropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->allowCommandBufferQueryCopies, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPerformanceCounterKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPerformanceCounterKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPerformanceCounterUnitKHR*)&forUnmarshaling->unit, *ptr, sizeof(VkPerformanceCounterUnitKHR));
    *ptr += sizeof(VkPerformanceCounterUnitKHR);
    memcpy((VkPerformanceCounterScopeKHR*)&forUnmarshaling->scope, *ptr, sizeof(VkPerformanceCounterScopeKHR));
    *ptr += sizeof(VkPerformanceCounterScopeKHR);
    memcpy((VkPerformanceCounterStorageKHR*)&forUnmarshaling->storage, *ptr, sizeof(VkPerformanceCounterStorageKHR));
    *ptr += sizeof(VkPerformanceCounterStorageKHR);
    memcpy((uint8_t*)forUnmarshaling->uuid, *ptr, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
}

void reservedunmarshal_VkPerformanceCounterDescriptionKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPerformanceCounterDescriptionKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPerformanceCounterDescriptionFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkPerformanceCounterDescriptionFlagsKHR));
    *ptr += sizeof(VkPerformanceCounterDescriptionFlagsKHR);
    memcpy((char*)forUnmarshaling->name, *ptr, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy((char*)forUnmarshaling->category, *ptr, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy((char*)forUnmarshaling->description, *ptr, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
}

void reservedunmarshal_VkQueryPoolPerformanceCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkQueryPoolPerformanceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->queueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->counterIndexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pCounterIndices, forUnmarshaling->counterIndexCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pCounterIndices, *ptr, forUnmarshaling->counterIndexCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->counterIndexCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkPerformanceCounterResultKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPerformanceCounterResultKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((int32_t*)&forUnmarshaling->int32, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedunmarshal_VkAcquireProfilingLockInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAcquireProfilingLockInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAcquireProfilingLockFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkAcquireProfilingLockFlagsKHR));
    *ptr += sizeof(VkAcquireProfilingLockFlagsKHR);
    memcpy((uint64_t*)&forUnmarshaling->timeout, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkPerformanceQuerySubmitInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPerformanceQuerySubmitInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->counterPassIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void reservedunmarshal_VkPhysicalDeviceSurfaceInfo2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceSurfaceInfo2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSurfaceKHR*)&forUnmarshaling->surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_0));
}

void reservedunmarshal_VkSurfaceCapabilities2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSurfaceCapabilities2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkSurfaceCapabilitiesKHR(vkStream, rootType, (VkSurfaceCapabilitiesKHR*)(&forUnmarshaling->surfaceCapabilities), ptr);
}

void reservedunmarshal_VkSurfaceFormat2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSurfaceFormat2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkSurfaceFormatKHR(vkStream, rootType, (VkSurfaceFormatKHR*)(&forUnmarshaling->surfaceFormat), ptr);
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void reservedunmarshal_VkDisplayProperties2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayProperties2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkDisplayPropertiesKHR(vkStream, rootType, (VkDisplayPropertiesKHR*)(&forUnmarshaling->displayProperties), ptr);
}

void reservedunmarshal_VkDisplayPlaneProperties2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayPlaneProperties2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkDisplayPlanePropertiesKHR(vkStream, rootType, (VkDisplayPlanePropertiesKHR*)(&forUnmarshaling->displayPlaneProperties), ptr);
}

void reservedunmarshal_VkDisplayModeProperties2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayModeProperties2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkDisplayModePropertiesKHR(vkStream, rootType, (VkDisplayModePropertiesKHR*)(&forUnmarshaling->displayModeProperties), ptr);
}

void reservedunmarshal_VkDisplayPlaneInfo2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayPlaneInfo2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDisplayModeKHR*)&forUnmarshaling->mode = (VkDisplayModeKHR)unbox_VkDisplayModeKHR((VkDisplayModeKHR)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->planeIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDisplayPlaneCapabilities2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayPlaneCapabilities2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkDisplayPlaneCapabilitiesKHR(vkStream, rootType, (VkDisplayPlaneCapabilitiesKHR*)(&forUnmarshaling->capabilities), ptr);
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_portability_subset
void reservedunmarshal_VkPhysicalDevicePortabilitySubsetFeaturesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDevicePortabilitySubsetFeaturesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->constantAlphaColorBlendFactors, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->events, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->imageViewFormatReinterpretation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->imageViewFormatSwizzle, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->imageView2DOn3DImage, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->multisampleArrayImage, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->mutableComparisonSamplers, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->pointPolygons, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->samplerMipLodBias, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->separateStencilMaskRef, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSampleRateInterpolationFunctions, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->tessellationIsolines, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->tessellationPointMode, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->triangleFans, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->vertexAttributeAccessBeyondStride, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDevicePortabilitySubsetPropertiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDevicePortabilitySubsetPropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->minVertexInputBindingStrideAlignment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_draw_indirect_count
#endif
#ifdef VK_KHR_shader_subgroup_extended_types
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_KHR_shader_atomic_int64
#endif
#ifdef VK_KHR_shader_clock
void reservedunmarshal_VkPhysicalDeviceShaderClockFeaturesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderClockFeaturesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderSubgroupClock, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderDeviceClock, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_driver_properties
#endif
#ifdef VK_KHR_shader_float_controls
#endif
#ifdef VK_KHR_depth_stencil_resolve
#endif
#ifdef VK_KHR_swapchain_mutable_format
#endif
#ifdef VK_KHR_timeline_semaphore
#endif
#ifdef VK_KHR_vulkan_memory_model
#endif
#ifdef VK_KHR_shader_terminate_invocation
void reservedunmarshal_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderTerminateInvocation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_fragment_shading_rate
void reservedunmarshal_VkFragmentShadingRateAttachmentInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkFragmentShadingRateAttachmentInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    vkStream->alloc((void**)&forUnmarshaling->pFragmentShadingRateAttachment, sizeof(const VkAttachmentReference2));
    reservedunmarshal_VkAttachmentReference2(vkStream, rootType, (VkAttachmentReference2*)(forUnmarshaling->pFragmentShadingRateAttachment), ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->shadingRateAttachmentTexelSize), ptr);
}

void reservedunmarshal_VkPipelineFragmentShadingRateStateCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineFragmentShadingRateStateCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->fragmentSize), ptr);
    memcpy((VkFragmentShadingRateCombinerOpKHR*)forUnmarshaling->combinerOps, *ptr, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
    *ptr += 2 * sizeof(VkFragmentShadingRateCombinerOpKHR);
}

void reservedunmarshal_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceFragmentShadingRateFeaturesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->pipelineFragmentShadingRate, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->primitiveFragmentShadingRate, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->attachmentFragmentShadingRate, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceFragmentShadingRatePropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->minFragmentShadingRateAttachmentTexelSize), ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->maxFragmentShadingRateAttachmentTexelSize), ptr);
    memcpy((uint32_t*)&forUnmarshaling->maxFragmentShadingRateAttachmentTexelSizeAspectRatio, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->primitiveFragmentShadingRateWithMultipleViewports, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->layeredShadingRateAttachments, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fragmentShadingRateNonTrivialCombinerOps, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->maxFragmentSize), ptr);
    memcpy((uint32_t*)&forUnmarshaling->maxFragmentSizeAspectRatio, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFragmentShadingRateCoverageSamples, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->maxFragmentShadingRateRasterizationSamples, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy((VkBool32*)&forUnmarshaling->fragmentShadingRateWithShaderDepthStencilWrites, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fragmentShadingRateWithSampleMask, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fragmentShadingRateWithShaderSampleMask, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fragmentShadingRateWithConservativeRasterization, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fragmentShadingRateWithFragmentShaderInterlock, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fragmentShadingRateWithCustomSampleLocations, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fragmentShadingRateStrictMultiplyCombiner, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceFragmentShadingRateKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceFragmentShadingRateKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSampleCountFlags*)&forUnmarshaling->sampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->fragmentSize), ptr);
}

#endif
#ifdef VK_KHR_spirv_1_4
#endif
#ifdef VK_KHR_surface_protected_capabilities
void reservedunmarshal_VkSurfaceProtectedCapabilitiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSurfaceProtectedCapabilitiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->supportsProtected, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_separate_depth_stencil_layouts
#endif
#ifdef VK_KHR_uniform_buffer_standard_layout
#endif
#ifdef VK_KHR_buffer_device_address
#endif
#ifdef VK_KHR_deferred_host_operations
#endif
#ifdef VK_KHR_pipeline_executable_properties
void reservedunmarshal_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->pipelineExecutableInfo, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPipelineInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipeline*)&forUnmarshaling->pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_0));
}

void reservedunmarshal_VkPipelineExecutablePropertiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineExecutablePropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkShaderStageFlags*)&forUnmarshaling->stages, *ptr, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    memcpy((char*)forUnmarshaling->name, *ptr, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy((char*)forUnmarshaling->description, *ptr, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy((uint32_t*)&forUnmarshaling->subgroupSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPipelineExecutableInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineExecutableInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipeline*)&forUnmarshaling->pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->executableIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPipelineExecutableStatisticValueKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineExecutableStatisticValueKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkBool32*)&forUnmarshaling->b32, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPipelineExecutableStatisticKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineExecutableStatisticKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((char*)forUnmarshaling->name, *ptr, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy((char*)forUnmarshaling->description, *ptr, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy((VkPipelineExecutableStatisticFormatKHR*)&forUnmarshaling->format, *ptr, sizeof(VkPipelineExecutableStatisticFormatKHR));
    *ptr += sizeof(VkPipelineExecutableStatisticFormatKHR);
    reservedunmarshal_VkPipelineExecutableStatisticValueKHR(vkStream, rootType, (VkPipelineExecutableStatisticValueKHR*)(&forUnmarshaling->value), ptr);
}

void reservedunmarshal_VkPipelineExecutableInternalRepresentationKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineExecutableInternalRepresentationKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((char*)forUnmarshaling->name, *ptr, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy((char*)forUnmarshaling->description, *ptr, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy((VkBool32*)&forUnmarshaling->isText, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((size_t*)&forUnmarshaling->dataSize, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->dataSize);
    *ptr += 8;
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pData, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pData);
    *ptr += 8;
    if (forUnmarshaling->pData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pData, forUnmarshaling->dataSize * sizeof(uint8_t));
        memcpy((void*)forUnmarshaling->pData, *ptr, forUnmarshaling->dataSize * sizeof(uint8_t));
        *ptr += forUnmarshaling->dataSize * sizeof(uint8_t);
    }
}

#endif
#ifdef VK_KHR_pipeline_library
void reservedunmarshal_VkPipelineLibraryCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineLibraryCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->libraryCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pLibraries, forUnmarshaling->libraryCount * sizeof(const VkPipeline));
    if (forUnmarshaling->libraryCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->libraryCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->libraryCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                *(((VkPipeline*)forUnmarshaling->pLibraries) + k) = (VkPipeline)unbox_VkPipeline((VkPipeline)tmpval);
            }
        }
    }
}

#endif
#ifdef VK_KHR_shader_non_semantic_info
#endif
#ifdef VK_KHR_copy_commands2
void reservedunmarshal_VkBufferCopy2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBufferCopy2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceSize*)&forUnmarshaling->srcOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->dstOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkCopyBufferInfo2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCopyBufferInfo2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->srcBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
    memcpy((uint32_t*)&forUnmarshaling->regionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->regionCount * sizeof(const VkBufferCopy2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->regionCount; ++i)
    {
        reservedunmarshal_VkBufferCopy2KHR(vkStream, rootType, (VkBufferCopy2KHR*)(forUnmarshaling->pRegions + i), ptr);
    }
}

void reservedunmarshal_VkImageCopy2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageCopy2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forUnmarshaling->srcOffset), ptr);
    reservedunmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forUnmarshaling->dstOffset), ptr);
    reservedunmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forUnmarshaling->extent), ptr);
}

void reservedunmarshal_VkCopyImageInfo2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCopyImageInfo2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    memcpy((VkImageLayout*)&forUnmarshaling->srcImageLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
    memcpy((VkImageLayout*)&forUnmarshaling->dstImageLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((uint32_t*)&forUnmarshaling->regionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->regionCount * sizeof(const VkImageCopy2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->regionCount; ++i)
    {
        reservedunmarshal_VkImageCopy2KHR(vkStream, rootType, (VkImageCopy2KHR*)(forUnmarshaling->pRegions + i), ptr);
    }
}

void reservedunmarshal_VkBufferImageCopy2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBufferImageCopy2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceSize*)&forUnmarshaling->bufferOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->bufferRowLength, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->bufferImageHeight, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forUnmarshaling->imageSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forUnmarshaling->imageOffset), ptr);
    reservedunmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forUnmarshaling->imageExtent), ptr);
}

void reservedunmarshal_VkCopyBufferToImageInfo2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCopyBufferToImageInfo2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->srcBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
    memcpy((VkImageLayout*)&forUnmarshaling->dstImageLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((uint32_t*)&forUnmarshaling->regionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->regionCount * sizeof(const VkBufferImageCopy2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->regionCount; ++i)
    {
        reservedunmarshal_VkBufferImageCopy2KHR(vkStream, rootType, (VkBufferImageCopy2KHR*)(forUnmarshaling->pRegions + i), ptr);
    }
}

void reservedunmarshal_VkCopyImageToBufferInfo2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCopyImageToBufferInfo2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    memcpy((VkImageLayout*)&forUnmarshaling->srcImageLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
    memcpy((uint32_t*)&forUnmarshaling->regionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->regionCount * sizeof(const VkBufferImageCopy2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->regionCount; ++i)
    {
        reservedunmarshal_VkBufferImageCopy2KHR(vkStream, rootType, (VkBufferImageCopy2KHR*)(forUnmarshaling->pRegions + i), ptr);
    }
}

void reservedunmarshal_VkImageBlit2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageBlit2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource), ptr);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(forUnmarshaling->srcOffsets + i), ptr);
    }
    reservedunmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource), ptr);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(forUnmarshaling->dstOffsets + i), ptr);
    }
}

void reservedunmarshal_VkBlitImageInfo2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBlitImageInfo2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    memcpy((VkImageLayout*)&forUnmarshaling->srcImageLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
    memcpy((VkImageLayout*)&forUnmarshaling->dstImageLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((uint32_t*)&forUnmarshaling->regionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->regionCount * sizeof(const VkImageBlit2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->regionCount; ++i)
    {
        reservedunmarshal_VkImageBlit2KHR(vkStream, rootType, (VkImageBlit2KHR*)(forUnmarshaling->pRegions + i), ptr);
    }
    memcpy((VkFilter*)&forUnmarshaling->filter, *ptr, sizeof(VkFilter));
    *ptr += sizeof(VkFilter);
}

void reservedunmarshal_VkImageResolve2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageResolve2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forUnmarshaling->srcOffset), ptr);
    reservedunmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forUnmarshaling->dstOffset), ptr);
    reservedunmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forUnmarshaling->extent), ptr);
}

void reservedunmarshal_VkResolveImageInfo2KHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkResolveImageInfo2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    memcpy((VkImageLayout*)&forUnmarshaling->srcImageLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
    memcpy((VkImageLayout*)&forUnmarshaling->dstImageLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((uint32_t*)&forUnmarshaling->regionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->regionCount * sizeof(const VkImageResolve2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->regionCount; ++i)
    {
        reservedunmarshal_VkImageResolve2KHR(vkStream, rootType, (VkImageResolve2KHR*)(forUnmarshaling->pRegions + i), ptr);
    }
}

#endif
#ifdef VK_ANDROID_native_buffer
void reservedunmarshal_VkNativeBufferANDROID(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkNativeBufferANDROID* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    // WARNING PTR CHECK
    memcpy((uint32_t**)&forUnmarshaling->handle, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->handle);
    *ptr += 8;
    if (forUnmarshaling->handle)
    {
        vkStream->alloc((void**)&forUnmarshaling->handle, sizeof(const uint32_t));
        memcpy((uint32_t*)forUnmarshaling->handle, *ptr, sizeof(const uint32_t));
        *ptr += sizeof(const uint32_t);
    }
    memcpy((int*)&forUnmarshaling->stride, *ptr, sizeof(int));
    *ptr += sizeof(int);
    memcpy((int*)&forUnmarshaling->format, *ptr, sizeof(int));
    *ptr += sizeof(int);
    memcpy((int*)&forUnmarshaling->usage, *ptr, sizeof(int));
    *ptr += sizeof(int);
    memcpy((uint64_t*)&forUnmarshaling->consumer, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->producer, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

#endif
#ifdef VK_EXT_debug_report
void reservedunmarshal_VkDebugReportCallbackCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDebugReportCallbackCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDebugReportFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkDebugReportFlagsEXT));
    *ptr += sizeof(VkDebugReportFlagsEXT);
    memcpy((PFN_vkDebugReportCallbackEXT*)&forUnmarshaling->pfnCallback, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnCallback);
    *ptr += 8;
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pUserData, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pUserData);
    *ptr += 8;
    if (forUnmarshaling->pUserData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
        memcpy((void*)forUnmarshaling->pUserData, *ptr, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void reservedunmarshal_VkPipelineRasterizationStateRasterizationOrderAMD(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineRasterizationStateRasterizationOrderAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkRasterizationOrderAMD*)&forUnmarshaling->rasterizationOrder, *ptr, sizeof(VkRasterizationOrderAMD));
    *ptr += sizeof(VkRasterizationOrderAMD);
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void reservedunmarshal_VkDebugMarkerObjectNameInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDebugMarkerObjectNameInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDebugReportObjectTypeEXT*)&forUnmarshaling->objectType, *ptr, sizeof(VkDebugReportObjectTypeEXT));
    *ptr += sizeof(VkDebugReportObjectTypeEXT);
    memcpy((uint64_t*)&forUnmarshaling->object, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pObjectName, ptr);
}

void reservedunmarshal_VkDebugMarkerObjectTagInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDebugMarkerObjectTagInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDebugReportObjectTypeEXT*)&forUnmarshaling->objectType, *ptr, sizeof(VkDebugReportObjectTypeEXT));
    *ptr += sizeof(VkDebugReportObjectTypeEXT);
    memcpy((uint64_t*)&forUnmarshaling->object, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->tagName, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((size_t*)&forUnmarshaling->tagSize, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->tagSize);
    *ptr += 8;
    vkStream->alloc((void**)&forUnmarshaling->pTag, forUnmarshaling->tagSize * sizeof(const uint8_t));
    memcpy((void*)forUnmarshaling->pTag, *ptr, forUnmarshaling->tagSize * sizeof(const uint8_t));
    *ptr += forUnmarshaling->tagSize * sizeof(const uint8_t);
}

void reservedunmarshal_VkDebugMarkerMarkerInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDebugMarkerMarkerInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pMarkerName, ptr);
    memcpy((float*)forUnmarshaling->color, *ptr, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void reservedunmarshal_VkDedicatedAllocationImageCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDedicatedAllocationImageCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->dedicatedAllocation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDedicatedAllocationBufferCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDedicatedAllocationBufferCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->dedicatedAllocation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDedicatedAllocationMemoryAllocateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDedicatedAllocationMemoryAllocateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
}

#endif
#ifdef VK_EXT_transform_feedback
void reservedunmarshal_VkPhysicalDeviceTransformFeedbackFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceTransformFeedbackFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->transformFeedback, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->geometryStreams, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceTransformFeedbackPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceTransformFeedbackPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxTransformFeedbackStreams, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTransformFeedbackBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDeviceSize*)&forUnmarshaling->maxTransformFeedbackBufferSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->maxTransformFeedbackStreamDataSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTransformFeedbackBufferDataSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTransformFeedbackBufferDataStride, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->transformFeedbackQueries, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->transformFeedbackStreamsLinesTriangles, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->transformFeedbackRasterizationStreamSelect, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->transformFeedbackDraw, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPipelineRasterizationStateStreamCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineRasterizationStateStreamCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineRasterizationStateStreamCreateFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineRasterizationStateStreamCreateFlagsEXT));
    *ptr += sizeof(VkPipelineRasterizationStateStreamCreateFlagsEXT);
    memcpy((uint32_t*)&forUnmarshaling->rasterizationStream, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_NVX_image_view_handle
void reservedunmarshal_VkImageViewHandleInfoNVX(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageViewHandleInfoNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImageView*)&forUnmarshaling->imageView = (VkImageView)unbox_VkImageView((VkImageView)(*&cgen_var_0));
    memcpy((VkDescriptorType*)&forUnmarshaling->descriptorType, *ptr, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSampler*)&forUnmarshaling->sampler = (VkSampler)unbox_VkSampler((VkSampler)(*&cgen_var_1));
}

void reservedunmarshal_VkImageViewAddressPropertiesNVX(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageViewAddressPropertiesNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceAddress*)&forUnmarshaling->deviceAddress, *ptr, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

#endif
#ifdef VK_AMD_draw_indirect_count
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
void reservedunmarshal_VkTextureLODGatherFormatPropertiesAMD(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkTextureLODGatherFormatPropertiesAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->supportsTextureGatherLODBiasAMD, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_AMD_shader_info
void reservedunmarshal_VkShaderResourceUsageAMD(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkShaderResourceUsageAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->numUsedVgprs, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->numUsedSgprs, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->ldsSizePerLocalWorkGroup, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((size_t*)&forUnmarshaling->ldsUsageSizeInBytes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->ldsUsageSizeInBytes);
    *ptr += 8;
    memcpy((size_t*)&forUnmarshaling->scratchMemUsageInBytes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->scratchMemUsageInBytes);
    *ptr += 8;
}

void reservedunmarshal_VkShaderStatisticsInfoAMD(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkShaderStatisticsInfoAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkShaderStageFlags*)&forUnmarshaling->shaderStageMask, *ptr, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    reservedunmarshal_VkShaderResourceUsageAMD(vkStream, rootType, (VkShaderResourceUsageAMD*)(&forUnmarshaling->resourceUsage), ptr);
    memcpy((uint32_t*)&forUnmarshaling->numPhysicalVgprs, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->numPhysicalSgprs, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->numAvailableVgprs, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->numAvailableSgprs, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)forUnmarshaling->computeWorkGroupSize, *ptr, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_GGP_stream_descriptor_surface
void reservedunmarshal_VkStreamDescriptorSurfaceCreateInfoGGP(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkStreamDescriptorSurfaceCreateInfoGGP* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkStreamDescriptorSurfaceCreateFlagsGGP*)&forUnmarshaling->flags, *ptr, sizeof(VkStreamDescriptorSurfaceCreateFlagsGGP));
    *ptr += sizeof(VkStreamDescriptorSurfaceCreateFlagsGGP);
    memcpy((GgpStreamDescriptor*)&forUnmarshaling->streamDescriptor, *ptr, sizeof(GgpStreamDescriptor));
    *ptr += sizeof(GgpStreamDescriptor);
}

#endif
#ifdef VK_NV_corner_sampled_image
void reservedunmarshal_VkPhysicalDeviceCornerSampledImageFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceCornerSampledImageFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->cornerSampledImage, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void reservedunmarshal_VkExternalImageFormatPropertiesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExternalImageFormatPropertiesNV* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkImageFormatProperties(vkStream, rootType, (VkImageFormatProperties*)(&forUnmarshaling->imageFormatProperties), ptr);
    memcpy((VkExternalMemoryFeatureFlagsNV*)&forUnmarshaling->externalMemoryFeatures, *ptr, sizeof(VkExternalMemoryFeatureFlagsNV));
    *ptr += sizeof(VkExternalMemoryFeatureFlagsNV);
    memcpy((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->exportFromImportedHandleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
    memcpy((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->compatibleHandleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

#endif
#ifdef VK_NV_external_memory
void reservedunmarshal_VkExternalMemoryImageCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExternalMemoryImageCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

void reservedunmarshal_VkExportMemoryAllocateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExportMemoryAllocateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

#endif
#ifdef VK_NV_external_memory_win32
void reservedunmarshal_VkImportMemoryWin32HandleInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImportMemoryWin32HandleInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
    memcpy((HANDLE*)&forUnmarshaling->handle, *ptr, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
}

void reservedunmarshal_VkExportMemoryWin32HandleInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExportMemoryWin32HandleInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    // WARNING PTR CHECK
    memcpy((SECURITY_ATTRIBUTES**)&forUnmarshaling->pAttributes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pAttributes);
    *ptr += 8;
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        memcpy((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, *ptr, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy((DWORD*)&forUnmarshaling->dwAccess, *ptr, sizeof(DWORD));
    *ptr += sizeof(DWORD);
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void reservedunmarshal_VkWin32KeyedMutexAcquireReleaseInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkWin32KeyedMutexAcquireReleaseInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->acquireCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAcquireSyncs, forUnmarshaling->acquireCount * sizeof(const VkDeviceMemory));
    if (forUnmarshaling->acquireCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->acquireCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->acquireCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                *(((VkDeviceMemory*)forUnmarshaling->pAcquireSyncs) + k) = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)tmpval);
            }
        }
    }
    vkStream->alloc((void**)&forUnmarshaling->pAcquireKeys, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    memcpy((uint64_t*)forUnmarshaling->pAcquireKeys, *ptr, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    *ptr += forUnmarshaling->acquireCount * sizeof(const uint64_t);
    vkStream->alloc((void**)&forUnmarshaling->pAcquireTimeoutMilliseconds, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pAcquireTimeoutMilliseconds, *ptr, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->acquireCount * sizeof(const uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->releaseCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pReleaseSyncs, forUnmarshaling->releaseCount * sizeof(const VkDeviceMemory));
    if (forUnmarshaling->releaseCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->releaseCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->releaseCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                *(((VkDeviceMemory*)forUnmarshaling->pReleaseSyncs) + k) = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)tmpval);
            }
        }
    }
    vkStream->alloc((void**)&forUnmarshaling->pReleaseKeys, forUnmarshaling->releaseCount * sizeof(const uint64_t));
    memcpy((uint64_t*)forUnmarshaling->pReleaseKeys, *ptr, forUnmarshaling->releaseCount * sizeof(const uint64_t));
    *ptr += forUnmarshaling->releaseCount * sizeof(const uint64_t);
}

#endif
#ifdef VK_EXT_validation_flags
void reservedunmarshal_VkValidationFlagsEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkValidationFlagsEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->disabledValidationCheckCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDisabledValidationChecks, forUnmarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
    memcpy((VkValidationCheckEXT*)forUnmarshaling->pDisabledValidationChecks, *ptr, forUnmarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
    *ptr += forUnmarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT);
}

#endif
#ifdef VK_NN_vi_surface
void reservedunmarshal_VkViSurfaceCreateInfoNN(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkViSurfaceCreateInfoNN* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkViSurfaceCreateFlagsNN*)&forUnmarshaling->flags, *ptr, sizeof(VkViSurfaceCreateFlagsNN));
    *ptr += sizeof(VkViSurfaceCreateFlagsNN);
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->window, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->window);
    *ptr += 8;
    if (forUnmarshaling->window)
    {
        vkStream->alloc((void**)&forUnmarshaling->window, sizeof(uint8_t));
        memcpy((void*)forUnmarshaling->window, *ptr, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
void reservedunmarshal_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->textureCompressionASTC_HDR, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_astc_decode_mode
void reservedunmarshal_VkImageViewASTCDecodeModeEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageViewASTCDecodeModeEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFormat*)&forUnmarshaling->decodeMode, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
}

void reservedunmarshal_VkPhysicalDeviceASTCDecodeFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceASTCDecodeFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->decodeModeSharedExponent, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_conditional_rendering
void reservedunmarshal_VkConditionalRenderingBeginInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkConditionalRenderingBeginInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkConditionalRenderingFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkConditionalRenderingFlagsEXT));
    *ptr += sizeof(VkConditionalRenderingFlagsEXT);
}

void reservedunmarshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceConditionalRenderingFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->conditionalRendering, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->inheritedConditionalRendering, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCommandBufferInheritanceConditionalRenderingInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->conditionalRenderingEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void reservedunmarshal_VkViewportWScalingNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkViewportWScalingNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((float*)&forUnmarshaling->xcoeff, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->ycoeff, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

void reservedunmarshal_VkPipelineViewportWScalingStateCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineViewportWScalingStateCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->viewportWScalingEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->viewportCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkViewportWScalingNV**)&forUnmarshaling->pViewportWScalings, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pViewportWScalings);
    *ptr += 8;
    if (forUnmarshaling->pViewportWScalings)
    {
        vkStream->alloc((void**)&forUnmarshaling->pViewportWScalings, forUnmarshaling->viewportCount * sizeof(const VkViewportWScalingNV));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            reservedunmarshal_VkViewportWScalingNV(vkStream, rootType, (VkViewportWScalingNV*)(forUnmarshaling->pViewportWScalings + i), ptr);
        }
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
#endif
#ifdef VK_EXT_acquire_xlib_display
#endif
#ifdef VK_EXT_display_surface_counter
void reservedunmarshal_VkSurfaceCapabilities2EXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSurfaceCapabilities2EXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->minImageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxImageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->currentExtent), ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->minImageExtent), ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->maxImageExtent), ptr);
    memcpy((uint32_t*)&forUnmarshaling->maxImageArrayLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, *ptr, sizeof(VkSurfaceTransformFlagsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagsKHR);
    memcpy((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->currentTransform, *ptr, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy((VkCompositeAlphaFlagsKHR*)&forUnmarshaling->supportedCompositeAlpha, *ptr, sizeof(VkCompositeAlphaFlagsKHR));
    *ptr += sizeof(VkCompositeAlphaFlagsKHR);
    memcpy((VkImageUsageFlags*)&forUnmarshaling->supportedUsageFlags, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy((VkSurfaceCounterFlagsEXT*)&forUnmarshaling->supportedSurfaceCounters, *ptr, sizeof(VkSurfaceCounterFlagsEXT));
    *ptr += sizeof(VkSurfaceCounterFlagsEXT);
}

#endif
#ifdef VK_EXT_display_control
void reservedunmarshal_VkDisplayPowerInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayPowerInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDisplayPowerStateEXT*)&forUnmarshaling->powerState, *ptr, sizeof(VkDisplayPowerStateEXT));
    *ptr += sizeof(VkDisplayPowerStateEXT);
}

void reservedunmarshal_VkDeviceEventInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceEventInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceEventTypeEXT*)&forUnmarshaling->deviceEvent, *ptr, sizeof(VkDeviceEventTypeEXT));
    *ptr += sizeof(VkDeviceEventTypeEXT);
}

void reservedunmarshal_VkDisplayEventInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayEventInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDisplayEventTypeEXT*)&forUnmarshaling->displayEvent, *ptr, sizeof(VkDisplayEventTypeEXT));
    *ptr += sizeof(VkDisplayEventTypeEXT);
}

void reservedunmarshal_VkSwapchainCounterCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSwapchainCounterCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSurfaceCounterFlagsEXT*)&forUnmarshaling->surfaceCounters, *ptr, sizeof(VkSurfaceCounterFlagsEXT));
    *ptr += sizeof(VkSurfaceCounterFlagsEXT);
}

#endif
#ifdef VK_GOOGLE_display_timing
void reservedunmarshal_VkRefreshCycleDurationGOOGLE(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRefreshCycleDurationGOOGLE* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint64_t*)&forUnmarshaling->refreshDuration, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkPastPresentationTimingGOOGLE(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPastPresentationTimingGOOGLE* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->presentID, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint64_t*)&forUnmarshaling->desiredPresentTime, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->actualPresentTime, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->earliestPresentTime, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->presentMargin, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkPresentTimeGOOGLE(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPresentTimeGOOGLE* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->presentID, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint64_t*)&forUnmarshaling->desiredPresentTime, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkPresentTimesInfoGOOGLE(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPresentTimesInfoGOOGLE* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->swapchainCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkPresentTimeGOOGLE**)&forUnmarshaling->pTimes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pTimes);
    *ptr += 8;
    if (forUnmarshaling->pTimes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pTimes, forUnmarshaling->swapchainCount * sizeof(const VkPresentTimeGOOGLE));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->swapchainCount; ++i)
        {
            reservedunmarshal_VkPresentTimeGOOGLE(vkStream, rootType, (VkPresentTimeGOOGLE*)(forUnmarshaling->pTimes + i), ptr);
        }
    }
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void reservedunmarshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->perViewPositionAllComponents, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_viewport_swizzle
void reservedunmarshal_VkViewportSwizzleNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkViewportSwizzleNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->x, *ptr, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
    memcpy((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->y, *ptr, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
    memcpy((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->z, *ptr, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
    memcpy((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->w, *ptr, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
}

void reservedunmarshal_VkPipelineViewportSwizzleStateCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineViewportSwizzleStateCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineViewportSwizzleStateCreateFlagsNV*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV));
    *ptr += sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV);
    memcpy((uint32_t*)&forUnmarshaling->viewportCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkViewportSwizzleNV**)&forUnmarshaling->pViewportSwizzles, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pViewportSwizzles);
    *ptr += 8;
    if (forUnmarshaling->pViewportSwizzles)
    {
        vkStream->alloc((void**)&forUnmarshaling->pViewportSwizzles, forUnmarshaling->viewportCount * sizeof(const VkViewportSwizzleNV));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            reservedunmarshal_VkViewportSwizzleNV(vkStream, rootType, (VkViewportSwizzleNV*)(forUnmarshaling->pViewportSwizzles + i), ptr);
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void reservedunmarshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceDiscardRectanglePropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxDiscardRectangles, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPipelineDiscardRectangleStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineDiscardRectangleStateCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineDiscardRectangleStateCreateFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT));
    *ptr += sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT);
    memcpy((VkDiscardRectangleModeEXT*)&forUnmarshaling->discardRectangleMode, *ptr, sizeof(VkDiscardRectangleModeEXT));
    *ptr += sizeof(VkDiscardRectangleModeEXT);
    memcpy((uint32_t*)&forUnmarshaling->discardRectangleCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkRect2D**)&forUnmarshaling->pDiscardRectangles, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pDiscardRectangles);
    *ptr += 8;
    if (forUnmarshaling->pDiscardRectangles)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDiscardRectangles, forUnmarshaling->discardRectangleCount * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->discardRectangleCount; ++i)
        {
            reservedunmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(forUnmarshaling->pDiscardRectangles + i), ptr);
        }
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void reservedunmarshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceConservativeRasterizationPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((float*)&forUnmarshaling->primitiveOverestimationSize, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxExtraPrimitiveOverestimationSize, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->extraPrimitiveOverestimationSizeGranularity, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((VkBool32*)&forUnmarshaling->primitiveUnderestimation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->conservativePointAndLineRasterization, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->degenerateTrianglesRasterized, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->degenerateLinesRasterized, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fullyCoveredFragmentShaderInputVariable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->conservativeRasterizationPostDepthCoverage, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineRasterizationConservativeStateCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineRasterizationConservativeStateCreateFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT));
    *ptr += sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT);
    memcpy((VkConservativeRasterizationModeEXT*)&forUnmarshaling->conservativeRasterizationMode, *ptr, sizeof(VkConservativeRasterizationModeEXT));
    *ptr += sizeof(VkConservativeRasterizationModeEXT);
    memcpy((float*)&forUnmarshaling->extraPrimitiveOverestimationSize, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

#endif
#ifdef VK_EXT_depth_clip_enable
void reservedunmarshal_VkPhysicalDeviceDepthClipEnableFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceDepthClipEnableFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->depthClipEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPipelineRasterizationDepthClipStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineRasterizationDepthClipStateCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineRasterizationDepthClipStateCreateFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineRasterizationDepthClipStateCreateFlagsEXT));
    *ptr += sizeof(VkPipelineRasterizationDepthClipStateCreateFlagsEXT);
    memcpy((VkBool32*)&forUnmarshaling->depthClipEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void reservedunmarshal_VkXYColorEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkXYColorEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((float*)&forUnmarshaling->x, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->y, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

void reservedunmarshal_VkHdrMetadataEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkHdrMetadataEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkXYColorEXT(vkStream, rootType, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryRed), ptr);
    reservedunmarshal_VkXYColorEXT(vkStream, rootType, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryGreen), ptr);
    reservedunmarshal_VkXYColorEXT(vkStream, rootType, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryBlue), ptr);
    reservedunmarshal_VkXYColorEXT(vkStream, rootType, (VkXYColorEXT*)(&forUnmarshaling->whitePoint), ptr);
    memcpy((float*)&forUnmarshaling->maxLuminance, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->minLuminance, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxContentLightLevel, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxFrameAverageLightLevel, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

#endif
#ifdef VK_MVK_ios_surface
void reservedunmarshal_VkIOSSurfaceCreateInfoMVK(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkIOSSurfaceCreateInfoMVK* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkIOSSurfaceCreateFlagsMVK*)&forUnmarshaling->flags, *ptr, sizeof(VkIOSSurfaceCreateFlagsMVK));
    *ptr += sizeof(VkIOSSurfaceCreateFlagsMVK);
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pView, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pView);
    *ptr += 8;
    if (forUnmarshaling->pView)
    {
        vkStream->alloc((void**)&forUnmarshaling->pView, sizeof(const uint8_t));
        memcpy((void*)forUnmarshaling->pView, *ptr, sizeof(const uint8_t));
        *ptr += sizeof(const uint8_t);
    }
}

#endif
#ifdef VK_MVK_macos_surface
void reservedunmarshal_VkMacOSSurfaceCreateInfoMVK(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMacOSSurfaceCreateInfoMVK* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkMacOSSurfaceCreateFlagsMVK*)&forUnmarshaling->flags, *ptr, sizeof(VkMacOSSurfaceCreateFlagsMVK));
    *ptr += sizeof(VkMacOSSurfaceCreateFlagsMVK);
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pView, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pView);
    *ptr += 8;
    if (forUnmarshaling->pView)
    {
        vkStream->alloc((void**)&forUnmarshaling->pView, sizeof(const uint8_t));
        memcpy((void*)forUnmarshaling->pView, *ptr, sizeof(const uint8_t));
        *ptr += sizeof(const uint8_t);
    }
}

#endif
#ifdef VK_MVK_moltenvk
#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void reservedunmarshal_VkDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDebugUtilsLabelEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pLabelName, ptr);
    memcpy((float*)forUnmarshaling->color, *ptr, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

void reservedunmarshal_VkDebugUtilsObjectNameInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDebugUtilsObjectNameInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkObjectType*)&forUnmarshaling->objectType, *ptr, sizeof(VkObjectType));
    *ptr += sizeof(VkObjectType);
    memcpy((uint64_t*)&forUnmarshaling->objectHandle, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        memcpy((char**)&forUnmarshaling->pObjectName, (*ptr), 8);
        android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pObjectName);
        *ptr += 8;
        if (forUnmarshaling->pObjectName)
        {
            vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pObjectName, ptr);
        }
    }
    else
    {
        vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pObjectName, ptr);
    }
}

void reservedunmarshal_VkDebugUtilsMessengerCallbackDataEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDebugUtilsMessengerCallbackDataEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDebugUtilsMessengerCallbackDataFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        memcpy((char**)&forUnmarshaling->pMessageIdName, (*ptr), 8);
        android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pMessageIdName);
        *ptr += 8;
        if (forUnmarshaling->pMessageIdName)
        {
            vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pMessageIdName, ptr);
        }
    }
    else
    {
        vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pMessageIdName, ptr);
    }
    memcpy((int32_t*)&forUnmarshaling->messageIdNumber, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pMessage, ptr);
    memcpy((uint32_t*)&forUnmarshaling->queueLabelCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkDebugUtilsLabelEXT**)&forUnmarshaling->pQueueLabels, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pQueueLabels);
    *ptr += 8;
    if (forUnmarshaling->pQueueLabels)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueLabels, forUnmarshaling->queueLabelCount * sizeof(VkDebugUtilsLabelEXT));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->queueLabelCount; ++i)
        {
            reservedunmarshal_VkDebugUtilsLabelEXT(vkStream, rootType, (VkDebugUtilsLabelEXT*)(forUnmarshaling->pQueueLabels + i), ptr);
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->cmdBufLabelCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkDebugUtilsLabelEXT**)&forUnmarshaling->pCmdBufLabels, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pCmdBufLabels);
    *ptr += 8;
    if (forUnmarshaling->pCmdBufLabels)
    {
        vkStream->alloc((void**)&forUnmarshaling->pCmdBufLabels, forUnmarshaling->cmdBufLabelCount * sizeof(VkDebugUtilsLabelEXT));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->cmdBufLabelCount; ++i)
        {
            reservedunmarshal_VkDebugUtilsLabelEXT(vkStream, rootType, (VkDebugUtilsLabelEXT*)(forUnmarshaling->pCmdBufLabels + i), ptr);
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->objectCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkDebugUtilsObjectNameInfoEXT**)&forUnmarshaling->pObjects, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pObjects);
    *ptr += 8;
    if (forUnmarshaling->pObjects)
    {
        vkStream->alloc((void**)&forUnmarshaling->pObjects, forUnmarshaling->objectCount * sizeof(VkDebugUtilsObjectNameInfoEXT));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->objectCount; ++i)
        {
            reservedunmarshal_VkDebugUtilsObjectNameInfoEXT(vkStream, rootType, (VkDebugUtilsObjectNameInfoEXT*)(forUnmarshaling->pObjects + i), ptr);
        }
    }
}

void reservedunmarshal_VkDebugUtilsMessengerCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDebugUtilsMessengerCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDebugUtilsMessengerCreateFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkDebugUtilsMessengerCreateFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessengerCreateFlagsEXT);
    memcpy((VkDebugUtilsMessageSeverityFlagsEXT*)&forUnmarshaling->messageSeverity, *ptr, sizeof(VkDebugUtilsMessageSeverityFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessageSeverityFlagsEXT);
    memcpy((VkDebugUtilsMessageTypeFlagsEXT*)&forUnmarshaling->messageType, *ptr, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessageTypeFlagsEXT);
    memcpy((PFN_vkDebugUtilsMessengerCallbackEXT*)&forUnmarshaling->pfnUserCallback, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnUserCallback);
    *ptr += 8;
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pUserData, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pUserData);
    *ptr += 8;
    if (forUnmarshaling->pUserData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
        memcpy((void*)forUnmarshaling->pUserData, *ptr, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

void reservedunmarshal_VkDebugUtilsObjectTagInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDebugUtilsObjectTagInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkObjectType*)&forUnmarshaling->objectType, *ptr, sizeof(VkObjectType));
    *ptr += sizeof(VkObjectType);
    memcpy((uint64_t*)&forUnmarshaling->objectHandle, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->tagName, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((size_t*)&forUnmarshaling->tagSize, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->tagSize);
    *ptr += 8;
    vkStream->alloc((void**)&forUnmarshaling->pTag, forUnmarshaling->tagSize * sizeof(const uint8_t));
    memcpy((void*)forUnmarshaling->pTag, *ptr, forUnmarshaling->tagSize * sizeof(const uint8_t));
    *ptr += forUnmarshaling->tagSize * sizeof(const uint8_t);
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void reservedunmarshal_VkAndroidHardwareBufferUsageANDROID(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAndroidHardwareBufferUsageANDROID* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint64_t*)&forUnmarshaling->androidHardwareBufferUsage, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkAndroidHardwareBufferPropertiesANDROID(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAndroidHardwareBufferPropertiesANDROID* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceSize*)&forUnmarshaling->allocationSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->memoryTypeBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkAndroidHardwareBufferFormatPropertiesANDROID(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAndroidHardwareBufferFormatPropertiesANDROID* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((uint64_t*)&forUnmarshaling->externalFormat, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((VkFormatFeatureFlags*)&forUnmarshaling->formatFeatures, *ptr, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
    reservedunmarshal_VkComponentMapping(vkStream, rootType, (VkComponentMapping*)(&forUnmarshaling->samplerYcbcrConversionComponents), ptr);
    memcpy((VkSamplerYcbcrModelConversion*)&forUnmarshaling->suggestedYcbcrModel, *ptr, sizeof(VkSamplerYcbcrModelConversion));
    *ptr += sizeof(VkSamplerYcbcrModelConversion);
    memcpy((VkSamplerYcbcrRange*)&forUnmarshaling->suggestedYcbcrRange, *ptr, sizeof(VkSamplerYcbcrRange));
    *ptr += sizeof(VkSamplerYcbcrRange);
    memcpy((VkChromaLocation*)&forUnmarshaling->suggestedXChromaOffset, *ptr, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
    memcpy((VkChromaLocation*)&forUnmarshaling->suggestedYChromaOffset, *ptr, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
}

void reservedunmarshal_VkImportAndroidHardwareBufferInfoANDROID(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImportAndroidHardwareBufferInfoANDROID* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    vkStream->alloc((void**)&forUnmarshaling->buffer, sizeof(AHardwareBuffer));
    memcpy((AHardwareBuffer*)forUnmarshaling->buffer, *ptr, sizeof(AHardwareBuffer));
    *ptr += sizeof(AHardwareBuffer);
}

void reservedunmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryGetAndroidHardwareBufferInfoANDROID* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_0));
}

void reservedunmarshal_VkExternalFormatANDROID(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkExternalFormatANDROID* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint64_t*)&forUnmarshaling->externalFormat, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_inline_uniform_block
void reservedunmarshal_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceInlineUniformBlockFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->inlineUniformBlock, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingInlineUniformBlockUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceInlineUniformBlockPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxInlineUniformBlockSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorInlineUniformBlocks, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetInlineUniformBlocks, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindInlineUniformBlocks, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkWriteDescriptorSetInlineUniformBlockEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkWriteDescriptorSetInlineUniformBlockEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->dataSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pData, forUnmarshaling->dataSize * sizeof(const uint8_t));
    memcpy((void*)forUnmarshaling->pData, *ptr, forUnmarshaling->dataSize * sizeof(const uint8_t));
    *ptr += forUnmarshaling->dataSize * sizeof(const uint8_t);
}

void reservedunmarshal_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDescriptorPoolInlineUniformBlockCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxInlineUniformBlockBindings, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void reservedunmarshal_VkSampleLocationEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSampleLocationEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((float*)&forUnmarshaling->x, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->y, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

void reservedunmarshal_VkSampleLocationsInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSampleLocationsInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->sampleLocationsPerPixel, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->sampleLocationGridSize), ptr);
    memcpy((uint32_t*)&forUnmarshaling->sampleLocationsCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSampleLocations, forUnmarshaling->sampleLocationsCount * sizeof(const VkSampleLocationEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->sampleLocationsCount; ++i)
    {
        reservedunmarshal_VkSampleLocationEXT(vkStream, rootType, (VkSampleLocationEXT*)(forUnmarshaling->pSampleLocations + i), ptr);
    }
}

void reservedunmarshal_VkAttachmentSampleLocationsEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAttachmentSampleLocationsEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->attachmentIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkSampleLocationsInfoEXT(vkStream, rootType, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo), ptr);
}

void reservedunmarshal_VkSubpassSampleLocationsEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSubpassSampleLocationsEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->subpassIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkSampleLocationsInfoEXT(vkStream, rootType, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo), ptr);
}

void reservedunmarshal_VkRenderPassSampleLocationsBeginInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRenderPassSampleLocationsBeginInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->attachmentInitialSampleLocationsCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAttachmentInitialSampleLocations, forUnmarshaling->attachmentInitialSampleLocationsCount * sizeof(const VkAttachmentSampleLocationsEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentInitialSampleLocationsCount; ++i)
    {
        reservedunmarshal_VkAttachmentSampleLocationsEXT(vkStream, rootType, (VkAttachmentSampleLocationsEXT*)(forUnmarshaling->pAttachmentInitialSampleLocations + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->postSubpassSampleLocationsCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPostSubpassSampleLocations, forUnmarshaling->postSubpassSampleLocationsCount * sizeof(const VkSubpassSampleLocationsEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->postSubpassSampleLocationsCount; ++i)
    {
        reservedunmarshal_VkSubpassSampleLocationsEXT(vkStream, rootType, (VkSubpassSampleLocationsEXT*)(forUnmarshaling->pPostSubpassSampleLocations + i), ptr);
    }
}

void reservedunmarshal_VkPipelineSampleLocationsStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineSampleLocationsStateCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->sampleLocationsEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    reservedunmarshal_VkSampleLocationsInfoEXT(vkStream, rootType, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo), ptr);
}

void reservedunmarshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceSampleLocationsPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSampleCountFlags*)&forUnmarshaling->sampleLocationSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->maxSampleLocationGridSize), ptr);
    memcpy((float*)forUnmarshaling->sampleLocationCoordinateRange, *ptr, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy((uint32_t*)&forUnmarshaling->sampleLocationSubPixelBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->variableSampleLocations, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkMultisamplePropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMultisamplePropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->maxSampleLocationGridSize), ptr);
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void reservedunmarshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->advancedBlendCoherentOperations, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->advancedBlendMaxColorAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->advancedBlendIndependentBlend, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->advancedBlendNonPremultipliedSrcColor, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->advancedBlendNonPremultipliedDstColor, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->advancedBlendCorrelatedOverlap, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->advancedBlendAllOperations, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineColorBlendAdvancedStateCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->srcPremultiplied, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->dstPremultiplied, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBlendOverlapEXT*)&forUnmarshaling->blendOverlap, *ptr, sizeof(VkBlendOverlapEXT));
    *ptr += sizeof(VkBlendOverlapEXT);
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void reservedunmarshal_VkPipelineCoverageToColorStateCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineCoverageToColorStateCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineCoverageToColorStateCreateFlagsNV*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineCoverageToColorStateCreateFlagsNV));
    *ptr += sizeof(VkPipelineCoverageToColorStateCreateFlagsNV);
    memcpy((VkBool32*)&forUnmarshaling->coverageToColorEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->coverageToColorLocation, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void reservedunmarshal_VkPipelineCoverageModulationStateCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineCoverageModulationStateCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineCoverageModulationStateCreateFlagsNV*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineCoverageModulationStateCreateFlagsNV));
    *ptr += sizeof(VkPipelineCoverageModulationStateCreateFlagsNV);
    memcpy((VkCoverageModulationModeNV*)&forUnmarshaling->coverageModulationMode, *ptr, sizeof(VkCoverageModulationModeNV));
    *ptr += sizeof(VkCoverageModulationModeNV);
    memcpy((VkBool32*)&forUnmarshaling->coverageModulationTableEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->coverageModulationTableCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((float**)&forUnmarshaling->pCoverageModulationTable, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pCoverageModulationTable);
    *ptr += 8;
    if (forUnmarshaling->pCoverageModulationTable)
    {
        vkStream->alloc((void**)&forUnmarshaling->pCoverageModulationTable, forUnmarshaling->coverageModulationTableCount * sizeof(const float));
        memcpy((float*)forUnmarshaling->pCoverageModulationTable, *ptr, forUnmarshaling->coverageModulationTableCount * sizeof(const float));
        *ptr += forUnmarshaling->coverageModulationTableCount * sizeof(const float);
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_NV_shader_sm_builtins
void reservedunmarshal_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->shaderSMCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->shaderWarpsPerSM, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderSMBuiltins, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_image_drm_format_modifier
void reservedunmarshal_VkDrmFormatModifierPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDrmFormatModifierPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint64_t*)&forUnmarshaling->drmFormatModifier, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint32_t*)&forUnmarshaling->drmFormatModifierPlaneCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkFormatFeatureFlags*)&forUnmarshaling->drmFormatModifierTilingFeatures, *ptr, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
}

void reservedunmarshal_VkDrmFormatModifierPropertiesListEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDrmFormatModifierPropertiesListEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->drmFormatModifierCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkDrmFormatModifierPropertiesEXT**)&forUnmarshaling->pDrmFormatModifierProperties, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pDrmFormatModifierProperties);
    *ptr += 8;
    if (forUnmarshaling->pDrmFormatModifierProperties)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDrmFormatModifierProperties, forUnmarshaling->drmFormatModifierCount * sizeof(VkDrmFormatModifierPropertiesEXT));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->drmFormatModifierCount; ++i)
        {
            reservedunmarshal_VkDrmFormatModifierPropertiesEXT(vkStream, rootType, (VkDrmFormatModifierPropertiesEXT*)(forUnmarshaling->pDrmFormatModifierProperties + i), ptr);
        }
    }
}

void reservedunmarshal_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceImageDrmFormatModifierInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint64_t*)&forUnmarshaling->drmFormatModifier, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((VkSharingMode*)&forUnmarshaling->sharingMode, *ptr, sizeof(VkSharingMode));
    *ptr += sizeof(VkSharingMode);
    memcpy((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((uint32_t**)&forUnmarshaling->pQueueFamilyIndices, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pQueueFamilyIndices);
    *ptr += 8;
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        memcpy((uint32_t*)forUnmarshaling->pQueueFamilyIndices, *ptr, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        *ptr += forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t);
    }
}

void reservedunmarshal_VkImageDrmFormatModifierListCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageDrmFormatModifierListCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->drmFormatModifierCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDrmFormatModifiers, forUnmarshaling->drmFormatModifierCount * sizeof(const uint64_t));
    memcpy((uint64_t*)forUnmarshaling->pDrmFormatModifiers, *ptr, forUnmarshaling->drmFormatModifierCount * sizeof(const uint64_t));
    *ptr += forUnmarshaling->drmFormatModifierCount * sizeof(const uint64_t);
}

void reservedunmarshal_VkImageDrmFormatModifierExplicitCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageDrmFormatModifierExplicitCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint64_t*)&forUnmarshaling->drmFormatModifier, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint32_t*)&forUnmarshaling->drmFormatModifierPlaneCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPlaneLayouts, forUnmarshaling->drmFormatModifierPlaneCount * sizeof(const VkSubresourceLayout));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->drmFormatModifierPlaneCount; ++i)
    {
        reservedunmarshal_VkSubresourceLayout(vkStream, rootType, (VkSubresourceLayout*)(forUnmarshaling->pPlaneLayouts + i), ptr);
    }
}

void reservedunmarshal_VkImageDrmFormatModifierPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImageDrmFormatModifierPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint64_t*)&forUnmarshaling->drmFormatModifier, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

#endif
#ifdef VK_EXT_validation_cache
void reservedunmarshal_VkValidationCacheCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkValidationCacheCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkValidationCacheCreateFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkValidationCacheCreateFlagsEXT));
    *ptr += sizeof(VkValidationCacheCreateFlagsEXT);
    memcpy((size_t*)&forUnmarshaling->initialDataSize, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->initialDataSize);
    *ptr += 8;
    vkStream->alloc((void**)&forUnmarshaling->pInitialData, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
    memcpy((void*)forUnmarshaling->pInitialData, *ptr, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
    *ptr += forUnmarshaling->initialDataSize * sizeof(const uint8_t);
}

void reservedunmarshal_VkShaderModuleValidationCacheCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkShaderModuleValidationCacheCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkValidationCacheEXT*)&forUnmarshaling->validationCache = (VkValidationCacheEXT)unbox_VkValidationCacheEXT((VkValidationCacheEXT)(*&cgen_var_0));
}

#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_NV_shading_rate_image
void reservedunmarshal_VkShadingRatePaletteNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkShadingRatePaletteNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->shadingRatePaletteEntryCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pShadingRatePaletteEntries, forUnmarshaling->shadingRatePaletteEntryCount * sizeof(const VkShadingRatePaletteEntryNV));
    memcpy((VkShadingRatePaletteEntryNV*)forUnmarshaling->pShadingRatePaletteEntries, *ptr, forUnmarshaling->shadingRatePaletteEntryCount * sizeof(const VkShadingRatePaletteEntryNV));
    *ptr += forUnmarshaling->shadingRatePaletteEntryCount * sizeof(const VkShadingRatePaletteEntryNV);
}

void reservedunmarshal_VkPipelineViewportShadingRateImageStateCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineViewportShadingRateImageStateCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shadingRateImageEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->viewportCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkShadingRatePaletteNV**)&forUnmarshaling->pShadingRatePalettes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pShadingRatePalettes);
    *ptr += 8;
    if (forUnmarshaling->pShadingRatePalettes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pShadingRatePalettes, forUnmarshaling->viewportCount * sizeof(const VkShadingRatePaletteNV));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            reservedunmarshal_VkShadingRatePaletteNV(vkStream, rootType, (VkShadingRatePaletteNV*)(forUnmarshaling->pShadingRatePalettes + i), ptr);
        }
    }
}

void reservedunmarshal_VkPhysicalDeviceShadingRateImageFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShadingRateImageFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shadingRateImage, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shadingRateCoarseSampleOrder, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceShadingRateImagePropertiesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShadingRateImagePropertiesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->shadingRateTexelSize), ptr);
    memcpy((uint32_t*)&forUnmarshaling->shadingRatePaletteSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->shadingRateMaxCoarseSamples, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkCoarseSampleLocationNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCoarseSampleLocationNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->pixelX, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->pixelY, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->sample, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkCoarseSampleOrderCustomNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCoarseSampleOrderCustomNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkShadingRatePaletteEntryNV*)&forUnmarshaling->shadingRate, *ptr, sizeof(VkShadingRatePaletteEntryNV));
    *ptr += sizeof(VkShadingRatePaletteEntryNV);
    memcpy((uint32_t*)&forUnmarshaling->sampleCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->sampleLocationCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSampleLocations, forUnmarshaling->sampleLocationCount * sizeof(const VkCoarseSampleLocationNV));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->sampleLocationCount; ++i)
    {
        reservedunmarshal_VkCoarseSampleLocationNV(vkStream, rootType, (VkCoarseSampleLocationNV*)(forUnmarshaling->pSampleLocations + i), ptr);
    }
}

void reservedunmarshal_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkCoarseSampleOrderTypeNV*)&forUnmarshaling->sampleOrderType, *ptr, sizeof(VkCoarseSampleOrderTypeNV));
    *ptr += sizeof(VkCoarseSampleOrderTypeNV);
    memcpy((uint32_t*)&forUnmarshaling->customSampleOrderCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pCustomSampleOrders, forUnmarshaling->customSampleOrderCount * sizeof(const VkCoarseSampleOrderCustomNV));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->customSampleOrderCount; ++i)
    {
        reservedunmarshal_VkCoarseSampleOrderCustomNV(vkStream, rootType, (VkCoarseSampleOrderCustomNV*)(forUnmarshaling->pCustomSampleOrders + i), ptr);
    }
}

#endif
#ifdef VK_NV_ray_tracing
void reservedunmarshal_VkRayTracingShaderGroupCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRayTracingShaderGroupCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkRayTracingShaderGroupTypeKHR*)&forUnmarshaling->type, *ptr, sizeof(VkRayTracingShaderGroupTypeKHR));
    *ptr += sizeof(VkRayTracingShaderGroupTypeKHR);
    memcpy((uint32_t*)&forUnmarshaling->generalShader, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->closestHitShader, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->anyHitShader, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->intersectionShader, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkRayTracingPipelineCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRayTracingPipelineCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineCreateFlags));
    *ptr += sizeof(VkPipelineCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->stageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pStages, forUnmarshaling->stageCount * sizeof(const VkPipelineShaderStageCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->stageCount; ++i)
    {
        reservedunmarshal_VkPipelineShaderStageCreateInfo(vkStream, rootType, (VkPipelineShaderStageCreateInfo*)(forUnmarshaling->pStages + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->groupCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pGroups, forUnmarshaling->groupCount * sizeof(const VkRayTracingShaderGroupCreateInfoNV));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->groupCount; ++i)
    {
        reservedunmarshal_VkRayTracingShaderGroupCreateInfoNV(vkStream, rootType, (VkRayTracingShaderGroupCreateInfoNV*)(forUnmarshaling->pGroups + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxRecursionDepth, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipelineLayout*)&forUnmarshaling->layout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipeline*)&forUnmarshaling->basePipelineHandle = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_1));
    memcpy((int32_t*)&forUnmarshaling->basePipelineIndex, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedunmarshal_VkGeometryTrianglesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkGeometryTrianglesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->vertexData = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->vertexOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->vertexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDeviceSize*)&forUnmarshaling->vertexStride, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkFormat*)&forUnmarshaling->vertexFormat, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->indexData = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
    memcpy((VkDeviceSize*)&forUnmarshaling->indexOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->indexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkIndexType*)&forUnmarshaling->indexType, *ptr, sizeof(VkIndexType));
    *ptr += sizeof(VkIndexType);
    uint64_t cgen_var_2;
    memcpy((uint64_t*)&cgen_var_2, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->transformData = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_2));
    memcpy((VkDeviceSize*)&forUnmarshaling->transformOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkGeometryAABBNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkGeometryAABBNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->aabbData = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->numAABBs, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->stride, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkGeometryDataNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkGeometryDataNV* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkGeometryTrianglesNV(vkStream, rootType, (VkGeometryTrianglesNV*)(&forUnmarshaling->triangles), ptr);
    reservedunmarshal_VkGeometryAABBNV(vkStream, rootType, (VkGeometryAABBNV*)(&forUnmarshaling->aabbs), ptr);
}

void reservedunmarshal_VkGeometryNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkGeometryNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkGeometryTypeKHR*)&forUnmarshaling->geometryType, *ptr, sizeof(VkGeometryTypeKHR));
    *ptr += sizeof(VkGeometryTypeKHR);
    reservedunmarshal_VkGeometryDataNV(vkStream, rootType, (VkGeometryDataNV*)(&forUnmarshaling->geometry), ptr);
    memcpy((VkGeometryFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkGeometryFlagsKHR));
    *ptr += sizeof(VkGeometryFlagsKHR);
}

void reservedunmarshal_VkAccelerationStructureInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAccelerationStructureTypeNV*)&forUnmarshaling->type, *ptr, sizeof(VkAccelerationStructureTypeNV));
    *ptr += sizeof(VkAccelerationStructureTypeNV);
    memcpy((VkBuildAccelerationStructureFlagsNV*)&forUnmarshaling->flags, *ptr, sizeof(VkBuildAccelerationStructureFlagsNV));
    *ptr += sizeof(VkBuildAccelerationStructureFlagsNV);
    memcpy((uint32_t*)&forUnmarshaling->instanceCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->geometryCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pGeometries, forUnmarshaling->geometryCount * sizeof(const VkGeometryNV));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->geometryCount; ++i)
    {
        reservedunmarshal_VkGeometryNV(vkStream, rootType, (VkGeometryNV*)(forUnmarshaling->pGeometries + i), ptr);
    }
}

void reservedunmarshal_VkAccelerationStructureCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceSize*)&forUnmarshaling->compactedSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    reservedunmarshal_VkAccelerationStructureInfoNV(vkStream, rootType, (VkAccelerationStructureInfoNV*)(&forUnmarshaling->info), ptr);
}

void reservedunmarshal_VkBindAccelerationStructureMemoryInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBindAccelerationStructureMemoryInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkAccelerationStructureNV*)&forUnmarshaling->accelerationStructure = (VkAccelerationStructureNV)unbox_VkAccelerationStructureNV((VkAccelerationStructureNV)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_1));
    memcpy((VkDeviceSize*)&forUnmarshaling->memoryOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->deviceIndexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pDeviceIndices, *ptr, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->deviceIndexCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkWriteDescriptorSetAccelerationStructureNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkWriteDescriptorSetAccelerationStructureNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->accelerationStructureCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkAccelerationStructureNV**)&forUnmarshaling->pAccelerationStructures, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pAccelerationStructures);
    *ptr += 8;
    if (forUnmarshaling->pAccelerationStructures)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAccelerationStructures, forUnmarshaling->accelerationStructureCount * sizeof(const VkAccelerationStructureNV));
        if (forUnmarshaling->accelerationStructureCount)
        {
            uint8_t* cgen_var_0_0_ptr = (uint8_t*)(*ptr);
            *ptr += 8 * forUnmarshaling->accelerationStructureCount;
            if (forUnmarshaling)
            {
                for (uint32_t k = 0; k < forUnmarshaling->accelerationStructureCount; ++k)
                {
                    uint64_t tmpval; memcpy(&tmpval, cgen_var_0_0_ptr + k * 8, sizeof(uint64_t));
                    *(((VkAccelerationStructureNV*)forUnmarshaling->pAccelerationStructures) + k) = (VkAccelerationStructureNV)unbox_VkAccelerationStructureNV((VkAccelerationStructureNV)tmpval);
                }
            }
        }
    }
}

void reservedunmarshal_VkAccelerationStructureMemoryRequirementsInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureMemoryRequirementsInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAccelerationStructureMemoryRequirementsTypeNV*)&forUnmarshaling->type, *ptr, sizeof(VkAccelerationStructureMemoryRequirementsTypeNV));
    *ptr += sizeof(VkAccelerationStructureMemoryRequirementsTypeNV);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkAccelerationStructureNV*)&forUnmarshaling->accelerationStructure = (VkAccelerationStructureNV)unbox_VkAccelerationStructureNV((VkAccelerationStructureNV)(*&cgen_var_0));
}

void reservedunmarshal_VkPhysicalDeviceRayTracingPropertiesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceRayTracingPropertiesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->shaderGroupHandleSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxRecursionDepth, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxShaderGroupStride, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->shaderGroupBaseAlignment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint64_t*)&forUnmarshaling->maxGeometryCount, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->maxInstanceCount, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->maxTriangleCount, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetAccelerationStructures, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkTransformMatrixKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkTransformMatrixKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((float*)forUnmarshaling->matrix, *ptr, ((3)*(4)) * sizeof(float));
    *ptr += ((3)*(4)) * sizeof(float);
}

void reservedunmarshal_VkAabbPositionsKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAabbPositionsKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((float*)&forUnmarshaling->minX, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->minY, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->minZ, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxX, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxY, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxZ, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

void reservedunmarshal_VkAccelerationStructureInstanceKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureInstanceKHR* forUnmarshaling,
    uint8_t** ptr)
{
    
    typedef struct VkAccelerationStructureInstanceKHRWithoutBitFields {
        VkTransformMatrixKHR          transform;
        uint32_t                      dwords[2];
        uint64_t                      accelerationStructureReference;
    } VkAccelerationStructureInstanceKHRWithoutBitFields;
    
    VkAccelerationStructureInstanceKHRWithoutBitFields* forUnmarshaling_new = (VkAccelerationStructureInstanceKHRWithoutBitFields*)(forUnmarshaling);
    reservedunmarshal_VkTransformMatrixKHR(vkStream, rootType, (VkTransformMatrixKHR*)(&forUnmarshaling_new->transform), ptr);
    for (uint32_t i = 0; i < 2; i++) {
        memcpy((uint32_t*)&(forUnmarshaling_new->dwords[i]), *ptr, sizeof(uint32_t));
        *ptr += sizeof(uint32_t);
    }
    memcpy((uint64_t*)&forUnmarshaling_new->accelerationStructureReference, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    
}

#endif
#ifdef VK_NV_representative_fragment_test
void reservedunmarshal_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->representativeFragmentTest, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineRepresentativeFragmentTestStateCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->representativeFragmentTestEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_filter_cubic
void reservedunmarshal_VkPhysicalDeviceImageViewImageFormatInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceImageViewImageFormatInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageViewType*)&forUnmarshaling->imageViewType, *ptr, sizeof(VkImageViewType));
    *ptr += sizeof(VkImageViewType);
}

void reservedunmarshal_VkFilterCubicImageViewImageFormatPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkFilterCubicImageViewImageFormatPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->filterCubic, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->filterCubicMinmax, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_QCOM_render_pass_shader_resolve
#endif
#ifdef VK_EXT_global_priority
void reservedunmarshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceQueueGlobalPriorityCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkQueueGlobalPriorityEXT*)&forUnmarshaling->globalPriority, *ptr, sizeof(VkQueueGlobalPriorityEXT));
    *ptr += sizeof(VkQueueGlobalPriorityEXT);
}

#endif
#ifdef VK_EXT_external_memory_host
void reservedunmarshal_VkImportMemoryHostPointerInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImportMemoryHostPointerInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pHostPointer, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pHostPointer);
    *ptr += 8;
    if (forUnmarshaling->pHostPointer)
    {
        vkStream->alloc((void**)&forUnmarshaling->pHostPointer, sizeof(uint8_t));
        memcpy((void*)forUnmarshaling->pHostPointer, *ptr, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

void reservedunmarshal_VkMemoryHostPointerPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryHostPointerPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->memoryTypeBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceExternalMemoryHostPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceSize*)&forUnmarshaling->minImportedHostPointerAlignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

#endif
#ifdef VK_AMD_buffer_marker
#endif
#ifdef VK_AMD_pipeline_compiler_control
void reservedunmarshal_VkPipelineCompilerControlCreateInfoAMD(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineCompilerControlCreateInfoAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineCompilerControlFlagsAMD*)&forUnmarshaling->compilerControlFlags, *ptr, sizeof(VkPipelineCompilerControlFlagsAMD));
    *ptr += sizeof(VkPipelineCompilerControlFlagsAMD);
}

#endif
#ifdef VK_EXT_calibrated_timestamps
void reservedunmarshal_VkCalibratedTimestampInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCalibratedTimestampInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkTimeDomainEXT*)&forUnmarshaling->timeDomain, *ptr, sizeof(VkTimeDomainEXT));
    *ptr += sizeof(VkTimeDomainEXT);
}

#endif
#ifdef VK_AMD_shader_core_properties
void reservedunmarshal_VkPhysicalDeviceShaderCorePropertiesAMD(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderCorePropertiesAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->shaderEngineCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->shaderArraysPerEngineCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->computeUnitsPerShaderArray, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->simdPerComputeUnit, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->wavefrontsPerSimd, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->wavefrontSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->sgprsPerSimd, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->minSgprAllocation, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxSgprAllocation, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->sgprAllocationGranularity, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->vgprsPerSimd, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->minVgprAllocation, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxVgprAllocation, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->vgprAllocationGranularity, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_memory_overallocation_behavior
void reservedunmarshal_VkDeviceMemoryOverallocationCreateInfoAMD(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceMemoryOverallocationCreateInfoAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkMemoryOverallocationBehaviorAMD*)&forUnmarshaling->overallocationBehavior, *ptr, sizeof(VkMemoryOverallocationBehaviorAMD));
    *ptr += sizeof(VkMemoryOverallocationBehaviorAMD);
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void reservedunmarshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxVertexAttribDivisor, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkVertexInputBindingDivisorDescriptionEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkVertexInputBindingDivisorDescriptionEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->binding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->divisor, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineVertexInputDivisorStateCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->vertexBindingDivisorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pVertexBindingDivisors, forUnmarshaling->vertexBindingDivisorCount * sizeof(const VkVertexInputBindingDivisorDescriptionEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexBindingDivisorCount; ++i)
    {
        reservedunmarshal_VkVertexInputBindingDivisorDescriptionEXT(vkStream, rootType, (VkVertexInputBindingDivisorDescriptionEXT*)(forUnmarshaling->pVertexBindingDivisors + i), ptr);
    }
}

void reservedunmarshal_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->vertexAttributeInstanceRateDivisor, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->vertexAttributeInstanceRateZeroDivisor, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_GGP_frame_token
void reservedunmarshal_VkPresentFrameTokenGGP(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPresentFrameTokenGGP* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((GgpFrameToken*)&forUnmarshaling->frameToken, *ptr, sizeof(GgpFrameToken));
    *ptr += sizeof(GgpFrameToken);
}

#endif
#ifdef VK_EXT_pipeline_creation_feedback
void reservedunmarshal_VkPipelineCreationFeedbackEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineCreationFeedbackEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkPipelineCreationFeedbackFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineCreationFeedbackFlagsEXT));
    *ptr += sizeof(VkPipelineCreationFeedbackFlagsEXT);
    memcpy((uint64_t*)&forUnmarshaling->duration, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkPipelineCreationFeedbackCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineCreationFeedbackCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    vkStream->alloc((void**)&forUnmarshaling->pPipelineCreationFeedback, sizeof(VkPipelineCreationFeedbackEXT));
    reservedunmarshal_VkPipelineCreationFeedbackEXT(vkStream, rootType, (VkPipelineCreationFeedbackEXT*)(forUnmarshaling->pPipelineCreationFeedback), ptr);
    memcpy((uint32_t*)&forUnmarshaling->pipelineStageCreationFeedbackCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPipelineStageCreationFeedbacks, forUnmarshaling->pipelineStageCreationFeedbackCount * sizeof(VkPipelineCreationFeedbackEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->pipelineStageCreationFeedbackCount; ++i)
    {
        reservedunmarshal_VkPipelineCreationFeedbackEXT(vkStream, rootType, (VkPipelineCreationFeedbackEXT*)(forUnmarshaling->pPipelineStageCreationFeedbacks + i), ptr);
    }
}

#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_compute_shader_derivatives
void reservedunmarshal_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->computeDerivativeGroupQuads, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->computeDerivativeGroupLinear, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_mesh_shader
void reservedunmarshal_VkPhysicalDeviceMeshShaderFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceMeshShaderFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->taskShader, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->meshShader, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceMeshShaderPropertiesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceMeshShaderPropertiesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxDrawMeshTasksCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTaskWorkGroupInvocations, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)forUnmarshaling->maxTaskWorkGroupSize, *ptr, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTaskTotalMemorySize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTaskOutputCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxMeshWorkGroupInvocations, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)forUnmarshaling->maxMeshWorkGroupSize, *ptr, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxMeshTotalMemorySize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxMeshOutputVertices, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxMeshOutputPrimitives, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxMeshMultiviewViewCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->meshOutputPerVertexGranularity, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->meshOutputPerPrimitiveGranularity, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDrawMeshTasksIndirectCommandNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDrawMeshTasksIndirectCommandNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->taskCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->firstTask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_NV_fragment_shader_barycentric
void reservedunmarshal_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->fragmentShaderBarycentric, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_shader_image_footprint
void reservedunmarshal_VkPhysicalDeviceShaderImageFootprintFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderImageFootprintFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->imageFootprint, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_scissor_exclusive
void reservedunmarshal_VkPipelineViewportExclusiveScissorStateCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineViewportExclusiveScissorStateCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->exclusiveScissorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkRect2D**)&forUnmarshaling->pExclusiveScissors, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pExclusiveScissors);
    *ptr += 8;
    if (forUnmarshaling->pExclusiveScissors)
    {
        vkStream->alloc((void**)&forUnmarshaling->pExclusiveScissors, forUnmarshaling->exclusiveScissorCount * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->exclusiveScissorCount; ++i)
        {
            reservedunmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(forUnmarshaling->pExclusiveScissors + i), ptr);
        }
    }
}

void reservedunmarshal_VkPhysicalDeviceExclusiveScissorFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceExclusiveScissorFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->exclusiveScissor, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void reservedunmarshal_VkQueueFamilyCheckpointPropertiesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkQueueFamilyCheckpointPropertiesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineStageFlags*)&forUnmarshaling->checkpointExecutionStageMask, *ptr, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
}

void reservedunmarshal_VkCheckpointDataNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCheckpointDataNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineStageFlagBits*)&forUnmarshaling->stage, *ptr, sizeof(VkPipelineStageFlagBits));
    *ptr += sizeof(VkPipelineStageFlagBits);
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pCheckpointMarker, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pCheckpointMarker);
    *ptr += 8;
    if (forUnmarshaling->pCheckpointMarker)
    {
        vkStream->alloc((void**)&forUnmarshaling->pCheckpointMarker, sizeof(uint8_t));
        memcpy((void*)forUnmarshaling->pCheckpointMarker, *ptr, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_INTEL_shader_integer_functions2
void reservedunmarshal_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderIntegerFunctions2, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_INTEL_performance_query
void reservedunmarshal_VkPerformanceValueDataINTEL(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPerformanceValueDataINTEL* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->value32, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPerformanceValueINTEL(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPerformanceValueINTEL* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkPerformanceValueTypeINTEL*)&forUnmarshaling->type, *ptr, sizeof(VkPerformanceValueTypeINTEL));
    *ptr += sizeof(VkPerformanceValueTypeINTEL);
    reservedunmarshal_VkPerformanceValueDataINTEL(vkStream, rootType, (VkPerformanceValueDataINTEL*)(&forUnmarshaling->data), ptr);
}

void reservedunmarshal_VkInitializePerformanceApiInfoINTEL(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkInitializePerformanceApiInfoINTEL* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pUserData, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pUserData);
    *ptr += 8;
    if (forUnmarshaling->pUserData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
        memcpy((void*)forUnmarshaling->pUserData, *ptr, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

void reservedunmarshal_VkQueryPoolPerformanceQueryCreateInfoINTEL(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkQueryPoolPerformanceQueryCreateInfoINTEL* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkQueryPoolSamplingModeINTEL*)&forUnmarshaling->performanceCountersSampling, *ptr, sizeof(VkQueryPoolSamplingModeINTEL));
    *ptr += sizeof(VkQueryPoolSamplingModeINTEL);
}

void reservedunmarshal_VkPerformanceMarkerInfoINTEL(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPerformanceMarkerInfoINTEL* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint64_t*)&forUnmarshaling->marker, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkPerformanceStreamMarkerInfoINTEL(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPerformanceStreamMarkerInfoINTEL* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->marker, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPerformanceOverrideInfoINTEL(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPerformanceOverrideInfoINTEL* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPerformanceOverrideTypeINTEL*)&forUnmarshaling->type, *ptr, sizeof(VkPerformanceOverrideTypeINTEL));
    *ptr += sizeof(VkPerformanceOverrideTypeINTEL);
    memcpy((VkBool32*)&forUnmarshaling->enable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint64_t*)&forUnmarshaling->parameter, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkPerformanceConfigurationAcquireInfoINTEL(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPerformanceConfigurationAcquireInfoINTEL* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPerformanceConfigurationTypeINTEL*)&forUnmarshaling->type, *ptr, sizeof(VkPerformanceConfigurationTypeINTEL));
    *ptr += sizeof(VkPerformanceConfigurationTypeINTEL);
}

#endif
#ifdef VK_EXT_pci_bus_info
void reservedunmarshal_VkPhysicalDevicePCIBusInfoPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDevicePCIBusInfoPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->pciDomain, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->pciBus, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->pciDevice, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->pciFunction, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_display_native_hdr
void reservedunmarshal_VkDisplayNativeHdrSurfaceCapabilitiesAMD(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDisplayNativeHdrSurfaceCapabilitiesAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->localDimmingSupport, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkSwapchainDisplayNativeHdrCreateInfoAMD(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSwapchainDisplayNativeHdrCreateInfoAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->localDimmingEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_FUCHSIA_imagepipe_surface
void reservedunmarshal_VkImagePipeSurfaceCreateInfoFUCHSIA(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImagePipeSurfaceCreateInfoFUCHSIA* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImagePipeSurfaceCreateFlagsFUCHSIA*)&forUnmarshaling->flags, *ptr, sizeof(VkImagePipeSurfaceCreateFlagsFUCHSIA));
    *ptr += sizeof(VkImagePipeSurfaceCreateFlagsFUCHSIA);
    memcpy((zx_handle_t*)&forUnmarshaling->imagePipeHandle, *ptr, sizeof(zx_handle_t));
    *ptr += sizeof(zx_handle_t);
}

#endif
#ifdef VK_EXT_metal_surface
void reservedunmarshal_VkMetalSurfaceCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMetalSurfaceCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkMetalSurfaceCreateFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkMetalSurfaceCreateFlagsEXT));
    *ptr += sizeof(VkMetalSurfaceCreateFlagsEXT);
    // WARNING PTR CHECK
    memcpy((CAMetalLayer**)&forUnmarshaling->pLayer, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pLayer);
    *ptr += 8;
    if (forUnmarshaling->pLayer)
    {
        vkStream->alloc((void**)&forUnmarshaling->pLayer, sizeof(const CAMetalLayer));
        memcpy((CAMetalLayer*)forUnmarshaling->pLayer, *ptr, sizeof(const CAMetalLayer));
        *ptr += sizeof(const CAMetalLayer);
    }
}

#endif
#ifdef VK_EXT_fragment_density_map
void reservedunmarshal_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceFragmentDensityMapFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    forUnmarshaling->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->fragmentDensityMap, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fragmentDensityMapDynamic, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fragmentDensityMapNonSubsampledImages, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceFragmentDensityMapPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    forUnmarshaling->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT;
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->minFragmentDensityTexelSize), ptr);
    reservedunmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forUnmarshaling->maxFragmentDensityTexelSize), ptr);
    memcpy((VkBool32*)&forUnmarshaling->fragmentDensityInvocations, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkRenderPassFragmentDensityMapCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRenderPassFragmentDensityMapCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    forUnmarshaling->sType = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT;
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkAttachmentReference(vkStream, rootType, (VkAttachmentReference*)(&forUnmarshaling->fragmentDensityMapAttachment), ptr);
}

#endif
#ifdef VK_EXT_scalar_block_layout
#endif
#ifdef VK_GOOGLE_hlsl_functionality1
#endif
#ifdef VK_GOOGLE_decorate_string
#endif
#ifdef VK_EXT_subgroup_size_control
void reservedunmarshal_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceSubgroupSizeControlFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->subgroupSizeControl, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->computeFullSubgroups, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceSubgroupSizeControlPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->minSubgroupSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxSubgroupSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxComputeWorkgroupSubgroups, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkShaderStageFlags*)&forUnmarshaling->requiredSubgroupSizeStages, *ptr, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
}

void reservedunmarshal_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->requiredSubgroupSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_shader_core_properties2
void reservedunmarshal_VkPhysicalDeviceShaderCoreProperties2AMD(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderCoreProperties2AMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkShaderCorePropertiesFlagsAMD*)&forUnmarshaling->shaderCoreFeatures, *ptr, sizeof(VkShaderCorePropertiesFlagsAMD));
    *ptr += sizeof(VkShaderCorePropertiesFlagsAMD);
    memcpy((uint32_t*)&forUnmarshaling->activeComputeUnitCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_device_coherent_memory
void reservedunmarshal_VkPhysicalDeviceCoherentMemoryFeaturesAMD(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceCoherentMemoryFeaturesAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->deviceCoherentMemory, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_shader_image_atomic_int64
void reservedunmarshal_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderImageInt64Atomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseImageInt64Atomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_memory_budget
void reservedunmarshal_VkPhysicalDeviceMemoryBudgetPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceMemoryBudgetPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceSize*)forUnmarshaling->heapBudget, *ptr, VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize));
    *ptr += VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)forUnmarshaling->heapUsage, *ptr, VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize));
    *ptr += VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize);
}

#endif
#ifdef VK_EXT_memory_priority
void reservedunmarshal_VkPhysicalDeviceMemoryPriorityFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceMemoryPriorityFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->memoryPriority, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkMemoryPriorityAllocateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkMemoryPriorityAllocateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((float*)&forUnmarshaling->priority, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
void reservedunmarshal_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->dedicatedAllocationImageAliasing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_buffer_device_address
void reservedunmarshal_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->bufferDeviceAddress, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->bufferDeviceAddressCaptureReplay, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->bufferDeviceAddressMultiDevice, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkBufferDeviceAddressCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBufferDeviceAddressCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceAddress*)&forUnmarshaling->deviceAddress, *ptr, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
}

#endif
#ifdef VK_EXT_tooling_info
void reservedunmarshal_VkPhysicalDeviceToolPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceToolPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((char*)forUnmarshaling->name, *ptr, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    memcpy((char*)forUnmarshaling->version, *ptr, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    memcpy((VkToolPurposeFlagsEXT*)&forUnmarshaling->purposes, *ptr, sizeof(VkToolPurposeFlagsEXT));
    *ptr += sizeof(VkToolPurposeFlagsEXT);
    memcpy((char*)forUnmarshaling->description, *ptr, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy((char*)forUnmarshaling->layer, *ptr, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
}

#endif
#ifdef VK_EXT_separate_stencil_usage
#endif
#ifdef VK_EXT_validation_features
void reservedunmarshal_VkValidationFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkValidationFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->enabledValidationFeatureCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pEnabledValidationFeatures, forUnmarshaling->enabledValidationFeatureCount * sizeof(const VkValidationFeatureEnableEXT));
    memcpy((VkValidationFeatureEnableEXT*)forUnmarshaling->pEnabledValidationFeatures, *ptr, forUnmarshaling->enabledValidationFeatureCount * sizeof(const VkValidationFeatureEnableEXT));
    *ptr += forUnmarshaling->enabledValidationFeatureCount * sizeof(const VkValidationFeatureEnableEXT);
    memcpy((uint32_t*)&forUnmarshaling->disabledValidationFeatureCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDisabledValidationFeatures, forUnmarshaling->disabledValidationFeatureCount * sizeof(const VkValidationFeatureDisableEXT));
    memcpy((VkValidationFeatureDisableEXT*)forUnmarshaling->pDisabledValidationFeatures, *ptr, forUnmarshaling->disabledValidationFeatureCount * sizeof(const VkValidationFeatureDisableEXT));
    *ptr += forUnmarshaling->disabledValidationFeatureCount * sizeof(const VkValidationFeatureDisableEXT);
}

#endif
#ifdef VK_NV_cooperative_matrix
void reservedunmarshal_VkCooperativeMatrixPropertiesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCooperativeMatrixPropertiesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->MSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->NSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->KSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkComponentTypeNV*)&forUnmarshaling->AType, *ptr, sizeof(VkComponentTypeNV));
    *ptr += sizeof(VkComponentTypeNV);
    memcpy((VkComponentTypeNV*)&forUnmarshaling->BType, *ptr, sizeof(VkComponentTypeNV));
    *ptr += sizeof(VkComponentTypeNV);
    memcpy((VkComponentTypeNV*)&forUnmarshaling->CType, *ptr, sizeof(VkComponentTypeNV));
    *ptr += sizeof(VkComponentTypeNV);
    memcpy((VkComponentTypeNV*)&forUnmarshaling->DType, *ptr, sizeof(VkComponentTypeNV));
    *ptr += sizeof(VkComponentTypeNV);
    memcpy((VkScopeNV*)&forUnmarshaling->scope, *ptr, sizeof(VkScopeNV));
    *ptr += sizeof(VkScopeNV);
}

void reservedunmarshal_VkPhysicalDeviceCooperativeMatrixFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceCooperativeMatrixFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->cooperativeMatrix, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->cooperativeMatrixRobustBufferAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceCooperativeMatrixPropertiesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceCooperativeMatrixPropertiesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkShaderStageFlags*)&forUnmarshaling->cooperativeMatrixSupportedStages, *ptr, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
}

#endif
#ifdef VK_NV_coverage_reduction_mode
void reservedunmarshal_VkPhysicalDeviceCoverageReductionModeFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceCoverageReductionModeFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->coverageReductionMode, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPipelineCoverageReductionStateCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineCoverageReductionStateCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineCoverageReductionStateCreateFlagsNV*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineCoverageReductionStateCreateFlagsNV));
    *ptr += sizeof(VkPipelineCoverageReductionStateCreateFlagsNV);
    memcpy((VkCoverageReductionModeNV*)&forUnmarshaling->coverageReductionMode, *ptr, sizeof(VkCoverageReductionModeNV));
    *ptr += sizeof(VkCoverageReductionModeNV);
}

void reservedunmarshal_VkFramebufferMixedSamplesCombinationNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkFramebufferMixedSamplesCombinationNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkCoverageReductionModeNV*)&forUnmarshaling->coverageReductionMode, *ptr, sizeof(VkCoverageReductionModeNV));
    *ptr += sizeof(VkCoverageReductionModeNV);
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->rasterizationSamples, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->depthStencilSamples, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->colorSamples, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
}

#endif
#ifdef VK_EXT_fragment_shader_interlock
void reservedunmarshal_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->fragmentShaderSampleInterlock, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fragmentShaderPixelInterlock, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fragmentShaderShadingRateInterlock, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_ycbcr_image_arrays
void reservedunmarshal_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->ycbcrImageArrays, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_full_screen_exclusive
void reservedunmarshal_VkSurfaceFullScreenExclusiveInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSurfaceFullScreenExclusiveInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFullScreenExclusiveEXT*)&forUnmarshaling->fullScreenExclusive, *ptr, sizeof(VkFullScreenExclusiveEXT));
    *ptr += sizeof(VkFullScreenExclusiveEXT);
}

void reservedunmarshal_VkSurfaceCapabilitiesFullScreenExclusiveEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSurfaceCapabilitiesFullScreenExclusiveEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->fullScreenExclusiveSupported, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkSurfaceFullScreenExclusiveWin32InfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSurfaceFullScreenExclusiveWin32InfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((HMONITOR*)&forUnmarshaling->hmonitor, *ptr, sizeof(HMONITOR));
    *ptr += sizeof(HMONITOR);
}

#endif
#ifdef VK_EXT_headless_surface
void reservedunmarshal_VkHeadlessSurfaceCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkHeadlessSurfaceCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkHeadlessSurfaceCreateFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkHeadlessSurfaceCreateFlagsEXT));
    *ptr += sizeof(VkHeadlessSurfaceCreateFlagsEXT);
}

#endif
#ifdef VK_EXT_line_rasterization
void reservedunmarshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceLineRasterizationFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->rectangularLines, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->bresenhamLines, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->smoothLines, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->stippledRectangularLines, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->stippledBresenhamLines, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->stippledSmoothLines, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceLineRasterizationPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->lineSubPixelPrecisionBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPipelineRasterizationLineStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineRasterizationLineStateCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkLineRasterizationModeEXT*)&forUnmarshaling->lineRasterizationMode, *ptr, sizeof(VkLineRasterizationModeEXT));
    *ptr += sizeof(VkLineRasterizationModeEXT);
    memcpy((VkBool32*)&forUnmarshaling->stippledLineEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->lineStippleFactor, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint16_t*)&forUnmarshaling->lineStipplePattern, *ptr, sizeof(uint16_t));
    *ptr += sizeof(uint16_t);
}

#endif
#ifdef VK_EXT_shader_atomic_float
void reservedunmarshal_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderBufferFloat32Atomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderBufferFloat32AtomicAdd, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderBufferFloat64Atomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderBufferFloat64AtomicAdd, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSharedFloat32Atomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSharedFloat32AtomicAdd, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSharedFloat64Atomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSharedFloat64AtomicAdd, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderImageFloat32Atomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderImageFloat32AtomicAdd, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseImageFloat32Atomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseImageFloat32AtomicAdd, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_host_query_reset
#endif
#ifdef VK_EXT_index_type_uint8
void reservedunmarshal_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceIndexTypeUint8FeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->indexTypeUint8, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_extended_dynamic_state
void reservedunmarshal_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->extendedDynamicState, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
void reservedunmarshal_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderDemoteToHelperInvocation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_device_generated_commands
void reservedunmarshal_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxGraphicsShaderGroupCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxIndirectSequenceCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxIndirectCommandsTokenCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxIndirectCommandsStreamCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxIndirectCommandsTokenOffset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxIndirectCommandsStreamStride, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->minSequencesCountBufferOffsetAlignment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->minSequencesIndexBufferOffsetAlignment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->minIndirectCommandsBufferOffsetAlignment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->deviceGeneratedCommands, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkGraphicsShaderGroupCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkGraphicsShaderGroupCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->stageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pStages, forUnmarshaling->stageCount * sizeof(const VkPipelineShaderStageCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->stageCount; ++i)
    {
        reservedunmarshal_VkPipelineShaderStageCreateInfo(vkStream, rootType, (VkPipelineShaderStageCreateInfo*)(forUnmarshaling->pStages + i), ptr);
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineVertexInputStateCreateInfo**)&forUnmarshaling->pVertexInputState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pVertexInputState);
    *ptr += 8;
    if (forUnmarshaling->pVertexInputState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pVertexInputState, sizeof(const VkPipelineVertexInputStateCreateInfo));
        reservedunmarshal_VkPipelineVertexInputStateCreateInfo(vkStream, rootType, (VkPipelineVertexInputStateCreateInfo*)(forUnmarshaling->pVertexInputState), ptr);
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineTessellationStateCreateInfo**)&forUnmarshaling->pTessellationState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pTessellationState);
    *ptr += 8;
    if (forUnmarshaling->pTessellationState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pTessellationState, sizeof(const VkPipelineTessellationStateCreateInfo));
        reservedunmarshal_VkPipelineTessellationStateCreateInfo(vkStream, rootType, (VkPipelineTessellationStateCreateInfo*)(forUnmarshaling->pTessellationState), ptr);
    }
}

void reservedunmarshal_VkGraphicsPipelineShaderGroupsCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkGraphicsPipelineShaderGroupsCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->groupCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pGroups, forUnmarshaling->groupCount * sizeof(const VkGraphicsShaderGroupCreateInfoNV));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->groupCount; ++i)
    {
        reservedunmarshal_VkGraphicsShaderGroupCreateInfoNV(vkStream, rootType, (VkGraphicsShaderGroupCreateInfoNV*)(forUnmarshaling->pGroups + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->pipelineCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPipelines, forUnmarshaling->pipelineCount * sizeof(const VkPipeline));
    if (forUnmarshaling->pipelineCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->pipelineCount;
        if (forUnmarshaling)
        {
            for (uint32_t k = 0; k < forUnmarshaling->pipelineCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                *(((VkPipeline*)forUnmarshaling->pPipelines) + k) = (VkPipeline)unbox_VkPipeline((VkPipeline)tmpval);
            }
        }
    }
}

void reservedunmarshal_VkBindShaderGroupIndirectCommandNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBindShaderGroupIndirectCommandNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->groupIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkBindIndexBufferIndirectCommandNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBindIndexBufferIndirectCommandNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceAddress*)&forUnmarshaling->bufferAddress, *ptr, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
    memcpy((uint32_t*)&forUnmarshaling->size, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkIndexType*)&forUnmarshaling->indexType, *ptr, sizeof(VkIndexType));
    *ptr += sizeof(VkIndexType);
}

void reservedunmarshal_VkBindVertexBufferIndirectCommandNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkBindVertexBufferIndirectCommandNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceAddress*)&forUnmarshaling->bufferAddress, *ptr, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
    memcpy((uint32_t*)&forUnmarshaling->size, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->stride, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkSetStateFlagsIndirectCommandNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSetStateFlagsIndirectCommandNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->data, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkIndirectCommandsStreamNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkIndirectCommandsStreamNV* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkIndirectCommandsLayoutTokenNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkIndirectCommandsLayoutTokenNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkIndirectCommandsTokenTypeNV*)&forUnmarshaling->tokenType, *ptr, sizeof(VkIndirectCommandsTokenTypeNV));
    *ptr += sizeof(VkIndirectCommandsTokenTypeNV);
    memcpy((uint32_t*)&forUnmarshaling->stream, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->offset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->vertexBindingUnit, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->vertexDynamicStride, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipelineLayout*)&forUnmarshaling->pushconstantPipelineLayout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_0));
    memcpy((VkShaderStageFlags*)&forUnmarshaling->pushconstantShaderStageFlags, *ptr, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    memcpy((uint32_t*)&forUnmarshaling->pushconstantOffset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->pushconstantSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkIndirectStateFlagsNV*)&forUnmarshaling->indirectStateFlags, *ptr, sizeof(VkIndirectStateFlagsNV));
    *ptr += sizeof(VkIndirectStateFlagsNV);
    memcpy((uint32_t*)&forUnmarshaling->indexTypeCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pIndexTypes, forUnmarshaling->indexTypeCount * sizeof(const VkIndexType));
    memcpy((VkIndexType*)forUnmarshaling->pIndexTypes, *ptr, forUnmarshaling->indexTypeCount * sizeof(const VkIndexType));
    *ptr += forUnmarshaling->indexTypeCount * sizeof(const VkIndexType);
    vkStream->alloc((void**)&forUnmarshaling->pIndexTypeValues, forUnmarshaling->indexTypeCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pIndexTypeValues, *ptr, forUnmarshaling->indexTypeCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->indexTypeCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkIndirectCommandsLayoutCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkIndirectCommandsLayoutCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkIndirectCommandsLayoutUsageFlagsNV*)&forUnmarshaling->flags, *ptr, sizeof(VkIndirectCommandsLayoutUsageFlagsNV));
    *ptr += sizeof(VkIndirectCommandsLayoutUsageFlagsNV);
    memcpy((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, *ptr, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    memcpy((uint32_t*)&forUnmarshaling->tokenCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pTokens, forUnmarshaling->tokenCount * sizeof(const VkIndirectCommandsLayoutTokenNV));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->tokenCount; ++i)
    {
        reservedunmarshal_VkIndirectCommandsLayoutTokenNV(vkStream, rootType, (VkIndirectCommandsLayoutTokenNV*)(forUnmarshaling->pTokens + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->streamCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pStreamStrides, forUnmarshaling->streamCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pStreamStrides, *ptr, forUnmarshaling->streamCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->streamCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkGeneratedCommandsInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkGeneratedCommandsInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, *ptr, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipeline*)&forUnmarshaling->pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkIndirectCommandsLayoutNV*)&forUnmarshaling->indirectCommandsLayout = (VkIndirectCommandsLayoutNV)unbox_VkIndirectCommandsLayoutNV((VkIndirectCommandsLayoutNV)(*&cgen_var_1));
    memcpy((uint32_t*)&forUnmarshaling->streamCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pStreams, forUnmarshaling->streamCount * sizeof(const VkIndirectCommandsStreamNV));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->streamCount; ++i)
    {
        reservedunmarshal_VkIndirectCommandsStreamNV(vkStream, rootType, (VkIndirectCommandsStreamNV*)(forUnmarshaling->pStreams + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->sequencesCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_2;
    memcpy((uint64_t*)&cgen_var_2, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->preprocessBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_2));
    memcpy((VkDeviceSize*)&forUnmarshaling->preprocessOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->preprocessSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    uint64_t cgen_var_3;
    memcpy((uint64_t*)&cgen_var_3, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->sequencesCountBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_3));
    memcpy((VkDeviceSize*)&forUnmarshaling->sequencesCountOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    uint64_t cgen_var_4;
    memcpy((uint64_t*)&cgen_var_4, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->sequencesIndexBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_4));
    memcpy((VkDeviceSize*)&forUnmarshaling->sequencesIndexOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkGeneratedCommandsMemoryRequirementsInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkGeneratedCommandsMemoryRequirementsInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, *ptr, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipeline*)&forUnmarshaling->pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkIndirectCommandsLayoutNV*)&forUnmarshaling->indirectCommandsLayout = (VkIndirectCommandsLayoutNV)unbox_VkIndirectCommandsLayoutNV((VkIndirectCommandsLayoutNV)(*&cgen_var_1));
    memcpy((uint32_t*)&forUnmarshaling->maxSequencesCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_EXT_texel_buffer_alignment
void reservedunmarshal_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->texelBufferAlignment, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceSize*)&forUnmarshaling->storageTexelBufferOffsetAlignmentBytes, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkBool32*)&forUnmarshaling->storageTexelBufferOffsetSingleTexelAlignment, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkDeviceSize*)&forUnmarshaling->uniformTexelBufferOffsetAlignmentBytes, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkBool32*)&forUnmarshaling->uniformTexelBufferOffsetSingleTexelAlignment, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_QCOM_render_pass_transform
void reservedunmarshal_VkRenderPassTransformBeginInfoQCOM(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRenderPassTransformBeginInfoQCOM* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->transform, *ptr, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
}

void reservedunmarshal_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCommandBufferInheritanceRenderPassTransformInfoQCOM* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->transform, *ptr, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    reservedunmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(&forUnmarshaling->renderArea), ptr);
}

#endif
#ifdef VK_EXT_device_memory_report
void reservedunmarshal_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->deviceMemoryReport, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDeviceMemoryReportCallbackDataEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceMemoryReportCallbackDataEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceMemoryReportFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkDeviceMemoryReportFlagsEXT));
    *ptr += sizeof(VkDeviceMemoryReportFlagsEXT);
    memcpy((VkDeviceMemoryReportEventTypeEXT*)&forUnmarshaling->type, *ptr, sizeof(VkDeviceMemoryReportEventTypeEXT));
    *ptr += sizeof(VkDeviceMemoryReportEventTypeEXT);
    memcpy((uint64_t*)&forUnmarshaling->memoryObjectId, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkObjectType*)&forUnmarshaling->objectType, *ptr, sizeof(VkObjectType));
    *ptr += sizeof(VkObjectType);
    memcpy((uint64_t*)&forUnmarshaling->objectHandle, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint32_t*)&forUnmarshaling->heapIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDeviceDeviceMemoryReportCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceDeviceMemoryReportCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceMemoryReportFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkDeviceMemoryReportFlagsEXT));
    *ptr += sizeof(VkDeviceMemoryReportFlagsEXT);
    memcpy((PFN_vkDeviceMemoryReportCallbackEXT*)&forUnmarshaling->pfnUserCallback, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnUserCallback);
    *ptr += 8;
    vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
    memcpy((void*)forUnmarshaling->pUserData, *ptr, sizeof(uint8_t));
    *ptr += sizeof(uint8_t);
}

#endif
#ifdef VK_EXT_robustness2
void reservedunmarshal_VkPhysicalDeviceRobustness2FeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceRobustness2FeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->robustBufferAccess2, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->robustImageAccess2, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->nullDescriptor, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceRobustness2PropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceRobustness2PropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceSize*)&forUnmarshaling->robustStorageBufferAccessSizeAlignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->robustUniformBufferAccessSizeAlignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

#endif
#ifdef VK_EXT_custom_border_color
void reservedunmarshal_VkSamplerCustomBorderColorCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkSamplerCustomBorderColorCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkClearColorValue(vkStream, rootType, (VkClearColorValue*)(&forUnmarshaling->customBorderColor), ptr);
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
}

void reservedunmarshal_VkPhysicalDeviceCustomBorderColorPropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceCustomBorderColorPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxCustomBorderColorSamplers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPhysicalDeviceCustomBorderColorFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceCustomBorderColorFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->customBorderColors, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->customBorderColorWithoutFormat, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_GOOGLE_user_type
#endif
#ifdef VK_EXT_private_data
void reservedunmarshal_VkPhysicalDevicePrivateDataFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDevicePrivateDataFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->privateData, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDevicePrivateDataCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDevicePrivateDataCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->privateDataSlotRequestCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPrivateDataSlotCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPrivateDataSlotCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPrivateDataSlotCreateFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkPrivateDataSlotCreateFlagsEXT));
    *ptr += sizeof(VkPrivateDataSlotCreateFlagsEXT);
}

#endif
#ifdef VK_EXT_pipeline_creation_cache_control
void reservedunmarshal_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->pipelineCreationCacheControl, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_device_diagnostics_config
void reservedunmarshal_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceDiagnosticsConfigFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->diagnosticsConfig, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDeviceDiagnosticsConfigCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceDiagnosticsConfigCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceDiagnosticsConfigFlagsNV*)&forUnmarshaling->flags, *ptr, sizeof(VkDeviceDiagnosticsConfigFlagsNV));
    *ptr += sizeof(VkDeviceDiagnosticsConfigFlagsNV);
}

#endif
#ifdef VK_QCOM_render_pass_store_ops
#endif
#ifdef VK_NV_fragment_shading_rate_enums
void reservedunmarshal_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->fragmentShadingRateEnums, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->supersampleFragmentShadingRates, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->noInvocationFragmentShadingRates, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->maxFragmentShadingRateInvocationCount, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
}

void reservedunmarshal_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPipelineFragmentShadingRateEnumStateCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFragmentShadingRateTypeNV*)&forUnmarshaling->shadingRateType, *ptr, sizeof(VkFragmentShadingRateTypeNV));
    *ptr += sizeof(VkFragmentShadingRateTypeNV);
    memcpy((VkFragmentShadingRateNV*)&forUnmarshaling->shadingRate, *ptr, sizeof(VkFragmentShadingRateNV));
    *ptr += sizeof(VkFragmentShadingRateNV);
    memcpy((VkFragmentShadingRateCombinerOpKHR*)forUnmarshaling->combinerOps, *ptr, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
    *ptr += 2 * sizeof(VkFragmentShadingRateCombinerOpKHR);
}

#endif
#ifdef VK_EXT_fragment_density_map2
void reservedunmarshal_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->fragmentDensityMapDeferred, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->subsampledLoads, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->subsampledCoarseReconstructionEarlyAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->maxSubsampledArrayLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetSubsampledSamplers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_QCOM_rotated_copy_commands
void reservedunmarshal_VkCopyCommandTransformInfoQCOM(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCopyCommandTransformInfoQCOM* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->transform, *ptr, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
}

#endif
#ifdef VK_EXT_image_robustness
void reservedunmarshal_VkPhysicalDeviceImageRobustnessFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceImageRobustnessFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->robustImageAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_4444_formats
void reservedunmarshal_VkPhysicalDevice4444FormatsFeaturesEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDevice4444FormatsFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->formatA4R4G4B4, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->formatA4B4G4R4, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_directfb_surface
void reservedunmarshal_VkDirectFBSurfaceCreateInfoEXT(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDirectFBSurfaceCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDirectFBSurfaceCreateFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkDirectFBSurfaceCreateFlagsEXT));
    *ptr += sizeof(VkDirectFBSurfaceCreateFlagsEXT);
    // WARNING PTR CHECK
    memcpy((IDirectFB**)&forUnmarshaling->dfb, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->dfb);
    *ptr += 8;
    if (forUnmarshaling->dfb)
    {
        vkStream->alloc((void**)&forUnmarshaling->dfb, sizeof(IDirectFB));
        memcpy((IDirectFB*)forUnmarshaling->dfb, *ptr, sizeof(IDirectFB));
        *ptr += sizeof(IDirectFB);
    }
    // WARNING PTR CHECK
    memcpy((IDirectFBSurface**)&forUnmarshaling->surface, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->surface);
    *ptr += 8;
    if (forUnmarshaling->surface)
    {
        vkStream->alloc((void**)&forUnmarshaling->surface, sizeof(IDirectFBSurface));
        memcpy((IDirectFBSurface*)forUnmarshaling->surface, *ptr, sizeof(IDirectFBSurface));
        *ptr += sizeof(IDirectFBSurface);
    }
}

#endif
#ifdef VK_GOOGLE_gfxstream
void reservedunmarshal_VkImportColorBufferGOOGLE(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImportColorBufferGOOGLE* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    forUnmarshaling->sType = VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE;
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->colorBuffer, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkImportBufferGOOGLE(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImportBufferGOOGLE* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    forUnmarshaling->sType = VK_STRUCTURE_TYPE_IMPORT_BUFFER_GOOGLE;
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->buffer, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkImportPhysicalAddressGOOGLE(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkImportPhysicalAddressGOOGLE* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    forUnmarshaling->sType = VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE;
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint64_t*)&forUnmarshaling->physicalAddress, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkImageTiling*)&forUnmarshaling->tiling, *ptr, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
    memcpy((uint32_t*)&forUnmarshaling->tilingParameter, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_acceleration_structure
void reservedunmarshal_VkDeviceOrHostAddressKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceOrHostAddressKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceAddress*)&forUnmarshaling->deviceAddress, *ptr, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
}

void reservedunmarshal_VkDeviceOrHostAddressConstKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkDeviceOrHostAddressConstKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceAddress*)&forUnmarshaling->deviceAddress, *ptr, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
}

void reservedunmarshal_VkAccelerationStructureBuildRangeInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureBuildRangeInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->primitiveCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->primitiveOffset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->firstVertex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->transformOffset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkAccelerationStructureGeometryTrianglesDataKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureGeometryTrianglesDataKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFormat*)&forUnmarshaling->vertexFormat, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    reservedunmarshal_VkDeviceOrHostAddressConstKHR(vkStream, rootType, (VkDeviceOrHostAddressConstKHR*)(&forUnmarshaling->vertexData), ptr);
    memcpy((VkDeviceSize*)&forUnmarshaling->vertexStride, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->maxVertex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkIndexType*)&forUnmarshaling->indexType, *ptr, sizeof(VkIndexType));
    *ptr += sizeof(VkIndexType);
    reservedunmarshal_VkDeviceOrHostAddressConstKHR(vkStream, rootType, (VkDeviceOrHostAddressConstKHR*)(&forUnmarshaling->indexData), ptr);
    reservedunmarshal_VkDeviceOrHostAddressConstKHR(vkStream, rootType, (VkDeviceOrHostAddressConstKHR*)(&forUnmarshaling->transformData), ptr);
}

void reservedunmarshal_VkAccelerationStructureGeometryAabbsDataKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureGeometryAabbsDataKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkDeviceOrHostAddressConstKHR(vkStream, rootType, (VkDeviceOrHostAddressConstKHR*)(&forUnmarshaling->data), ptr);
    memcpy((VkDeviceSize*)&forUnmarshaling->stride, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkAccelerationStructureGeometryInstancesDataKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureGeometryInstancesDataKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->arrayOfPointers, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    reservedunmarshal_VkDeviceOrHostAddressConstKHR(vkStream, rootType, (VkDeviceOrHostAddressConstKHR*)(&forUnmarshaling->data), ptr);
}

void reservedunmarshal_VkAccelerationStructureGeometryDataKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureGeometryDataKHR* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkAccelerationStructureGeometryTrianglesDataKHR(vkStream, rootType, (VkAccelerationStructureGeometryTrianglesDataKHR*)(&forUnmarshaling->triangles), ptr);
}

void reservedunmarshal_VkAccelerationStructureGeometryKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureGeometryKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkGeometryTypeKHR*)&forUnmarshaling->geometryType, *ptr, sizeof(VkGeometryTypeKHR));
    *ptr += sizeof(VkGeometryTypeKHR);
    reservedunmarshal_VkAccelerationStructureGeometryDataKHR(vkStream, rootType, (VkAccelerationStructureGeometryDataKHR*)(&forUnmarshaling->geometry), ptr);
    memcpy((VkGeometryFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkGeometryFlagsKHR));
    *ptr += sizeof(VkGeometryFlagsKHR);
}

void reservedunmarshal_VkAccelerationStructureBuildGeometryInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureBuildGeometryInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAccelerationStructureTypeKHR*)&forUnmarshaling->type, *ptr, sizeof(VkAccelerationStructureTypeKHR));
    *ptr += sizeof(VkAccelerationStructureTypeKHR);
    memcpy((VkBuildAccelerationStructureFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkBuildAccelerationStructureFlagsKHR));
    *ptr += sizeof(VkBuildAccelerationStructureFlagsKHR);
    memcpy((VkBuildAccelerationStructureModeKHR*)&forUnmarshaling->mode, *ptr, sizeof(VkBuildAccelerationStructureModeKHR));
    *ptr += sizeof(VkBuildAccelerationStructureModeKHR);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkAccelerationStructureKHR*)&forUnmarshaling->srcAccelerationStructure = (VkAccelerationStructureKHR)unbox_VkAccelerationStructureKHR((VkAccelerationStructureKHR)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkAccelerationStructureKHR*)&forUnmarshaling->dstAccelerationStructure = (VkAccelerationStructureKHR)unbox_VkAccelerationStructureKHR((VkAccelerationStructureKHR)(*&cgen_var_1));
    memcpy((uint32_t*)&forUnmarshaling->geometryCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkAccelerationStructureGeometryKHR**)&forUnmarshaling->pGeometries, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pGeometries);
    *ptr += 8;
    if (forUnmarshaling->pGeometries)
    {
        vkStream->alloc((void**)&forUnmarshaling->pGeometries, forUnmarshaling->geometryCount * sizeof(const VkAccelerationStructureGeometryKHR));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->geometryCount; ++i)
        {
            reservedunmarshal_VkAccelerationStructureGeometryKHR(vkStream, rootType, (VkAccelerationStructureGeometryKHR*)(forUnmarshaling->pGeometries + i), ptr);
        }
    }
    reservedunmarshal_VkDeviceOrHostAddressKHR(vkStream, rootType, (VkDeviceOrHostAddressKHR*)(&forUnmarshaling->scratchData), ptr);
}

void reservedunmarshal_VkAccelerationStructureCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAccelerationStructureCreateFlagsKHR*)&forUnmarshaling->createFlags, *ptr, sizeof(VkAccelerationStructureCreateFlagsKHR));
    *ptr += sizeof(VkAccelerationStructureCreateFlagsKHR);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkAccelerationStructureTypeKHR*)&forUnmarshaling->type, *ptr, sizeof(VkAccelerationStructureTypeKHR));
    *ptr += sizeof(VkAccelerationStructureTypeKHR);
    memcpy((VkDeviceAddress*)&forUnmarshaling->deviceAddress, *ptr, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
}

void reservedunmarshal_VkWriteDescriptorSetAccelerationStructureKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkWriteDescriptorSetAccelerationStructureKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->accelerationStructureCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkAccelerationStructureKHR**)&forUnmarshaling->pAccelerationStructures, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pAccelerationStructures);
    *ptr += 8;
    if (forUnmarshaling->pAccelerationStructures)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAccelerationStructures, forUnmarshaling->accelerationStructureCount * sizeof(const VkAccelerationStructureKHR));
        if (forUnmarshaling->accelerationStructureCount)
        {
            uint8_t* cgen_var_0_0_ptr = (uint8_t*)(*ptr);
            *ptr += 8 * forUnmarshaling->accelerationStructureCount;
            if (forUnmarshaling)
            {
                for (uint32_t k = 0; k < forUnmarshaling->accelerationStructureCount; ++k)
                {
                    uint64_t tmpval; memcpy(&tmpval, cgen_var_0_0_ptr + k * 8, sizeof(uint64_t));
                    *(((VkAccelerationStructureKHR*)forUnmarshaling->pAccelerationStructures) + k) = (VkAccelerationStructureKHR)unbox_VkAccelerationStructureKHR((VkAccelerationStructureKHR)tmpval);
                }
            }
        }
    }
}

void reservedunmarshal_VkPhysicalDeviceAccelerationStructureFeaturesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceAccelerationStructureFeaturesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->accelerationStructure, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->accelerationStructureCaptureReplay, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->accelerationStructureIndirectBuild, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->accelerationStructureHostCommands, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingAccelerationStructureUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceAccelerationStructurePropertiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceAccelerationStructurePropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint64_t*)&forUnmarshaling->maxGeometryCount, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->maxInstanceCount, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->maxPrimitiveCount, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorAccelerationStructures, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindAccelerationStructures, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetAccelerationStructures, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindAccelerationStructures, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->minAccelerationStructureScratchOffsetAlignment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkAccelerationStructureDeviceAddressInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureDeviceAddressInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkAccelerationStructureKHR*)&forUnmarshaling->accelerationStructure = (VkAccelerationStructureKHR)unbox_VkAccelerationStructureKHR((VkAccelerationStructureKHR)(*&cgen_var_0));
}

void reservedunmarshal_VkAccelerationStructureVersionInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureVersionInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    vkStream->alloc((void**)&forUnmarshaling->pVersionData, 2*VK_UUID_SIZE * sizeof(const uint8_t));
    memcpy((uint8_t*)forUnmarshaling->pVersionData, *ptr, 2*VK_UUID_SIZE * sizeof(const uint8_t));
    *ptr += 2*VK_UUID_SIZE * sizeof(const uint8_t);
}

void reservedunmarshal_VkCopyAccelerationStructureToMemoryInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCopyAccelerationStructureToMemoryInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkAccelerationStructureKHR*)&forUnmarshaling->src = (VkAccelerationStructureKHR)unbox_VkAccelerationStructureKHR((VkAccelerationStructureKHR)(*&cgen_var_0));
    reservedunmarshal_VkDeviceOrHostAddressKHR(vkStream, rootType, (VkDeviceOrHostAddressKHR*)(&forUnmarshaling->dst), ptr);
    memcpy((VkCopyAccelerationStructureModeKHR*)&forUnmarshaling->mode, *ptr, sizeof(VkCopyAccelerationStructureModeKHR));
    *ptr += sizeof(VkCopyAccelerationStructureModeKHR);
}

void reservedunmarshal_VkCopyMemoryToAccelerationStructureInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCopyMemoryToAccelerationStructureInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkDeviceOrHostAddressConstKHR(vkStream, rootType, (VkDeviceOrHostAddressConstKHR*)(&forUnmarshaling->src), ptr);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkAccelerationStructureKHR*)&forUnmarshaling->dst = (VkAccelerationStructureKHR)unbox_VkAccelerationStructureKHR((VkAccelerationStructureKHR)(*&cgen_var_0));
    memcpy((VkCopyAccelerationStructureModeKHR*)&forUnmarshaling->mode, *ptr, sizeof(VkCopyAccelerationStructureModeKHR));
    *ptr += sizeof(VkCopyAccelerationStructureModeKHR);
}

void reservedunmarshal_VkCopyAccelerationStructureInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkCopyAccelerationStructureInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkAccelerationStructureKHR*)&forUnmarshaling->src = (VkAccelerationStructureKHR)unbox_VkAccelerationStructureKHR((VkAccelerationStructureKHR)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkAccelerationStructureKHR*)&forUnmarshaling->dst = (VkAccelerationStructureKHR)unbox_VkAccelerationStructureKHR((VkAccelerationStructureKHR)(*&cgen_var_1));
    memcpy((VkCopyAccelerationStructureModeKHR*)&forUnmarshaling->mode, *ptr, sizeof(VkCopyAccelerationStructureModeKHR));
    *ptr += sizeof(VkCopyAccelerationStructureModeKHR);
}

void reservedunmarshal_VkAccelerationStructureBuildSizesInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkAccelerationStructureBuildSizesInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceSize*)&forUnmarshaling->accelerationStructureSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->updateScratchSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->buildScratchSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

#endif
#ifdef VK_KHR_ray_tracing_pipeline
void reservedunmarshal_VkRayTracingShaderGroupCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRayTracingShaderGroupCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkRayTracingShaderGroupTypeKHR*)&forUnmarshaling->type, *ptr, sizeof(VkRayTracingShaderGroupTypeKHR));
    *ptr += sizeof(VkRayTracingShaderGroupTypeKHR);
    memcpy((uint32_t*)&forUnmarshaling->generalShader, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->closestHitShader, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->anyHitShader, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->intersectionShader, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pShaderGroupCaptureReplayHandle, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pShaderGroupCaptureReplayHandle);
    *ptr += 8;
    if (forUnmarshaling->pShaderGroupCaptureReplayHandle)
    {
        vkStream->alloc((void**)&forUnmarshaling->pShaderGroupCaptureReplayHandle, sizeof(const uint8_t));
        memcpy((void*)forUnmarshaling->pShaderGroupCaptureReplayHandle, *ptr, sizeof(const uint8_t));
        *ptr += sizeof(const uint8_t);
    }
}

void reservedunmarshal_VkRayTracingPipelineInterfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRayTracingPipelineInterfaceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxPipelineRayPayloadSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPipelineRayHitAttributeSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkRayTracingPipelineCreateInfoKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkRayTracingPipelineCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineCreateFlags));
    *ptr += sizeof(VkPipelineCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->stageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pStages, forUnmarshaling->stageCount * sizeof(const VkPipelineShaderStageCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->stageCount; ++i)
    {
        reservedunmarshal_VkPipelineShaderStageCreateInfo(vkStream, rootType, (VkPipelineShaderStageCreateInfo*)(forUnmarshaling->pStages + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->groupCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pGroups, forUnmarshaling->groupCount * sizeof(const VkRayTracingShaderGroupCreateInfoKHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->groupCount; ++i)
    {
        reservedunmarshal_VkRayTracingShaderGroupCreateInfoKHR(vkStream, rootType, (VkRayTracingShaderGroupCreateInfoKHR*)(forUnmarshaling->pGroups + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxPipelineRayRecursionDepth, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkPipelineLibraryCreateInfoKHR**)&forUnmarshaling->pLibraryInfo, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pLibraryInfo);
    *ptr += 8;
    if (forUnmarshaling->pLibraryInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pLibraryInfo, sizeof(const VkPipelineLibraryCreateInfoKHR));
        reservedunmarshal_VkPipelineLibraryCreateInfoKHR(vkStream, rootType, (VkPipelineLibraryCreateInfoKHR*)(forUnmarshaling->pLibraryInfo), ptr);
    }
    // WARNING PTR CHECK
    memcpy((VkRayTracingPipelineInterfaceCreateInfoKHR**)&forUnmarshaling->pLibraryInterface, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pLibraryInterface);
    *ptr += 8;
    if (forUnmarshaling->pLibraryInterface)
    {
        vkStream->alloc((void**)&forUnmarshaling->pLibraryInterface, sizeof(const VkRayTracingPipelineInterfaceCreateInfoKHR));
        reservedunmarshal_VkRayTracingPipelineInterfaceCreateInfoKHR(vkStream, rootType, (VkRayTracingPipelineInterfaceCreateInfoKHR*)(forUnmarshaling->pLibraryInterface), ptr);
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineDynamicStateCreateInfo**)&forUnmarshaling->pDynamicState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pDynamicState);
    *ptr += 8;
    if (forUnmarshaling->pDynamicState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDynamicState, sizeof(const VkPipelineDynamicStateCreateInfo));
        reservedunmarshal_VkPipelineDynamicStateCreateInfo(vkStream, rootType, (VkPipelineDynamicStateCreateInfo*)(forUnmarshaling->pDynamicState), ptr);
    }
    uint64_t cgen_var_3;
    memcpy((uint64_t*)&cgen_var_3, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipelineLayout*)&forUnmarshaling->layout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_3));
    uint64_t cgen_var_4;
    memcpy((uint64_t*)&cgen_var_4, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipeline*)&forUnmarshaling->basePipelineHandle = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_4));
    memcpy((int32_t*)&forUnmarshaling->basePipelineIndex, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedunmarshal_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceRayTracingPipelineFeaturesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->rayTracingPipeline, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->rayTracingPipelineShaderGroupHandleCaptureReplay, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->rayTracingPipelineShaderGroupHandleCaptureReplayMixed, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->rayTracingPipelineTraceRaysIndirect, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->rayTraversalPrimitiveCulling, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceRayTracingPipelinePropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->shaderGroupHandleSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxRayRecursionDepth, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxShaderGroupStride, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->shaderGroupBaseAlignment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->shaderGroupHandleCaptureReplaySize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxRayDispatchInvocationCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->shaderGroupHandleAlignment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxRayHitAttributeSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkStridedDeviceAddressRegionKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkStridedDeviceAddressRegionKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceAddress*)&forUnmarshaling->deviceAddress, *ptr, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
    memcpy((VkDeviceSize*)&forUnmarshaling->stride, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkTraceRaysIndirectCommandKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkTraceRaysIndirectCommandKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->width, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->height, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->depth, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_ray_query
void reservedunmarshal_VkPhysicalDeviceRayQueryFeaturesKHR(
    VulkanStream* vkStream,
    VkStructureType rootType,
    VkPhysicalDeviceRayQueryFeaturesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forUnmarshaling->sType;
    }
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->rayQuery, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
void reservedunmarshal_extension_struct(
    VulkanStream* vkStream,
    VkStructureType rootType,
    void* structExtension_out,
    uint8_t** ptr)
{
    VkInstanceCreateInfo* structAccess = (VkInstanceCreateInfo*)(structExtension_out);
    uint32_t currExtSize = goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, structExtension_out);
    if (!currExtSize && structExtension_out)
    {
        // unknown struct extension; skip and call on its pNext field
        reservedunmarshal_extension_struct(vkStream, rootType, (void*)structAccess->pNext, ptr);
        return;
    }
    else
    {
        // known or null extension struct
        if (!currExtSize)
        {
            // exit if this was a null extension struct (size == 0 in this branch)
            return;
        }
    }
    if (!structExtension_out)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension_out);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceSubgroupProperties(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceSubgroupProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            reservedunmarshal_VkPhysicalDevice16BitStorageFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDevice16BitStorageFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            reservedunmarshal_VkMemoryDedicatedRequirements(vkStream, rootType, reinterpret_cast<VkMemoryDedicatedRequirements*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            reservedunmarshal_VkMemoryDedicatedAllocateInfo(vkStream, rootType, reinterpret_cast<VkMemoryDedicatedAllocateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            reservedunmarshal_VkMemoryAllocateFlagsInfo(vkStream, rootType, reinterpret_cast<VkMemoryAllocateFlagsInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            reservedunmarshal_VkDeviceGroupRenderPassBeginInfo(vkStream, rootType, reinterpret_cast<VkDeviceGroupRenderPassBeginInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            reservedunmarshal_VkDeviceGroupCommandBufferBeginInfo(vkStream, rootType, reinterpret_cast<VkDeviceGroupCommandBufferBeginInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            reservedunmarshal_VkDeviceGroupSubmitInfo(vkStream, rootType, reinterpret_cast<VkDeviceGroupSubmitInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            reservedunmarshal_VkDeviceGroupBindSparseInfo(vkStream, rootType, reinterpret_cast<VkDeviceGroupBindSparseInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            reservedunmarshal_VkBindBufferMemoryDeviceGroupInfo(vkStream, rootType, reinterpret_cast<VkBindBufferMemoryDeviceGroupInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            reservedunmarshal_VkBindImageMemoryDeviceGroupInfo(vkStream, rootType, reinterpret_cast<VkBindImageMemoryDeviceGroupInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            reservedunmarshal_VkDeviceGroupDeviceCreateInfo(vkStream, rootType, reinterpret_cast<VkDeviceGroupDeviceCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            reservedunmarshal_VkPhysicalDeviceFeatures2(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFeatures2*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDevicePointClippingProperties(vkStream, rootType, reinterpret_cast<VkPhysicalDevicePointClippingProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            reservedunmarshal_VkRenderPassInputAttachmentAspectCreateInfo(vkStream, rootType, reinterpret_cast<VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            reservedunmarshal_VkImageViewUsageCreateInfo(vkStream, rootType, reinterpret_cast<VkImageViewUsageCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            reservedunmarshal_VkPipelineTessellationDomainOriginStateCreateInfo(vkStream, rootType, reinterpret_cast<VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            reservedunmarshal_VkRenderPassMultiviewCreateInfo(vkStream, rootType, reinterpret_cast<VkRenderPassMultiviewCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceMultiviewFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceMultiviewFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceMultiviewProperties(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceMultiviewProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceVariablePointersFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceVariablePointersFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceProtectedMemoryFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceProtectedMemoryProperties(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceProtectedMemoryProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            reservedunmarshal_VkProtectedSubmitInfo(vkStream, rootType, reinterpret_cast<VkProtectedSubmitInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            reservedunmarshal_VkSamplerYcbcrConversionInfo(vkStream, rootType, reinterpret_cast<VkSamplerYcbcrConversionInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            reservedunmarshal_VkBindImagePlaneMemoryInfo(vkStream, rootType, reinterpret_cast<VkBindImagePlaneMemoryInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            reservedunmarshal_VkImagePlaneMemoryRequirementsInfo(vkStream, rootType, reinterpret_cast<VkImagePlaneMemoryRequirementsInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            reservedunmarshal_VkSamplerYcbcrConversionImageFormatProperties(vkStream, rootType, reinterpret_cast<VkSamplerYcbcrConversionImageFormatProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            reservedunmarshal_VkPhysicalDeviceExternalImageFormatInfo(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceExternalImageFormatInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            reservedunmarshal_VkExternalImageFormatProperties(vkStream, rootType, reinterpret_cast<VkExternalImageFormatProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceIDProperties(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceIDProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            reservedunmarshal_VkExternalMemoryImageCreateInfo(vkStream, rootType, reinterpret_cast<VkExternalMemoryImageCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            reservedunmarshal_VkExternalMemoryBufferCreateInfo(vkStream, rootType, reinterpret_cast<VkExternalMemoryBufferCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            reservedunmarshal_VkExportMemoryAllocateInfo(vkStream, rootType, reinterpret_cast<VkExportMemoryAllocateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            reservedunmarshal_VkExportFenceCreateInfo(vkStream, rootType, reinterpret_cast<VkExportFenceCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            reservedunmarshal_VkExportSemaphoreCreateInfo(vkStream, rootType, reinterpret_cast<VkExportSemaphoreCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceMaintenance3Properties(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceMaintenance3Properties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceShaderDrawParametersFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderDrawParametersFeatures*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_VERSION_1_2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceVulkan11Features(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceVulkan11Features*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceVulkan11Properties(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceVulkan11Properties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceVulkan12Features(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceVulkan12Features*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceVulkan12Properties(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceVulkan12Properties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            reservedunmarshal_VkImageFormatListCreateInfo(vkStream, rootType, reinterpret_cast<VkImageFormatListCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            reservedunmarshal_VkPhysicalDevice8BitStorageFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDevice8BitStorageFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceDriverProperties(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceDriverProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceShaderAtomicInt64Features(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderAtomicInt64Features*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceShaderFloat16Int8Features(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderFloat16Int8Features*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceFloatControlsProperties(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFloatControlsProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
        {
            reservedunmarshal_VkDescriptorSetLayoutBindingFlagsCreateInfo(vkStream, rootType, reinterpret_cast<VkDescriptorSetLayoutBindingFlagsCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceDescriptorIndexingFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceDescriptorIndexingFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceDescriptorIndexingProperties(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceDescriptorIndexingProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
        {
            reservedunmarshal_VkDescriptorSetVariableDescriptorCountAllocateInfo(vkStream, rootType, reinterpret_cast<VkDescriptorSetVariableDescriptorCountAllocateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
            reservedunmarshal_VkDescriptorSetVariableDescriptorCountLayoutSupport(vkStream, rootType, reinterpret_cast<VkDescriptorSetVariableDescriptorCountLayoutSupport*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
        {
            reservedunmarshal_VkSubpassDescriptionDepthStencilResolve(vkStream, rootType, reinterpret_cast<VkSubpassDescriptionDepthStencilResolve*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceDepthStencilResolveProperties(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceDepthStencilResolveProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceScalarBlockLayoutFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceScalarBlockLayoutFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            reservedunmarshal_VkImageStencilUsageCreateInfo(vkStream, rootType, reinterpret_cast<VkImageStencilUsageCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
        {
            reservedunmarshal_VkSamplerReductionModeCreateInfo(vkStream, rootType, reinterpret_cast<VkSamplerReductionModeCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceSamplerFilterMinmaxProperties(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceSamplerFilterMinmaxProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceVulkanMemoryModelFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceVulkanMemoryModelFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceImagelessFramebufferFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceImagelessFramebufferFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
        {
            reservedunmarshal_VkFramebufferAttachmentsCreateInfo(vkStream, rootType, reinterpret_cast<VkFramebufferAttachmentsCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
        {
            reservedunmarshal_VkRenderPassAttachmentBeginInfo(vkStream, rootType, reinterpret_cast<VkRenderPassAttachmentBeginInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
        {
            reservedunmarshal_VkAttachmentReferenceStencilLayout(vkStream, rootType, reinterpret_cast<VkAttachmentReferenceStencilLayout*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
        {
            reservedunmarshal_VkAttachmentDescriptionStencilLayout(vkStream, rootType, reinterpret_cast<VkAttachmentDescriptionStencilLayout*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceHostQueryResetFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceHostQueryResetFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceTimelineSemaphoreFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceTimelineSemaphoreProperties(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
            reservedunmarshal_VkSemaphoreTypeCreateInfo(vkStream, rootType, reinterpret_cast<VkSemaphoreTypeCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            reservedunmarshal_VkTimelineSemaphoreSubmitInfo(vkStream, rootType, reinterpret_cast<VkTimelineSemaphoreSubmitInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceBufferDeviceAddressFeatures(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceBufferDeviceAddressFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
            reservedunmarshal_VkBufferOpaqueCaptureAddressCreateInfo(vkStream, rootType, reinterpret_cast<VkBufferOpaqueCaptureAddressCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
            reservedunmarshal_VkMemoryOpaqueCaptureAddressAllocateInfo(vkStream, rootType, reinterpret_cast<VkMemoryOpaqueCaptureAddressAllocateInfo*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            reservedunmarshal_VkImageSwapchainCreateInfoKHR(vkStream, rootType, reinterpret_cast<VkImageSwapchainCreateInfoKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            reservedunmarshal_VkBindImageMemorySwapchainInfoKHR(vkStream, rootType, reinterpret_cast<VkBindImageMemorySwapchainInfoKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            reservedunmarshal_VkDeviceGroupPresentInfoKHR(vkStream, rootType, reinterpret_cast<VkDeviceGroupPresentInfoKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            reservedunmarshal_VkDeviceGroupSwapchainCreateInfoKHR(vkStream, rootType, reinterpret_cast<VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            reservedunmarshal_VkDisplayPresentInfoKHR(vkStream, rootType, reinterpret_cast<VkDisplayPresentInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            reservedunmarshal_VkImportMemoryWin32HandleInfoKHR(vkStream, rootType, reinterpret_cast<VkImportMemoryWin32HandleInfoKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            reservedunmarshal_VkExportMemoryWin32HandleInfoKHR(vkStream, rootType, reinterpret_cast<VkExportMemoryWin32HandleInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            reservedunmarshal_VkImportMemoryFdInfoKHR(vkStream, rootType, reinterpret_cast<VkImportMemoryFdInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            reservedunmarshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(vkStream, rootType, reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            reservedunmarshal_VkExportSemaphoreWin32HandleInfoKHR(vkStream, rootType, reinterpret_cast<VkExportSemaphoreWin32HandleInfoKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            reservedunmarshal_VkD3D12FenceSubmitInfoKHR(vkStream, rootType, reinterpret_cast<VkD3D12FenceSubmitInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            reservedunmarshal_VkPhysicalDevicePushDescriptorPropertiesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            reservedunmarshal_VkPresentRegionsKHR(vkStream, rootType, reinterpret_cast<VkPresentRegionsKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            reservedunmarshal_VkSharedPresentSurfaceCapabilitiesKHR(vkStream, rootType, reinterpret_cast<VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            reservedunmarshal_VkExportFenceWin32HandleInfoKHR(vkStream, rootType, reinterpret_cast<VkExportFenceWin32HandleInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_performance_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            reservedunmarshal_VkPhysicalDevicePerformanceQueryFeaturesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDevicePerformanceQueryFeaturesKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {
            reservedunmarshal_VkPhysicalDevicePerformanceQueryPropertiesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDevicePerformanceQueryPropertiesKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
        {
            reservedunmarshal_VkQueryPoolPerformanceCreateInfoKHR(vkStream, rootType, reinterpret_cast<VkQueryPoolPerformanceCreateInfoKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            reservedunmarshal_VkPerformanceQuerySubmitInfoKHR(vkStream, rootType, reinterpret_cast<VkPerformanceQuerySubmitInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_portability_subset
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR:
        {
            reservedunmarshal_VkPhysicalDevicePortabilitySubsetFeaturesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDevicePortabilitySubsetFeaturesKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR:
        {
            reservedunmarshal_VkPhysicalDevicePortabilitySubsetPropertiesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDevicePortabilitySubsetPropertiesKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_shader_clock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            reservedunmarshal_VkPhysicalDeviceShaderClockFeaturesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderClockFeaturesKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_shader_terminate_invocation
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR:
        {
            reservedunmarshal_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_fragment_shading_rate
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
            reservedunmarshal_VkFragmentShadingRateAttachmentInfoKHR(vkStream, rootType, reinterpret_cast<VkFragmentShadingRateAttachmentInfoKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {
            reservedunmarshal_VkPipelineFragmentShadingRateStateCreateInfoKHR(vkStream, rootType, reinterpret_cast<VkPipelineFragmentShadingRateStateCreateInfoKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            reservedunmarshal_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFragmentShadingRateFeaturesKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {
            reservedunmarshal_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFragmentShadingRatePropertiesKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_surface_protected_capabilities
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
        {
            reservedunmarshal_VkSurfaceProtectedCapabilitiesKHR(vkStream, rootType, reinterpret_cast<VkSurfaceProtectedCapabilitiesKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_pipeline_executable_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            reservedunmarshal_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            reservedunmarshal_VkNativeBufferANDROID(vkStream, rootType, reinterpret_cast<VkNativeBufferANDROID*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkDebugReportCallbackCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkDebugReportCallbackCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            reservedunmarshal_VkPipelineRasterizationStateRasterizationOrderAMD(vkStream, rootType, reinterpret_cast<VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkDedicatedAllocationImageCreateInfoNV(vkStream, rootType, reinterpret_cast<VkDedicatedAllocationImageCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            reservedunmarshal_VkDedicatedAllocationBufferCreateInfoNV(vkStream, rootType, reinterpret_cast<VkDedicatedAllocationBufferCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            reservedunmarshal_VkDedicatedAllocationMemoryAllocateInfoNV(vkStream, rootType, reinterpret_cast<VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_transform_feedback
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceTransformFeedbackFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceTransformFeedbackPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineRasterizationStateStreamCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkPipelineRasterizationStateStreamCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            reservedunmarshal_VkTextureLODGatherFormatPropertiesAMD(vkStream, rootType, reinterpret_cast<VkTextureLODGatherFormatPropertiesAMD*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_corner_sampled_image
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceCornerSampledImageFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceCornerSampledImageFeaturesNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkExternalMemoryImageCreateInfoNV(vkStream, rootType, reinterpret_cast<VkExternalMemoryImageCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            reservedunmarshal_VkExportMemoryAllocateInfoNV(vkStream, rootType, reinterpret_cast<VkExportMemoryAllocateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            reservedunmarshal_VkImportMemoryWin32HandleInfoNV(vkStream, rootType, reinterpret_cast<VkImportMemoryWin32HandleInfoNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            reservedunmarshal_VkExportMemoryWin32HandleInfoNV(vkStream, rootType, reinterpret_cast<VkExportMemoryWin32HandleInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            reservedunmarshal_VkWin32KeyedMutexAcquireReleaseInfoNV(vkStream, rootType, reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            reservedunmarshal_VkValidationFlagsEXT(vkStream, rootType, reinterpret_cast<VkValidationFlagsEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_astc_decode_mode
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
        {
            reservedunmarshal_VkImageViewASTCDecodeModeEXT(vkStream, rootType, reinterpret_cast<VkImageViewASTCDecodeModeEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceASTCDecodeFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceASTCDecodeFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            reservedunmarshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(vkStream, rootType, reinterpret_cast<VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkPipelineViewportWScalingStateCreateInfoNV(vkStream, rootType, reinterpret_cast<VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkSwapchainCounterCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkSwapchainCounterCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            reservedunmarshal_VkPresentTimesInfoGOOGLE(vkStream, rootType, reinterpret_cast<VkPresentTimesInfoGOOGLE*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            reservedunmarshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkPipelineViewportSwizzleStateCreateInfoNV(vkStream, rootType, reinterpret_cast<VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineDiscardRectangleStateCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_depth_clip_enable
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceDepthClipEnableFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineRasterizationDepthClipStateCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkDebugUtilsMessengerCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkDebugUtilsMessengerCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            reservedunmarshal_VkAndroidHardwareBufferUsageANDROID(vkStream, rootType, reinterpret_cast<VkAndroidHardwareBufferUsageANDROID*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            reservedunmarshal_VkAndroidHardwareBufferFormatPropertiesANDROID(vkStream, rootType, reinterpret_cast<VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            reservedunmarshal_VkImportAndroidHardwareBufferInfoANDROID(vkStream, rootType, reinterpret_cast<VkImportAndroidHardwareBufferInfoANDROID*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            reservedunmarshal_VkExternalFormatANDROID(vkStream, rootType, reinterpret_cast<VkExternalFormatANDROID*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_inline_uniform_block
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceInlineUniformBlockFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceInlineUniformBlockPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
        {
            reservedunmarshal_VkWriteDescriptorSetInlineUniformBlockEXT(vkStream, rootType, reinterpret_cast<VkWriteDescriptorSetInlineUniformBlockEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkDescriptorPoolInlineUniformBlockCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            reservedunmarshal_VkSampleLocationsInfoEXT(vkStream, rootType, reinterpret_cast<VkSampleLocationsInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            reservedunmarshal_VkRenderPassSampleLocationsBeginInfoEXT(vkStream, rootType, reinterpret_cast<VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineSampleLocationsStateCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkPipelineCoverageToColorStateCreateInfoNV(vkStream, rootType, reinterpret_cast<VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkPipelineCoverageModulationStateCreateInfoNV(vkStream, rootType, reinterpret_cast<VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_shader_sm_builtins
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_image_drm_format_modifier
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
        {
            reservedunmarshal_VkDrmFormatModifierPropertiesListEXT(vkStream, rootType, reinterpret_cast<VkDrmFormatModifierPropertiesListEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkImageDrmFormatModifierListCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkImageDrmFormatModifierListCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkImageDrmFormatModifierExplicitCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkImageDrmFormatModifierExplicitCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkShaderModuleValidationCacheCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_shading_rate_image
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkPipelineViewportShadingRateImageStateCreateInfoNV(vkStream, rootType, reinterpret_cast<VkPipelineViewportShadingRateImageStateCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceShadingRateImageFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShadingRateImageFeaturesNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceShadingRateImagePropertiesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShadingRateImagePropertiesNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(vkStream, rootType, reinterpret_cast<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_ray_tracing
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
        {
            reservedunmarshal_VkWriteDescriptorSetAccelerationStructureNV(vkStream, rootType, reinterpret_cast<VkWriteDescriptorSetAccelerationStructureNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceRayTracingPropertiesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceRayTracingPropertiesNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_representative_fragment_test
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(vkStream, rootType, reinterpret_cast<VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_filter_cubic
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceImageViewImageFormatInfoEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceImageViewImageFormatInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {
            reservedunmarshal_VkFilterCubicImageViewImageFormatPropertiesEXT(vkStream, rootType, reinterpret_cast<VkFilterCubicImageViewImageFormatPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            reservedunmarshal_VkImportMemoryHostPointerInfoEXT(vkStream, rootType, reinterpret_cast<VkImportMemoryHostPointerInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_AMD_pipeline_compiler_control
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
            reservedunmarshal_VkPipelineCompilerControlCreateInfoAMD(vkStream, rootType, reinterpret_cast<VkPipelineCompilerControlCreateInfoAMD*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            reservedunmarshal_VkPhysicalDeviceShaderCorePropertiesAMD(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_AMD_memory_overallocation_behavior
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {
            reservedunmarshal_VkDeviceMemoryOverallocationCreateInfoAMD(vkStream, rootType, reinterpret_cast<VkDeviceMemoryOverallocationCreateInfoAMD*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_GGP_frame_token
        case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
        {
            reservedunmarshal_VkPresentFrameTokenGGP(vkStream, rootType, reinterpret_cast<VkPresentFrameTokenGGP*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_pipeline_creation_feedback
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineCreationFeedbackCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkPipelineCreationFeedbackCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_compute_shader_derivatives
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_mesh_shader
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceMeshShaderFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceMeshShaderFeaturesNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceMeshShaderPropertiesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceMeshShaderPropertiesNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_fragment_shader_barycentric
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_shader_image_footprint
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceShaderImageFootprintFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_scissor_exclusive
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkPipelineViewportExclusiveScissorStateCreateInfoNV(vkStream, rootType, reinterpret_cast<VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceExclusiveScissorFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceExclusiveScissorFeaturesNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            reservedunmarshal_VkQueueFamilyCheckpointPropertiesNV(vkStream, rootType, reinterpret_cast<VkQueueFamilyCheckpointPropertiesNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_INTEL_shader_integer_functions2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            reservedunmarshal_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_INTEL_performance_query
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
        {
            reservedunmarshal_VkQueryPoolPerformanceQueryCreateInfoINTEL(vkStream, rootType, reinterpret_cast<VkQueryPoolPerformanceQueryCreateInfoINTEL*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_pci_bus_info
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDevicePCIBusInfoPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDevicePCIBusInfoPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_AMD_display_native_hdr
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
        {
            reservedunmarshal_VkDisplayNativeHdrSurfaceCapabilitiesAMD(vkStream, rootType, reinterpret_cast<VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
        {
            reservedunmarshal_VkSwapchainDisplayNativeHdrCreateInfoAMD(vkStream, rootType, reinterpret_cast<VkSwapchainDisplayNativeHdrCreateInfoAMD*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_fragment_density_map
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
            switch(rootType)
            {
                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
                {
                    reservedunmarshal_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(structExtension_out), ptr);
                    break;
                }
                case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO:
                {
                    reservedunmarshal_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(structExtension_out), ptr);
                    break;
                }
                case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
                {
                    reservedunmarshal_VkImportColorBufferGOOGLE(vkStream, rootType, reinterpret_cast<VkImportColorBufferGOOGLE*>(structExtension_out), ptr);
                    break;
                }
                default:
                {
                    reservedunmarshal_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(structExtension_out), ptr);
                    break;
                }
            }
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
        {
            switch(rootType)
            {
                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2:
                {
                    reservedunmarshal_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(structExtension_out), ptr);
                    break;
                }
                case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
                {
                    reservedunmarshal_VkImportPhysicalAddressGOOGLE(vkStream, rootType, reinterpret_cast<VkImportPhysicalAddressGOOGLE*>(structExtension_out), ptr);
                    break;
                }
                default:
                {
                    reservedunmarshal_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(structExtension_out), ptr);
                    break;
                }
            }
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
        {
            switch(rootType)
            {
                case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO:
                {
                    reservedunmarshal_VkRenderPassFragmentDensityMapCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkRenderPassFragmentDensityMapCreateInfoEXT*>(structExtension_out), ptr);
                    break;
                }
                case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2:
                {
                    reservedunmarshal_VkRenderPassFragmentDensityMapCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkRenderPassFragmentDensityMapCreateInfoEXT*>(structExtension_out), ptr);
                    break;
                }
                case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
                {
                    reservedunmarshal_VkImportBufferGOOGLE(vkStream, rootType, reinterpret_cast<VkImportBufferGOOGLE*>(structExtension_out), ptr);
                    break;
                }
                default:
                {
                    reservedunmarshal_VkRenderPassFragmentDensityMapCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkRenderPassFragmentDensityMapCreateInfoEXT*>(structExtension_out), ptr);
                    break;
                }
            }
            break;
        }
#endif
#ifdef VK_EXT_subgroup_size_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {
            reservedunmarshal_VkPhysicalDeviceShaderCoreProperties2AMD(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderCoreProperties2AMD*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_AMD_device_coherent_memory
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            reservedunmarshal_VkPhysicalDeviceCoherentMemoryFeaturesAMD(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_shader_image_atomic_int64
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_memory_budget
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceMemoryBudgetPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_memory_priority
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceMemoryPriorityFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {
            reservedunmarshal_VkMemoryPriorityAllocateInfoEXT(vkStream, rootType, reinterpret_cast<VkMemoryPriorityAllocateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_buffer_device_address
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkBufferDeviceAddressCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkBufferDeviceAddressCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_validation_features
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
            reservedunmarshal_VkValidationFeaturesEXT(vkStream, rootType, reinterpret_cast<VkValidationFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_cooperative_matrix
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceCooperativeMatrixFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceCooperativeMatrixPropertiesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_coverage_reduction_mode
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceCoverageReductionModeFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkPipelineCoverageReductionStateCreateInfoNV(vkStream, rootType, reinterpret_cast<VkPipelineCoverageReductionStateCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_fragment_shader_interlock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_ycbcr_image_arrays
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_full_screen_exclusive
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
        {
            reservedunmarshal_VkSurfaceFullScreenExclusiveInfoEXT(vkStream, rootType, reinterpret_cast<VkSurfaceFullScreenExclusiveInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
        {
            reservedunmarshal_VkSurfaceCapabilitiesFullScreenExclusiveEXT(vkStream, rootType, reinterpret_cast<VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
        {
            reservedunmarshal_VkSurfaceFullScreenExclusiveWin32InfoEXT(vkStream, rootType, reinterpret_cast<VkSurfaceFullScreenExclusiveWin32InfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_line_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineRasterizationLineStateCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_shader_atomic_float
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_index_type_uint8
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceIndexTypeUint8FeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_device_generated_commands
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {
            reservedunmarshal_VkGraphicsPipelineShaderGroupsCreateInfoNV(vkStream, rootType, reinterpret_cast<VkGraphicsPipelineShaderGroupsCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_texel_buffer_alignment
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_QCOM_render_pass_transform
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
        {
            reservedunmarshal_VkRenderPassTransformBeginInfoQCOM(vkStream, rootType, reinterpret_cast<VkRenderPassTransformBeginInfoQCOM*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
        {
            reservedunmarshal_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(vkStream, rootType, reinterpret_cast<VkCommandBufferInheritanceRenderPassTransformInfoQCOM*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_device_memory_report
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkDeviceDeviceMemoryReportCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkDeviceDeviceMemoryReportCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_robustness2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceRobustness2FeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceRobustness2FeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceRobustness2PropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceRobustness2PropertiesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_custom_border_color
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkSamplerCustomBorderColorCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkSamplerCustomBorderColorCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceCustomBorderColorPropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceCustomBorderColorPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceCustomBorderColorFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_private_data
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDevicePrivateDataFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDevicePrivateDataFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkDevicePrivateDataCreateInfoEXT(vkStream, rootType, reinterpret_cast<VkDevicePrivateDataCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_pipeline_creation_cache_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_device_diagnostics_config
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceDiagnosticsConfigFeaturesNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {
            reservedunmarshal_VkDeviceDiagnosticsConfigCreateInfoNV(vkStream, rootType, reinterpret_cast<VkDeviceDiagnosticsConfigCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_fragment_shading_rate_enums
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {
            reservedunmarshal_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(vkStream, rootType, reinterpret_cast<VkPipelineFragmentShadingRateEnumStateCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_fragment_density_map2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_QCOM_rotated_copy_commands
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {
            reservedunmarshal_VkCopyCommandTransformInfoQCOM(vkStream, rootType, reinterpret_cast<VkCopyCommandTransformInfoQCOM*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_image_robustness
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceImageRobustnessFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceImageRobustnessFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_4444_formats
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDevice4444FormatsFeaturesEXT(vkStream, rootType, reinterpret_cast<VkPhysicalDevice4444FormatsFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_GOOGLE_gfxstream
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE:
        {
            reservedunmarshal_VkImportColorBufferGOOGLE(vkStream, rootType, reinterpret_cast<VkImportColorBufferGOOGLE*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_BUFFER_GOOGLE:
        {
            reservedunmarshal_VkImportBufferGOOGLE(vkStream, rootType, reinterpret_cast<VkImportBufferGOOGLE*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE:
        {
            reservedunmarshal_VkImportPhysicalAddressGOOGLE(vkStream, rootType, reinterpret_cast<VkImportPhysicalAddressGOOGLE*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
        {
            reservedunmarshal_VkWriteDescriptorSetAccelerationStructureKHR(vkStream, rootType, reinterpret_cast<VkWriteDescriptorSetAccelerationStructureKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            reservedunmarshal_VkPhysicalDeviceAccelerationStructureFeaturesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceAccelerationStructureFeaturesKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {
            reservedunmarshal_VkPhysicalDeviceAccelerationStructurePropertiesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceAccelerationStructurePropertiesKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            reservedunmarshal_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceRayTracingPipelineFeaturesKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {
            reservedunmarshal_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceRayTracingPipelinePropertiesKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_ray_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            reservedunmarshal_VkPhysicalDeviceRayQueryFeaturesKHR(vkStream, rootType, reinterpret_cast<VkPhysicalDeviceRayQueryFeaturesKHR*>(structExtension_out), ptr);
            break;
        }
#endif
        default:
        {
            // fatal; the switch is only taken if the extension struct is known
            abort();
        }
    }
}


} // namespace goldfish_vk
