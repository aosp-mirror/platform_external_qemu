// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_reserved_marshaling
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "goldfish_vk_reserved_marshaling.h"


#include "goldfish_vk_extension_structs.h"
#include "goldfish_vk_private_defs.h"


namespace goldfish_vk {

void reservedmarshal_extension_struct(
    VulkanStream* vkStream,
    const void* structExtension,
    uint8_t** ptr);

void reservedunmarshal_extension_struct(
    VulkanStream* vkStream,
    void* structExtension_out,
    uint8_t** ptr);

#ifdef VK_VERSION_1_0
void reservedunmarshal_VkApplicationInfo(
    VulkanStream* vkStream,
    VkApplicationInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        memcpy((char**)&forUnmarshaling->pApplicationName, (*ptr), 8);
        android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pApplicationName);
        *ptr += 8;
        if (forUnmarshaling->pApplicationName)
        {
            vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pApplicationName, ptr);
        }
    }
    else
    {
        vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pApplicationName, ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->applicationVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        memcpy((char**)&forUnmarshaling->pEngineName, (*ptr), 8);
        android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pEngineName);
        *ptr += 8;
        if (forUnmarshaling->pEngineName)
        {
            vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pEngineName, ptr);
        }
    }
    else
    {
        vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pEngineName, ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->engineVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->apiVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkInstanceCreateInfo(
    VulkanStream* vkStream,
    VkInstanceCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkInstanceCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkInstanceCreateFlags));
    *ptr += sizeof(VkInstanceCreateFlags);
    // WARNING PTR CHECK
    memcpy((VkApplicationInfo**)&forUnmarshaling->pApplicationInfo, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pApplicationInfo);
    *ptr += 8;
    if (forUnmarshaling->pApplicationInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pApplicationInfo, sizeof(const VkApplicationInfo));
        reservedunmarshal_VkApplicationInfo(vkStream, (VkApplicationInfo*)(forUnmarshaling->pApplicationInfo), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->enabledLayerCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->loadStringArrayInPlaceWithStreamPtr((char***)&forUnmarshaling->ppEnabledLayerNames, ptr);
    memcpy((uint32_t*)&forUnmarshaling->enabledExtensionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->loadStringArrayInPlaceWithStreamPtr((char***)&forUnmarshaling->ppEnabledExtensionNames, ptr);
}

void reservedunmarshal_VkAllocationCallbacks(
    VulkanStream* vkStream,
    VkAllocationCallbacks* forUnmarshaling,
    uint8_t** ptr)
{
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pUserData, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pUserData);
    *ptr += 8;
    if (forUnmarshaling->pUserData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
        memcpy((void*)forUnmarshaling->pUserData, *ptr, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
    memcpy((PFN_vkAllocationFunction*)&forUnmarshaling->pfnAllocation, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnAllocation);
    *ptr += 8;
    memcpy((PFN_vkReallocationFunction*)&forUnmarshaling->pfnReallocation, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnReallocation);
    *ptr += 8;
    memcpy((PFN_vkFreeFunction*)&forUnmarshaling->pfnFree, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnFree);
    *ptr += 8;
    memcpy((PFN_vkInternalAllocationNotification*)&forUnmarshaling->pfnInternalAllocation, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnInternalAllocation);
    *ptr += 8;
    memcpy((PFN_vkInternalFreeNotification*)&forUnmarshaling->pfnInternalFree, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnInternalFree);
    *ptr += 8;
}

void reservedunmarshal_VkPhysicalDeviceFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkBool32*)&forUnmarshaling->robustBufferAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fullDrawIndexUint32, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->imageCubeArray, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->independentBlend, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->geometryShader, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->tessellationShader, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sampleRateShading, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->dualSrcBlend, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->logicOp, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->multiDrawIndirect, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->drawIndirectFirstInstance, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->depthClamp, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->depthBiasClamp, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fillModeNonSolid, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->depthBounds, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->wideLines, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->largePoints, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->alphaToOne, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->multiViewport, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->samplerAnisotropy, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->textureCompressionETC2, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->textureCompressionASTC_LDR, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->textureCompressionBC, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->occlusionQueryPrecise, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->pipelineStatisticsQuery, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->vertexPipelineStoresAndAtomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fragmentStoresAndAtomics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderTessellationAndGeometryPointSize, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderImageGatherExtended, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageExtendedFormats, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageMultisample, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageReadWithoutFormat, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageWriteWithoutFormat, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSampledImageArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderClipDistance, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderCullDistance, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderFloat64, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderInt64, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderInt16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderResourceResidency, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderResourceMinLod, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseBinding, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidencyBuffer, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidencyImage2D, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidencyImage3D, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidency2Samples, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidency4Samples, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidency8Samples, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidency16Samples, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->sparseResidencyAliased, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->variableMultisampleRate, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->inheritedQueries, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkFormatProperties(
    VulkanStream* vkStream,
    VkFormatProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkFormatFeatureFlags*)&forUnmarshaling->linearTilingFeatures, *ptr, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
    memcpy((VkFormatFeatureFlags*)&forUnmarshaling->optimalTilingFeatures, *ptr, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
    memcpy((VkFormatFeatureFlags*)&forUnmarshaling->bufferFeatures, *ptr, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
}

void reservedunmarshal_VkExtent3D(
    VulkanStream* vkStream,
    VkExtent3D* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->width, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->height, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->depth, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkImageFormatProperties(
    VulkanStream* vkStream,
    VkImageFormatProperties* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->maxExtent), ptr);
    memcpy((uint32_t*)&forUnmarshaling->maxMipLevels, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxArrayLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->sampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkDeviceSize*)&forUnmarshaling->maxResourceSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkPhysicalDeviceLimits(
    VulkanStream* vkStream,
    VkPhysicalDeviceLimits* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->maxImageDimension1D, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxImageDimension2D, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxImageDimension3D, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxImageDimensionCube, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxImageArrayLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTexelBufferElements, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxUniformBufferRange, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxStorageBufferRange, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPushConstantsSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxMemoryAllocationCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxSamplerAllocationCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDeviceSize*)&forUnmarshaling->bufferImageGranularity, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->sparseAddressSpaceSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->maxBoundDescriptorSets, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorSamplers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUniformBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorStorageBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorSampledImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorStorageImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorInputAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageResources, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetSamplers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUniformBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUniformBuffersDynamic, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageBuffersDynamic, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetSampledImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetInputAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxVertexInputAttributes, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxVertexInputBindings, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxVertexInputAttributeOffset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxVertexInputBindingStride, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxVertexOutputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationGenerationLevel, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationPatchSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationControlPerVertexInputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationControlPerVertexOutputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationControlPerPatchOutputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationControlTotalOutputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationEvaluationInputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTessellationEvaluationOutputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxGeometryShaderInvocations, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxGeometryInputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxGeometryOutputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxGeometryOutputVertices, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxGeometryTotalOutputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFragmentInputComponents, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFragmentOutputAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFragmentDualSrcAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFragmentCombinedOutputResources, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxComputeSharedMemorySize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)forUnmarshaling->maxComputeWorkGroupCount, *ptr, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxComputeWorkGroupInvocations, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)forUnmarshaling->maxComputeWorkGroupSize, *ptr, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->subPixelPrecisionBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->subTexelPrecisionBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->mipmapPrecisionBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDrawIndexedIndexValue, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDrawIndirectCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((float*)&forUnmarshaling->maxSamplerLodBias, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxSamplerAnisotropy, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((uint32_t*)&forUnmarshaling->maxViewports, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)forUnmarshaling->maxViewportDimensions, *ptr, 2 * sizeof(uint32_t));
    *ptr += 2 * sizeof(uint32_t);
    memcpy((float*)forUnmarshaling->viewportBoundsRange, *ptr, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy((uint32_t*)&forUnmarshaling->viewportSubPixelBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((size_t*)&forUnmarshaling->minMemoryMapAlignment, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->minMemoryMapAlignment);
    *ptr += 8;
    memcpy((VkDeviceSize*)&forUnmarshaling->minTexelBufferOffsetAlignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->minUniformBufferOffsetAlignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->minStorageBufferOffsetAlignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((int32_t*)&forUnmarshaling->minTexelOffset, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTexelOffset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((int32_t*)&forUnmarshaling->minTexelGatherOffset, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxTexelGatherOffset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((float*)&forUnmarshaling->minInterpolationOffset, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxInterpolationOffset, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((uint32_t*)&forUnmarshaling->subPixelInterpolationOffsetBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFramebufferWidth, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFramebufferHeight, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxFramebufferLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->framebufferColorSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->framebufferDepthSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->framebufferStencilSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->framebufferNoAttachmentsSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((uint32_t*)&forUnmarshaling->maxColorAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->sampledImageColorSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->sampledImageIntegerSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->sampledImageDepthSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->sampledImageStencilSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((VkSampleCountFlags*)&forUnmarshaling->storageImageSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy((uint32_t*)&forUnmarshaling->maxSampleMaskWords, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->timestampComputeAndGraphics, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((float*)&forUnmarshaling->timestampPeriod, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((uint32_t*)&forUnmarshaling->maxClipDistances, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxCullDistances, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxCombinedClipAndCullDistances, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->discreteQueuePriorities, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((float*)forUnmarshaling->pointSizeRange, *ptr, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy((float*)forUnmarshaling->lineWidthRange, *ptr, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy((float*)&forUnmarshaling->pointSizeGranularity, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->lineWidthGranularity, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((VkBool32*)&forUnmarshaling->strictLines, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->standardSampleLocations, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkDeviceSize*)&forUnmarshaling->optimalBufferCopyOffsetAlignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->optimalBufferCopyRowPitchAlignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->nonCoherentAtomSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkPhysicalDeviceSparseProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceSparseProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkBool32*)&forUnmarshaling->residencyStandard2DBlockShape, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->residencyStandard2DMultisampleBlockShape, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->residencyStandard3DBlockShape, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->residencyAlignedMipSize, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->residencyNonResidentStrict, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->apiVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->driverVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->vendorID, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->deviceID, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkPhysicalDeviceType*)&forUnmarshaling->deviceType, *ptr, sizeof(VkPhysicalDeviceType));
    *ptr += sizeof(VkPhysicalDeviceType);
    memcpy((char*)forUnmarshaling->deviceName, *ptr, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char);
    memcpy((uint8_t*)forUnmarshaling->pipelineCacheUUID, *ptr, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    reservedunmarshal_VkPhysicalDeviceLimits(vkStream, (VkPhysicalDeviceLimits*)(&forUnmarshaling->limits), ptr);
    reservedunmarshal_VkPhysicalDeviceSparseProperties(vkStream, (VkPhysicalDeviceSparseProperties*)(&forUnmarshaling->sparseProperties), ptr);
}

void reservedunmarshal_VkQueueFamilyProperties(
    VulkanStream* vkStream,
    VkQueueFamilyProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkQueueFlags*)&forUnmarshaling->queueFlags, *ptr, sizeof(VkQueueFlags));
    *ptr += sizeof(VkQueueFlags);
    memcpy((uint32_t*)&forUnmarshaling->queueCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->timestampValidBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->minImageTransferGranularity), ptr);
}

void reservedunmarshal_VkMemoryType(
    VulkanStream* vkStream,
    VkMemoryType* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkMemoryPropertyFlags*)&forUnmarshaling->propertyFlags, *ptr, sizeof(VkMemoryPropertyFlags));
    *ptr += sizeof(VkMemoryPropertyFlags);
    memcpy((uint32_t*)&forUnmarshaling->heapIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkMemoryHeap(
    VulkanStream* vkStream,
    VkMemoryHeap* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkMemoryHeapFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkMemoryHeapFlags));
    *ptr += sizeof(VkMemoryHeapFlags);
}

void reservedunmarshal_VkPhysicalDeviceMemoryProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceMemoryProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->memoryTypeCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        reservedunmarshal_VkMemoryType(vkStream, (VkMemoryType*)(forUnmarshaling->memoryTypes + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->memoryHeapCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        reservedunmarshal_VkMemoryHeap(vkStream, (VkMemoryHeap*)(forUnmarshaling->memoryHeaps + i), ptr);
    }
}

void reservedunmarshal_VkDeviceQueueCreateInfo(
    VulkanStream* vkStream,
    VkDeviceQueueCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceQueueCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkDeviceQueueCreateFlags));
    *ptr += sizeof(VkDeviceQueueCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->queueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->queueCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pQueuePriorities, forUnmarshaling->queueCount * sizeof(const float));
    memcpy((float*)forUnmarshaling->pQueuePriorities, *ptr, forUnmarshaling->queueCount * sizeof(const float));
    *ptr += forUnmarshaling->queueCount * sizeof(const float);
}

void reservedunmarshal_VkDeviceCreateInfo(
    VulkanStream* vkStream,
    VkDeviceCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkDeviceCreateFlags));
    *ptr += sizeof(VkDeviceCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->queueCreateInfoCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pQueueCreateInfos, forUnmarshaling->queueCreateInfoCount * sizeof(const VkDeviceQueueCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->queueCreateInfoCount; ++i)
    {
        reservedunmarshal_VkDeviceQueueCreateInfo(vkStream, (VkDeviceQueueCreateInfo*)(forUnmarshaling->pQueueCreateInfos + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->enabledLayerCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->loadStringArrayInPlaceWithStreamPtr((char***)&forUnmarshaling->ppEnabledLayerNames, ptr);
    memcpy((uint32_t*)&forUnmarshaling->enabledExtensionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->loadStringArrayInPlaceWithStreamPtr((char***)&forUnmarshaling->ppEnabledExtensionNames, ptr);
    // WARNING PTR CHECK
    memcpy((VkPhysicalDeviceFeatures**)&forUnmarshaling->pEnabledFeatures, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pEnabledFeatures);
    *ptr += 8;
    if (forUnmarshaling->pEnabledFeatures)
    {
        vkStream->alloc((void**)&forUnmarshaling->pEnabledFeatures, sizeof(const VkPhysicalDeviceFeatures));
        reservedunmarshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(forUnmarshaling->pEnabledFeatures), ptr);
    }
}

void reservedunmarshal_VkExtensionProperties(
    VulkanStream* vkStream,
    VkExtensionProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((char*)forUnmarshaling->extensionName, *ptr, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    memcpy((uint32_t*)&forUnmarshaling->specVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkLayerProperties(
    VulkanStream* vkStream,
    VkLayerProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((char*)forUnmarshaling->layerName, *ptr, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    memcpy((uint32_t*)&forUnmarshaling->specVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->implementationVersion, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((char*)forUnmarshaling->description, *ptr, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
}

void reservedunmarshal_VkSubmitInfo(
    VulkanStream* vkStream,
    VkSubmitInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->waitSemaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->waitSemaphoreCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->waitSemaphoreCount;
        for (uint32_t k = 0; k < forUnmarshaling->waitSemaphoreCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
            *(((VkSemaphore*)forUnmarshaling->pWaitSemaphores) + k) = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)tmpval);
        }
    }
    vkStream->alloc((void**)&forUnmarshaling->pWaitDstStageMask, forUnmarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    memcpy((VkPipelineStageFlags*)forUnmarshaling->pWaitDstStageMask, *ptr, forUnmarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    *ptr += forUnmarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags);
    memcpy((uint32_t*)&forUnmarshaling->commandBufferCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pCommandBuffers, forUnmarshaling->commandBufferCount * sizeof(const VkCommandBuffer));
    if (forUnmarshaling->commandBufferCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->commandBufferCount;
        for (uint32_t k = 0; k < forUnmarshaling->commandBufferCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
            *(((VkCommandBuffer*)forUnmarshaling->pCommandBuffers) + k) = (VkCommandBuffer)unbox_VkCommandBuffer((VkCommandBuffer)tmpval);
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->signalSemaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphores, forUnmarshaling->signalSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->signalSemaphoreCount)
    {
        uint8_t* cgen_var_2_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->signalSemaphoreCount;
        for (uint32_t k = 0; k < forUnmarshaling->signalSemaphoreCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_2_ptr + k * 8, sizeof(uint64_t));
            *(((VkSemaphore*)forUnmarshaling->pSignalSemaphores) + k) = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)tmpval);
        }
    }
}

void reservedunmarshal_VkMemoryAllocateInfo(
    VulkanStream* vkStream,
    VkMemoryAllocateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceSize*)&forUnmarshaling->allocationSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->memoryTypeIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkMappedMemoryRange(
    VulkanStream* vkStream,
    VkMappedMemoryRange* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkMemoryRequirements(
    VulkanStream* vkStream,
    VkMemoryRequirements* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->alignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->memoryTypeBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkSparseImageFormatProperties(
    VulkanStream* vkStream,
    VkSparseImageFormatProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkImageAspectFlags*)&forUnmarshaling->aspectMask, *ptr, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    reservedunmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->imageGranularity), ptr);
    memcpy((VkSparseImageFormatFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSparseImageFormatFlags));
    *ptr += sizeof(VkSparseImageFormatFlags);
}

void reservedunmarshal_VkSparseImageMemoryRequirements(
    VulkanStream* vkStream,
    VkSparseImageMemoryRequirements* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forUnmarshaling->formatProperties), ptr);
    memcpy((uint32_t*)&forUnmarshaling->imageMipTailFirstLod, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDeviceSize*)&forUnmarshaling->imageMipTailSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->imageMipTailOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->imageMipTailStride, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkSparseMemoryBind(
    VulkanStream* vkStream,
    VkSparseMemoryBind* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceSize*)&forUnmarshaling->resourceOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->memoryOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkSparseMemoryBindFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSparseMemoryBindFlags));
    *ptr += sizeof(VkSparseMemoryBindFlags);
}

void reservedunmarshal_VkSparseBufferMemoryBindInfo(
    VulkanStream* vkStream,
    VkSparseBufferMemoryBindInfo* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->bindCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pBinds, forUnmarshaling->bindCount * sizeof(const VkSparseMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        reservedunmarshal_VkSparseMemoryBind(vkStream, (VkSparseMemoryBind*)(forUnmarshaling->pBinds + i), ptr);
    }
}

void reservedunmarshal_VkSparseImageOpaqueMemoryBindInfo(
    VulkanStream* vkStream,
    VkSparseImageOpaqueMemoryBindInfo* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->bindCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pBinds, forUnmarshaling->bindCount * sizeof(const VkSparseMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        reservedunmarshal_VkSparseMemoryBind(vkStream, (VkSparseMemoryBind*)(forUnmarshaling->pBinds + i), ptr);
    }
}

void reservedunmarshal_VkImageSubresource(
    VulkanStream* vkStream,
    VkImageSubresource* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkImageAspectFlags*)&forUnmarshaling->aspectMask, *ptr, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy((uint32_t*)&forUnmarshaling->mipLevel, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->arrayLayer, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkOffset3D(
    VulkanStream* vkStream,
    VkOffset3D* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((int32_t*)&forUnmarshaling->x, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy((int32_t*)&forUnmarshaling->y, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy((int32_t*)&forUnmarshaling->z, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedunmarshal_VkSparseImageMemoryBind(
    VulkanStream* vkStream,
    VkSparseImageMemoryBind* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkImageSubresource(vkStream, (VkImageSubresource*)(&forUnmarshaling->subresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->offset), ptr);
    reservedunmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent), ptr);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->memoryOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkSparseMemoryBindFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSparseMemoryBindFlags));
    *ptr += sizeof(VkSparseMemoryBindFlags);
}

void reservedunmarshal_VkSparseImageMemoryBindInfo(
    VulkanStream* vkStream,
    VkSparseImageMemoryBindInfo* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->bindCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pBinds, forUnmarshaling->bindCount * sizeof(const VkSparseImageMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        reservedunmarshal_VkSparseImageMemoryBind(vkStream, (VkSparseImageMemoryBind*)(forUnmarshaling->pBinds + i), ptr);
    }
}

void reservedunmarshal_VkBindSparseInfo(
    VulkanStream* vkStream,
    VkBindSparseInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->waitSemaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->waitSemaphoreCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->waitSemaphoreCount;
        for (uint32_t k = 0; k < forUnmarshaling->waitSemaphoreCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
            *(((VkSemaphore*)forUnmarshaling->pWaitSemaphores) + k) = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)tmpval);
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->bufferBindCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pBufferBinds, forUnmarshaling->bufferBindCount * sizeof(const VkSparseBufferMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bufferBindCount; ++i)
    {
        reservedunmarshal_VkSparseBufferMemoryBindInfo(vkStream, (VkSparseBufferMemoryBindInfo*)(forUnmarshaling->pBufferBinds + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->imageOpaqueBindCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pImageOpaqueBinds, forUnmarshaling->imageOpaqueBindCount * sizeof(const VkSparseImageOpaqueMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->imageOpaqueBindCount; ++i)
    {
        reservedunmarshal_VkSparseImageOpaqueMemoryBindInfo(vkStream, (VkSparseImageOpaqueMemoryBindInfo*)(forUnmarshaling->pImageOpaqueBinds + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->imageBindCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pImageBinds, forUnmarshaling->imageBindCount * sizeof(const VkSparseImageMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->imageBindCount; ++i)
    {
        reservedunmarshal_VkSparseImageMemoryBindInfo(vkStream, (VkSparseImageMemoryBindInfo*)(forUnmarshaling->pImageBinds + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->signalSemaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphores, forUnmarshaling->signalSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->signalSemaphoreCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->signalSemaphoreCount;
        for (uint32_t k = 0; k < forUnmarshaling->signalSemaphoreCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
            *(((VkSemaphore*)forUnmarshaling->pSignalSemaphores) + k) = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)tmpval);
        }
    }
}

void reservedunmarshal_VkFenceCreateInfo(
    VulkanStream* vkStream,
    VkFenceCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFenceCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkFenceCreateFlags));
    *ptr += sizeof(VkFenceCreateFlags);
}

void reservedunmarshal_VkSemaphoreCreateInfo(
    VulkanStream* vkStream,
    VkSemaphoreCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSemaphoreCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSemaphoreCreateFlags));
    *ptr += sizeof(VkSemaphoreCreateFlags);
}

void reservedunmarshal_VkEventCreateInfo(
    VulkanStream* vkStream,
    VkEventCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkEventCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkEventCreateFlags));
    *ptr += sizeof(VkEventCreateFlags);
}

void reservedunmarshal_VkQueryPoolCreateInfo(
    VulkanStream* vkStream,
    VkQueryPoolCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkQueryPoolCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkQueryPoolCreateFlags));
    *ptr += sizeof(VkQueryPoolCreateFlags);
    memcpy((VkQueryType*)&forUnmarshaling->queryType, *ptr, sizeof(VkQueryType));
    *ptr += sizeof(VkQueryType);
    memcpy((uint32_t*)&forUnmarshaling->queryCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkQueryPipelineStatisticFlags*)&forUnmarshaling->pipelineStatistics, *ptr, sizeof(VkQueryPipelineStatisticFlags));
    *ptr += sizeof(VkQueryPipelineStatisticFlags);
}

void reservedunmarshal_VkBufferCreateInfo(
    VulkanStream* vkStream,
    VkBufferCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBufferCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkBufferCreateFlags));
    *ptr += sizeof(VkBufferCreateFlags);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkBufferUsageFlags*)&forUnmarshaling->usage, *ptr, sizeof(VkBufferUsageFlags));
    *ptr += sizeof(VkBufferUsageFlags);
    memcpy((VkSharingMode*)&forUnmarshaling->sharingMode, *ptr, sizeof(VkSharingMode));
    *ptr += sizeof(VkSharingMode);
    memcpy((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((uint32_t**)&forUnmarshaling->pQueueFamilyIndices, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pQueueFamilyIndices);
    *ptr += 8;
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        memcpy((uint32_t*)forUnmarshaling->pQueueFamilyIndices, *ptr, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        *ptr += forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t);
    }
}

void reservedunmarshal_VkBufferViewCreateInfo(
    VulkanStream* vkStream,
    VkBufferViewCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBufferViewCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkBufferViewCreateFlags));
    *ptr += sizeof(VkBufferViewCreateFlags);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->range, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkImageCreateInfo(
    VulkanStream* vkStream,
    VkImageCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkImageCreateFlags));
    *ptr += sizeof(VkImageCreateFlags);
    memcpy((VkImageType*)&forUnmarshaling->imageType, *ptr, sizeof(VkImageType));
    *ptr += sizeof(VkImageType);
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    reservedunmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent), ptr);
    memcpy((uint32_t*)&forUnmarshaling->mipLevels, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->arrayLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->samples, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy((VkImageTiling*)&forUnmarshaling->tiling, *ptr, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
    memcpy((VkImageUsageFlags*)&forUnmarshaling->usage, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy((VkSharingMode*)&forUnmarshaling->sharingMode, *ptr, sizeof(VkSharingMode));
    *ptr += sizeof(VkSharingMode);
    memcpy((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((uint32_t**)&forUnmarshaling->pQueueFamilyIndices, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pQueueFamilyIndices);
    *ptr += 8;
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        memcpy((uint32_t*)forUnmarshaling->pQueueFamilyIndices, *ptr, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        *ptr += forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t);
    }
    memcpy((VkImageLayout*)&forUnmarshaling->initialLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedunmarshal_VkSubresourceLayout(
    VulkanStream* vkStream,
    VkSubresourceLayout* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->rowPitch, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->arrayPitch, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->depthPitch, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkComponentMapping(
    VulkanStream* vkStream,
    VkComponentMapping* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkComponentSwizzle*)&forUnmarshaling->r, *ptr, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
    memcpy((VkComponentSwizzle*)&forUnmarshaling->g, *ptr, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
    memcpy((VkComponentSwizzle*)&forUnmarshaling->b, *ptr, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
    memcpy((VkComponentSwizzle*)&forUnmarshaling->a, *ptr, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
}

void reservedunmarshal_VkImageSubresourceRange(
    VulkanStream* vkStream,
    VkImageSubresourceRange* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkImageAspectFlags*)&forUnmarshaling->aspectMask, *ptr, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy((uint32_t*)&forUnmarshaling->baseMipLevel, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->levelCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->baseArrayLayer, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->layerCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkImageViewCreateInfo(
    VulkanStream* vkStream,
    VkImageViewCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageViewCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkImageViewCreateFlags));
    *ptr += sizeof(VkImageViewCreateFlags);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    memcpy((VkImageViewType*)&forUnmarshaling->viewType, *ptr, sizeof(VkImageViewType));
    *ptr += sizeof(VkImageViewType);
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    reservedunmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forUnmarshaling->components), ptr);
    reservedunmarshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forUnmarshaling->subresourceRange), ptr);
}

void reservedunmarshal_VkShaderModuleCreateInfo(
    VulkanStream* vkStream,
    VkShaderModuleCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkShaderModuleCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkShaderModuleCreateFlags));
    *ptr += sizeof(VkShaderModuleCreateFlags);
    memcpy((size_t*)&forUnmarshaling->codeSize, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->codeSize);
    *ptr += 8;
    vkStream->alloc((void**)&forUnmarshaling->pCode, (forUnmarshaling->codeSize / 4) * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pCode, *ptr, (forUnmarshaling->codeSize / 4) * sizeof(const uint32_t));
    *ptr += (forUnmarshaling->codeSize / 4) * sizeof(const uint32_t);
}

void reservedunmarshal_VkPipelineCacheCreateInfo(
    VulkanStream* vkStream,
    VkPipelineCacheCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineCacheCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineCacheCreateFlags));
    *ptr += sizeof(VkPipelineCacheCreateFlags);
    memcpy((size_t*)&forUnmarshaling->initialDataSize, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->initialDataSize);
    *ptr += 8;
    vkStream->alloc((void**)&forUnmarshaling->pInitialData, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
    memcpy((void*)forUnmarshaling->pInitialData, *ptr, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
    *ptr += forUnmarshaling->initialDataSize * sizeof(const uint8_t);
}

void reservedunmarshal_VkSpecializationMapEntry(
    VulkanStream* vkStream,
    VkSpecializationMapEntry* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->constantID, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->offset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((size_t*)&forUnmarshaling->size, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->size);
    *ptr += 8;
}

void reservedunmarshal_VkSpecializationInfo(
    VulkanStream* vkStream,
    VkSpecializationInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->mapEntryCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pMapEntries, forUnmarshaling->mapEntryCount * sizeof(const VkSpecializationMapEntry));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->mapEntryCount; ++i)
    {
        reservedunmarshal_VkSpecializationMapEntry(vkStream, (VkSpecializationMapEntry*)(forUnmarshaling->pMapEntries + i), ptr);
    }
    memcpy((size_t*)&forUnmarshaling->dataSize, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->dataSize);
    *ptr += 8;
    vkStream->alloc((void**)&forUnmarshaling->pData, forUnmarshaling->dataSize * sizeof(const uint8_t));
    memcpy((void*)forUnmarshaling->pData, *ptr, forUnmarshaling->dataSize * sizeof(const uint8_t));
    *ptr += forUnmarshaling->dataSize * sizeof(const uint8_t);
}

void reservedunmarshal_VkPipelineShaderStageCreateInfo(
    VulkanStream* vkStream,
    VkPipelineShaderStageCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineShaderStageCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineShaderStageCreateFlags));
    *ptr += sizeof(VkPipelineShaderStageCreateFlags);
    memcpy((VkShaderStageFlagBits*)&forUnmarshaling->stage, *ptr, sizeof(VkShaderStageFlagBits));
    *ptr += sizeof(VkShaderStageFlagBits);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkShaderModule*)&forUnmarshaling->module = (VkShaderModule)unbox_VkShaderModule((VkShaderModule)(*&cgen_var_0));
    vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pName, ptr);
    // WARNING PTR CHECK
    memcpy((VkSpecializationInfo**)&forUnmarshaling->pSpecializationInfo, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pSpecializationInfo);
    *ptr += 8;
    if (forUnmarshaling->pSpecializationInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pSpecializationInfo, sizeof(const VkSpecializationInfo));
        reservedunmarshal_VkSpecializationInfo(vkStream, (VkSpecializationInfo*)(forUnmarshaling->pSpecializationInfo), ptr);
    }
}

void reservedunmarshal_VkVertexInputBindingDescription(
    VulkanStream* vkStream,
    VkVertexInputBindingDescription* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->binding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->stride, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkVertexInputRate*)&forUnmarshaling->inputRate, *ptr, sizeof(VkVertexInputRate));
    *ptr += sizeof(VkVertexInputRate);
}

void reservedunmarshal_VkVertexInputAttributeDescription(
    VulkanStream* vkStream,
    VkVertexInputAttributeDescription* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->location, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->binding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((uint32_t*)&forUnmarshaling->offset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPipelineVertexInputStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineVertexInputStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineVertexInputStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineVertexInputStateCreateFlags));
    *ptr += sizeof(VkPipelineVertexInputStateCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->vertexBindingDescriptionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pVertexBindingDescriptions, forUnmarshaling->vertexBindingDescriptionCount * sizeof(const VkVertexInputBindingDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexBindingDescriptionCount; ++i)
    {
        reservedunmarshal_VkVertexInputBindingDescription(vkStream, (VkVertexInputBindingDescription*)(forUnmarshaling->pVertexBindingDescriptions + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->vertexAttributeDescriptionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pVertexAttributeDescriptions, forUnmarshaling->vertexAttributeDescriptionCount * sizeof(const VkVertexInputAttributeDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexAttributeDescriptionCount; ++i)
    {
        reservedunmarshal_VkVertexInputAttributeDescription(vkStream, (VkVertexInputAttributeDescription*)(forUnmarshaling->pVertexAttributeDescriptions + i), ptr);
    }
}

void reservedunmarshal_VkPipelineInputAssemblyStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineInputAssemblyStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineInputAssemblyStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineInputAssemblyStateCreateFlags));
    *ptr += sizeof(VkPipelineInputAssemblyStateCreateFlags);
    memcpy((VkPrimitiveTopology*)&forUnmarshaling->topology, *ptr, sizeof(VkPrimitiveTopology));
    *ptr += sizeof(VkPrimitiveTopology);
    memcpy((VkBool32*)&forUnmarshaling->primitiveRestartEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPipelineTessellationStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineTessellationStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineTessellationStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineTessellationStateCreateFlags));
    *ptr += sizeof(VkPipelineTessellationStateCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->patchControlPoints, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkViewport(
    VulkanStream* vkStream,
    VkViewport* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((float*)&forUnmarshaling->x, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->y, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->width, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->height, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->minDepth, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxDepth, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

void reservedunmarshal_VkOffset2D(
    VulkanStream* vkStream,
    VkOffset2D* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((int32_t*)&forUnmarshaling->x, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy((int32_t*)&forUnmarshaling->y, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedunmarshal_VkExtent2D(
    VulkanStream* vkStream,
    VkExtent2D* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->width, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->height, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkRect2D(
    VulkanStream* vkStream,
    VkRect2D* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->offset), ptr);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->extent), ptr);
}

void reservedunmarshal_VkPipelineViewportStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineViewportStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineViewportStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineViewportStateCreateFlags));
    *ptr += sizeof(VkPipelineViewportStateCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->viewportCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkViewport**)&forUnmarshaling->pViewports, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pViewports);
    *ptr += 8;
    if (forUnmarshaling->pViewports)
    {
        vkStream->alloc((void**)&forUnmarshaling->pViewports, forUnmarshaling->viewportCount * sizeof(const VkViewport));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            reservedunmarshal_VkViewport(vkStream, (VkViewport*)(forUnmarshaling->pViewports + i), ptr);
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->scissorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkRect2D**)&forUnmarshaling->pScissors, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pScissors);
    *ptr += 8;
    if (forUnmarshaling->pScissors)
    {
        vkStream->alloc((void**)&forUnmarshaling->pScissors, forUnmarshaling->scissorCount * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->scissorCount; ++i)
        {
            reservedunmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pScissors + i), ptr);
        }
    }
}

void reservedunmarshal_VkPipelineRasterizationStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineRasterizationStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineRasterizationStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineRasterizationStateCreateFlags));
    *ptr += sizeof(VkPipelineRasterizationStateCreateFlags);
    memcpy((VkBool32*)&forUnmarshaling->depthClampEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->rasterizerDiscardEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkPolygonMode*)&forUnmarshaling->polygonMode, *ptr, sizeof(VkPolygonMode));
    *ptr += sizeof(VkPolygonMode);
    memcpy((VkCullModeFlags*)&forUnmarshaling->cullMode, *ptr, sizeof(VkCullModeFlags));
    *ptr += sizeof(VkCullModeFlags);
    memcpy((VkFrontFace*)&forUnmarshaling->frontFace, *ptr, sizeof(VkFrontFace));
    *ptr += sizeof(VkFrontFace);
    memcpy((VkBool32*)&forUnmarshaling->depthBiasEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((float*)&forUnmarshaling->depthBiasConstantFactor, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->depthBiasClamp, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->depthBiasSlopeFactor, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->lineWidth, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

void reservedunmarshal_VkPipelineMultisampleStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineMultisampleStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineMultisampleStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineMultisampleStateCreateFlags));
    *ptr += sizeof(VkPipelineMultisampleStateCreateFlags);
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->rasterizationSamples, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy((VkBool32*)&forUnmarshaling->sampleShadingEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((float*)&forUnmarshaling->minSampleShading, *ptr, sizeof(float));
    *ptr += sizeof(float);
    // WARNING PTR CHECK
    memcpy((VkSampleMask**)&forUnmarshaling->pSampleMask, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pSampleMask);
    *ptr += 8;
    if (forUnmarshaling->pSampleMask)
    {
        vkStream->alloc((void**)&forUnmarshaling->pSampleMask, (((forUnmarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
        memcpy((VkSampleMask*)forUnmarshaling->pSampleMask, *ptr, (((forUnmarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
        *ptr += (((forUnmarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask);
    }
    memcpy((VkBool32*)&forUnmarshaling->alphaToCoverageEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->alphaToOneEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkStencilOpState(
    VulkanStream* vkStream,
    VkStencilOpState* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStencilOp*)&forUnmarshaling->failOp, *ptr, sizeof(VkStencilOp));
    *ptr += sizeof(VkStencilOp);
    memcpy((VkStencilOp*)&forUnmarshaling->passOp, *ptr, sizeof(VkStencilOp));
    *ptr += sizeof(VkStencilOp);
    memcpy((VkStencilOp*)&forUnmarshaling->depthFailOp, *ptr, sizeof(VkStencilOp));
    *ptr += sizeof(VkStencilOp);
    memcpy((VkCompareOp*)&forUnmarshaling->compareOp, *ptr, sizeof(VkCompareOp));
    *ptr += sizeof(VkCompareOp);
    memcpy((uint32_t*)&forUnmarshaling->compareMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->writeMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->reference, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPipelineDepthStencilStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineDepthStencilStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineDepthStencilStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineDepthStencilStateCreateFlags));
    *ptr += sizeof(VkPipelineDepthStencilStateCreateFlags);
    memcpy((VkBool32*)&forUnmarshaling->depthTestEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->depthWriteEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkCompareOp*)&forUnmarshaling->depthCompareOp, *ptr, sizeof(VkCompareOp));
    *ptr += sizeof(VkCompareOp);
    memcpy((VkBool32*)&forUnmarshaling->depthBoundsTestEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->stencilTestEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    reservedunmarshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forUnmarshaling->front), ptr);
    reservedunmarshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forUnmarshaling->back), ptr);
    memcpy((float*)&forUnmarshaling->minDepthBounds, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxDepthBounds, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

void reservedunmarshal_VkPipelineColorBlendAttachmentState(
    VulkanStream* vkStream,
    VkPipelineColorBlendAttachmentState* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkBool32*)&forUnmarshaling->blendEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBlendFactor*)&forUnmarshaling->srcColorBlendFactor, *ptr, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy((VkBlendFactor*)&forUnmarshaling->dstColorBlendFactor, *ptr, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy((VkBlendOp*)&forUnmarshaling->colorBlendOp, *ptr, sizeof(VkBlendOp));
    *ptr += sizeof(VkBlendOp);
    memcpy((VkBlendFactor*)&forUnmarshaling->srcAlphaBlendFactor, *ptr, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy((VkBlendFactor*)&forUnmarshaling->dstAlphaBlendFactor, *ptr, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy((VkBlendOp*)&forUnmarshaling->alphaBlendOp, *ptr, sizeof(VkBlendOp));
    *ptr += sizeof(VkBlendOp);
    memcpy((VkColorComponentFlags*)&forUnmarshaling->colorWriteMask, *ptr, sizeof(VkColorComponentFlags));
    *ptr += sizeof(VkColorComponentFlags);
}

void reservedunmarshal_VkPipelineColorBlendStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineColorBlendStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineColorBlendStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineColorBlendStateCreateFlags));
    *ptr += sizeof(VkPipelineColorBlendStateCreateFlags);
    memcpy((VkBool32*)&forUnmarshaling->logicOpEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkLogicOp*)&forUnmarshaling->logicOp, *ptr, sizeof(VkLogicOp));
    *ptr += sizeof(VkLogicOp);
    memcpy((uint32_t*)&forUnmarshaling->attachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkPipelineColorBlendAttachmentState));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        reservedunmarshal_VkPipelineColorBlendAttachmentState(vkStream, (VkPipelineColorBlendAttachmentState*)(forUnmarshaling->pAttachments + i), ptr);
    }
    memcpy((float*)forUnmarshaling->blendConstants, *ptr, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

void reservedunmarshal_VkPipelineDynamicStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineDynamicStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineDynamicStateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineDynamicStateCreateFlags));
    *ptr += sizeof(VkPipelineDynamicStateCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->dynamicStateCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDynamicStates, forUnmarshaling->dynamicStateCount * sizeof(const VkDynamicState));
    memcpy((VkDynamicState*)forUnmarshaling->pDynamicStates, *ptr, forUnmarshaling->dynamicStateCount * sizeof(const VkDynamicState));
    *ptr += forUnmarshaling->dynamicStateCount * sizeof(const VkDynamicState);
}

void reservedunmarshal_VkGraphicsPipelineCreateInfo(
    VulkanStream* vkStream,
    VkGraphicsPipelineCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    uint32_t hasRasterization = 1;
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        memcpy((uint32_t*)&hasRasterization, (*ptr), 4);
        android::base::Stream::fromBe32((uint8_t*)&hasRasterization);
        *ptr += 4;
    }
    uint32_t hasTessellation = 1;
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        memcpy((uint32_t*)&hasTessellation, (*ptr), 4);
        android::base::Stream::fromBe32((uint8_t*)&hasTessellation);
        *ptr += 4;
    }
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineCreateFlags));
    *ptr += sizeof(VkPipelineCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->stageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pStages, forUnmarshaling->stageCount * sizeof(const VkPipelineShaderStageCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->stageCount; ++i)
    {
        reservedunmarshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(forUnmarshaling->pStages + i), ptr);
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        memcpy((VkPipelineVertexInputStateCreateInfo**)&forUnmarshaling->pVertexInputState, (*ptr), 8);
        android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pVertexInputState);
        *ptr += 8;
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forUnmarshaling->pVertexInputState))
    {
        vkStream->alloc((void**)&forUnmarshaling->pVertexInputState, sizeof(const VkPipelineVertexInputStateCreateInfo));
        reservedunmarshal_VkPipelineVertexInputStateCreateInfo(vkStream, (VkPipelineVertexInputStateCreateInfo*)(forUnmarshaling->pVertexInputState), ptr);
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        memcpy((VkPipelineInputAssemblyStateCreateInfo**)&forUnmarshaling->pInputAssemblyState, (*ptr), 8);
        android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pInputAssemblyState);
        *ptr += 8;
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forUnmarshaling->pInputAssemblyState))
    {
        vkStream->alloc((void**)&forUnmarshaling->pInputAssemblyState, sizeof(const VkPipelineInputAssemblyStateCreateInfo));
        reservedunmarshal_VkPipelineInputAssemblyStateCreateInfo(vkStream, (VkPipelineInputAssemblyStateCreateInfo*)(forUnmarshaling->pInputAssemblyState), ptr);
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineTessellationStateCreateInfo**)&forUnmarshaling->pTessellationState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pTessellationState);
    *ptr += 8;
    if (forUnmarshaling->pTessellationState)
    {
        if (hasTessellation)
        {
            vkStream->alloc((void**)&forUnmarshaling->pTessellationState, sizeof(const VkPipelineTessellationStateCreateInfo));
            reservedunmarshal_VkPipelineTessellationStateCreateInfo(vkStream, (VkPipelineTessellationStateCreateInfo*)(forUnmarshaling->pTessellationState), ptr);
        }
        else
        {
            forUnmarshaling->pTessellationState = 0;
        }
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineViewportStateCreateInfo**)&forUnmarshaling->pViewportState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pViewportState);
    *ptr += 8;
    if (forUnmarshaling->pViewportState)
    {
        if (hasRasterization)
        {
            vkStream->alloc((void**)&forUnmarshaling->pViewportState, sizeof(const VkPipelineViewportStateCreateInfo));
            reservedunmarshal_VkPipelineViewportStateCreateInfo(vkStream, (VkPipelineViewportStateCreateInfo*)(forUnmarshaling->pViewportState), ptr);
        }
        else
        {
            forUnmarshaling->pViewportState = 0;
        }
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        memcpy((VkPipelineRasterizationStateCreateInfo**)&forUnmarshaling->pRasterizationState, (*ptr), 8);
        android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pRasterizationState);
        *ptr += 8;
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forUnmarshaling->pRasterizationState))
    {
        vkStream->alloc((void**)&forUnmarshaling->pRasterizationState, sizeof(const VkPipelineRasterizationStateCreateInfo));
        reservedunmarshal_VkPipelineRasterizationStateCreateInfo(vkStream, (VkPipelineRasterizationStateCreateInfo*)(forUnmarshaling->pRasterizationState), ptr);
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineMultisampleStateCreateInfo**)&forUnmarshaling->pMultisampleState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pMultisampleState);
    *ptr += 8;
    if (forUnmarshaling->pMultisampleState)
    {
        if (hasRasterization)
        {
            vkStream->alloc((void**)&forUnmarshaling->pMultisampleState, sizeof(const VkPipelineMultisampleStateCreateInfo));
            reservedunmarshal_VkPipelineMultisampleStateCreateInfo(vkStream, (VkPipelineMultisampleStateCreateInfo*)(forUnmarshaling->pMultisampleState), ptr);
        }
        else
        {
            forUnmarshaling->pMultisampleState = 0;
        }
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineDepthStencilStateCreateInfo**)&forUnmarshaling->pDepthStencilState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pDepthStencilState);
    *ptr += 8;
    if (forUnmarshaling->pDepthStencilState)
    {
        if (hasRasterization)
        {
            vkStream->alloc((void**)&forUnmarshaling->pDepthStencilState, sizeof(const VkPipelineDepthStencilStateCreateInfo));
            reservedunmarshal_VkPipelineDepthStencilStateCreateInfo(vkStream, (VkPipelineDepthStencilStateCreateInfo*)(forUnmarshaling->pDepthStencilState), ptr);
        }
        else
        {
            forUnmarshaling->pDepthStencilState = 0;
        }
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineColorBlendStateCreateInfo**)&forUnmarshaling->pColorBlendState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pColorBlendState);
    *ptr += 8;
    if (forUnmarshaling->pColorBlendState)
    {
        if (hasRasterization)
        {
            vkStream->alloc((void**)&forUnmarshaling->pColorBlendState, sizeof(const VkPipelineColorBlendStateCreateInfo));
            reservedunmarshal_VkPipelineColorBlendStateCreateInfo(vkStream, (VkPipelineColorBlendStateCreateInfo*)(forUnmarshaling->pColorBlendState), ptr);
        }
        else
        {
            forUnmarshaling->pColorBlendState = 0;
        }
    }
    // WARNING PTR CHECK
    memcpy((VkPipelineDynamicStateCreateInfo**)&forUnmarshaling->pDynamicState, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pDynamicState);
    *ptr += 8;
    if (forUnmarshaling->pDynamicState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDynamicState, sizeof(const VkPipelineDynamicStateCreateInfo));
        reservedunmarshal_VkPipelineDynamicStateCreateInfo(vkStream, (VkPipelineDynamicStateCreateInfo*)(forUnmarshaling->pDynamicState), ptr);
    }
    uint64_t cgen_var_6;
    memcpy((uint64_t*)&cgen_var_6, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipelineLayout*)&forUnmarshaling->layout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_6));
    uint64_t cgen_var_7;
    memcpy((uint64_t*)&cgen_var_7, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkRenderPass*)&forUnmarshaling->renderPass = (VkRenderPass)unbox_VkRenderPass((VkRenderPass)(*&cgen_var_7));
    memcpy((uint32_t*)&forUnmarshaling->subpass, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_8;
    memcpy((uint64_t*)&cgen_var_8, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipeline*)&forUnmarshaling->basePipelineHandle = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_8));
    memcpy((int32_t*)&forUnmarshaling->basePipelineIndex, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedunmarshal_VkComputePipelineCreateInfo(
    VulkanStream* vkStream,
    VkComputePipelineCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineCreateFlags));
    *ptr += sizeof(VkPipelineCreateFlags);
    reservedunmarshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(&forUnmarshaling->stage), ptr);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipelineLayout*)&forUnmarshaling->layout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipeline*)&forUnmarshaling->basePipelineHandle = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_1));
    memcpy((int32_t*)&forUnmarshaling->basePipelineIndex, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedunmarshal_VkPushConstantRange(
    VulkanStream* vkStream,
    VkPushConstantRange* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkShaderStageFlags*)&forUnmarshaling->stageFlags, *ptr, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    memcpy((uint32_t*)&forUnmarshaling->offset, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->size, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPipelineLayoutCreateInfo(
    VulkanStream* vkStream,
    VkPipelineLayoutCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineLayoutCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineLayoutCreateFlags));
    *ptr += sizeof(VkPipelineLayoutCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->setLayoutCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSetLayouts, forUnmarshaling->setLayoutCount * sizeof(const VkDescriptorSetLayout));
    if (forUnmarshaling->setLayoutCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->setLayoutCount;
        for (uint32_t k = 0; k < forUnmarshaling->setLayoutCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
            *(((VkDescriptorSetLayout*)forUnmarshaling->pSetLayouts) + k) = (VkDescriptorSetLayout)unbox_VkDescriptorSetLayout((VkDescriptorSetLayout)tmpval);
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->pushConstantRangeCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPushConstantRanges, forUnmarshaling->pushConstantRangeCount * sizeof(const VkPushConstantRange));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->pushConstantRangeCount; ++i)
    {
        reservedunmarshal_VkPushConstantRange(vkStream, (VkPushConstantRange*)(forUnmarshaling->pPushConstantRanges + i), ptr);
    }
}

void reservedunmarshal_VkSamplerCreateInfo(
    VulkanStream* vkStream,
    VkSamplerCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSamplerCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSamplerCreateFlags));
    *ptr += sizeof(VkSamplerCreateFlags);
    memcpy((VkFilter*)&forUnmarshaling->magFilter, *ptr, sizeof(VkFilter));
    *ptr += sizeof(VkFilter);
    memcpy((VkFilter*)&forUnmarshaling->minFilter, *ptr, sizeof(VkFilter));
    *ptr += sizeof(VkFilter);
    memcpy((VkSamplerMipmapMode*)&forUnmarshaling->mipmapMode, *ptr, sizeof(VkSamplerMipmapMode));
    *ptr += sizeof(VkSamplerMipmapMode);
    memcpy((VkSamplerAddressMode*)&forUnmarshaling->addressModeU, *ptr, sizeof(VkSamplerAddressMode));
    *ptr += sizeof(VkSamplerAddressMode);
    memcpy((VkSamplerAddressMode*)&forUnmarshaling->addressModeV, *ptr, sizeof(VkSamplerAddressMode));
    *ptr += sizeof(VkSamplerAddressMode);
    memcpy((VkSamplerAddressMode*)&forUnmarshaling->addressModeW, *ptr, sizeof(VkSamplerAddressMode));
    *ptr += sizeof(VkSamplerAddressMode);
    memcpy((float*)&forUnmarshaling->mipLodBias, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((VkBool32*)&forUnmarshaling->anisotropyEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((float*)&forUnmarshaling->maxAnisotropy, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((VkBool32*)&forUnmarshaling->compareEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkCompareOp*)&forUnmarshaling->compareOp, *ptr, sizeof(VkCompareOp));
    *ptr += sizeof(VkCompareOp);
    memcpy((float*)&forUnmarshaling->minLod, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxLod, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((VkBorderColor*)&forUnmarshaling->borderColor, *ptr, sizeof(VkBorderColor));
    *ptr += sizeof(VkBorderColor);
    memcpy((VkBool32*)&forUnmarshaling->unnormalizedCoordinates, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDescriptorSetLayoutBinding(
    VulkanStream* vkStream,
    VkDescriptorSetLayoutBinding* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->binding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDescriptorType*)&forUnmarshaling->descriptorType, *ptr, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    memcpy((uint32_t*)&forUnmarshaling->descriptorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkShaderStageFlags*)&forUnmarshaling->stageFlags, *ptr, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    // WARNING PTR CHECK
    memcpy((VkSampler**)&forUnmarshaling->pImmutableSamplers, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pImmutableSamplers);
    *ptr += 8;
    if (forUnmarshaling->pImmutableSamplers)
    {
        vkStream->alloc((void**)&forUnmarshaling->pImmutableSamplers, forUnmarshaling->descriptorCount * sizeof(const VkSampler));
        if (forUnmarshaling->descriptorCount)
        {
            uint8_t* cgen_var_0_0_ptr = (uint8_t*)(*ptr);
            *ptr += 8 * forUnmarshaling->descriptorCount;
            for (uint32_t k = 0; k < forUnmarshaling->descriptorCount; ++k)
            {
                uint64_t tmpval; memcpy(&tmpval, cgen_var_0_0_ptr + k * 8, sizeof(uint64_t));
                *(((VkSampler*)forUnmarshaling->pImmutableSamplers) + k) = (VkSampler)unbox_VkSampler((VkSampler)tmpval);
            }
        }
    }
}

void reservedunmarshal_VkDescriptorSetLayoutCreateInfo(
    VulkanStream* vkStream,
    VkDescriptorSetLayoutCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDescriptorSetLayoutCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkDescriptorSetLayoutCreateFlags));
    *ptr += sizeof(VkDescriptorSetLayoutCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->bindingCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pBindings, forUnmarshaling->bindingCount * sizeof(const VkDescriptorSetLayoutBinding));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindingCount; ++i)
    {
        reservedunmarshal_VkDescriptorSetLayoutBinding(vkStream, (VkDescriptorSetLayoutBinding*)(forUnmarshaling->pBindings + i), ptr);
    }
}

void reservedunmarshal_VkDescriptorPoolSize(
    VulkanStream* vkStream,
    VkDescriptorPoolSize* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDescriptorType*)&forUnmarshaling->type, *ptr, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    memcpy((uint32_t*)&forUnmarshaling->descriptorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDescriptorPoolCreateInfo(
    VulkanStream* vkStream,
    VkDescriptorPoolCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDescriptorPoolCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkDescriptorPoolCreateFlags));
    *ptr += sizeof(VkDescriptorPoolCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->maxSets, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->poolSizeCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPoolSizes, forUnmarshaling->poolSizeCount * sizeof(const VkDescriptorPoolSize));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->poolSizeCount; ++i)
    {
        reservedunmarshal_VkDescriptorPoolSize(vkStream, (VkDescriptorPoolSize*)(forUnmarshaling->pPoolSizes + i), ptr);
    }
}

void reservedunmarshal_VkDescriptorSetAllocateInfo(
    VulkanStream* vkStream,
    VkDescriptorSetAllocateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDescriptorPool*)&forUnmarshaling->descriptorPool = (VkDescriptorPool)unbox_VkDescriptorPool((VkDescriptorPool)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->descriptorSetCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSetLayouts, forUnmarshaling->descriptorSetCount * sizeof(const VkDescriptorSetLayout));
    if (forUnmarshaling->descriptorSetCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->descriptorSetCount;
        for (uint32_t k = 0; k < forUnmarshaling->descriptorSetCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
            *(((VkDescriptorSetLayout*)forUnmarshaling->pSetLayouts) + k) = (VkDescriptorSetLayout)unbox_VkDescriptorSetLayout((VkDescriptorSetLayout)tmpval);
        }
    }
}

void reservedunmarshal_VkDescriptorImageInfo(
    VulkanStream* vkStream,
    VkDescriptorImageInfo* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSampler*)&forUnmarshaling->sampler = (VkSampler)unbox_VkSampler((VkSampler)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImageView*)&forUnmarshaling->imageView = (VkImageView)unbox_VkImageView((VkImageView)(*&cgen_var_1));
    memcpy((VkImageLayout*)&forUnmarshaling->imageLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedunmarshal_VkDescriptorBufferInfo(
    VulkanStream* vkStream,
    VkDescriptorBufferInfo* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->range, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkWriteDescriptorSet(
    VulkanStream* vkStream,
    VkWriteDescriptorSet* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDescriptorSet*)&forUnmarshaling->dstSet = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->dstBinding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dstArrayElement, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->descriptorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDescriptorType*)&forUnmarshaling->descriptorType, *ptr, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    // WARNING PTR CHECK
    memcpy((VkDescriptorImageInfo**)&forUnmarshaling->pImageInfo, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pImageInfo);
    *ptr += 8;
    if (forUnmarshaling->pImageInfo)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_SAMPLER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_IMAGE == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT == forUnmarshaling->descriptorType))))
        {
            vkStream->alloc((void**)&forUnmarshaling->pImageInfo, forUnmarshaling->descriptorCount * sizeof(const VkDescriptorImageInfo));
            for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorCount; ++i)
            {
                reservedunmarshal_VkDescriptorImageInfo(vkStream, (VkDescriptorImageInfo*)(forUnmarshaling->pImageInfo + i), ptr);
            }
        }
        else
        {
            forUnmarshaling->pImageInfo = 0;
        }
    }
    // WARNING PTR CHECK
    memcpy((VkDescriptorBufferInfo**)&forUnmarshaling->pBufferInfo, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pBufferInfo);
    *ptr += 8;
    if (forUnmarshaling->pBufferInfo)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC == forUnmarshaling->descriptorType))))
        {
            vkStream->alloc((void**)&forUnmarshaling->pBufferInfo, forUnmarshaling->descriptorCount * sizeof(const VkDescriptorBufferInfo));
            for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorCount; ++i)
            {
                reservedunmarshal_VkDescriptorBufferInfo(vkStream, (VkDescriptorBufferInfo*)(forUnmarshaling->pBufferInfo + i), ptr);
            }
        }
        else
        {
            forUnmarshaling->pBufferInfo = 0;
        }
    }
    // WARNING PTR CHECK
    memcpy((VkBufferView**)&forUnmarshaling->pTexelBufferView, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pTexelBufferView);
    *ptr += 8;
    if (forUnmarshaling->pTexelBufferView)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER == forUnmarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER == forUnmarshaling->descriptorType))))
        {
            vkStream->alloc((void**)&forUnmarshaling->pTexelBufferView, forUnmarshaling->descriptorCount * sizeof(const VkBufferView));
            if (forUnmarshaling->descriptorCount)
            {
                uint8_t* cgen_var_3_0_ptr = (uint8_t*)(*ptr);
                *ptr += 8 * forUnmarshaling->descriptorCount;
                for (uint32_t k = 0; k < forUnmarshaling->descriptorCount; ++k)
                {
                    uint64_t tmpval; memcpy(&tmpval, cgen_var_3_0_ptr + k * 8, sizeof(uint64_t));
                    *(((VkBufferView*)forUnmarshaling->pTexelBufferView) + k) = (VkBufferView)unbox_VkBufferView((VkBufferView)tmpval);
                }
            }
        }
        else
        {
            forUnmarshaling->pTexelBufferView = 0;
        }
    }
}

void reservedunmarshal_VkCopyDescriptorSet(
    VulkanStream* vkStream,
    VkCopyDescriptorSet* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDescriptorSet*)&forUnmarshaling->srcSet = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->srcBinding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->srcArrayElement, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDescriptorSet*)&forUnmarshaling->dstSet = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)(*&cgen_var_1));
    memcpy((uint32_t*)&forUnmarshaling->dstBinding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dstArrayElement, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->descriptorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkFramebufferCreateInfo(
    VulkanStream* vkStream,
    VkFramebufferCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFramebufferCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkFramebufferCreateFlags));
    *ptr += sizeof(VkFramebufferCreateFlags);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkRenderPass*)&forUnmarshaling->renderPass = (VkRenderPass)unbox_VkRenderPass((VkRenderPass)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->attachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkImageView));
    if (forUnmarshaling->attachmentCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->attachmentCount;
        for (uint32_t k = 0; k < forUnmarshaling->attachmentCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
            *(((VkImageView*)forUnmarshaling->pAttachments) + k) = (VkImageView)unbox_VkImageView((VkImageView)tmpval);
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->width, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->height, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->layers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkAttachmentDescription(
    VulkanStream* vkStream,
    VkAttachmentDescription* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkAttachmentDescriptionFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkAttachmentDescriptionFlags));
    *ptr += sizeof(VkAttachmentDescriptionFlags);
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->samples, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy((VkAttachmentLoadOp*)&forUnmarshaling->loadOp, *ptr, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy((VkAttachmentStoreOp*)&forUnmarshaling->storeOp, *ptr, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy((VkAttachmentLoadOp*)&forUnmarshaling->stencilLoadOp, *ptr, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy((VkAttachmentStoreOp*)&forUnmarshaling->stencilStoreOp, *ptr, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy((VkImageLayout*)&forUnmarshaling->initialLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((VkImageLayout*)&forUnmarshaling->finalLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedunmarshal_VkAttachmentReference(
    VulkanStream* vkStream,
    VkAttachmentReference* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->attachment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkImageLayout*)&forUnmarshaling->layout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedunmarshal_VkSubpassDescription(
    VulkanStream* vkStream,
    VkSubpassDescription* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkSubpassDescriptionFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSubpassDescriptionFlags));
    *ptr += sizeof(VkSubpassDescriptionFlags);
    memcpy((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, *ptr, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    memcpy((uint32_t*)&forUnmarshaling->inputAttachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pInputAttachments, forUnmarshaling->inputAttachmentCount * sizeof(const VkAttachmentReference));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->inputAttachmentCount; ++i)
    {
        reservedunmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pInputAttachments + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->colorAttachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pColorAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
    {
        reservedunmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pColorAttachments + i), ptr);
    }
    // WARNING PTR CHECK
    memcpy((VkAttachmentReference**)&forUnmarshaling->pResolveAttachments, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pResolveAttachments);
    *ptr += 8;
    if (forUnmarshaling->pResolveAttachments)
    {
        vkStream->alloc((void**)&forUnmarshaling->pResolveAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
        {
            reservedunmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pResolveAttachments + i), ptr);
        }
    }
    // WARNING PTR CHECK
    memcpy((VkAttachmentReference**)&forUnmarshaling->pDepthStencilAttachment, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pDepthStencilAttachment);
    *ptr += 8;
    if (forUnmarshaling->pDepthStencilAttachment)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDepthStencilAttachment, sizeof(const VkAttachmentReference));
        reservedunmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pDepthStencilAttachment), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->preserveAttachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPreserveAttachments, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pPreserveAttachments, *ptr, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkSubpassDependency(
    VulkanStream* vkStream,
    VkSubpassDependency* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->srcSubpass, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dstSubpass, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkPipelineStageFlags*)&forUnmarshaling->srcStageMask, *ptr, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy((VkPipelineStageFlags*)&forUnmarshaling->dstStageMask, *ptr, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy((VkAccessFlags*)&forUnmarshaling->srcAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkAccessFlags*)&forUnmarshaling->dstAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkDependencyFlags*)&forUnmarshaling->dependencyFlags, *ptr, sizeof(VkDependencyFlags));
    *ptr += sizeof(VkDependencyFlags);
}

void reservedunmarshal_VkRenderPassCreateInfo(
    VulkanStream* vkStream,
    VkRenderPassCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkRenderPassCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkRenderPassCreateFlags));
    *ptr += sizeof(VkRenderPassCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->attachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkAttachmentDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        reservedunmarshal_VkAttachmentDescription(vkStream, (VkAttachmentDescription*)(forUnmarshaling->pAttachments + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->subpassCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSubpasses, forUnmarshaling->subpassCount * sizeof(const VkSubpassDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->subpassCount; ++i)
    {
        reservedunmarshal_VkSubpassDescription(vkStream, (VkSubpassDescription*)(forUnmarshaling->pSubpasses + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->dependencyCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDependencies, forUnmarshaling->dependencyCount * sizeof(const VkSubpassDependency));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->dependencyCount; ++i)
    {
        reservedunmarshal_VkSubpassDependency(vkStream, (VkSubpassDependency*)(forUnmarshaling->pDependencies + i), ptr);
    }
}

void reservedunmarshal_VkCommandPoolCreateInfo(
    VulkanStream* vkStream,
    VkCommandPoolCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkCommandPoolCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkCommandPoolCreateFlags));
    *ptr += sizeof(VkCommandPoolCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->queueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkCommandBufferAllocateInfo(
    VulkanStream* vkStream,
    VkCommandBufferAllocateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkCommandPool*)&forUnmarshaling->commandPool = (VkCommandPool)unbox_VkCommandPool((VkCommandPool)(*&cgen_var_0));
    memcpy((VkCommandBufferLevel*)&forUnmarshaling->level, *ptr, sizeof(VkCommandBufferLevel));
    *ptr += sizeof(VkCommandBufferLevel);
    memcpy((uint32_t*)&forUnmarshaling->commandBufferCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkCommandBufferInheritanceInfo(
    VulkanStream* vkStream,
    VkCommandBufferInheritanceInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkRenderPass*)&forUnmarshaling->renderPass = (VkRenderPass)unbox_VkRenderPass((VkRenderPass)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->subpass, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkFramebuffer*)&forUnmarshaling->framebuffer = (VkFramebuffer)unbox_VkFramebuffer((VkFramebuffer)(*&cgen_var_1));
    memcpy((VkBool32*)&forUnmarshaling->occlusionQueryEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkQueryControlFlags*)&forUnmarshaling->queryFlags, *ptr, sizeof(VkQueryControlFlags));
    *ptr += sizeof(VkQueryControlFlags);
    memcpy((VkQueryPipelineStatisticFlags*)&forUnmarshaling->pipelineStatistics, *ptr, sizeof(VkQueryPipelineStatisticFlags));
    *ptr += sizeof(VkQueryPipelineStatisticFlags);
}

void reservedunmarshal_VkCommandBufferBeginInfo(
    VulkanStream* vkStream,
    VkCommandBufferBeginInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkCommandBufferUsageFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkCommandBufferUsageFlags));
    *ptr += sizeof(VkCommandBufferUsageFlags);
    // WARNING PTR CHECK
    memcpy((VkCommandBufferInheritanceInfo**)&forUnmarshaling->pInheritanceInfo, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pInheritanceInfo);
    *ptr += 8;
    if (forUnmarshaling->pInheritanceInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pInheritanceInfo, sizeof(const VkCommandBufferInheritanceInfo));
        reservedunmarshal_VkCommandBufferInheritanceInfo(vkStream, (VkCommandBufferInheritanceInfo*)(forUnmarshaling->pInheritanceInfo), ptr);
    }
}

void reservedunmarshal_VkBufferCopy(
    VulkanStream* vkStream,
    VkBufferCopy* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceSize*)&forUnmarshaling->srcOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->dstOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkImageSubresourceLayers(
    VulkanStream* vkStream,
    VkImageSubresourceLayers* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkImageAspectFlags*)&forUnmarshaling->aspectMask, *ptr, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy((uint32_t*)&forUnmarshaling->mipLevel, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->baseArrayLayer, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->layerCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkImageCopy(
    VulkanStream* vkStream,
    VkImageCopy* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->srcOffset), ptr);
    reservedunmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->dstOffset), ptr);
    reservedunmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent), ptr);
}

void reservedunmarshal_VkImageBlit(
    VulkanStream* vkStream,
    VkImageBlit* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource), ptr);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        reservedunmarshal_VkOffset3D(vkStream, (VkOffset3D*)(forUnmarshaling->srcOffsets + i), ptr);
    }
    reservedunmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource), ptr);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        reservedunmarshal_VkOffset3D(vkStream, (VkOffset3D*)(forUnmarshaling->dstOffsets + i), ptr);
    }
}

void reservedunmarshal_VkBufferImageCopy(
    VulkanStream* vkStream,
    VkBufferImageCopy* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDeviceSize*)&forUnmarshaling->bufferOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->bufferRowLength, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->bufferImageHeight, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->imageSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->imageOffset), ptr);
    reservedunmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->imageExtent), ptr);
}

void reservedunmarshal_VkClearColorValue(
    VulkanStream* vkStream,
    VkClearColorValue* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((float*)forUnmarshaling->float32, *ptr, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

void reservedunmarshal_VkClearDepthStencilValue(
    VulkanStream* vkStream,
    VkClearDepthStencilValue* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((float*)&forUnmarshaling->depth, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((uint32_t*)&forUnmarshaling->stencil, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkClearValue(
    VulkanStream* vkStream,
    VkClearValue* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkClearColorValue(vkStream, (VkClearColorValue*)(&forUnmarshaling->color), ptr);
}

void reservedunmarshal_VkClearAttachment(
    VulkanStream* vkStream,
    VkClearAttachment* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkImageAspectFlags*)&forUnmarshaling->aspectMask, *ptr, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy((uint32_t*)&forUnmarshaling->colorAttachment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkClearValue(vkStream, (VkClearValue*)(&forUnmarshaling->clearValue), ptr);
}

void reservedunmarshal_VkClearRect(
    VulkanStream* vkStream,
    VkClearRect* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->rect), ptr);
    memcpy((uint32_t*)&forUnmarshaling->baseArrayLayer, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->layerCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkImageResolve(
    VulkanStream* vkStream,
    VkImageResolve* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->srcOffset), ptr);
    reservedunmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource), ptr);
    reservedunmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->dstOffset), ptr);
    reservedunmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent), ptr);
}

void reservedunmarshal_VkMemoryBarrier(
    VulkanStream* vkStream,
    VkMemoryBarrier* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAccessFlags*)&forUnmarshaling->srcAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkAccessFlags*)&forUnmarshaling->dstAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
}

void reservedunmarshal_VkBufferMemoryBarrier(
    VulkanStream* vkStream,
    VkBufferMemoryBarrier* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAccessFlags*)&forUnmarshaling->srcAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkAccessFlags*)&forUnmarshaling->dstAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((uint32_t*)&forUnmarshaling->srcQueueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dstQueueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkImageMemoryBarrier(
    VulkanStream* vkStream,
    VkImageMemoryBarrier* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAccessFlags*)&forUnmarshaling->srcAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkAccessFlags*)&forUnmarshaling->dstAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkImageLayout*)&forUnmarshaling->oldLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((VkImageLayout*)&forUnmarshaling->newLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((uint32_t*)&forUnmarshaling->srcQueueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dstQueueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    reservedunmarshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forUnmarshaling->subresourceRange), ptr);
}

void reservedunmarshal_VkRenderPassBeginInfo(
    VulkanStream* vkStream,
    VkRenderPassBeginInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkRenderPass*)&forUnmarshaling->renderPass = (VkRenderPass)unbox_VkRenderPass((VkRenderPass)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkFramebuffer*)&forUnmarshaling->framebuffer = (VkFramebuffer)unbox_VkFramebuffer((VkFramebuffer)(*&cgen_var_1));
    reservedunmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->renderArea), ptr);
    memcpy((uint32_t*)&forUnmarshaling->clearValueCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkClearValue**)&forUnmarshaling->pClearValues, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pClearValues);
    *ptr += 8;
    if (forUnmarshaling->pClearValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pClearValues, forUnmarshaling->clearValueCount * sizeof(const VkClearValue));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->clearValueCount; ++i)
        {
            reservedunmarshal_VkClearValue(vkStream, (VkClearValue*)(forUnmarshaling->pClearValues + i), ptr);
        }
    }
}

void reservedunmarshal_VkDispatchIndirectCommand(
    VulkanStream* vkStream,
    VkDispatchIndirectCommand* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->x, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->y, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->z, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDrawIndexedIndirectCommand(
    VulkanStream* vkStream,
    VkDrawIndexedIndirectCommand* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->indexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->instanceCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->firstIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((int32_t*)&forUnmarshaling->vertexOffset, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy((uint32_t*)&forUnmarshaling->firstInstance, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDrawIndirectCommand(
    VulkanStream* vkStream,
    VkDrawIndirectCommand* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->vertexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->instanceCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->firstVertex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->firstInstance, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkBaseOutStructure(
    VulkanStream* vkStream,
    VkBaseOutStructure* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((VkBaseOutStructure*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
}

void reservedunmarshal_VkBaseInStructure(
    VulkanStream* vkStream,
    VkBaseInStructure* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((VkBaseInStructure*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
}

#endif
#ifdef VK_VERSION_1_1
void reservedunmarshal_VkPhysicalDeviceSubgroupProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceSubgroupProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->subgroupSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkShaderStageFlags*)&forUnmarshaling->supportedStages, *ptr, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    memcpy((VkSubgroupFeatureFlags*)&forUnmarshaling->supportedOperations, *ptr, sizeof(VkSubgroupFeatureFlags));
    *ptr += sizeof(VkSubgroupFeatureFlags);
    memcpy((VkBool32*)&forUnmarshaling->quadOperationsInAllStages, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkBindBufferMemoryInfo(
    VulkanStream* vkStream,
    VkBindBufferMemoryInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_1));
    memcpy((VkDeviceSize*)&forUnmarshaling->memoryOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkBindImageMemoryInfo(
    VulkanStream* vkStream,
    VkBindImageMemoryInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_1));
    memcpy((VkDeviceSize*)&forUnmarshaling->memoryOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkPhysicalDevice16BitStorageFeatures(
    VulkanStream* vkStream,
    VkPhysicalDevice16BitStorageFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->storageBuffer16BitAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->uniformAndStorageBuffer16BitAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->storagePushConstant16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->storageInputOutput16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkMemoryDedicatedRequirements(
    VulkanStream* vkStream,
    VkMemoryDedicatedRequirements* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->prefersDedicatedAllocation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->requiresDedicatedAllocation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkMemoryDedicatedAllocateInfo(
    VulkanStream* vkStream,
    VkMemoryDedicatedAllocateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
}

void reservedunmarshal_VkMemoryAllocateFlagsInfo(
    VulkanStream* vkStream,
    VkMemoryAllocateFlagsInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkMemoryAllocateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkMemoryAllocateFlags));
    *ptr += sizeof(VkMemoryAllocateFlags);
    memcpy((uint32_t*)&forUnmarshaling->deviceMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDeviceGroupRenderPassBeginInfo(
    VulkanStream* vkStream,
    VkDeviceGroupRenderPassBeginInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->deviceMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->deviceRenderAreaCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDeviceRenderAreas, forUnmarshaling->deviceRenderAreaCount * sizeof(const VkRect2D));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->deviceRenderAreaCount; ++i)
    {
        reservedunmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pDeviceRenderAreas + i), ptr);
    }
}

void reservedunmarshal_VkDeviceGroupCommandBufferBeginInfo(
    VulkanStream* vkStream,
    VkDeviceGroupCommandBufferBeginInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->deviceMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDeviceGroupSubmitInfo(
    VulkanStream* vkStream,
    VkDeviceGroupSubmitInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->waitSemaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphoreDeviceIndices, forUnmarshaling->waitSemaphoreCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pWaitSemaphoreDeviceIndices, *ptr, forUnmarshaling->waitSemaphoreCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->waitSemaphoreCount * sizeof(const uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->commandBufferCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pCommandBufferDeviceMasks, forUnmarshaling->commandBufferCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pCommandBufferDeviceMasks, *ptr, forUnmarshaling->commandBufferCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->commandBufferCount * sizeof(const uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->signalSemaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphoreDeviceIndices, forUnmarshaling->signalSemaphoreCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pSignalSemaphoreDeviceIndices, *ptr, forUnmarshaling->signalSemaphoreCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->signalSemaphoreCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkDeviceGroupBindSparseInfo(
    VulkanStream* vkStream,
    VkDeviceGroupBindSparseInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->resourceDeviceIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->memoryDeviceIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkBindBufferMemoryDeviceGroupInfo(
    VulkanStream* vkStream,
    VkBindBufferMemoryDeviceGroupInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->deviceIndexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pDeviceIndices, *ptr, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->deviceIndexCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkBindImageMemoryDeviceGroupInfo(
    VulkanStream* vkStream,
    VkBindImageMemoryDeviceGroupInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->deviceIndexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pDeviceIndices, *ptr, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->deviceIndexCount * sizeof(const uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->splitInstanceBindRegionCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSplitInstanceBindRegions, forUnmarshaling->splitInstanceBindRegionCount * sizeof(const VkRect2D));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->splitInstanceBindRegionCount; ++i)
    {
        reservedunmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pSplitInstanceBindRegions + i), ptr);
    }
}

void reservedunmarshal_VkPhysicalDeviceGroupProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceGroupProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->physicalDeviceCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkPhysicalDevice*)forUnmarshaling->physicalDevices, *ptr, VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice));
    *ptr += VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice);
    memcpy((VkBool32*)&forUnmarshaling->subsetAllocation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDeviceGroupDeviceCreateInfo(
    VulkanStream* vkStream,
    VkDeviceGroupDeviceCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->physicalDeviceCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPhysicalDevices, forUnmarshaling->physicalDeviceCount * sizeof(const VkPhysicalDevice));
    if (forUnmarshaling->physicalDeviceCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->physicalDeviceCount;
        for (uint32_t k = 0; k < forUnmarshaling->physicalDeviceCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
            *(((VkPhysicalDevice*)forUnmarshaling->pPhysicalDevices) + k) = (VkPhysicalDevice)unbox_VkPhysicalDevice((VkPhysicalDevice)tmpval);
        }
    }
}

void reservedunmarshal_VkBufferMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    VkBufferMemoryRequirementsInfo2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
}

void reservedunmarshal_VkImageMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    VkImageMemoryRequirementsInfo2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
}

void reservedunmarshal_VkImageSparseMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    VkImageSparseMemoryRequirementsInfo2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
}

void reservedunmarshal_VkMemoryRequirements2(
    VulkanStream* vkStream,
    VkMemoryRequirements2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(&forUnmarshaling->memoryRequirements), ptr);
}

void reservedunmarshal_VkSparseImageMemoryRequirements2(
    VulkanStream* vkStream,
    VkSparseImageMemoryRequirements2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(&forUnmarshaling->memoryRequirements), ptr);
}

void reservedunmarshal_VkPhysicalDeviceFeatures2(
    VulkanStream* vkStream,
    VkPhysicalDeviceFeatures2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(&forUnmarshaling->features), ptr);
}

void reservedunmarshal_VkPhysicalDeviceProperties2(
    VulkanStream* vkStream,
    VkPhysicalDeviceProperties2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(&forUnmarshaling->properties), ptr);
}

void reservedunmarshal_VkFormatProperties2(
    VulkanStream* vkStream,
    VkFormatProperties2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkFormatProperties(vkStream, (VkFormatProperties*)(&forUnmarshaling->formatProperties), ptr);
}

void reservedunmarshal_VkImageFormatProperties2(
    VulkanStream* vkStream,
    VkImageFormatProperties2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forUnmarshaling->imageFormatProperties), ptr);
}

void reservedunmarshal_VkPhysicalDeviceImageFormatInfo2(
    VulkanStream* vkStream,
    VkPhysicalDeviceImageFormatInfo2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkImageType*)&forUnmarshaling->type, *ptr, sizeof(VkImageType));
    *ptr += sizeof(VkImageType);
    memcpy((VkImageTiling*)&forUnmarshaling->tiling, *ptr, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
    memcpy((VkImageUsageFlags*)&forUnmarshaling->usage, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy((VkImageCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkImageCreateFlags));
    *ptr += sizeof(VkImageCreateFlags);
}

void reservedunmarshal_VkQueueFamilyProperties2(
    VulkanStream* vkStream,
    VkQueueFamilyProperties2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(&forUnmarshaling->queueFamilyProperties), ptr);
}

void reservedunmarshal_VkPhysicalDeviceMemoryProperties2(
    VulkanStream* vkStream,
    VkPhysicalDeviceMemoryProperties2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(&forUnmarshaling->memoryProperties), ptr);
}

void reservedunmarshal_VkSparseImageFormatProperties2(
    VulkanStream* vkStream,
    VkSparseImageFormatProperties2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forUnmarshaling->properties), ptr);
}

void reservedunmarshal_VkPhysicalDeviceSparseImageFormatInfo2(
    VulkanStream* vkStream,
    VkPhysicalDeviceSparseImageFormatInfo2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkImageType*)&forUnmarshaling->type, *ptr, sizeof(VkImageType));
    *ptr += sizeof(VkImageType);
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->samples, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy((VkImageUsageFlags*)&forUnmarshaling->usage, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy((VkImageTiling*)&forUnmarshaling->tiling, *ptr, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
}

void reservedunmarshal_VkPhysicalDevicePointClippingProperties(
    VulkanStream* vkStream,
    VkPhysicalDevicePointClippingProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPointClippingBehavior*)&forUnmarshaling->pointClippingBehavior, *ptr, sizeof(VkPointClippingBehavior));
    *ptr += sizeof(VkPointClippingBehavior);
}

void reservedunmarshal_VkInputAttachmentAspectReference(
    VulkanStream* vkStream,
    VkInputAttachmentAspectReference* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->subpass, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->inputAttachmentIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkImageAspectFlags*)&forUnmarshaling->aspectMask, *ptr, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
}

void reservedunmarshal_VkRenderPassInputAttachmentAspectCreateInfo(
    VulkanStream* vkStream,
    VkRenderPassInputAttachmentAspectCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->aspectReferenceCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAspectReferences, forUnmarshaling->aspectReferenceCount * sizeof(const VkInputAttachmentAspectReference));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->aspectReferenceCount; ++i)
    {
        reservedunmarshal_VkInputAttachmentAspectReference(vkStream, (VkInputAttachmentAspectReference*)(forUnmarshaling->pAspectReferences + i), ptr);
    }
}

void reservedunmarshal_VkImageViewUsageCreateInfo(
    VulkanStream* vkStream,
    VkImageViewUsageCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageUsageFlags*)&forUnmarshaling->usage, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
}

void reservedunmarshal_VkPipelineTessellationDomainOriginStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineTessellationDomainOriginStateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkTessellationDomainOrigin*)&forUnmarshaling->domainOrigin, *ptr, sizeof(VkTessellationDomainOrigin));
    *ptr += sizeof(VkTessellationDomainOrigin);
}

void reservedunmarshal_VkRenderPassMultiviewCreateInfo(
    VulkanStream* vkStream,
    VkRenderPassMultiviewCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->subpassCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pViewMasks, forUnmarshaling->subpassCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pViewMasks, *ptr, forUnmarshaling->subpassCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->subpassCount * sizeof(const uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dependencyCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pViewOffsets, forUnmarshaling->dependencyCount * sizeof(const int32_t));
    memcpy((int32_t*)forUnmarshaling->pViewOffsets, *ptr, forUnmarshaling->dependencyCount * sizeof(const int32_t));
    *ptr += forUnmarshaling->dependencyCount * sizeof(const int32_t);
    memcpy((uint32_t*)&forUnmarshaling->correlationMaskCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pCorrelationMasks, forUnmarshaling->correlationMaskCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pCorrelationMasks, *ptr, forUnmarshaling->correlationMaskCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->correlationMaskCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkPhysicalDeviceMultiviewFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceMultiviewFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->multiview, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->multiviewGeometryShader, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->multiviewTessellationShader, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceMultiviewProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceMultiviewProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxMultiviewViewCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxMultiviewInstanceIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPhysicalDeviceVariablePointerFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceVariablePointerFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->variablePointersStorageBuffer, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->variablePointers, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceProtectedMemoryFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceProtectedMemoryFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->protectedMemory, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceProtectedMemoryProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceProtectedMemoryProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->protectedNoFault, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDeviceQueueInfo2(
    VulkanStream* vkStream,
    VkDeviceQueueInfo2* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceQueueCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkDeviceQueueCreateFlags));
    *ptr += sizeof(VkDeviceQueueCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->queueFamilyIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->queueIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkProtectedSubmitInfo(
    VulkanStream* vkStream,
    VkProtectedSubmitInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->protectedSubmit, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkSamplerYcbcrConversionCreateInfo(
    VulkanStream* vkStream,
    VkSamplerYcbcrConversionCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkSamplerYcbcrModelConversion*)&forUnmarshaling->ycbcrModel, *ptr, sizeof(VkSamplerYcbcrModelConversion));
    *ptr += sizeof(VkSamplerYcbcrModelConversion);
    memcpy((VkSamplerYcbcrRange*)&forUnmarshaling->ycbcrRange, *ptr, sizeof(VkSamplerYcbcrRange));
    *ptr += sizeof(VkSamplerYcbcrRange);
    reservedunmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forUnmarshaling->components), ptr);
    memcpy((VkChromaLocation*)&forUnmarshaling->xChromaOffset, *ptr, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
    memcpy((VkChromaLocation*)&forUnmarshaling->yChromaOffset, *ptr, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
    memcpy((VkFilter*)&forUnmarshaling->chromaFilter, *ptr, sizeof(VkFilter));
    *ptr += sizeof(VkFilter);
    memcpy((VkBool32*)&forUnmarshaling->forceExplicitReconstruction, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkSamplerYcbcrConversionInfo(
    VulkanStream* vkStream,
    VkSamplerYcbcrConversionInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSamplerYcbcrConversion*)&forUnmarshaling->conversion = (VkSamplerYcbcrConversion)unbox_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion)(*&cgen_var_0));
}

void reservedunmarshal_VkBindImagePlaneMemoryInfo(
    VulkanStream* vkStream,
    VkBindImagePlaneMemoryInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageAspectFlagBits*)&forUnmarshaling->planeAspect, *ptr, sizeof(VkImageAspectFlagBits));
    *ptr += sizeof(VkImageAspectFlagBits);
}

void reservedunmarshal_VkImagePlaneMemoryRequirementsInfo(
    VulkanStream* vkStream,
    VkImagePlaneMemoryRequirementsInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageAspectFlagBits*)&forUnmarshaling->planeAspect, *ptr, sizeof(VkImageAspectFlagBits));
    *ptr += sizeof(VkImageAspectFlagBits);
}

void reservedunmarshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceSamplerYcbcrConversionFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->samplerYcbcrConversion, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkSamplerYcbcrConversionImageFormatProperties(
    VulkanStream* vkStream,
    VkSamplerYcbcrConversionImageFormatProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->combinedImageSamplerDescriptorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDescriptorUpdateTemplateEntry(
    VulkanStream* vkStream,
    VkDescriptorUpdateTemplateEntry* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->dstBinding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dstArrayElement, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->descriptorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDescriptorType*)&forUnmarshaling->descriptorType, *ptr, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    memcpy((size_t*)&forUnmarshaling->offset, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->offset);
    *ptr += 8;
    memcpy((size_t*)&forUnmarshaling->stride, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->stride);
    *ptr += 8;
}

void reservedunmarshal_VkDescriptorUpdateTemplateCreateInfo(
    VulkanStream* vkStream,
    VkDescriptorUpdateTemplateCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDescriptorUpdateTemplateCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkDescriptorUpdateTemplateCreateFlags));
    *ptr += sizeof(VkDescriptorUpdateTemplateCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->descriptorUpdateEntryCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDescriptorUpdateEntries, forUnmarshaling->descriptorUpdateEntryCount * sizeof(const VkDescriptorUpdateTemplateEntry));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorUpdateEntryCount; ++i)
    {
        reservedunmarshal_VkDescriptorUpdateTemplateEntry(vkStream, (VkDescriptorUpdateTemplateEntry*)(forUnmarshaling->pDescriptorUpdateEntries + i), ptr);
    }
    memcpy((VkDescriptorUpdateTemplateType*)&forUnmarshaling->templateType, *ptr, sizeof(VkDescriptorUpdateTemplateType));
    *ptr += sizeof(VkDescriptorUpdateTemplateType);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDescriptorSetLayout*)&forUnmarshaling->descriptorSetLayout = (VkDescriptorSetLayout)unbox_VkDescriptorSetLayout((VkDescriptorSetLayout)(*&cgen_var_0));
    memcpy((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, *ptr, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipelineLayout*)&forUnmarshaling->pipelineLayout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_1));
    memcpy((uint32_t*)&forUnmarshaling->set, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkExternalMemoryProperties(
    VulkanStream* vkStream,
    VkExternalMemoryProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkExternalMemoryFeatureFlags*)&forUnmarshaling->externalMemoryFeatures, *ptr, sizeof(VkExternalMemoryFeatureFlags));
    *ptr += sizeof(VkExternalMemoryFeatureFlags);
    memcpy((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
    memcpy((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedunmarshal_VkPhysicalDeviceExternalImageFormatInfo(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalImageFormatInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

void reservedunmarshal_VkExternalImageFormatProperties(
    VulkanStream* vkStream,
    VkExternalImageFormatProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forUnmarshaling->externalMemoryProperties), ptr);
}

void reservedunmarshal_VkPhysicalDeviceExternalBufferInfo(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalBufferInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBufferCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkBufferCreateFlags));
    *ptr += sizeof(VkBufferCreateFlags);
    memcpy((VkBufferUsageFlags*)&forUnmarshaling->usage, *ptr, sizeof(VkBufferUsageFlags));
    *ptr += sizeof(VkBufferUsageFlags);
    memcpy((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

void reservedunmarshal_VkExternalBufferProperties(
    VulkanStream* vkStream,
    VkExternalBufferProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forUnmarshaling->externalMemoryProperties), ptr);
}

void reservedunmarshal_VkPhysicalDeviceIDProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceIDProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint8_t*)forUnmarshaling->deviceUUID, *ptr, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    memcpy((uint8_t*)forUnmarshaling->driverUUID, *ptr, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    memcpy((uint8_t*)forUnmarshaling->deviceLUID, *ptr, VK_LUID_SIZE * sizeof(uint8_t));
    *ptr += VK_LUID_SIZE * sizeof(uint8_t);
    memcpy((uint32_t*)&forUnmarshaling->deviceNodeMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->deviceLUIDValid, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkExternalMemoryImageCreateInfo(
    VulkanStream* vkStream,
    VkExternalMemoryImageCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedunmarshal_VkExternalMemoryBufferCreateInfo(
    VulkanStream* vkStream,
    VkExternalMemoryBufferCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedunmarshal_VkExportMemoryAllocateInfo(
    VulkanStream* vkStream,
    VkExportMemoryAllocateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedunmarshal_VkPhysicalDeviceExternalFenceInfo(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalFenceInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
}

void reservedunmarshal_VkExternalFenceProperties(
    VulkanStream* vkStream,
    VkExternalFenceProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, *ptr, sizeof(VkExternalFenceHandleTypeFlags));
    *ptr += sizeof(VkExternalFenceHandleTypeFlags);
    memcpy((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, *ptr, sizeof(VkExternalFenceHandleTypeFlags));
    *ptr += sizeof(VkExternalFenceHandleTypeFlags);
    memcpy((VkExternalFenceFeatureFlags*)&forUnmarshaling->externalFenceFeatures, *ptr, sizeof(VkExternalFenceFeatureFlags));
    *ptr += sizeof(VkExternalFenceFeatureFlags);
}

void reservedunmarshal_VkExportFenceCreateInfo(
    VulkanStream* vkStream,
    VkExportFenceCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->handleTypes, *ptr, sizeof(VkExternalFenceHandleTypeFlags));
    *ptr += sizeof(VkExternalFenceHandleTypeFlags);
}

void reservedunmarshal_VkExportSemaphoreCreateInfo(
    VulkanStream* vkStream,
    VkExportSemaphoreCreateInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->handleTypes, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlags));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlags);
}

void reservedunmarshal_VkPhysicalDeviceExternalSemaphoreInfo(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalSemaphoreInfo* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

void reservedunmarshal_VkExternalSemaphoreProperties(
    VulkanStream* vkStream,
    VkExternalSemaphoreProperties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlags));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlags);
    memcpy((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlags));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlags);
    memcpy((VkExternalSemaphoreFeatureFlags*)&forUnmarshaling->externalSemaphoreFeatures, *ptr, sizeof(VkExternalSemaphoreFeatureFlags));
    *ptr += sizeof(VkExternalSemaphoreFeatureFlags);
}

void reservedunmarshal_VkPhysicalDeviceMaintenance3Properties(
    VulkanStream* vkStream,
    VkPhysicalDeviceMaintenance3Properties* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxPerSetDescriptors, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkDeviceSize*)&forUnmarshaling->maxMemoryAllocationSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkDescriptorSetLayoutSupport(
    VulkanStream* vkStream,
    VkDescriptorSetLayoutSupport* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->supported, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceShaderDrawParameterFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderDrawParameterFeatures* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderDrawParameters, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_surface
void reservedunmarshal_VkSurfaceCapabilitiesKHR(
    VulkanStream* vkStream,
    VkSurfaceCapabilitiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->minImageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxImageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->currentExtent), ptr);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minImageExtent), ptr);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxImageExtent), ptr);
    memcpy((uint32_t*)&forUnmarshaling->maxImageArrayLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, *ptr, sizeof(VkSurfaceTransformFlagsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagsKHR);
    memcpy((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->currentTransform, *ptr, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy((VkCompositeAlphaFlagsKHR*)&forUnmarshaling->supportedCompositeAlpha, *ptr, sizeof(VkCompositeAlphaFlagsKHR));
    *ptr += sizeof(VkCompositeAlphaFlagsKHR);
    memcpy((VkImageUsageFlags*)&forUnmarshaling->supportedUsageFlags, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
}

void reservedunmarshal_VkSurfaceFormatKHR(
    VulkanStream* vkStream,
    VkSurfaceFormatKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkColorSpaceKHR*)&forUnmarshaling->colorSpace, *ptr, sizeof(VkColorSpaceKHR));
    *ptr += sizeof(VkColorSpaceKHR);
}

#endif
#ifdef VK_KHR_swapchain
void reservedunmarshal_VkSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    VkSwapchainCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSwapchainCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkSwapchainCreateFlagsKHR));
    *ptr += sizeof(VkSwapchainCreateFlagsKHR);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSurfaceKHR*)&forUnmarshaling->surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->minImageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkFormat*)&forUnmarshaling->imageFormat, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkColorSpaceKHR*)&forUnmarshaling->imageColorSpace, *ptr, sizeof(VkColorSpaceKHR));
    *ptr += sizeof(VkColorSpaceKHR);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->imageExtent), ptr);
    memcpy((uint32_t*)&forUnmarshaling->imageArrayLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkImageUsageFlags*)&forUnmarshaling->imageUsage, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy((VkSharingMode*)&forUnmarshaling->imageSharingMode, *ptr, sizeof(VkSharingMode));
    *ptr += sizeof(VkSharingMode);
    memcpy((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((uint32_t**)&forUnmarshaling->pQueueFamilyIndices, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pQueueFamilyIndices);
    *ptr += 8;
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        memcpy((uint32_t*)forUnmarshaling->pQueueFamilyIndices, *ptr, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        *ptr += forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t);
    }
    memcpy((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->preTransform, *ptr, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy((VkCompositeAlphaFlagBitsKHR*)&forUnmarshaling->compositeAlpha, *ptr, sizeof(VkCompositeAlphaFlagBitsKHR));
    *ptr += sizeof(VkCompositeAlphaFlagBitsKHR);
    memcpy((VkPresentModeKHR*)&forUnmarshaling->presentMode, *ptr, sizeof(VkPresentModeKHR));
    *ptr += sizeof(VkPresentModeKHR);
    memcpy((VkBool32*)&forUnmarshaling->clipped, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    uint64_t cgen_var_2;
    memcpy((uint64_t*)&cgen_var_2, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSwapchainKHR*)&forUnmarshaling->oldSwapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_2));
}

void reservedunmarshal_VkPresentInfoKHR(
    VulkanStream* vkStream,
    VkPresentInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->waitSemaphoreCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    if (forUnmarshaling->waitSemaphoreCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->waitSemaphoreCount;
        for (uint32_t k = 0; k < forUnmarshaling->waitSemaphoreCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
            *(((VkSemaphore*)forUnmarshaling->pWaitSemaphores) + k) = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)tmpval);
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->swapchainCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSwapchains, forUnmarshaling->swapchainCount * sizeof(const VkSwapchainKHR));
    if (forUnmarshaling->swapchainCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->swapchainCount;
        for (uint32_t k = 0; k < forUnmarshaling->swapchainCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
            *(((VkSwapchainKHR*)forUnmarshaling->pSwapchains) + k) = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)tmpval);
        }
    }
    vkStream->alloc((void**)&forUnmarshaling->pImageIndices, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pImageIndices, *ptr, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->swapchainCount * sizeof(const uint32_t);
    // WARNING PTR CHECK
    memcpy((VkResult**)&forUnmarshaling->pResults, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pResults);
    *ptr += 8;
    if (forUnmarshaling->pResults)
    {
        vkStream->alloc((void**)&forUnmarshaling->pResults, forUnmarshaling->swapchainCount * sizeof(VkResult));
        memcpy((VkResult*)forUnmarshaling->pResults, *ptr, forUnmarshaling->swapchainCount * sizeof(VkResult));
        *ptr += forUnmarshaling->swapchainCount * sizeof(VkResult);
    }
}

void reservedunmarshal_VkImageSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    VkImageSwapchainCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSwapchainKHR*)&forUnmarshaling->swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_0));
}

void reservedunmarshal_VkBindImageMemorySwapchainInfoKHR(
    VulkanStream* vkStream,
    VkBindImageMemorySwapchainInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSwapchainKHR*)&forUnmarshaling->swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->imageIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkAcquireNextImageInfoKHR(
    VulkanStream* vkStream,
    VkAcquireNextImageInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSwapchainKHR*)&forUnmarshaling->swapchain = (VkSwapchainKHR)unbox_VkSwapchainKHR((VkSwapchainKHR)(*&cgen_var_0));
    memcpy((uint64_t*)&forUnmarshaling->timeout, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSemaphore*)&forUnmarshaling->semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_1));
    uint64_t cgen_var_2;
    memcpy((uint64_t*)&cgen_var_2, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkFence*)&forUnmarshaling->fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_2));
    memcpy((uint32_t*)&forUnmarshaling->deviceMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDeviceGroupPresentCapabilitiesKHR(
    VulkanStream* vkStream,
    VkDeviceGroupPresentCapabilitiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)forUnmarshaling->presentMask, *ptr, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t));
    *ptr += VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t);
    memcpy((VkDeviceGroupPresentModeFlagsKHR*)&forUnmarshaling->modes, *ptr, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    *ptr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
}

void reservedunmarshal_VkDeviceGroupPresentInfoKHR(
    VulkanStream* vkStream,
    VkDeviceGroupPresentInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->swapchainCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDeviceMasks, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pDeviceMasks, *ptr, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->swapchainCount * sizeof(const uint32_t);
    memcpy((VkDeviceGroupPresentModeFlagBitsKHR*)&forUnmarshaling->mode, *ptr, sizeof(VkDeviceGroupPresentModeFlagBitsKHR));
    *ptr += sizeof(VkDeviceGroupPresentModeFlagBitsKHR);
}

void reservedunmarshal_VkDeviceGroupSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    VkDeviceGroupSwapchainCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceGroupPresentModeFlagsKHR*)&forUnmarshaling->modes, *ptr, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    *ptr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
}

#endif
#ifdef VK_KHR_display
void reservedunmarshal_VkDisplayPropertiesKHR(
    VulkanStream* vkStream,
    VkDisplayPropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDisplayKHR*)&forUnmarshaling->display = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_0));
    vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->displayName, ptr);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->physicalDimensions), ptr);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->physicalResolution), ptr);
    memcpy((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, *ptr, sizeof(VkSurfaceTransformFlagsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagsKHR);
    memcpy((VkBool32*)&forUnmarshaling->planeReorderPossible, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->persistentContent, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDisplayModeParametersKHR(
    VulkanStream* vkStream,
    VkDisplayModeParametersKHR* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->visibleRegion), ptr);
    memcpy((uint32_t*)&forUnmarshaling->refreshRate, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDisplayModePropertiesKHR(
    VulkanStream* vkStream,
    VkDisplayModePropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDisplayModeKHR*)&forUnmarshaling->displayMode = (VkDisplayModeKHR)unbox_VkDisplayModeKHR((VkDisplayModeKHR)(*&cgen_var_0));
    reservedunmarshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forUnmarshaling->parameters), ptr);
}

void reservedunmarshal_VkDisplayModeCreateInfoKHR(
    VulkanStream* vkStream,
    VkDisplayModeCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDisplayModeCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkDisplayModeCreateFlagsKHR));
    *ptr += sizeof(VkDisplayModeCreateFlagsKHR);
    reservedunmarshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forUnmarshaling->parameters), ptr);
}

void reservedunmarshal_VkDisplayPlaneCapabilitiesKHR(
    VulkanStream* vkStream,
    VkDisplayPlaneCapabilitiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkDisplayPlaneAlphaFlagsKHR*)&forUnmarshaling->supportedAlpha, *ptr, sizeof(VkDisplayPlaneAlphaFlagsKHR));
    *ptr += sizeof(VkDisplayPlaneAlphaFlagsKHR);
    reservedunmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->minSrcPosition), ptr);
    reservedunmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->maxSrcPosition), ptr);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minSrcExtent), ptr);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxSrcExtent), ptr);
    reservedunmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->minDstPosition), ptr);
    reservedunmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->maxDstPosition), ptr);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minDstExtent), ptr);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxDstExtent), ptr);
}

void reservedunmarshal_VkDisplayPlanePropertiesKHR(
    VulkanStream* vkStream,
    VkDisplayPlanePropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDisplayKHR*)&forUnmarshaling->currentDisplay = (VkDisplayKHR)unbox_VkDisplayKHR((VkDisplayKHR)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->currentStackIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDisplaySurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkDisplaySurfaceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDisplaySurfaceCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkDisplaySurfaceCreateFlagsKHR));
    *ptr += sizeof(VkDisplaySurfaceCreateFlagsKHR);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDisplayModeKHR*)&forUnmarshaling->displayMode = (VkDisplayModeKHR)unbox_VkDisplayModeKHR((VkDisplayModeKHR)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->planeIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->planeStackIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->transform, *ptr, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy((float*)&forUnmarshaling->globalAlpha, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((VkDisplayPlaneAlphaFlagBitsKHR*)&forUnmarshaling->alphaMode, *ptr, sizeof(VkDisplayPlaneAlphaFlagBitsKHR));
    *ptr += sizeof(VkDisplayPlaneAlphaFlagBitsKHR);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->imageExtent), ptr);
}

#endif
#ifdef VK_KHR_display_swapchain
void reservedunmarshal_VkDisplayPresentInfoKHR(
    VulkanStream* vkStream,
    VkDisplayPresentInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->srcRect), ptr);
    reservedunmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->dstRect), ptr);
    memcpy((VkBool32*)&forUnmarshaling->persistent, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_xlib_surface
void reservedunmarshal_VkXlibSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkXlibSurfaceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkXlibSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkXlibSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkXlibSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    memcpy((Display**)&forUnmarshaling->dpy, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->dpy);
    *ptr += 8;
    if (forUnmarshaling->dpy)
    {
        vkStream->alloc((void**)&forUnmarshaling->dpy, sizeof(Display));
        memcpy((Display*)forUnmarshaling->dpy, *ptr, sizeof(Display));
        *ptr += sizeof(Display);
    }
    memcpy((Window*)&forUnmarshaling->window, *ptr, sizeof(Window));
    *ptr += sizeof(Window);
}

#endif
#ifdef VK_KHR_xcb_surface
void reservedunmarshal_VkXcbSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkXcbSurfaceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkXcbSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkXcbSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkXcbSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    memcpy((xcb_connection_t**)&forUnmarshaling->connection, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->connection);
    *ptr += 8;
    if (forUnmarshaling->connection)
    {
        vkStream->alloc((void**)&forUnmarshaling->connection, sizeof(xcb_connection_t));
        memcpy((xcb_connection_t*)forUnmarshaling->connection, *ptr, sizeof(xcb_connection_t));
        *ptr += sizeof(xcb_connection_t);
    }
    memcpy((xcb_window_t*)&forUnmarshaling->window, *ptr, sizeof(xcb_window_t));
    *ptr += sizeof(xcb_window_t);
}

#endif
#ifdef VK_KHR_wayland_surface
void reservedunmarshal_VkWaylandSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkWaylandSurfaceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkWaylandSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkWaylandSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkWaylandSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    memcpy((wl_display**)&forUnmarshaling->display, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->display);
    *ptr += 8;
    if (forUnmarshaling->display)
    {
        vkStream->alloc((void**)&forUnmarshaling->display, sizeof(wl_display));
        memcpy((wl_display*)forUnmarshaling->display, *ptr, sizeof(wl_display));
        *ptr += sizeof(wl_display);
    }
    // WARNING PTR CHECK
    memcpy((wl_surface**)&forUnmarshaling->surface, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->surface);
    *ptr += 8;
    if (forUnmarshaling->surface)
    {
        vkStream->alloc((void**)&forUnmarshaling->surface, sizeof(wl_surface));
        memcpy((wl_surface*)forUnmarshaling->surface, *ptr, sizeof(wl_surface));
        *ptr += sizeof(wl_surface);
    }
}

#endif
#ifdef VK_KHR_mir_surface
void reservedunmarshal_VkMirSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkMirSurfaceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkMirSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkMirSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkMirSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    memcpy((MirConnection**)&forUnmarshaling->connection, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->connection);
    *ptr += 8;
    if (forUnmarshaling->connection)
    {
        vkStream->alloc((void**)&forUnmarshaling->connection, sizeof(MirConnection));
        memcpy((MirConnection*)forUnmarshaling->connection, *ptr, sizeof(MirConnection));
        *ptr += sizeof(MirConnection);
    }
    // WARNING PTR CHECK
    memcpy((MirSurface**)&forUnmarshaling->mirSurface, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->mirSurface);
    *ptr += 8;
    if (forUnmarshaling->mirSurface)
    {
        vkStream->alloc((void**)&forUnmarshaling->mirSurface, sizeof(MirSurface));
        memcpy((MirSurface*)forUnmarshaling->mirSurface, *ptr, sizeof(MirSurface));
        *ptr += sizeof(MirSurface);
    }
}

#endif
#ifdef VK_KHR_android_surface
void reservedunmarshal_VkAndroidSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkAndroidSurfaceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAndroidSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkAndroidSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkAndroidSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    memcpy((ANativeWindow**)&forUnmarshaling->window, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->window);
    *ptr += 8;
    if (forUnmarshaling->window)
    {
        vkStream->alloc((void**)&forUnmarshaling->window, sizeof(ANativeWindow));
        memcpy((ANativeWindow*)forUnmarshaling->window, *ptr, sizeof(ANativeWindow));
        *ptr += sizeof(ANativeWindow);
    }
}

#endif
#ifdef VK_KHR_win32_surface
void reservedunmarshal_VkWin32SurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkWin32SurfaceCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkWin32SurfaceCreateFlagsKHR*)&forUnmarshaling->flags, *ptr, sizeof(VkWin32SurfaceCreateFlagsKHR));
    *ptr += sizeof(VkWin32SurfaceCreateFlagsKHR);
    memcpy((HINSTANCE*)&forUnmarshaling->hinstance, *ptr, sizeof(HINSTANCE));
    *ptr += sizeof(HINSTANCE);
    memcpy((HWND*)&forUnmarshaling->hwnd, *ptr, sizeof(HWND));
    *ptr += sizeof(HWND);
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_device_group
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_device_group_creation
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void reservedunmarshal_VkImportMemoryWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkImportMemoryWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    memcpy((HANDLE*)&forUnmarshaling->handle, *ptr, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
    memcpy((LPCWSTR*)&forUnmarshaling->name, *ptr, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedunmarshal_VkExportMemoryWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkExportMemoryWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    // WARNING PTR CHECK
    memcpy((SECURITY_ATTRIBUTES**)&forUnmarshaling->pAttributes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pAttributes);
    *ptr += 8;
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        memcpy((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, *ptr, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy((DWORD*)&forUnmarshaling->dwAccess, *ptr, sizeof(DWORD));
    *ptr += sizeof(DWORD);
    memcpy((LPCWSTR*)&forUnmarshaling->name, *ptr, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedunmarshal_VkMemoryWin32HandlePropertiesKHR(
    VulkanStream* vkStream,
    VkMemoryWin32HandlePropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->memoryTypeBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkMemoryGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkMemoryGetWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_0));
    memcpy((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_memory_fd
void reservedunmarshal_VkImportMemoryFdInfoKHR(
    VulkanStream* vkStream,
    VkImportMemoryFdInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    memcpy((int*)&forUnmarshaling->fd, *ptr, sizeof(int));
    *ptr += sizeof(int);
}

void reservedunmarshal_VkMemoryFdPropertiesKHR(
    VulkanStream* vkStream,
    VkMemoryFdPropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->memoryTypeBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkMemoryGetFdInfoKHR(
    VulkanStream* vkStream,
    VkMemoryGetFdInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_0));
    memcpy((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void reservedunmarshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    VulkanStream* vkStream,
    VkWin32KeyedMutexAcquireReleaseInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->acquireCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAcquireSyncs, forUnmarshaling->acquireCount * sizeof(const VkDeviceMemory));
    if (forUnmarshaling->acquireCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->acquireCount;
        for (uint32_t k = 0; k < forUnmarshaling->acquireCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
            *(((VkDeviceMemory*)forUnmarshaling->pAcquireSyncs) + k) = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)tmpval);
        }
    }
    vkStream->alloc((void**)&forUnmarshaling->pAcquireKeys, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    memcpy((uint64_t*)forUnmarshaling->pAcquireKeys, *ptr, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    *ptr += forUnmarshaling->acquireCount * sizeof(const uint64_t);
    vkStream->alloc((void**)&forUnmarshaling->pAcquireTimeouts, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pAcquireTimeouts, *ptr, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->acquireCount * sizeof(const uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->releaseCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pReleaseSyncs, forUnmarshaling->releaseCount * sizeof(const VkDeviceMemory));
    if (forUnmarshaling->releaseCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->releaseCount;
        for (uint32_t k = 0; k < forUnmarshaling->releaseCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
            *(((VkDeviceMemory*)forUnmarshaling->pReleaseSyncs) + k) = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)tmpval);
        }
    }
    vkStream->alloc((void**)&forUnmarshaling->pReleaseKeys, forUnmarshaling->releaseCount * sizeof(const uint64_t));
    memcpy((uint64_t*)forUnmarshaling->pReleaseKeys, *ptr, forUnmarshaling->releaseCount * sizeof(const uint64_t));
    *ptr += forUnmarshaling->releaseCount * sizeof(const uint64_t);
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void reservedunmarshal_VkImportSemaphoreWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkImportSemaphoreWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSemaphore*)&forUnmarshaling->semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_0));
    memcpy((VkSemaphoreImportFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSemaphoreImportFlags));
    *ptr += sizeof(VkSemaphoreImportFlags);
    memcpy((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
    memcpy((HANDLE*)&forUnmarshaling->handle, *ptr, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
    memcpy((LPCWSTR*)&forUnmarshaling->name, *ptr, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedunmarshal_VkExportSemaphoreWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkExportSemaphoreWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    // WARNING PTR CHECK
    memcpy((SECURITY_ATTRIBUTES**)&forUnmarshaling->pAttributes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pAttributes);
    *ptr += 8;
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        memcpy((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, *ptr, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy((DWORD*)&forUnmarshaling->dwAccess, *ptr, sizeof(DWORD));
    *ptr += sizeof(DWORD);
    memcpy((LPCWSTR*)&forUnmarshaling->name, *ptr, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedunmarshal_VkD3D12FenceSubmitInfoKHR(
    VulkanStream* vkStream,
    VkD3D12FenceSubmitInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->waitSemaphoreValuesCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((uint64_t**)&forUnmarshaling->pWaitSemaphoreValues, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pWaitSemaphoreValues);
    *ptr += 8;
    if (forUnmarshaling->pWaitSemaphoreValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphoreValues, forUnmarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t));
        memcpy((uint64_t*)forUnmarshaling->pWaitSemaphoreValues, *ptr, forUnmarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t));
        *ptr += forUnmarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t);
    }
    memcpy((uint32_t*)&forUnmarshaling->signalSemaphoreValuesCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((uint64_t**)&forUnmarshaling->pSignalSemaphoreValues, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pSignalSemaphoreValues);
    *ptr += 8;
    if (forUnmarshaling->pSignalSemaphoreValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphoreValues, forUnmarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t));
        memcpy((uint64_t*)forUnmarshaling->pSignalSemaphoreValues, *ptr, forUnmarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t));
        *ptr += forUnmarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t);
    }
}

void reservedunmarshal_VkSemaphoreGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkSemaphoreGetWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSemaphore*)&forUnmarshaling->semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_0));
    memcpy((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void reservedunmarshal_VkImportSemaphoreFdInfoKHR(
    VulkanStream* vkStream,
    VkImportSemaphoreFdInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSemaphore*)&forUnmarshaling->semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_0));
    memcpy((VkSemaphoreImportFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSemaphoreImportFlags));
    *ptr += sizeof(VkSemaphoreImportFlags);
    memcpy((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
    memcpy((int*)&forUnmarshaling->fd, *ptr, sizeof(int));
    *ptr += sizeof(int);
}

void reservedunmarshal_VkSemaphoreGetFdInfoKHR(
    VulkanStream* vkStream,
    VkSemaphoreGetFdInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSemaphore*)&forUnmarshaling->semaphore = (VkSemaphore)unbox_VkSemaphore((VkSemaphore)(*&cgen_var_0));
    memcpy((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_push_descriptor
void reservedunmarshal_VkPhysicalDevicePushDescriptorPropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevicePushDescriptorPropertiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxPushDescriptors, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void reservedunmarshal_VkRectLayerKHR(
    VulkanStream* vkStream,
    VkRectLayerKHR* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->offset), ptr);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->extent), ptr);
    memcpy((uint32_t*)&forUnmarshaling->layer, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPresentRegionKHR(
    VulkanStream* vkStream,
    VkPresentRegionKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->rectangleCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkRectLayerKHR**)&forUnmarshaling->pRectangles, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pRectangles);
    *ptr += 8;
    if (forUnmarshaling->pRectangles)
    {
        vkStream->alloc((void**)&forUnmarshaling->pRectangles, forUnmarshaling->rectangleCount * sizeof(const VkRectLayerKHR));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->rectangleCount; ++i)
        {
            reservedunmarshal_VkRectLayerKHR(vkStream, (VkRectLayerKHR*)(forUnmarshaling->pRectangles + i), ptr);
        }
    }
}

void reservedunmarshal_VkPresentRegionsKHR(
    VulkanStream* vkStream,
    VkPresentRegionsKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->swapchainCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkPresentRegionKHR**)&forUnmarshaling->pRegions, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pRegions);
    *ptr += 8;
    if (forUnmarshaling->pRegions)
    {
        vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->swapchainCount * sizeof(const VkPresentRegionKHR));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->swapchainCount; ++i)
        {
            reservedunmarshal_VkPresentRegionKHR(vkStream, (VkPresentRegionKHR*)(forUnmarshaling->pRegions + i), ptr);
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_create_renderpass2
void reservedunmarshal_VkAttachmentDescription2KHR(
    VulkanStream* vkStream,
    VkAttachmentDescription2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkAttachmentDescriptionFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkAttachmentDescriptionFlags));
    *ptr += sizeof(VkAttachmentDescriptionFlags);
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->samples, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy((VkAttachmentLoadOp*)&forUnmarshaling->loadOp, *ptr, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy((VkAttachmentStoreOp*)&forUnmarshaling->storeOp, *ptr, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy((VkAttachmentLoadOp*)&forUnmarshaling->stencilLoadOp, *ptr, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy((VkAttachmentStoreOp*)&forUnmarshaling->stencilStoreOp, *ptr, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy((VkImageLayout*)&forUnmarshaling->initialLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((VkImageLayout*)&forUnmarshaling->finalLayout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedunmarshal_VkAttachmentReference2KHR(
    VulkanStream* vkStream,
    VkAttachmentReference2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->attachment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkImageLayout*)&forUnmarshaling->layout, *ptr, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy((VkImageAspectFlags*)&forUnmarshaling->aspectMask, *ptr, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
}

void reservedunmarshal_VkSubpassDescription2KHR(
    VulkanStream* vkStream,
    VkSubpassDescription2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSubpassDescriptionFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkSubpassDescriptionFlags));
    *ptr += sizeof(VkSubpassDescriptionFlags);
    memcpy((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, *ptr, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    memcpy((uint32_t*)&forUnmarshaling->viewMask, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->inputAttachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pInputAttachments, forUnmarshaling->inputAttachmentCount * sizeof(const VkAttachmentReference2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->inputAttachmentCount; ++i)
    {
        reservedunmarshal_VkAttachmentReference2KHR(vkStream, (VkAttachmentReference2KHR*)(forUnmarshaling->pInputAttachments + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->colorAttachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pColorAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
    {
        reservedunmarshal_VkAttachmentReference2KHR(vkStream, (VkAttachmentReference2KHR*)(forUnmarshaling->pColorAttachments + i), ptr);
    }
    // WARNING PTR CHECK
    memcpy((VkAttachmentReference2KHR**)&forUnmarshaling->pResolveAttachments, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pResolveAttachments);
    *ptr += 8;
    if (forUnmarshaling->pResolveAttachments)
    {
        vkStream->alloc((void**)&forUnmarshaling->pResolveAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference2KHR));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
        {
            reservedunmarshal_VkAttachmentReference2KHR(vkStream, (VkAttachmentReference2KHR*)(forUnmarshaling->pResolveAttachments + i), ptr);
        }
    }
    // WARNING PTR CHECK
    memcpy((VkAttachmentReference2KHR**)&forUnmarshaling->pDepthStencilAttachment, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pDepthStencilAttachment);
    *ptr += 8;
    if (forUnmarshaling->pDepthStencilAttachment)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDepthStencilAttachment, sizeof(const VkAttachmentReference2KHR));
        reservedunmarshal_VkAttachmentReference2KHR(vkStream, (VkAttachmentReference2KHR*)(forUnmarshaling->pDepthStencilAttachment), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->preserveAttachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPreserveAttachments, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pPreserveAttachments, *ptr, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkSubpassDependency2KHR(
    VulkanStream* vkStream,
    VkSubpassDependency2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->srcSubpass, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dstSubpass, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkPipelineStageFlags*)&forUnmarshaling->srcStageMask, *ptr, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy((VkPipelineStageFlags*)&forUnmarshaling->dstStageMask, *ptr, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy((VkAccessFlags*)&forUnmarshaling->srcAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkAccessFlags*)&forUnmarshaling->dstAccessMask, *ptr, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy((VkDependencyFlags*)&forUnmarshaling->dependencyFlags, *ptr, sizeof(VkDependencyFlags));
    *ptr += sizeof(VkDependencyFlags);
    memcpy((int32_t*)&forUnmarshaling->viewOffset, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedunmarshal_VkRenderPassCreateInfo2KHR(
    VulkanStream* vkStream,
    VkRenderPassCreateInfo2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkRenderPassCreateFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkRenderPassCreateFlags));
    *ptr += sizeof(VkRenderPassCreateFlags);
    memcpy((uint32_t*)&forUnmarshaling->attachmentCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkAttachmentDescription2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        reservedunmarshal_VkAttachmentDescription2KHR(vkStream, (VkAttachmentDescription2KHR*)(forUnmarshaling->pAttachments + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->subpassCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSubpasses, forUnmarshaling->subpassCount * sizeof(const VkSubpassDescription2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->subpassCount; ++i)
    {
        reservedunmarshal_VkSubpassDescription2KHR(vkStream, (VkSubpassDescription2KHR*)(forUnmarshaling->pSubpasses + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->dependencyCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDependencies, forUnmarshaling->dependencyCount * sizeof(const VkSubpassDependency2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->dependencyCount; ++i)
    {
        reservedunmarshal_VkSubpassDependency2KHR(vkStream, (VkSubpassDependency2KHR*)(forUnmarshaling->pDependencies + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->correlatedViewMaskCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pCorrelatedViewMasks, forUnmarshaling->correlatedViewMaskCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pCorrelatedViewMasks, *ptr, forUnmarshaling->correlatedViewMaskCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->correlatedViewMaskCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkSubpassBeginInfoKHR(
    VulkanStream* vkStream,
    VkSubpassBeginInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSubpassContents*)&forUnmarshaling->contents, *ptr, sizeof(VkSubpassContents));
    *ptr += sizeof(VkSubpassContents);
}

void reservedunmarshal_VkSubpassEndInfoKHR(
    VulkanStream* vkStream,
    VkSubpassEndInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
}

#endif
#ifdef VK_KHR_shared_presentable_image
void reservedunmarshal_VkSharedPresentSurfaceCapabilitiesKHR(
    VulkanStream* vkStream,
    VkSharedPresentSurfaceCapabilitiesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkImageUsageFlags*)&forUnmarshaling->sharedPresentSupportedUsageFlags, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
}

#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void reservedunmarshal_VkImportFenceWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkImportFenceWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkFence*)&forUnmarshaling->fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_0));
    memcpy((VkFenceImportFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkFenceImportFlags));
    *ptr += sizeof(VkFenceImportFlags);
    memcpy((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
    memcpy((HANDLE*)&forUnmarshaling->handle, *ptr, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
    memcpy((LPCWSTR*)&forUnmarshaling->name, *ptr, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedunmarshal_VkExportFenceWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkExportFenceWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    // WARNING PTR CHECK
    memcpy((SECURITY_ATTRIBUTES**)&forUnmarshaling->pAttributes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pAttributes);
    *ptr += 8;
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        memcpy((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, *ptr, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy((DWORD*)&forUnmarshaling->dwAccess, *ptr, sizeof(DWORD));
    *ptr += sizeof(DWORD);
    memcpy((LPCWSTR*)&forUnmarshaling->name, *ptr, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedunmarshal_VkFenceGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkFenceGetWin32HandleInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkFence*)&forUnmarshaling->fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_0));
    memcpy((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_fence_fd
void reservedunmarshal_VkImportFenceFdInfoKHR(
    VulkanStream* vkStream,
    VkImportFenceFdInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkFence*)&forUnmarshaling->fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_0));
    memcpy((VkFenceImportFlags*)&forUnmarshaling->flags, *ptr, sizeof(VkFenceImportFlags));
    *ptr += sizeof(VkFenceImportFlags);
    memcpy((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
    memcpy((int*)&forUnmarshaling->fd, *ptr, sizeof(int));
    *ptr += sizeof(int);
}

void reservedunmarshal_VkFenceGetFdInfoKHR(
    VulkanStream* vkStream,
    VkFenceGetFdInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkFence*)&forUnmarshaling->fence = (VkFence)unbox_VkFence((VkFence)(*&cgen_var_0));
    memcpy((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void reservedunmarshal_VkPhysicalDeviceSurfaceInfo2KHR(
    VulkanStream* vkStream,
    VkPhysicalDeviceSurfaceInfo2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkSurfaceKHR*)&forUnmarshaling->surface = (VkSurfaceKHR)unbox_VkSurfaceKHR((VkSurfaceKHR)(*&cgen_var_0));
}

void reservedunmarshal_VkSurfaceCapabilities2KHR(
    VulkanStream* vkStream,
    VkSurfaceCapabilities2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(&forUnmarshaling->surfaceCapabilities), ptr);
}

void reservedunmarshal_VkSurfaceFormat2KHR(
    VulkanStream* vkStream,
    VkSurfaceFormat2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(&forUnmarshaling->surfaceFormat), ptr);
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void reservedunmarshal_VkDisplayProperties2KHR(
    VulkanStream* vkStream,
    VkDisplayProperties2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(&forUnmarshaling->displayProperties), ptr);
}

void reservedunmarshal_VkDisplayPlaneProperties2KHR(
    VulkanStream* vkStream,
    VkDisplayPlaneProperties2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(&forUnmarshaling->displayPlaneProperties), ptr);
}

void reservedunmarshal_VkDisplayModeProperties2KHR(
    VulkanStream* vkStream,
    VkDisplayModeProperties2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(&forUnmarshaling->displayModeProperties), ptr);
}

void reservedunmarshal_VkDisplayPlaneInfo2KHR(
    VulkanStream* vkStream,
    VkDisplayPlaneInfo2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDisplayModeKHR*)&forUnmarshaling->mode = (VkDisplayModeKHR)unbox_VkDisplayModeKHR((VkDisplayModeKHR)(*&cgen_var_0));
    memcpy((uint32_t*)&forUnmarshaling->planeIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDisplayPlaneCapabilities2KHR(
    VulkanStream* vkStream,
    VkDisplayPlaneCapabilities2KHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(&forUnmarshaling->capabilities), ptr);
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
void reservedunmarshal_VkImageFormatListCreateInfoKHR(
    VulkanStream* vkStream,
    VkImageFormatListCreateInfoKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->viewFormatCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pViewFormats, forUnmarshaling->viewFormatCount * sizeof(const VkFormat));
    memcpy((VkFormat*)forUnmarshaling->pViewFormats, *ptr, forUnmarshaling->viewFormatCount * sizeof(const VkFormat));
    *ptr += forUnmarshaling->viewFormatCount * sizeof(const VkFormat);
}

#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_draw_indirect_count
#endif
#ifdef VK_KHR_8bit_storage
void reservedunmarshal_VkPhysicalDevice8BitStorageFeaturesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice8BitStorageFeaturesKHR* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->storageBuffer8BitAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->uniformAndStorageBuffer8BitAccess, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->storagePushConstant8, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_shader_float16_int8
void reservedunmarshal_VkPhysicalDeviceShaderFloat16Int8Features(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderFloat16Int8Features* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderFloat16, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderInt8, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_ANDROID_native_buffer
void reservedunmarshal_VkNativeBufferANDROID(
    VulkanStream* vkStream,
    VkNativeBufferANDROID* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    // WARNING PTR CHECK
    memcpy((uint32_t**)&forUnmarshaling->handle, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->handle);
    *ptr += 8;
    if (forUnmarshaling->handle)
    {
        vkStream->alloc((void**)&forUnmarshaling->handle, sizeof(const uint32_t));
        memcpy((uint32_t*)forUnmarshaling->handle, *ptr, sizeof(const uint32_t));
        *ptr += sizeof(const uint32_t);
    }
    memcpy((int*)&forUnmarshaling->stride, *ptr, sizeof(int));
    *ptr += sizeof(int);
    memcpy((int*)&forUnmarshaling->format, *ptr, sizeof(int));
    *ptr += sizeof(int);
    memcpy((int*)&forUnmarshaling->usage, *ptr, sizeof(int));
    *ptr += sizeof(int);
    memcpy((uint64_t*)&forUnmarshaling->consumer, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->producer, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

#endif
#ifdef VK_EXT_debug_report
void reservedunmarshal_VkDebugReportCallbackCreateInfoEXT(
    VulkanStream* vkStream,
    VkDebugReportCallbackCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDebugReportFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkDebugReportFlagsEXT));
    *ptr += sizeof(VkDebugReportFlagsEXT);
    memcpy((PFN_vkDebugReportCallbackEXT*)&forUnmarshaling->pfnCallback, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnCallback);
    *ptr += 8;
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pUserData, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pUserData);
    *ptr += 8;
    if (forUnmarshaling->pUserData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
        memcpy((void*)forUnmarshaling->pUserData, *ptr, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void reservedunmarshal_VkPipelineRasterizationStateRasterizationOrderAMD(
    VulkanStream* vkStream,
    VkPipelineRasterizationStateRasterizationOrderAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkRasterizationOrderAMD*)&forUnmarshaling->rasterizationOrder, *ptr, sizeof(VkRasterizationOrderAMD));
    *ptr += sizeof(VkRasterizationOrderAMD);
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void reservedunmarshal_VkDebugMarkerObjectNameInfoEXT(
    VulkanStream* vkStream,
    VkDebugMarkerObjectNameInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDebugReportObjectTypeEXT*)&forUnmarshaling->objectType, *ptr, sizeof(VkDebugReportObjectTypeEXT));
    *ptr += sizeof(VkDebugReportObjectTypeEXT);
    memcpy((uint64_t*)&forUnmarshaling->object, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pObjectName, ptr);
}

void reservedunmarshal_VkDebugMarkerObjectTagInfoEXT(
    VulkanStream* vkStream,
    VkDebugMarkerObjectTagInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDebugReportObjectTypeEXT*)&forUnmarshaling->objectType, *ptr, sizeof(VkDebugReportObjectTypeEXT));
    *ptr += sizeof(VkDebugReportObjectTypeEXT);
    memcpy((uint64_t*)&forUnmarshaling->object, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->tagName, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((size_t*)&forUnmarshaling->tagSize, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->tagSize);
    *ptr += 8;
    vkStream->alloc((void**)&forUnmarshaling->pTag, forUnmarshaling->tagSize * sizeof(const uint8_t));
    memcpy((void*)forUnmarshaling->pTag, *ptr, forUnmarshaling->tagSize * sizeof(const uint8_t));
    *ptr += forUnmarshaling->tagSize * sizeof(const uint8_t);
}

void reservedunmarshal_VkDebugMarkerMarkerInfoEXT(
    VulkanStream* vkStream,
    VkDebugMarkerMarkerInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pMarkerName, ptr);
    memcpy((float*)forUnmarshaling->color, *ptr, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void reservedunmarshal_VkDedicatedAllocationImageCreateInfoNV(
    VulkanStream* vkStream,
    VkDedicatedAllocationImageCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->dedicatedAllocation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDedicatedAllocationBufferCreateInfoNV(
    VulkanStream* vkStream,
    VkDedicatedAllocationBufferCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->dedicatedAllocation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDedicatedAllocationMemoryAllocateInfoNV(
    VulkanStream* vkStream,
    VkDedicatedAllocationMemoryAllocateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkImage*)&forUnmarshaling->image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
}

#endif
#ifdef VK_AMD_draw_indirect_count
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
void reservedunmarshal_VkTextureLODGatherFormatPropertiesAMD(
    VulkanStream* vkStream,
    VkTextureLODGatherFormatPropertiesAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->supportsTextureGatherLODBiasAMD, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_AMD_shader_info
void reservedunmarshal_VkShaderResourceUsageAMD(
    VulkanStream* vkStream,
    VkShaderResourceUsageAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->numUsedVgprs, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->numUsedSgprs, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->ldsSizePerLocalWorkGroup, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((size_t*)&forUnmarshaling->ldsUsageSizeInBytes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->ldsUsageSizeInBytes);
    *ptr += 8;
    memcpy((size_t*)&forUnmarshaling->scratchMemUsageInBytes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->scratchMemUsageInBytes);
    *ptr += 8;
}

void reservedunmarshal_VkShaderStatisticsInfoAMD(
    VulkanStream* vkStream,
    VkShaderStatisticsInfoAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkShaderStageFlags*)&forUnmarshaling->shaderStageMask, *ptr, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    reservedunmarshal_VkShaderResourceUsageAMD(vkStream, (VkShaderResourceUsageAMD*)(&forUnmarshaling->resourceUsage), ptr);
    memcpy((uint32_t*)&forUnmarshaling->numPhysicalVgprs, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->numPhysicalSgprs, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->numAvailableVgprs, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->numAvailableSgprs, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)forUnmarshaling->computeWorkGroupSize, *ptr, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void reservedunmarshal_VkExternalImageFormatPropertiesNV(
    VulkanStream* vkStream,
    VkExternalImageFormatPropertiesNV* forUnmarshaling,
    uint8_t** ptr)
{
    reservedunmarshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forUnmarshaling->imageFormatProperties), ptr);
    memcpy((VkExternalMemoryFeatureFlagsNV*)&forUnmarshaling->externalMemoryFeatures, *ptr, sizeof(VkExternalMemoryFeatureFlagsNV));
    *ptr += sizeof(VkExternalMemoryFeatureFlagsNV);
    memcpy((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->exportFromImportedHandleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
    memcpy((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->compatibleHandleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

#endif
#ifdef VK_NV_external_memory
void reservedunmarshal_VkExternalMemoryImageCreateInfoNV(
    VulkanStream* vkStream,
    VkExternalMemoryImageCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

void reservedunmarshal_VkExportMemoryAllocateInfoNV(
    VulkanStream* vkStream,
    VkExportMemoryAllocateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleTypes, *ptr, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

#endif
#ifdef VK_NV_external_memory_win32
void reservedunmarshal_VkImportMemoryWin32HandleInfoNV(
    VulkanStream* vkStream,
    VkImportMemoryWin32HandleInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
    memcpy((HANDLE*)&forUnmarshaling->handle, *ptr, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
}

void reservedunmarshal_VkExportMemoryWin32HandleInfoNV(
    VulkanStream* vkStream,
    VkExportMemoryWin32HandleInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    // WARNING PTR CHECK
    memcpy((SECURITY_ATTRIBUTES**)&forUnmarshaling->pAttributes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pAttributes);
    *ptr += 8;
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        memcpy((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, *ptr, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy((DWORD*)&forUnmarshaling->dwAccess, *ptr, sizeof(DWORD));
    *ptr += sizeof(DWORD);
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void reservedunmarshal_VkWin32KeyedMutexAcquireReleaseInfoNV(
    VulkanStream* vkStream,
    VkWin32KeyedMutexAcquireReleaseInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->acquireCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAcquireSyncs, forUnmarshaling->acquireCount * sizeof(const VkDeviceMemory));
    if (forUnmarshaling->acquireCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->acquireCount;
        for (uint32_t k = 0; k < forUnmarshaling->acquireCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
            *(((VkDeviceMemory*)forUnmarshaling->pAcquireSyncs) + k) = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)tmpval);
        }
    }
    vkStream->alloc((void**)&forUnmarshaling->pAcquireKeys, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    memcpy((uint64_t*)forUnmarshaling->pAcquireKeys, *ptr, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    *ptr += forUnmarshaling->acquireCount * sizeof(const uint64_t);
    vkStream->alloc((void**)&forUnmarshaling->pAcquireTimeoutMilliseconds, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pAcquireTimeoutMilliseconds, *ptr, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->acquireCount * sizeof(const uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->releaseCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pReleaseSyncs, forUnmarshaling->releaseCount * sizeof(const VkDeviceMemory));
    if (forUnmarshaling->releaseCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        *ptr += 8 * forUnmarshaling->releaseCount;
        for (uint32_t k = 0; k < forUnmarshaling->releaseCount; ++k)
        {
            uint64_t tmpval; memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
            *(((VkDeviceMemory*)forUnmarshaling->pReleaseSyncs) + k) = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)tmpval);
        }
    }
    vkStream->alloc((void**)&forUnmarshaling->pReleaseKeys, forUnmarshaling->releaseCount * sizeof(const uint64_t));
    memcpy((uint64_t*)forUnmarshaling->pReleaseKeys, *ptr, forUnmarshaling->releaseCount * sizeof(const uint64_t));
    *ptr += forUnmarshaling->releaseCount * sizeof(const uint64_t);
}

#endif
#ifdef VK_EXT_validation_flags
void reservedunmarshal_VkValidationFlagsEXT(
    VulkanStream* vkStream,
    VkValidationFlagsEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->disabledValidationCheckCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDisabledValidationChecks, forUnmarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
    memcpy((VkValidationCheckEXT*)forUnmarshaling->pDisabledValidationChecks, *ptr, forUnmarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
    *ptr += forUnmarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT);
}

#endif
#ifdef VK_NN_vi_surface
void reservedunmarshal_VkViSurfaceCreateInfoNN(
    VulkanStream* vkStream,
    VkViSurfaceCreateInfoNN* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkViSurfaceCreateFlagsNN*)&forUnmarshaling->flags, *ptr, sizeof(VkViSurfaceCreateFlagsNN));
    *ptr += sizeof(VkViSurfaceCreateFlagsNN);
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->window, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->window);
    *ptr += 8;
    if (forUnmarshaling->window)
    {
        vkStream->alloc((void**)&forUnmarshaling->window, sizeof(uint8_t));
        memcpy((void*)forUnmarshaling->window, *ptr, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
void reservedunmarshal_VkConditionalRenderingBeginInfoEXT(
    VulkanStream* vkStream,
    VkConditionalRenderingBeginInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkConditionalRenderingFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkConditionalRenderingFlagsEXT));
    *ptr += sizeof(VkConditionalRenderingFlagsEXT);
}

void reservedunmarshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceConditionalRenderingFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->conditionalRendering, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->inheritedConditionalRendering, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    VulkanStream* vkStream,
    VkCommandBufferInheritanceConditionalRenderingInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->conditionalRenderingEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NVX_device_generated_commands
void reservedunmarshal_VkDeviceGeneratedCommandsFeaturesNVX(
    VulkanStream* vkStream,
    VkDeviceGeneratedCommandsFeaturesNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->computeBindingPointSupport, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkDeviceGeneratedCommandsLimitsNVX(
    VulkanStream* vkStream,
    VkDeviceGeneratedCommandsLimitsNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxIndirectCommandsLayoutTokenCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxObjectEntryCounts, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->minSequenceCountBufferOffsetAlignment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->minSequenceIndexBufferOffsetAlignment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->minCommandsTokenBufferOffsetAlignment, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkIndirectCommandsTokenNVX(
    VulkanStream* vkStream,
    VkIndirectCommandsTokenNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkIndirectCommandsTokenTypeNVX*)&forUnmarshaling->tokenType, *ptr, sizeof(VkIndirectCommandsTokenTypeNVX));
    *ptr += sizeof(VkIndirectCommandsTokenTypeNVX);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((VkDeviceSize*)&forUnmarshaling->offset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkIndirectCommandsLayoutTokenNVX(
    VulkanStream* vkStream,
    VkIndirectCommandsLayoutTokenNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkIndirectCommandsTokenTypeNVX*)&forUnmarshaling->tokenType, *ptr, sizeof(VkIndirectCommandsTokenTypeNVX));
    *ptr += sizeof(VkIndirectCommandsTokenTypeNVX);
    memcpy((uint32_t*)&forUnmarshaling->bindingUnit, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->dynamicCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->divisor, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkIndirectCommandsLayoutCreateInfoNVX(
    VulkanStream* vkStream,
    VkIndirectCommandsLayoutCreateInfoNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, *ptr, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    memcpy((VkIndirectCommandsLayoutUsageFlagsNVX*)&forUnmarshaling->flags, *ptr, sizeof(VkIndirectCommandsLayoutUsageFlagsNVX));
    *ptr += sizeof(VkIndirectCommandsLayoutUsageFlagsNVX);
    memcpy((uint32_t*)&forUnmarshaling->tokenCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pTokens, forUnmarshaling->tokenCount * sizeof(const VkIndirectCommandsLayoutTokenNVX));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->tokenCount; ++i)
    {
        reservedunmarshal_VkIndirectCommandsLayoutTokenNVX(vkStream, (VkIndirectCommandsLayoutTokenNVX*)(forUnmarshaling->pTokens + i), ptr);
    }
}

void reservedunmarshal_VkCmdProcessCommandsInfoNVX(
    VulkanStream* vkStream,
    VkCmdProcessCommandsInfoNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkObjectTableNVX*)&forUnmarshaling->objectTable = (VkObjectTableNVX)unbox_VkObjectTableNVX((VkObjectTableNVX)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkIndirectCommandsLayoutNVX*)&forUnmarshaling->indirectCommandsLayout = (VkIndirectCommandsLayoutNVX)unbox_VkIndirectCommandsLayoutNVX((VkIndirectCommandsLayoutNVX)(*&cgen_var_1));
    memcpy((uint32_t*)&forUnmarshaling->indirectCommandsTokenCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pIndirectCommandsTokens, forUnmarshaling->indirectCommandsTokenCount * sizeof(const VkIndirectCommandsTokenNVX));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->indirectCommandsTokenCount; ++i)
    {
        reservedunmarshal_VkIndirectCommandsTokenNVX(vkStream, (VkIndirectCommandsTokenNVX*)(forUnmarshaling->pIndirectCommandsTokens + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxSequencesCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_2;
    memcpy((uint64_t*)&cgen_var_2, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkCommandBuffer*)&forUnmarshaling->targetCommandBuffer = (VkCommandBuffer)unbox_VkCommandBuffer((VkCommandBuffer)(*&cgen_var_2));
    uint64_t cgen_var_3;
    memcpy((uint64_t*)&cgen_var_3, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->sequencesCountBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_3));
    memcpy((VkDeviceSize*)&forUnmarshaling->sequencesCountOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    uint64_t cgen_var_4;
    memcpy((uint64_t*)&cgen_var_4, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->sequencesIndexBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_4));
    memcpy((VkDeviceSize*)&forUnmarshaling->sequencesIndexOffset, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedunmarshal_VkCmdReserveSpaceForCommandsInfoNVX(
    VulkanStream* vkStream,
    VkCmdReserveSpaceForCommandsInfoNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkObjectTableNVX*)&forUnmarshaling->objectTable = (VkObjectTableNVX)unbox_VkObjectTableNVX((VkObjectTableNVX)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkIndirectCommandsLayoutNVX*)&forUnmarshaling->indirectCommandsLayout = (VkIndirectCommandsLayoutNVX)unbox_VkIndirectCommandsLayoutNVX((VkIndirectCommandsLayoutNVX)(*&cgen_var_1));
    memcpy((uint32_t*)&forUnmarshaling->maxSequencesCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkObjectTableCreateInfoNVX(
    VulkanStream* vkStream,
    VkObjectTableCreateInfoNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->objectCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pObjectEntryTypes, forUnmarshaling->objectCount * sizeof(const VkObjectEntryTypeNVX));
    memcpy((VkObjectEntryTypeNVX*)forUnmarshaling->pObjectEntryTypes, *ptr, forUnmarshaling->objectCount * sizeof(const VkObjectEntryTypeNVX));
    *ptr += forUnmarshaling->objectCount * sizeof(const VkObjectEntryTypeNVX);
    vkStream->alloc((void**)&forUnmarshaling->pObjectEntryCounts, forUnmarshaling->objectCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pObjectEntryCounts, *ptr, forUnmarshaling->objectCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->objectCount * sizeof(const uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pObjectEntryUsageFlags, forUnmarshaling->objectCount * sizeof(const VkObjectEntryUsageFlagsNVX));
    memcpy((VkObjectEntryUsageFlagsNVX*)forUnmarshaling->pObjectEntryUsageFlags, *ptr, forUnmarshaling->objectCount * sizeof(const VkObjectEntryUsageFlagsNVX));
    *ptr += forUnmarshaling->objectCount * sizeof(const VkObjectEntryUsageFlagsNVX);
    memcpy((uint32_t*)&forUnmarshaling->maxUniformBuffersPerDescriptor, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxStorageBuffersPerDescriptor, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxStorageImagesPerDescriptor, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxSampledImagesPerDescriptor, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPipelineLayouts, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkObjectTableEntryNVX(
    VulkanStream* vkStream,
    VkObjectTableEntryNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkObjectEntryTypeNVX*)&forUnmarshaling->type, *ptr, sizeof(VkObjectEntryTypeNVX));
    *ptr += sizeof(VkObjectEntryTypeNVX);
    memcpy((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, *ptr, sizeof(VkObjectEntryUsageFlagsNVX));
    *ptr += sizeof(VkObjectEntryUsageFlagsNVX);
}

void reservedunmarshal_VkObjectTablePipelineEntryNVX(
    VulkanStream* vkStream,
    VkObjectTablePipelineEntryNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkObjectEntryTypeNVX*)&forUnmarshaling->type, *ptr, sizeof(VkObjectEntryTypeNVX));
    *ptr += sizeof(VkObjectEntryTypeNVX);
    memcpy((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, *ptr, sizeof(VkObjectEntryUsageFlagsNVX));
    *ptr += sizeof(VkObjectEntryUsageFlagsNVX);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipeline*)&forUnmarshaling->pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_0));
}

void reservedunmarshal_VkObjectTableDescriptorSetEntryNVX(
    VulkanStream* vkStream,
    VkObjectTableDescriptorSetEntryNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkObjectEntryTypeNVX*)&forUnmarshaling->type, *ptr, sizeof(VkObjectEntryTypeNVX));
    *ptr += sizeof(VkObjectEntryTypeNVX);
    memcpy((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, *ptr, sizeof(VkObjectEntryUsageFlagsNVX));
    *ptr += sizeof(VkObjectEntryUsageFlagsNVX);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipelineLayout*)&forUnmarshaling->pipelineLayout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_0));
    uint64_t cgen_var_1;
    memcpy((uint64_t*)&cgen_var_1, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDescriptorSet*)&forUnmarshaling->descriptorSet = (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)(*&cgen_var_1));
}

void reservedunmarshal_VkObjectTableVertexBufferEntryNVX(
    VulkanStream* vkStream,
    VkObjectTableVertexBufferEntryNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkObjectEntryTypeNVX*)&forUnmarshaling->type, *ptr, sizeof(VkObjectEntryTypeNVX));
    *ptr += sizeof(VkObjectEntryTypeNVX);
    memcpy((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, *ptr, sizeof(VkObjectEntryUsageFlagsNVX));
    *ptr += sizeof(VkObjectEntryUsageFlagsNVX);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
}

void reservedunmarshal_VkObjectTableIndexBufferEntryNVX(
    VulkanStream* vkStream,
    VkObjectTableIndexBufferEntryNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkObjectEntryTypeNVX*)&forUnmarshaling->type, *ptr, sizeof(VkObjectEntryTypeNVX));
    *ptr += sizeof(VkObjectEntryTypeNVX);
    memcpy((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, *ptr, sizeof(VkObjectEntryUsageFlagsNVX));
    *ptr += sizeof(VkObjectEntryUsageFlagsNVX);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkBuffer*)&forUnmarshaling->buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
    memcpy((VkIndexType*)&forUnmarshaling->indexType, *ptr, sizeof(VkIndexType));
    *ptr += sizeof(VkIndexType);
}

void reservedunmarshal_VkObjectTablePushConstantEntryNVX(
    VulkanStream* vkStream,
    VkObjectTablePushConstantEntryNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkObjectEntryTypeNVX*)&forUnmarshaling->type, *ptr, sizeof(VkObjectEntryTypeNVX));
    *ptr += sizeof(VkObjectEntryTypeNVX);
    memcpy((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, *ptr, sizeof(VkObjectEntryUsageFlagsNVX));
    *ptr += sizeof(VkObjectEntryUsageFlagsNVX);
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkPipelineLayout*)&forUnmarshaling->pipelineLayout = (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_0));
    memcpy((VkShaderStageFlags*)&forUnmarshaling->stageFlags, *ptr, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void reservedunmarshal_VkViewportWScalingNV(
    VulkanStream* vkStream,
    VkViewportWScalingNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((float*)&forUnmarshaling->xcoeff, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->ycoeff, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

void reservedunmarshal_VkPipelineViewportWScalingStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineViewportWScalingStateCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->viewportWScalingEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->viewportCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkViewportWScalingNV**)&forUnmarshaling->pViewportWScalings, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pViewportWScalings);
    *ptr += 8;
    if (forUnmarshaling->pViewportWScalings)
    {
        vkStream->alloc((void**)&forUnmarshaling->pViewportWScalings, forUnmarshaling->viewportCount * sizeof(const VkViewportWScalingNV));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            reservedunmarshal_VkViewportWScalingNV(vkStream, (VkViewportWScalingNV*)(forUnmarshaling->pViewportWScalings + i), ptr);
        }
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
#endif
#ifdef VK_EXT_acquire_xlib_display
#endif
#ifdef VK_EXT_display_surface_counter
void reservedunmarshal_VkSurfaceCapabilities2EXT(
    VulkanStream* vkStream,
    VkSurfaceCapabilities2EXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->minImageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxImageCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->currentExtent), ptr);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minImageExtent), ptr);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxImageExtent), ptr);
    memcpy((uint32_t*)&forUnmarshaling->maxImageArrayLayers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, *ptr, sizeof(VkSurfaceTransformFlagsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagsKHR);
    memcpy((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->currentTransform, *ptr, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy((VkCompositeAlphaFlagsKHR*)&forUnmarshaling->supportedCompositeAlpha, *ptr, sizeof(VkCompositeAlphaFlagsKHR));
    *ptr += sizeof(VkCompositeAlphaFlagsKHR);
    memcpy((VkImageUsageFlags*)&forUnmarshaling->supportedUsageFlags, *ptr, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy((VkSurfaceCounterFlagsEXT*)&forUnmarshaling->supportedSurfaceCounters, *ptr, sizeof(VkSurfaceCounterFlagsEXT));
    *ptr += sizeof(VkSurfaceCounterFlagsEXT);
}

#endif
#ifdef VK_EXT_display_control
void reservedunmarshal_VkDisplayPowerInfoEXT(
    VulkanStream* vkStream,
    VkDisplayPowerInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDisplayPowerStateEXT*)&forUnmarshaling->powerState, *ptr, sizeof(VkDisplayPowerStateEXT));
    *ptr += sizeof(VkDisplayPowerStateEXT);
}

void reservedunmarshal_VkDeviceEventInfoEXT(
    VulkanStream* vkStream,
    VkDeviceEventInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceEventTypeEXT*)&forUnmarshaling->deviceEvent, *ptr, sizeof(VkDeviceEventTypeEXT));
    *ptr += sizeof(VkDeviceEventTypeEXT);
}

void reservedunmarshal_VkDisplayEventInfoEXT(
    VulkanStream* vkStream,
    VkDisplayEventInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDisplayEventTypeEXT*)&forUnmarshaling->displayEvent, *ptr, sizeof(VkDisplayEventTypeEXT));
    *ptr += sizeof(VkDisplayEventTypeEXT);
}

void reservedunmarshal_VkSwapchainCounterCreateInfoEXT(
    VulkanStream* vkStream,
    VkSwapchainCounterCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSurfaceCounterFlagsEXT*)&forUnmarshaling->surfaceCounters, *ptr, sizeof(VkSurfaceCounterFlagsEXT));
    *ptr += sizeof(VkSurfaceCounterFlagsEXT);
}

#endif
#ifdef VK_GOOGLE_display_timing
void reservedunmarshal_VkRefreshCycleDurationGOOGLE(
    VulkanStream* vkStream,
    VkRefreshCycleDurationGOOGLE* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint64_t*)&forUnmarshaling->refreshDuration, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkPastPresentationTimingGOOGLE(
    VulkanStream* vkStream,
    VkPastPresentationTimingGOOGLE* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->presentID, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint64_t*)&forUnmarshaling->desiredPresentTime, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->actualPresentTime, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->earliestPresentTime, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->presentMargin, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkPresentTimeGOOGLE(
    VulkanStream* vkStream,
    VkPresentTimeGOOGLE* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->presentID, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint64_t*)&forUnmarshaling->desiredPresentTime, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkPresentTimesInfoGOOGLE(
    VulkanStream* vkStream,
    VkPresentTimesInfoGOOGLE* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->swapchainCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkPresentTimeGOOGLE**)&forUnmarshaling->pTimes, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pTimes);
    *ptr += 8;
    if (forUnmarshaling->pTimes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pTimes, forUnmarshaling->swapchainCount * sizeof(const VkPresentTimeGOOGLE));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->swapchainCount; ++i)
        {
            reservedunmarshal_VkPresentTimeGOOGLE(vkStream, (VkPresentTimeGOOGLE*)(forUnmarshaling->pTimes + i), ptr);
        }
    }
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void reservedunmarshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VulkanStream* vkStream,
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->perViewPositionAllComponents, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_viewport_swizzle
void reservedunmarshal_VkViewportSwizzleNV(
    VulkanStream* vkStream,
    VkViewportSwizzleNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->x, *ptr, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
    memcpy((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->y, *ptr, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
    memcpy((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->z, *ptr, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
    memcpy((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->w, *ptr, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
}

void reservedunmarshal_VkPipelineViewportSwizzleStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineViewportSwizzleStateCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineViewportSwizzleStateCreateFlagsNV*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV));
    *ptr += sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV);
    memcpy((uint32_t*)&forUnmarshaling->viewportCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkViewportSwizzleNV**)&forUnmarshaling->pViewportSwizzles, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pViewportSwizzles);
    *ptr += 8;
    if (forUnmarshaling->pViewportSwizzles)
    {
        vkStream->alloc((void**)&forUnmarshaling->pViewportSwizzles, forUnmarshaling->viewportCount * sizeof(const VkViewportSwizzleNV));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            reservedunmarshal_VkViewportSwizzleNV(vkStream, (VkViewportSwizzleNV*)(forUnmarshaling->pViewportSwizzles + i), ptr);
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void reservedunmarshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceDiscardRectanglePropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxDiscardRectangles, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPipelineDiscardRectangleStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineDiscardRectangleStateCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineDiscardRectangleStateCreateFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT));
    *ptr += sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT);
    memcpy((VkDiscardRectangleModeEXT*)&forUnmarshaling->discardRectangleMode, *ptr, sizeof(VkDiscardRectangleModeEXT));
    *ptr += sizeof(VkDiscardRectangleModeEXT);
    memcpy((uint32_t*)&forUnmarshaling->discardRectangleCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkRect2D**)&forUnmarshaling->pDiscardRectangles, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pDiscardRectangles);
    *ptr += 8;
    if (forUnmarshaling->pDiscardRectangles)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDiscardRectangles, forUnmarshaling->discardRectangleCount * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->discardRectangleCount; ++i)
        {
            reservedunmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pDiscardRectangles + i), ptr);
        }
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void reservedunmarshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceConservativeRasterizationPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((float*)&forUnmarshaling->primitiveOverestimationSize, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxExtraPrimitiveOverestimationSize, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->extraPrimitiveOverestimationSizeGranularity, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((VkBool32*)&forUnmarshaling->primitiveUnderestimation, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->conservativePointAndLineRasterization, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->degenerateTrianglesRasterized, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->degenerateLinesRasterized, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->fullyCoveredFragmentShaderInputVariable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->conservativeRasterizationPostDepthCoverage, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineRasterizationConservativeStateCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineRasterizationConservativeStateCreateFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT));
    *ptr += sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT);
    memcpy((VkConservativeRasterizationModeEXT*)&forUnmarshaling->conservativeRasterizationMode, *ptr, sizeof(VkConservativeRasterizationModeEXT));
    *ptr += sizeof(VkConservativeRasterizationModeEXT);
    memcpy((float*)&forUnmarshaling->extraPrimitiveOverestimationSize, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void reservedunmarshal_VkXYColorEXT(
    VulkanStream* vkStream,
    VkXYColorEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((float*)&forUnmarshaling->x, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->y, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

void reservedunmarshal_VkHdrMetadataEXT(
    VulkanStream* vkStream,
    VkHdrMetadataEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryRed), ptr);
    reservedunmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryGreen), ptr);
    reservedunmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryBlue), ptr);
    reservedunmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->whitePoint), ptr);
    memcpy((float*)&forUnmarshaling->maxLuminance, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->minLuminance, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxContentLightLevel, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->maxFrameAverageLightLevel, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

#endif
#ifdef VK_MVK_ios_surface
void reservedunmarshal_VkIOSSurfaceCreateInfoMVK(
    VulkanStream* vkStream,
    VkIOSSurfaceCreateInfoMVK* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkIOSSurfaceCreateFlagsMVK*)&forUnmarshaling->flags, *ptr, sizeof(VkIOSSurfaceCreateFlagsMVK));
    *ptr += sizeof(VkIOSSurfaceCreateFlagsMVK);
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pView, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pView);
    *ptr += 8;
    if (forUnmarshaling->pView)
    {
        vkStream->alloc((void**)&forUnmarshaling->pView, sizeof(const uint8_t));
        memcpy((void*)forUnmarshaling->pView, *ptr, sizeof(const uint8_t));
        *ptr += sizeof(const uint8_t);
    }
}

#endif
#ifdef VK_MVK_macos_surface
void reservedunmarshal_VkMacOSSurfaceCreateInfoMVK(
    VulkanStream* vkStream,
    VkMacOSSurfaceCreateInfoMVK* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkMacOSSurfaceCreateFlagsMVK*)&forUnmarshaling->flags, *ptr, sizeof(VkMacOSSurfaceCreateFlagsMVK));
    *ptr += sizeof(VkMacOSSurfaceCreateFlagsMVK);
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pView, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pView);
    *ptr += 8;
    if (forUnmarshaling->pView)
    {
        vkStream->alloc((void**)&forUnmarshaling->pView, sizeof(const uint8_t));
        memcpy((void*)forUnmarshaling->pView, *ptr, sizeof(const uint8_t));
        *ptr += sizeof(const uint8_t);
    }
}

#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void reservedunmarshal_VkDebugUtilsObjectNameInfoEXT(
    VulkanStream* vkStream,
    VkDebugUtilsObjectNameInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkObjectType*)&forUnmarshaling->objectType, *ptr, sizeof(VkObjectType));
    *ptr += sizeof(VkObjectType);
    memcpy((uint64_t*)&forUnmarshaling->objectHandle, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        memcpy((char**)&forUnmarshaling->pObjectName, (*ptr), 8);
        android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pObjectName);
        *ptr += 8;
        if (forUnmarshaling->pObjectName)
        {
            vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pObjectName, ptr);
        }
    }
    else
    {
        vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pObjectName, ptr);
    }
}

void reservedunmarshal_VkDebugUtilsObjectTagInfoEXT(
    VulkanStream* vkStream,
    VkDebugUtilsObjectTagInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkObjectType*)&forUnmarshaling->objectType, *ptr, sizeof(VkObjectType));
    *ptr += sizeof(VkObjectType);
    memcpy((uint64_t*)&forUnmarshaling->objectHandle, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((uint64_t*)&forUnmarshaling->tagName, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((size_t*)&forUnmarshaling->tagSize, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->tagSize);
    *ptr += 8;
    vkStream->alloc((void**)&forUnmarshaling->pTag, forUnmarshaling->tagSize * sizeof(const uint8_t));
    memcpy((void*)forUnmarshaling->pTag, *ptr, forUnmarshaling->tagSize * sizeof(const uint8_t));
    *ptr += forUnmarshaling->tagSize * sizeof(const uint8_t);
}

void reservedunmarshal_VkDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkDebugUtilsLabelEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pLabelName, ptr);
    memcpy((float*)forUnmarshaling->color, *ptr, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

void reservedunmarshal_VkDebugUtilsMessengerCallbackDataEXT(
    VulkanStream* vkStream,
    VkDebugUtilsMessengerCallbackDataEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDebugUtilsMessengerCallbackDataFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        memcpy((char**)&forUnmarshaling->pMessageIdName, (*ptr), 8);
        android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pMessageIdName);
        *ptr += 8;
        if (forUnmarshaling->pMessageIdName)
        {
            vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pMessageIdName, ptr);
        }
    }
    else
    {
        vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pMessageIdName, ptr);
    }
    memcpy((int32_t*)&forUnmarshaling->messageIdNumber, *ptr, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    vkStream->loadStringInPlaceWithStreamPtr((char**)&forUnmarshaling->pMessage, ptr);
    memcpy((uint32_t*)&forUnmarshaling->queueLabelCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkDebugUtilsLabelEXT**)&forUnmarshaling->pQueueLabels, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pQueueLabels);
    *ptr += 8;
    if (forUnmarshaling->pQueueLabels)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueLabels, forUnmarshaling->queueLabelCount * sizeof(VkDebugUtilsLabelEXT));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->queueLabelCount; ++i)
        {
            reservedunmarshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forUnmarshaling->pQueueLabels + i), ptr);
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->cmdBufLabelCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkDebugUtilsLabelEXT**)&forUnmarshaling->pCmdBufLabels, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pCmdBufLabels);
    *ptr += 8;
    if (forUnmarshaling->pCmdBufLabels)
    {
        vkStream->alloc((void**)&forUnmarshaling->pCmdBufLabels, forUnmarshaling->cmdBufLabelCount * sizeof(VkDebugUtilsLabelEXT));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->cmdBufLabelCount; ++i)
        {
            reservedunmarshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forUnmarshaling->pCmdBufLabels + i), ptr);
        }
    }
    memcpy((uint32_t*)&forUnmarshaling->objectCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((VkDebugUtilsObjectNameInfoEXT**)&forUnmarshaling->pObjects, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pObjects);
    *ptr += 8;
    if (forUnmarshaling->pObjects)
    {
        vkStream->alloc((void**)&forUnmarshaling->pObjects, forUnmarshaling->objectCount * sizeof(VkDebugUtilsObjectNameInfoEXT));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->objectCount; ++i)
        {
            reservedunmarshal_VkDebugUtilsObjectNameInfoEXT(vkStream, (VkDebugUtilsObjectNameInfoEXT*)(forUnmarshaling->pObjects + i), ptr);
        }
    }
}

void reservedunmarshal_VkDebugUtilsMessengerCreateInfoEXT(
    VulkanStream* vkStream,
    VkDebugUtilsMessengerCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDebugUtilsMessengerCreateFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkDebugUtilsMessengerCreateFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessengerCreateFlagsEXT);
    memcpy((VkDebugUtilsMessageSeverityFlagsEXT*)&forUnmarshaling->messageSeverity, *ptr, sizeof(VkDebugUtilsMessageSeverityFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessageSeverityFlagsEXT);
    memcpy((VkDebugUtilsMessageTypeFlagsEXT*)&forUnmarshaling->messageType, *ptr, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessageTypeFlagsEXT);
    memcpy((PFN_vkDebugUtilsMessengerCallbackEXT*)&forUnmarshaling->pfnUserCallback, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pfnUserCallback);
    *ptr += 8;
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pUserData, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pUserData);
    *ptr += 8;
    if (forUnmarshaling->pUserData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
        memcpy((void*)forUnmarshaling->pUserData, *ptr, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void reservedunmarshal_VkAndroidHardwareBufferUsageANDROID(
    VulkanStream* vkStream,
    VkAndroidHardwareBufferUsageANDROID* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint64_t*)&forUnmarshaling->androidHardwareBufferUsage, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedunmarshal_VkAndroidHardwareBufferPropertiesANDROID(
    VulkanStream* vkStream,
    VkAndroidHardwareBufferPropertiesANDROID* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceSize*)&forUnmarshaling->allocationSize, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((uint32_t*)&forUnmarshaling->memoryTypeBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkAndroidHardwareBufferFormatPropertiesANDROID(
    VulkanStream* vkStream,
    VkAndroidHardwareBufferFormatPropertiesANDROID* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((uint64_t*)&forUnmarshaling->externalFormat, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((VkFormatFeatureFlags*)&forUnmarshaling->formatFeatures, *ptr, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
    reservedunmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forUnmarshaling->samplerYcbcrConversionComponents), ptr);
    memcpy((VkSamplerYcbcrModelConversion*)&forUnmarshaling->suggestedYcbcrModel, *ptr, sizeof(VkSamplerYcbcrModelConversion));
    *ptr += sizeof(VkSamplerYcbcrModelConversion);
    memcpy((VkSamplerYcbcrRange*)&forUnmarshaling->suggestedYcbcrRange, *ptr, sizeof(VkSamplerYcbcrRange));
    *ptr += sizeof(VkSamplerYcbcrRange);
    memcpy((VkChromaLocation*)&forUnmarshaling->suggestedXChromaOffset, *ptr, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
    memcpy((VkChromaLocation*)&forUnmarshaling->suggestedYChromaOffset, *ptr, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
}

void reservedunmarshal_VkImportAndroidHardwareBufferInfoANDROID(
    VulkanStream* vkStream,
    VkImportAndroidHardwareBufferInfoANDROID* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    vkStream->alloc((void**)&forUnmarshaling->buffer, sizeof(AHardwareBuffer));
    memcpy((AHardwareBuffer*)forUnmarshaling->buffer, *ptr, sizeof(AHardwareBuffer));
    *ptr += sizeof(AHardwareBuffer);
}

void reservedunmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    VulkanStream* vkStream,
    VkMemoryGetAndroidHardwareBufferInfoANDROID* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkDeviceMemory*)&forUnmarshaling->memory = (VkDeviceMemory)unbox_VkDeviceMemory((VkDeviceMemory)(*&cgen_var_0));
}

void reservedunmarshal_VkExternalFormatANDROID(
    VulkanStream* vkStream,
    VkExternalFormatANDROID* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint64_t*)&forUnmarshaling->externalFormat, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
void reservedunmarshal_VkSamplerReductionModeCreateInfoEXT(
    VulkanStream* vkStream,
    VkSamplerReductionModeCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSamplerReductionModeEXT*)&forUnmarshaling->reductionMode, *ptr, sizeof(VkSamplerReductionModeEXT));
    *ptr += sizeof(VkSamplerReductionModeEXT);
}

void reservedunmarshal_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->filterMinmaxSingleComponentFormats, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->filterMinmaxImageComponentMapping, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void reservedunmarshal_VkSampleLocationEXT(
    VulkanStream* vkStream,
    VkSampleLocationEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((float*)&forUnmarshaling->x, *ptr, sizeof(float));
    *ptr += sizeof(float);
    memcpy((float*)&forUnmarshaling->y, *ptr, sizeof(float));
    *ptr += sizeof(float);
}

void reservedunmarshal_VkSampleLocationsInfoEXT(
    VulkanStream* vkStream,
    VkSampleLocationsInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSampleCountFlagBits*)&forUnmarshaling->sampleLocationsPerPixel, *ptr, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->sampleLocationGridSize), ptr);
    memcpy((uint32_t*)&forUnmarshaling->sampleLocationsCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pSampleLocations, forUnmarshaling->sampleLocationsCount * sizeof(const VkSampleLocationEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->sampleLocationsCount; ++i)
    {
        reservedunmarshal_VkSampleLocationEXT(vkStream, (VkSampleLocationEXT*)(forUnmarshaling->pSampleLocations + i), ptr);
    }
}

void reservedunmarshal_VkAttachmentSampleLocationsEXT(
    VulkanStream* vkStream,
    VkAttachmentSampleLocationsEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->attachmentIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo), ptr);
}

void reservedunmarshal_VkSubpassSampleLocationsEXT(
    VulkanStream* vkStream,
    VkSubpassSampleLocationsEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->subpassIndex, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedunmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo), ptr);
}

void reservedunmarshal_VkRenderPassSampleLocationsBeginInfoEXT(
    VulkanStream* vkStream,
    VkRenderPassSampleLocationsBeginInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->attachmentInitialSampleLocationsCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pAttachmentInitialSampleLocations, forUnmarshaling->attachmentInitialSampleLocationsCount * sizeof(const VkAttachmentSampleLocationsEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentInitialSampleLocationsCount; ++i)
    {
        reservedunmarshal_VkAttachmentSampleLocationsEXT(vkStream, (VkAttachmentSampleLocationsEXT*)(forUnmarshaling->pAttachmentInitialSampleLocations + i), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->postSubpassSampleLocationsCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pPostSubpassSampleLocations, forUnmarshaling->postSubpassSampleLocationsCount * sizeof(const VkSubpassSampleLocationsEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->postSubpassSampleLocationsCount; ++i)
    {
        reservedunmarshal_VkSubpassSampleLocationsEXT(vkStream, (VkSubpassSampleLocationsEXT*)(forUnmarshaling->pPostSubpassSampleLocations + i), ptr);
    }
}

void reservedunmarshal_VkPipelineSampleLocationsStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineSampleLocationsStateCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->sampleLocationsEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    reservedunmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo), ptr);
}

void reservedunmarshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceSampleLocationsPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkSampleCountFlags*)&forUnmarshaling->sampleLocationSampleCounts, *ptr, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxSampleLocationGridSize), ptr);
    memcpy((float*)forUnmarshaling->sampleLocationCoordinateRange, *ptr, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy((uint32_t*)&forUnmarshaling->sampleLocationSubPixelBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->variableSampleLocations, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkMultisamplePropertiesEXT(
    VulkanStream* vkStream,
    VkMultisamplePropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    reservedunmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxSampleLocationGridSize), ptr);
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void reservedunmarshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->advancedBlendCoherentOperations, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->advancedBlendMaxColorAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->advancedBlendIndependentBlend, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->advancedBlendNonPremultipliedSrcColor, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->advancedBlendNonPremultipliedDstColor, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->advancedBlendCorrelatedOverlap, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->advancedBlendAllOperations, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineColorBlendAdvancedStateCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->srcPremultiplied, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->dstPremultiplied, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBlendOverlapEXT*)&forUnmarshaling->blendOverlap, *ptr, sizeof(VkBlendOverlapEXT));
    *ptr += sizeof(VkBlendOverlapEXT);
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void reservedunmarshal_VkPipelineCoverageToColorStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineCoverageToColorStateCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineCoverageToColorStateCreateFlagsNV*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineCoverageToColorStateCreateFlagsNV));
    *ptr += sizeof(VkPipelineCoverageToColorStateCreateFlagsNV);
    memcpy((VkBool32*)&forUnmarshaling->coverageToColorEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->coverageToColorLocation, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void reservedunmarshal_VkPipelineCoverageModulationStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineCoverageModulationStateCreateInfoNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineCoverageModulationStateCreateFlagsNV*)&forUnmarshaling->flags, *ptr, sizeof(VkPipelineCoverageModulationStateCreateFlagsNV));
    *ptr += sizeof(VkPipelineCoverageModulationStateCreateFlagsNV);
    memcpy((VkCoverageModulationModeNV*)&forUnmarshaling->coverageModulationMode, *ptr, sizeof(VkCoverageModulationModeNV));
    *ptr += sizeof(VkCoverageModulationModeNV);
    memcpy((VkBool32*)&forUnmarshaling->coverageModulationTableEnable, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->coverageModulationTableCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    memcpy((float**)&forUnmarshaling->pCoverageModulationTable, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pCoverageModulationTable);
    *ptr += 8;
    if (forUnmarshaling->pCoverageModulationTable)
    {
        vkStream->alloc((void**)&forUnmarshaling->pCoverageModulationTable, forUnmarshaling->coverageModulationTableCount * sizeof(const float));
        memcpy((float*)forUnmarshaling->pCoverageModulationTable, *ptr, forUnmarshaling->coverageModulationTableCount * sizeof(const float));
        *ptr += forUnmarshaling->coverageModulationTableCount * sizeof(const float);
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
void reservedunmarshal_VkValidationCacheCreateInfoEXT(
    VulkanStream* vkStream,
    VkValidationCacheCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkValidationCacheCreateFlagsEXT*)&forUnmarshaling->flags, *ptr, sizeof(VkValidationCacheCreateFlagsEXT));
    *ptr += sizeof(VkValidationCacheCreateFlagsEXT);
    memcpy((size_t*)&forUnmarshaling->initialDataSize, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->initialDataSize);
    *ptr += 8;
    vkStream->alloc((void**)&forUnmarshaling->pInitialData, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
    memcpy((void*)forUnmarshaling->pInitialData, *ptr, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
    *ptr += forUnmarshaling->initialDataSize * sizeof(const uint8_t);
}

void reservedunmarshal_VkShaderModuleValidationCacheCreateInfoEXT(
    VulkanStream* vkStream,
    VkShaderModuleValidationCacheCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    uint64_t cgen_var_0;
    memcpy((uint64_t*)&cgen_var_0, *ptr, 1 * 8);
    *ptr += 1 * 8;
    *(VkValidationCacheEXT*)&forUnmarshaling->validationCache = (VkValidationCacheEXT)unbox_VkValidationCacheEXT((VkValidationCacheEXT)(*&cgen_var_0));
}

#endif
#ifdef VK_EXT_descriptor_indexing
void reservedunmarshal_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(
    VulkanStream* vkStream,
    VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->bindingCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pBindingFlags, forUnmarshaling->bindingCount * sizeof(const VkDescriptorBindingFlagsEXT));
    memcpy((VkDescriptorBindingFlagsEXT*)forUnmarshaling->pBindingFlags, *ptr, forUnmarshaling->bindingCount * sizeof(const VkDescriptorBindingFlagsEXT));
    *ptr += forUnmarshaling->bindingCount * sizeof(const VkDescriptorBindingFlagsEXT);
}

void reservedunmarshal_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceDescriptorIndexingFeaturesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderUniformTexelBufferArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageTexelBufferArrayDynamicIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSampledImageArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderUniformTexelBufferArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageTexelBufferArrayNonUniformIndexing, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingUniformBufferUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingSampledImageUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingStorageImageUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingStorageBufferUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingUniformTexelBufferUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingStorageTexelBufferUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingUpdateUnusedWhilePending, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingPartiallyBound, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->descriptorBindingVariableDescriptorCount, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->runtimeDescriptorArray, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedunmarshal_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceDescriptorIndexingPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxUpdateAfterBindDescriptorsInAllPools, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderSampledImageArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderStorageImageArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayNonUniformIndexingNative, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->robustBufferAccessUpdateAfterBind, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((VkBool32*)&forUnmarshaling->quadDivergentImplicitLod, *ptr, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindSamplers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindUniformBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindStorageBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindSampledImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindStorageImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindInputAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxPerStageUpdateAfterBindResources, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindSamplers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindUniformBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageBuffers, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindSampledImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageImages, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindInputAttachments, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(
    VulkanStream* vkStream,
    VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->descriptorSetCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pDescriptorCounts, forUnmarshaling->descriptorSetCount * sizeof(const uint32_t));
    memcpy((uint32_t*)forUnmarshaling->pDescriptorCounts, *ptr, forUnmarshaling->descriptorSetCount * sizeof(const uint32_t));
    *ptr += forUnmarshaling->descriptorSetCount * sizeof(const uint32_t);
}

void reservedunmarshal_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(
    VulkanStream* vkStream,
    VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxVariableDescriptorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
void reservedunmarshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    VulkanStream* vkStream,
    VkDeviceQueueGlobalPriorityCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkQueueGlobalPriorityEXT*)&forUnmarshaling->globalPriority, *ptr, sizeof(VkQueueGlobalPriorityEXT));
    *ptr += sizeof(VkQueueGlobalPriorityEXT);
}

#endif
#ifdef VK_EXT_external_memory_host
void reservedunmarshal_VkImportMemoryHostPointerInfoEXT(
    VulkanStream* vkStream,
    VkImportMemoryHostPointerInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, *ptr, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pHostPointer, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pHostPointer);
    *ptr += 8;
    if (forUnmarshaling->pHostPointer)
    {
        vkStream->alloc((void**)&forUnmarshaling->pHostPointer, sizeof(uint8_t));
        memcpy((void*)forUnmarshaling->pHostPointer, *ptr, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

void reservedunmarshal_VkMemoryHostPointerPropertiesEXT(
    VulkanStream* vkStream,
    VkMemoryHostPointerPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->memoryTypeBits, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalMemoryHostPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkDeviceSize*)&forUnmarshaling->minImportedHostPointerAlignment, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

#endif
#ifdef VK_AMD_buffer_marker
#endif
#ifdef VK_AMD_shader_core_properties
void reservedunmarshal_VkPhysicalDeviceShaderCorePropertiesAMD(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderCorePropertiesAMD* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->shaderEngineCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->shaderArraysPerEngineCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->computeUnitsPerShaderArray, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->simdPerComputeUnit, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->wavefrontsPerSimd, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->wavefrontSize, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->sgprsPerSimd, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->minSgprAllocation, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxSgprAllocation, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->sgprAllocationGranularity, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->vgprsPerSimd, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->minVgprAllocation, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->maxVgprAllocation, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->vgprAllocationGranularity, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void reservedunmarshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->maxVertexAttribDivisor, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkVertexInputBindingDivisorDescriptionEXT(
    VulkanStream* vkStream,
    VkVertexInputBindingDivisorDescriptionEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((uint32_t*)&forUnmarshaling->binding, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy((uint32_t*)&forUnmarshaling->divisor, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineVertexInputDivisorStateCreateInfoEXT* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->vertexBindingDivisorCount, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    vkStream->alloc((void**)&forUnmarshaling->pVertexBindingDivisors, forUnmarshaling->vertexBindingDivisorCount * sizeof(const VkVertexInputBindingDivisorDescriptionEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexBindingDivisorCount; ++i)
    {
        reservedunmarshal_VkVertexInputBindingDivisorDescriptionEXT(vkStream, (VkVertexInputBindingDivisorDescriptionEXT*)(forUnmarshaling->pVertexBindingDivisors + i), ptr);
    }
}

#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void reservedunmarshal_VkQueueFamilyCheckpointPropertiesNV(
    VulkanStream* vkStream,
    VkQueueFamilyCheckpointPropertiesNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineStageFlags*)&forUnmarshaling->checkpointExecutionStageMask, *ptr, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
}

void reservedunmarshal_VkCheckpointDataNV(
    VulkanStream* vkStream,
    VkCheckpointDataNV* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((VkPipelineStageFlagBits*)&forUnmarshaling->stage, *ptr, sizeof(VkPipelineStageFlagBits));
    *ptr += sizeof(VkPipelineStageFlagBits);
    // WARNING PTR CHECK
    memcpy((void**)&forUnmarshaling->pCheckpointMarker, (*ptr), 8);
    android::base::Stream::fromBe64((uint8_t*)&forUnmarshaling->pCheckpointMarker);
    *ptr += 8;
    if (forUnmarshaling->pCheckpointMarker)
    {
        vkStream->alloc((void**)&forUnmarshaling->pCheckpointMarker, sizeof(uint8_t));
        memcpy((void*)forUnmarshaling->pCheckpointMarker, *ptr, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_GOOGLE_address_space
#endif
#ifdef VK_GOOGLE_color_buffer
void reservedunmarshal_VkImportColorBufferGOOGLE(
    VulkanStream* vkStream,
    VkImportColorBufferGOOGLE* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->colorBuffer, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkImportBufferGOOGLE(
    VulkanStream* vkStream,
    VkImportBufferGOOGLE* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint32_t*)&forUnmarshaling->buffer, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedunmarshal_VkImportPhysicalAddressGOOGLE(
    VulkanStream* vkStream,
    VkImportPhysicalAddressGOOGLE* forUnmarshaling,
    uint8_t** ptr)
{
    memcpy((VkStructureType*)&forUnmarshaling->sType, *ptr, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    uint32_t pNext_size;
    memcpy((uint32_t*)&pNext_size, *ptr, sizeof(uint32_t));
    android::base::Stream::fromBe32((uint8_t*)&pNext_size);
    *ptr += sizeof(uint32_t);
    forUnmarshaling->pNext = nullptr;
    if (pNext_size)
    {
        vkStream->alloc((void**)&forUnmarshaling->pNext, sizeof(VkStructureType));
        memcpy((void*)forUnmarshaling->pNext, *ptr, sizeof(VkStructureType));
        *ptr += sizeof(VkStructureType);
        VkStructureType extType = *(VkStructureType*)(forUnmarshaling->pNext);
        vkStream->alloc((void**)&forUnmarshaling->pNext, goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), forUnmarshaling->pNext));
        *(VkStructureType*)forUnmarshaling->pNext = extType;
        reservedunmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext), ptr);
    }
    memcpy((uint64_t*)&forUnmarshaling->physicalAddress, *ptr, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy((VkDeviceSize*)&forUnmarshaling->size, *ptr, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy((VkFormat*)&forUnmarshaling->format, *ptr, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy((VkImageTiling*)&forUnmarshaling->tiling, *ptr, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
    memcpy((uint32_t*)&forUnmarshaling->tilingParameter, *ptr, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_GOOGLE_sized_descriptor_update_template
#endif
#ifdef VK_GOOGLE_async_command_buffers
#endif
#ifdef VK_GOOGLE_create_resources_with_requirements
#endif
#ifdef VK_GOOGLE_address_space_info
#endif
#ifdef VK_GOOGLE_free_memory_sync
#endif
#ifdef VK_GOOGLE_async_queue_submit
#endif
#ifdef VK_GOOGLE_linear_image_layout
#endif
#ifdef VK_MVK_moltenvk
#endif
#ifdef VK_GOOGLE_queue_submit_with_commands
#endif
void reservedunmarshal_extension_struct(
    VulkanStream* vkStream,
    void* structExtension_out,
    uint8_t** ptr)
{
    VkInstanceCreateInfo* structAccess = (VkInstanceCreateInfo*)(structExtension_out);
    uint32_t currExtSize = goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), structExtension_out);
    if (!currExtSize && structExtension_out)
    {
        // unknown struct extension; skip and call on its pNext field
        reservedunmarshal_extension_struct(vkStream, (void*)structAccess->pNext, ptr);
        return;
    }
    else
    {
        // known or null extension struct
        if (!currExtSize)
        {
            // exit if this was a null extension struct (size == 0 in this branch)
            return;
        }
    }
    if (!structExtension_out)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension_out);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceSubgroupProperties(vkStream, reinterpret_cast<VkPhysicalDeviceSubgroupProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            reservedunmarshal_VkPhysicalDevice16BitStorageFeatures(vkStream, reinterpret_cast<VkPhysicalDevice16BitStorageFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            reservedunmarshal_VkMemoryDedicatedRequirements(vkStream, reinterpret_cast<VkMemoryDedicatedRequirements*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            reservedunmarshal_VkMemoryDedicatedAllocateInfo(vkStream, reinterpret_cast<VkMemoryDedicatedAllocateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            reservedunmarshal_VkMemoryAllocateFlagsInfo(vkStream, reinterpret_cast<VkMemoryAllocateFlagsInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            reservedunmarshal_VkDeviceGroupRenderPassBeginInfo(vkStream, reinterpret_cast<VkDeviceGroupRenderPassBeginInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            reservedunmarshal_VkDeviceGroupCommandBufferBeginInfo(vkStream, reinterpret_cast<VkDeviceGroupCommandBufferBeginInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            reservedunmarshal_VkDeviceGroupSubmitInfo(vkStream, reinterpret_cast<VkDeviceGroupSubmitInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            reservedunmarshal_VkDeviceGroupBindSparseInfo(vkStream, reinterpret_cast<VkDeviceGroupBindSparseInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            reservedunmarshal_VkBindBufferMemoryDeviceGroupInfo(vkStream, reinterpret_cast<VkBindBufferMemoryDeviceGroupInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            reservedunmarshal_VkBindImageMemoryDeviceGroupInfo(vkStream, reinterpret_cast<VkBindImageMemoryDeviceGroupInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            reservedunmarshal_VkDeviceGroupDeviceCreateInfo(vkStream, reinterpret_cast<VkDeviceGroupDeviceCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            reservedunmarshal_VkPhysicalDeviceFeatures2(vkStream, reinterpret_cast<VkPhysicalDeviceFeatures2*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDevicePointClippingProperties(vkStream, reinterpret_cast<VkPhysicalDevicePointClippingProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            reservedunmarshal_VkRenderPassInputAttachmentAspectCreateInfo(vkStream, reinterpret_cast<VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            reservedunmarshal_VkImageViewUsageCreateInfo(vkStream, reinterpret_cast<VkImageViewUsageCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            reservedunmarshal_VkPipelineTessellationDomainOriginStateCreateInfo(vkStream, reinterpret_cast<VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            reservedunmarshal_VkRenderPassMultiviewCreateInfo(vkStream, reinterpret_cast<VkRenderPassMultiviewCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceMultiviewFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceMultiviewFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceMultiviewProperties(vkStream, reinterpret_cast<VkPhysicalDeviceMultiviewProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceVariablePointerFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceVariablePointerFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceProtectedMemoryFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceProtectedMemoryProperties(vkStream, reinterpret_cast<VkPhysicalDeviceProtectedMemoryProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            reservedunmarshal_VkProtectedSubmitInfo(vkStream, reinterpret_cast<VkProtectedSubmitInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            reservedunmarshal_VkSamplerYcbcrConversionInfo(vkStream, reinterpret_cast<VkSamplerYcbcrConversionInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            reservedunmarshal_VkBindImagePlaneMemoryInfo(vkStream, reinterpret_cast<VkBindImagePlaneMemoryInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            reservedunmarshal_VkImagePlaneMemoryRequirementsInfo(vkStream, reinterpret_cast<VkImagePlaneMemoryRequirementsInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            reservedunmarshal_VkSamplerYcbcrConversionImageFormatProperties(vkStream, reinterpret_cast<VkSamplerYcbcrConversionImageFormatProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            reservedunmarshal_VkPhysicalDeviceExternalImageFormatInfo(vkStream, reinterpret_cast<VkPhysicalDeviceExternalImageFormatInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            reservedunmarshal_VkExternalImageFormatProperties(vkStream, reinterpret_cast<VkExternalImageFormatProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceIDProperties(vkStream, reinterpret_cast<VkPhysicalDeviceIDProperties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            reservedunmarshal_VkExternalMemoryImageCreateInfo(vkStream, reinterpret_cast<VkExternalMemoryImageCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            reservedunmarshal_VkExternalMemoryBufferCreateInfo(vkStream, reinterpret_cast<VkExternalMemoryBufferCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            reservedunmarshal_VkExportMemoryAllocateInfo(vkStream, reinterpret_cast<VkExportMemoryAllocateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            reservedunmarshal_VkExportFenceCreateInfo(vkStream, reinterpret_cast<VkExportFenceCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            reservedunmarshal_VkExportSemaphoreCreateInfo(vkStream, reinterpret_cast<VkExportSemaphoreCreateInfo*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            reservedunmarshal_VkPhysicalDeviceMaintenance3Properties(vkStream, reinterpret_cast<VkPhysicalDeviceMaintenance3Properties*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceShaderDrawParameterFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceShaderDrawParameterFeatures*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            reservedunmarshal_VkImageSwapchainCreateInfoKHR(vkStream, reinterpret_cast<VkImageSwapchainCreateInfoKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            reservedunmarshal_VkBindImageMemorySwapchainInfoKHR(vkStream, reinterpret_cast<VkBindImageMemorySwapchainInfoKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            reservedunmarshal_VkDeviceGroupPresentInfoKHR(vkStream, reinterpret_cast<VkDeviceGroupPresentInfoKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            reservedunmarshal_VkDeviceGroupSwapchainCreateInfoKHR(vkStream, reinterpret_cast<VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            reservedunmarshal_VkDisplayPresentInfoKHR(vkStream, reinterpret_cast<VkDisplayPresentInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            reservedunmarshal_VkImportMemoryWin32HandleInfoKHR(vkStream, reinterpret_cast<VkImportMemoryWin32HandleInfoKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            reservedunmarshal_VkExportMemoryWin32HandleInfoKHR(vkStream, reinterpret_cast<VkExportMemoryWin32HandleInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            reservedunmarshal_VkImportMemoryFdInfoKHR(vkStream, reinterpret_cast<VkImportMemoryFdInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            reservedunmarshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(vkStream, reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            reservedunmarshal_VkExportSemaphoreWin32HandleInfoKHR(vkStream, reinterpret_cast<VkExportSemaphoreWin32HandleInfoKHR*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            reservedunmarshal_VkD3D12FenceSubmitInfoKHR(vkStream, reinterpret_cast<VkD3D12FenceSubmitInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            reservedunmarshal_VkPhysicalDevicePushDescriptorPropertiesKHR(vkStream, reinterpret_cast<VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            reservedunmarshal_VkPresentRegionsKHR(vkStream, reinterpret_cast<VkPresentRegionsKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            reservedunmarshal_VkSharedPresentSurfaceCapabilitiesKHR(vkStream, reinterpret_cast<VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            reservedunmarshal_VkExportFenceWin32HandleInfoKHR(vkStream, reinterpret_cast<VkExportFenceWin32HandleInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_image_format_list
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR:
        {
            reservedunmarshal_VkImageFormatListCreateInfoKHR(vkStream, reinterpret_cast<VkImageFormatListCreateInfoKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_8bit_storage
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
        {
            reservedunmarshal_VkPhysicalDevice8BitStorageFeaturesKHR(vkStream, reinterpret_cast<VkPhysicalDevice8BitStorageFeaturesKHR*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_KHR_shader_float16_int8
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            reservedunmarshal_VkPhysicalDeviceShaderFloat16Int8Features(vkStream, reinterpret_cast<VkPhysicalDeviceShaderFloat16Int8Features*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            reservedunmarshal_VkNativeBufferANDROID(vkStream, reinterpret_cast<VkNativeBufferANDROID*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkDebugReportCallbackCreateInfoEXT(vkStream, reinterpret_cast<VkDebugReportCallbackCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            reservedunmarshal_VkPipelineRasterizationStateRasterizationOrderAMD(vkStream, reinterpret_cast<VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkDedicatedAllocationImageCreateInfoNV(vkStream, reinterpret_cast<VkDedicatedAllocationImageCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            reservedunmarshal_VkDedicatedAllocationBufferCreateInfoNV(vkStream, reinterpret_cast<VkDedicatedAllocationBufferCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            reservedunmarshal_VkDedicatedAllocationMemoryAllocateInfoNV(vkStream, reinterpret_cast<VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            reservedunmarshal_VkTextureLODGatherFormatPropertiesAMD(vkStream, reinterpret_cast<VkTextureLODGatherFormatPropertiesAMD*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkExternalMemoryImageCreateInfoNV(vkStream, reinterpret_cast<VkExternalMemoryImageCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            reservedunmarshal_VkExportMemoryAllocateInfoNV(vkStream, reinterpret_cast<VkExportMemoryAllocateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            reservedunmarshal_VkImportMemoryWin32HandleInfoNV(vkStream, reinterpret_cast<VkImportMemoryWin32HandleInfoNV*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            reservedunmarshal_VkExportMemoryWin32HandleInfoNV(vkStream, reinterpret_cast<VkExportMemoryWin32HandleInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            reservedunmarshal_VkWin32KeyedMutexAcquireReleaseInfoNV(vkStream, reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            reservedunmarshal_VkValidationFlagsEXT(vkStream, reinterpret_cast<VkValidationFlagsEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            reservedunmarshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(vkStream, reinterpret_cast<VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkPipelineViewportWScalingStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkSwapchainCounterCreateInfoEXT(vkStream, reinterpret_cast<VkSwapchainCounterCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            reservedunmarshal_VkPresentTimesInfoGOOGLE(vkStream, reinterpret_cast<VkPresentTimesInfoGOOGLE*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            reservedunmarshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(vkStream, reinterpret_cast<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkPipelineViewportSwizzleStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineDiscardRectangleStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkDebugUtilsMessengerCreateInfoEXT(vkStream, reinterpret_cast<VkDebugUtilsMessengerCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            reservedunmarshal_VkAndroidHardwareBufferUsageANDROID(vkStream, reinterpret_cast<VkAndroidHardwareBufferUsageANDROID*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            reservedunmarshal_VkAndroidHardwareBufferFormatPropertiesANDROID(vkStream, reinterpret_cast<VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            reservedunmarshal_VkImportAndroidHardwareBufferInfoANDROID(vkStream, reinterpret_cast<VkImportAndroidHardwareBufferInfoANDROID*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            reservedunmarshal_VkExternalFormatANDROID(vkStream, reinterpret_cast<VkExternalFormatANDROID*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_sampler_filter_minmax
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkSamplerReductionModeCreateInfoEXT(vkStream, reinterpret_cast<VkSamplerReductionModeCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            reservedunmarshal_VkSampleLocationsInfoEXT(vkStream, reinterpret_cast<VkSampleLocationsInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            reservedunmarshal_VkRenderPassSampleLocationsBeginInfoEXT(vkStream, reinterpret_cast<VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineSampleLocationsStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkPipelineCoverageToColorStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            reservedunmarshal_VkPipelineCoverageModulationStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkShaderModuleValidationCacheCreateInfoEXT(vkStream, reinterpret_cast<VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_descriptor_indexing
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(vkStream, reinterpret_cast<VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceDescriptorIndexingFeaturesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceDescriptorIndexingPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT:
        {
            reservedunmarshal_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(vkStream, reinterpret_cast<VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT:
        {
            reservedunmarshal_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(vkStream, reinterpret_cast<VkDescriptorSetVariableDescriptorCountLayoutSupportEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(vkStream, reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            reservedunmarshal_VkImportMemoryHostPointerInfoEXT(vkStream, reinterpret_cast<VkImportMemoryHostPointerInfoEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            reservedunmarshal_VkPhysicalDeviceShaderCorePropertiesAMD(vkStream, reinterpret_cast<VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            reservedunmarshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            reservedunmarshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            reservedunmarshal_VkQueueFamilyCheckpointPropertiesNV(vkStream, reinterpret_cast<VkQueueFamilyCheckpointPropertiesNV*>(structExtension_out), ptr);
            break;
        }
#endif
#ifdef VK_GOOGLE_color_buffer
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE:
        {
            reservedunmarshal_VkImportColorBufferGOOGLE(vkStream, reinterpret_cast<VkImportColorBufferGOOGLE*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_BUFFER_GOOGLE:
        {
            reservedunmarshal_VkImportBufferGOOGLE(vkStream, reinterpret_cast<VkImportBufferGOOGLE*>(structExtension_out), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE:
        {
            reservedunmarshal_VkImportPhysicalAddressGOOGLE(vkStream, reinterpret_cast<VkImportPhysicalAddressGOOGLE*>(structExtension_out), ptr);
            break;
        }
#endif
        default:
        {
            // fatal; the switch is only taken if the extension struct is known
            abort();
        }
    }
}


} // namespace goldfish_vk
