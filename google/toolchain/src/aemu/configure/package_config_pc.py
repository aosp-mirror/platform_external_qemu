# -*- coding: utf-8 -*-
# Copyright 2023 - The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the',  help='License');
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an',  help='AS IS' BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import logging
import re
import shutil
from pathlib import Path
from typing import Dict, Set

from aemu.process.runner import check_output, run


class PackageConfigPc:
    """
    PackageConfigPc - A class for generating pkg-config (.pc) files.

    This class facilitates the creation of pkg-config files, which are used to provide
    configuration information to build systems and compile/link applications.

    The following things can be shimmed:

    'Requires'    : Set of dependencies you want to specify
    'link_flags'  : Extra link_flags that should be used
    'link_name'   : Create symlink to the existing archive
    'name'        : Shim the name, vs. using the derived one.
    """

    def __init__(
        self,
        name: str,
        version: str,
        release_dir: Path,
        archive: Path,
        includes: Set[Path],
        shim: Dict[str, str],
    ):
        self.name = shim.get("name", name)
        self.release_dir = release_dir.as_posix()
        self.version = version
        self.requires = shim.get("Requires", "")
        self.link_flags = shim.get("link_flags", "")
        self.archive = archive
        self.libdir = archive.parent.as_posix()
        self.lib = archive.with_suffix("").name
        if self.lib.startswith("lib"):
            self.lib = self.lib[3:]
        self.shim = shim

        if includes is None:
            self.include_dir = ""
            self.cflags = ""
        else:
            self.include_dir = next(iter(includes))
            self.cflags = (
                " ".join([f"-I{path.as_posix()}" for path in includes])
                + f" {shim.get('cflags', '')}"
            )

    def is_static(self):
        return self.archive.suffix == ".a"

    def _template(self):
        if self.archive.suffix == ".a":
            libs = f"{self.archive} {self.link_flags}"
        else:
            libs = f"-L{self.libdir} -l{self.lib} {self.link_flags}"

        return f"""prefix={self.release_dir}
    includedir={self.include_dir}
    libdir={self.libdir}
    bindir={{prefix}}/bin

    Name: {self.name}
    Description: Auto generated by Android Meson Generator
    Version: {self.version}

    Requires: {self.requires}
    Cflags: {self.cflags}
    Libs: {libs}
    """

    def _shim_link(self, archive, shim):
        """
        Create a symbolic link to the library if specified in the shim.

        Args:
            archive (Path): The path to the library archive.
            shim (Dict): The shim configuration.

        Returns:
            None
        """
        if "link_name" in shim and archive.name != shim.get("link_name"):
            logging.info("Shimming link to: %s (%s)", archive, archive.exists())
            shim_link = archive.parent / shim.get("link_name")
            if not shim_link.exists():
                archive.link_to(shim_link)

    def _patch_dylib(self, dylib: Path):
        # Workaround for b/331243894
        rpath_regex = re.compile(r"^.*@rpath\/([^\s]+)")
        result = check_output(["otool", "-L", dylib])
        rpathline = result.splitlines()[1]
        match = rpath_regex.match(rpathline)
        if match:
            bazel_name = dylib.parent / match.group(1)
            bazel_name.symlink_to(dylib)
            logging.info("Patching up bazel @path %s -> %s", bazel_name, dylib)
        else:
            logging.info("Not patching %s", dylib)

    def _patch_solib(self, solib: Path):
        # Run the objdump command to extract SONAME
        objdump_output = run(["objdump", "-p", solib])

        # Find the line containing SONAME
        soname_line = next((line for line in objdump_output if "SONAME" in line), None)

        if soname_line:
            # Extract the SONAME file that the library is using and setup the symlink
            soname = solib.parent / soname_line.split()[1]
            target_relative = solib.relative_to(soname.parent)
            soname.symlink_to(target_relative)

    def binplace(self, dest_dir: Path):
        """Binplace the shared libraries to the given location."""
        so_ext = [".so", ".dylib", ".dll"]
        for ext in so_ext:
            for lib in [
                f"lib{self.lib}",
                self.name,
                self.lib,
            ]:
                possible = Path(self.libdir) / f"{lib}{ext}"
                if possible.exists():
                    logging.debug("Binplacing: %s -> %s", possible, dest_dir)
                    destination = dest_dir / f"{lib}{self.shim.get('dll_ext', ext)}"
                    shutil.copyfile(possible, destination)
                    if ext == ".dylib":
                        # Patch up bazel @rpath
                        self._patch_dylib(destination)
                    if ext == ".so":
                        # Patch up links if needed
                        self._patch_solib(destination)

                    return

    def write(self, dest_dir: Path):
        """
        Write the generated pkg-config file to the specified destination directory.

        Args:
            dest_dir (Path): The destination directory.

        Returns:
            None
        """
        dest_dir.mkdir(exist_ok=True)
        location = dest_dir / f"{self.name}.pc"

        # Write the pkg-config file.
        logging.info("Generating %s", location)
        with open(location, "w", encoding="utf-8") as f:
            f.write(self._template())
