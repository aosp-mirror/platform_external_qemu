/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_UI_GENERATED_TRACERS_H
#define TRACE_UI_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_CONSOLE_GFX_NEW_EVENT;
extern TraceEvent _TRACE_CONSOLE_GFX_REUSE_EVENT;
extern TraceEvent _TRACE_CONSOLE_GFX_CLOSE_EVENT;
extern TraceEvent _TRACE_CONSOLE_PUTCHAR_CSI_EVENT;
extern TraceEvent _TRACE_CONSOLE_PUTCHAR_UNHANDLED_EVENT;
extern TraceEvent _TRACE_CONSOLE_TXT_NEW_EVENT;
extern TraceEvent _TRACE_CONSOLE_SELECT_EVENT;
extern TraceEvent _TRACE_CONSOLE_REFRESH_EVENT;
extern TraceEvent _TRACE_DISPLAYSURFACE_CREATE_EVENT;
extern TraceEvent _TRACE_DISPLAYSURFACE_CREATE_FROM_EVENT;
extern TraceEvent _TRACE_DISPLAYSURFACE_CREATE_PIXMAN_EVENT;
extern TraceEvent _TRACE_DISPLAYSURFACE_FREE_EVENT;
extern TraceEvent _TRACE_DISPLAYCHANGELISTENER_REGISTER_EVENT;
extern TraceEvent _TRACE_DISPLAYCHANGELISTENER_UNREGISTER_EVENT;
extern TraceEvent _TRACE_PPM_SAVE_EVENT;
extern TraceEvent _TRACE_GD_SWITCH_EVENT;
extern TraceEvent _TRACE_GD_UPDATE_EVENT;
extern TraceEvent _TRACE_GD_KEY_EVENT_EVENT;
extern TraceEvent _TRACE_GD_GRAB_EVENT;
extern TraceEvent _TRACE_GD_UNGRAB_EVENT;
extern TraceEvent _TRACE_GD_KEYMAP_WINDOWING_EVENT;
extern TraceEvent _TRACE_VNC_KEY_GUEST_LEDS_EVENT;
extern TraceEvent _TRACE_VNC_KEY_MAP_INIT_EVENT;
extern TraceEvent _TRACE_VNC_KEY_EVENT_EXT_EVENT;
extern TraceEvent _TRACE_VNC_KEY_EVENT_MAP_EVENT;
extern TraceEvent _TRACE_VNC_KEY_SYNC_NUMLOCK_EVENT;
extern TraceEvent _TRACE_VNC_KEY_SYNC_CAPSLOCK_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_EOF_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_IO_ERROR_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_CONNECT_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_DISCONNECT_START_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_DISCONNECT_FINISH_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_IO_WRAP_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_THROTTLE_THRESHOLD_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_THROTTLE_INCREMENTAL_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_THROTTLE_FORCED_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_THROTTLE_AUDIO_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_UNTHROTTLE_FORCED_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_UNTHROTTLE_INCREMENTAL_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_OUTPUT_LIMIT_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_INIT_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_START_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_PASS_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_FAIL_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_REJECT_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_VENCRYPT_VERSION_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_VENCRYPT_SUBAUTH_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_SASL_MECH_LIST_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_SASL_MECH_CHOOSE_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_SASL_START_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_SASL_STEP_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_SASL_SSF_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_SASL_USERNAME_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_SASL_ACL_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_KEY_NUMBER_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_KEY_QCODE_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_BTN_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_REL_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_ABS_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_SYNC_EVENT;
extern TraceEvent _TRACE_INPUT_MOUSE_MODE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_ADD_MEMSLOT_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_DEL_MEMSLOT_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_WAKEUP_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_CREATE_UPDATE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_DISPLAY_UPDATE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_DISPLAY_SURFACE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_DISPLAY_REFRESH_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_UI_INFO_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_GL_SURFACE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_GL_SCANOUT_DISABLE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_GL_SCANOUT_TEXTURE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_GL_CURSOR_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_GL_FORWARD_DMABUF_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_GL_RENDER_DMABUF_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_GL_UPDATE_EVENT;
extern TraceEvent _TRACE_KEYMAP_PARSE_EVENT;
extern TraceEvent _TRACE_KEYMAP_ADD_EVENT;
extern TraceEvent _TRACE_KEYMAP_UNMAPPED_EVENT;
extern TraceEvent _TRACE_XKEYMAP_EXTENSION_EVENT;
extern TraceEvent _TRACE_XKEYMAP_VENDOR_EVENT;
extern TraceEvent _TRACE_XKEYMAP_KEYCODES_EVENT;
extern TraceEvent _TRACE_XKEYMAP_KEYMAP_EVENT;
extern uint16_t _TRACE_CONSOLE_GFX_NEW_DSTATE;
extern uint16_t _TRACE_CONSOLE_GFX_REUSE_DSTATE;
extern uint16_t _TRACE_CONSOLE_GFX_CLOSE_DSTATE;
extern uint16_t _TRACE_CONSOLE_PUTCHAR_CSI_DSTATE;
extern uint16_t _TRACE_CONSOLE_PUTCHAR_UNHANDLED_DSTATE;
extern uint16_t _TRACE_CONSOLE_TXT_NEW_DSTATE;
extern uint16_t _TRACE_CONSOLE_SELECT_DSTATE;
extern uint16_t _TRACE_CONSOLE_REFRESH_DSTATE;
extern uint16_t _TRACE_DISPLAYSURFACE_CREATE_DSTATE;
extern uint16_t _TRACE_DISPLAYSURFACE_CREATE_FROM_DSTATE;
extern uint16_t _TRACE_DISPLAYSURFACE_CREATE_PIXMAN_DSTATE;
extern uint16_t _TRACE_DISPLAYSURFACE_FREE_DSTATE;
extern uint16_t _TRACE_DISPLAYCHANGELISTENER_REGISTER_DSTATE;
extern uint16_t _TRACE_DISPLAYCHANGELISTENER_UNREGISTER_DSTATE;
extern uint16_t _TRACE_PPM_SAVE_DSTATE;
extern uint16_t _TRACE_GD_SWITCH_DSTATE;
extern uint16_t _TRACE_GD_UPDATE_DSTATE;
extern uint16_t _TRACE_GD_KEY_EVENT_DSTATE;
extern uint16_t _TRACE_GD_GRAB_DSTATE;
extern uint16_t _TRACE_GD_UNGRAB_DSTATE;
extern uint16_t _TRACE_GD_KEYMAP_WINDOWING_DSTATE;
extern uint16_t _TRACE_VNC_KEY_GUEST_LEDS_DSTATE;
extern uint16_t _TRACE_VNC_KEY_MAP_INIT_DSTATE;
extern uint16_t _TRACE_VNC_KEY_EVENT_EXT_DSTATE;
extern uint16_t _TRACE_VNC_KEY_EVENT_MAP_DSTATE;
extern uint16_t _TRACE_VNC_KEY_SYNC_NUMLOCK_DSTATE;
extern uint16_t _TRACE_VNC_KEY_SYNC_CAPSLOCK_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_EOF_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_IO_ERROR_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_CONNECT_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_DISCONNECT_START_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_DISCONNECT_FINISH_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_IO_WRAP_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_THROTTLE_THRESHOLD_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_THROTTLE_INCREMENTAL_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_THROTTLE_FORCED_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_THROTTLE_AUDIO_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_UNTHROTTLE_FORCED_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_UNTHROTTLE_INCREMENTAL_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_OUTPUT_LIMIT_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_INIT_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_START_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_PASS_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_FAIL_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_REJECT_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_VENCRYPT_VERSION_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_VENCRYPT_SUBAUTH_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_SASL_MECH_LIST_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_SASL_MECH_CHOOSE_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_SASL_START_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_SASL_STEP_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_SASL_SSF_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_SASL_USERNAME_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_SASL_ACL_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_KEY_NUMBER_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_KEY_QCODE_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_BTN_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_REL_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_ABS_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_SYNC_DSTATE;
extern uint16_t _TRACE_INPUT_MOUSE_MODE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_ADD_MEMSLOT_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_DEL_MEMSLOT_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_WAKEUP_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_CREATE_UPDATE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_DISPLAY_UPDATE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_DISPLAY_SURFACE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_DISPLAY_REFRESH_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_UI_INFO_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_GL_SURFACE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_GL_SCANOUT_DISABLE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_GL_SCANOUT_TEXTURE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_GL_CURSOR_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_GL_FORWARD_DMABUF_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_GL_RENDER_DMABUF_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_GL_UPDATE_DSTATE;
extern uint16_t _TRACE_KEYMAP_PARSE_DSTATE;
extern uint16_t _TRACE_KEYMAP_ADD_DSTATE;
extern uint16_t _TRACE_KEYMAP_UNMAPPED_DSTATE;
extern uint16_t _TRACE_XKEYMAP_EXTENSION_DSTATE;
extern uint16_t _TRACE_XKEYMAP_VENDOR_DSTATE;
extern uint16_t _TRACE_XKEYMAP_KEYCODES_DSTATE;
extern uint16_t _TRACE_XKEYMAP_KEYMAP_DSTATE;
#define TRACE_CONSOLE_GFX_NEW_ENABLED 1
#define TRACE_CONSOLE_GFX_REUSE_ENABLED 1
#define TRACE_CONSOLE_GFX_CLOSE_ENABLED 1
#define TRACE_CONSOLE_PUTCHAR_CSI_ENABLED 1
#define TRACE_CONSOLE_PUTCHAR_UNHANDLED_ENABLED 1
#define TRACE_CONSOLE_TXT_NEW_ENABLED 1
#define TRACE_CONSOLE_SELECT_ENABLED 1
#define TRACE_CONSOLE_REFRESH_ENABLED 1
#define TRACE_DISPLAYSURFACE_CREATE_ENABLED 1
#define TRACE_DISPLAYSURFACE_CREATE_FROM_ENABLED 1
#define TRACE_DISPLAYSURFACE_CREATE_PIXMAN_ENABLED 1
#define TRACE_DISPLAYSURFACE_FREE_ENABLED 1
#define TRACE_DISPLAYCHANGELISTENER_REGISTER_ENABLED 1
#define TRACE_DISPLAYCHANGELISTENER_UNREGISTER_ENABLED 1
#define TRACE_PPM_SAVE_ENABLED 1
#define TRACE_GD_SWITCH_ENABLED 1
#define TRACE_GD_UPDATE_ENABLED 1
#define TRACE_GD_KEY_EVENT_ENABLED 1
#define TRACE_GD_GRAB_ENABLED 1
#define TRACE_GD_UNGRAB_ENABLED 1
#define TRACE_GD_KEYMAP_WINDOWING_ENABLED 1
#define TRACE_VNC_KEY_GUEST_LEDS_ENABLED 1
#define TRACE_VNC_KEY_MAP_INIT_ENABLED 1
#define TRACE_VNC_KEY_EVENT_EXT_ENABLED 1
#define TRACE_VNC_KEY_EVENT_MAP_ENABLED 1
#define TRACE_VNC_KEY_SYNC_NUMLOCK_ENABLED 1
#define TRACE_VNC_KEY_SYNC_CAPSLOCK_ENABLED 1
#define TRACE_VNC_CLIENT_EOF_ENABLED 1
#define TRACE_VNC_CLIENT_IO_ERROR_ENABLED 1
#define TRACE_VNC_CLIENT_CONNECT_ENABLED 1
#define TRACE_VNC_CLIENT_DISCONNECT_START_ENABLED 1
#define TRACE_VNC_CLIENT_DISCONNECT_FINISH_ENABLED 1
#define TRACE_VNC_CLIENT_IO_WRAP_ENABLED 1
#define TRACE_VNC_CLIENT_THROTTLE_THRESHOLD_ENABLED 1
#define TRACE_VNC_CLIENT_THROTTLE_INCREMENTAL_ENABLED 1
#define TRACE_VNC_CLIENT_THROTTLE_FORCED_ENABLED 1
#define TRACE_VNC_CLIENT_THROTTLE_AUDIO_ENABLED 1
#define TRACE_VNC_CLIENT_UNTHROTTLE_FORCED_ENABLED 1
#define TRACE_VNC_CLIENT_UNTHROTTLE_INCREMENTAL_ENABLED 1
#define TRACE_VNC_CLIENT_OUTPUT_LIMIT_ENABLED 1
#define TRACE_VNC_AUTH_INIT_ENABLED 1
#define TRACE_VNC_AUTH_START_ENABLED 1
#define TRACE_VNC_AUTH_PASS_ENABLED 1
#define TRACE_VNC_AUTH_FAIL_ENABLED 1
#define TRACE_VNC_AUTH_REJECT_ENABLED 1
#define TRACE_VNC_AUTH_VENCRYPT_VERSION_ENABLED 1
#define TRACE_VNC_AUTH_VENCRYPT_SUBAUTH_ENABLED 1
#define TRACE_VNC_AUTH_SASL_MECH_LIST_ENABLED 1
#define TRACE_VNC_AUTH_SASL_MECH_CHOOSE_ENABLED 1
#define TRACE_VNC_AUTH_SASL_START_ENABLED 1
#define TRACE_VNC_AUTH_SASL_STEP_ENABLED 1
#define TRACE_VNC_AUTH_SASL_SSF_ENABLED 1
#define TRACE_VNC_AUTH_SASL_USERNAME_ENABLED 1
#define TRACE_VNC_AUTH_SASL_ACL_ENABLED 1
#define TRACE_INPUT_EVENT_KEY_NUMBER_ENABLED 1
#define TRACE_INPUT_EVENT_KEY_QCODE_ENABLED 1
#define TRACE_INPUT_EVENT_BTN_ENABLED 1
#define TRACE_INPUT_EVENT_REL_ENABLED 1
#define TRACE_INPUT_EVENT_ABS_ENABLED 1
#define TRACE_INPUT_EVENT_SYNC_ENABLED 1
#define TRACE_INPUT_MOUSE_MODE_ENABLED 1
#define TRACE_QEMU_SPICE_ADD_MEMSLOT_ENABLED 1
#define TRACE_QEMU_SPICE_DEL_MEMSLOT_ENABLED 1
#define TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE_ENABLED 1
#define TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE_ENABLED 1
#define TRACE_QEMU_SPICE_WAKEUP_ENABLED 1
#define TRACE_QEMU_SPICE_CREATE_UPDATE_ENABLED 1
#define TRACE_QEMU_SPICE_DISPLAY_UPDATE_ENABLED 1
#define TRACE_QEMU_SPICE_DISPLAY_SURFACE_ENABLED 1
#define TRACE_QEMU_SPICE_DISPLAY_REFRESH_ENABLED 1
#define TRACE_QEMU_SPICE_UI_INFO_ENABLED 1
#define TRACE_QEMU_SPICE_GL_SURFACE_ENABLED 1
#define TRACE_QEMU_SPICE_GL_SCANOUT_DISABLE_ENABLED 1
#define TRACE_QEMU_SPICE_GL_SCANOUT_TEXTURE_ENABLED 1
#define TRACE_QEMU_SPICE_GL_CURSOR_ENABLED 1
#define TRACE_QEMU_SPICE_GL_FORWARD_DMABUF_ENABLED 1
#define TRACE_QEMU_SPICE_GL_RENDER_DMABUF_ENABLED 1
#define TRACE_QEMU_SPICE_GL_UPDATE_ENABLED 1
#define TRACE_KEYMAP_PARSE_ENABLED 1
#define TRACE_KEYMAP_ADD_ENABLED 1
#define TRACE_KEYMAP_UNMAPPED_ENABLED 1
#define TRACE_XKEYMAP_EXTENSION_ENABLED 1
#define TRACE_XKEYMAP_VENDOR_ENABLED 1
#define TRACE_XKEYMAP_KEYCODES_ENABLED 1
#define TRACE_XKEYMAP_KEYMAP_ENABLED 1

#define TRACE_CONSOLE_GFX_NEW_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_console_gfx_new(void)
{
}

static inline void trace_console_gfx_new(void)
{
    if (true) {
        _nocheck__trace_console_gfx_new();
    }
}

#define TRACE_CONSOLE_GFX_REUSE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_console_gfx_reuse(int index)
{
}

static inline void trace_console_gfx_reuse(int index)
{
    if (true) {
        _nocheck__trace_console_gfx_reuse(index);
    }
}

#define TRACE_CONSOLE_GFX_CLOSE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_console_gfx_close(int index)
{
}

static inline void trace_console_gfx_close(int index)
{
    if (true) {
        _nocheck__trace_console_gfx_close(index);
    }
}

#define TRACE_CONSOLE_PUTCHAR_CSI_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_console_putchar_csi(int esc_param0, int esc_param1, int ch, int nb_esc_params)
{
}

static inline void trace_console_putchar_csi(int esc_param0, int esc_param1, int ch, int nb_esc_params)
{
    if (true) {
        _nocheck__trace_console_putchar_csi(esc_param0, esc_param1, ch, nb_esc_params);
    }
}

#define TRACE_CONSOLE_PUTCHAR_UNHANDLED_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_console_putchar_unhandled(int ch)
{
}

static inline void trace_console_putchar_unhandled(int ch)
{
    if (true) {
        _nocheck__trace_console_putchar_unhandled(ch);
    }
}

#define TRACE_CONSOLE_TXT_NEW_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_console_txt_new(int w, int h)
{
}

static inline void trace_console_txt_new(int w, int h)
{
    if (true) {
        _nocheck__trace_console_txt_new(w, h);
    }
}

#define TRACE_CONSOLE_SELECT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_console_select(int nr)
{
}

static inline void trace_console_select(int nr)
{
    if (true) {
        _nocheck__trace_console_select(nr);
    }
}

#define TRACE_CONSOLE_REFRESH_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_console_refresh(int interval)
{
}

static inline void trace_console_refresh(int interval)
{
    if (true) {
        _nocheck__trace_console_refresh(interval);
    }
}

#define TRACE_DISPLAYSURFACE_CREATE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_displaysurface_create(void * display_surface, int w, int h)
{
}

static inline void trace_displaysurface_create(void * display_surface, int w, int h)
{
    if (true) {
        _nocheck__trace_displaysurface_create(display_surface, w, h);
    }
}

#define TRACE_DISPLAYSURFACE_CREATE_FROM_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_displaysurface_create_from(void * display_surface, int w, int h, uint32_t format)
{
}

static inline void trace_displaysurface_create_from(void * display_surface, int w, int h, uint32_t format)
{
    if (true) {
        _nocheck__trace_displaysurface_create_from(display_surface, w, h, format);
    }
}

#define TRACE_DISPLAYSURFACE_CREATE_PIXMAN_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_displaysurface_create_pixman(void * display_surface)
{
}

static inline void trace_displaysurface_create_pixman(void * display_surface)
{
    if (true) {
        _nocheck__trace_displaysurface_create_pixman(display_surface);
    }
}

#define TRACE_DISPLAYSURFACE_FREE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_displaysurface_free(void * display_surface)
{
}

static inline void trace_displaysurface_free(void * display_surface)
{
    if (true) {
        _nocheck__trace_displaysurface_free(display_surface);
    }
}

#define TRACE_DISPLAYCHANGELISTENER_REGISTER_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_displaychangelistener_register(void * dcl, const char * name)
{
}

static inline void trace_displaychangelistener_register(void * dcl, const char * name)
{
    if (true) {
        _nocheck__trace_displaychangelistener_register(dcl, name);
    }
}

#define TRACE_DISPLAYCHANGELISTENER_UNREGISTER_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_displaychangelistener_unregister(void * dcl, const char * name)
{
}

static inline void trace_displaychangelistener_unregister(void * dcl, const char * name)
{
    if (true) {
        _nocheck__trace_displaychangelistener_unregister(dcl, name);
    }
}

#define TRACE_PPM_SAVE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_ppm_save(const char * filename, void * display_surface)
{
}

static inline void trace_ppm_save(const char * filename, void * display_surface)
{
    if (true) {
        _nocheck__trace_ppm_save(filename, display_surface);
    }
}

#define TRACE_GD_SWITCH_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_gd_switch(const char * tab, int width, int height)
{
}

static inline void trace_gd_switch(const char * tab, int width, int height)
{
    if (true) {
        _nocheck__trace_gd_switch(tab, width, height);
    }
}

#define TRACE_GD_UPDATE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_gd_update(const char * tab, int x, int y, int w, int h)
{
}

static inline void trace_gd_update(const char * tab, int x, int y, int w, int h)
{
    if (true) {
        _nocheck__trace_gd_update(tab, x, y, w, h);
    }
}

#define TRACE_GD_KEY_EVENT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_gd_key_event(const char * tab, int gdk_keycode, int qkeycode, const char * action)
{
}

static inline void trace_gd_key_event(const char * tab, int gdk_keycode, int qkeycode, const char * action)
{
    if (true) {
        _nocheck__trace_gd_key_event(tab, gdk_keycode, qkeycode, action);
    }
}

#define TRACE_GD_GRAB_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_gd_grab(const char * tab, const char * device, const char * reason)
{
}

static inline void trace_gd_grab(const char * tab, const char * device, const char * reason)
{
    if (true) {
        _nocheck__trace_gd_grab(tab, device, reason);
    }
}

#define TRACE_GD_UNGRAB_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_gd_ungrab(const char * tab, const char * device)
{
}

static inline void trace_gd_ungrab(const char * tab, const char * device)
{
    if (true) {
        _nocheck__trace_gd_ungrab(tab, device);
    }
}

#define TRACE_GD_KEYMAP_WINDOWING_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_gd_keymap_windowing(const char * name)
{
}

static inline void trace_gd_keymap_windowing(const char * name)
{
    if (true) {
        _nocheck__trace_gd_keymap_windowing(name);
    }
}

#define TRACE_VNC_KEY_GUEST_LEDS_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_key_guest_leds(bool caps, bool num, bool scroll)
{
}

static inline void trace_vnc_key_guest_leds(bool caps, bool num, bool scroll)
{
    if (true) {
        _nocheck__trace_vnc_key_guest_leds(caps, num, scroll);
    }
}

#define TRACE_VNC_KEY_MAP_INIT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_key_map_init(const char * layout)
{
}

static inline void trace_vnc_key_map_init(const char * layout)
{
    if (true) {
        _nocheck__trace_vnc_key_map_init(layout);
    }
}

#define TRACE_VNC_KEY_EVENT_EXT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_key_event_ext(bool down, int sym, int keycode, const char * name)
{
}

static inline void trace_vnc_key_event_ext(bool down, int sym, int keycode, const char * name)
{
    if (true) {
        _nocheck__trace_vnc_key_event_ext(down, sym, keycode, name);
    }
}

#define TRACE_VNC_KEY_EVENT_MAP_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_key_event_map(bool down, int sym, int keycode, const char * name)
{
}

static inline void trace_vnc_key_event_map(bool down, int sym, int keycode, const char * name)
{
    if (true) {
        _nocheck__trace_vnc_key_event_map(down, sym, keycode, name);
    }
}

#define TRACE_VNC_KEY_SYNC_NUMLOCK_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_key_sync_numlock(bool on)
{
}

static inline void trace_vnc_key_sync_numlock(bool on)
{
    if (true) {
        _nocheck__trace_vnc_key_sync_numlock(on);
    }
}

#define TRACE_VNC_KEY_SYNC_CAPSLOCK_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_key_sync_capslock(bool on)
{
}

static inline void trace_vnc_key_sync_capslock(bool on)
{
    if (true) {
        _nocheck__trace_vnc_key_sync_capslock(on);
    }
}

#define TRACE_VNC_CLIENT_EOF_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_client_eof(void * state, void * ioc)
{
}

static inline void trace_vnc_client_eof(void * state, void * ioc)
{
    if (true) {
        _nocheck__trace_vnc_client_eof(state, ioc);
    }
}

#define TRACE_VNC_CLIENT_IO_ERROR_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_client_io_error(void * state, void * ioc, const char * msg)
{
}

static inline void trace_vnc_client_io_error(void * state, void * ioc, const char * msg)
{
    if (true) {
        _nocheck__trace_vnc_client_io_error(state, ioc, msg);
    }
}

#define TRACE_VNC_CLIENT_CONNECT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_client_connect(void * state, void * ioc)
{
}

static inline void trace_vnc_client_connect(void * state, void * ioc)
{
    if (true) {
        _nocheck__trace_vnc_client_connect(state, ioc);
    }
}

#define TRACE_VNC_CLIENT_DISCONNECT_START_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_client_disconnect_start(void * state, void * ioc)
{
}

static inline void trace_vnc_client_disconnect_start(void * state, void * ioc)
{
    if (true) {
        _nocheck__trace_vnc_client_disconnect_start(state, ioc);
    }
}

#define TRACE_VNC_CLIENT_DISCONNECT_FINISH_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_client_disconnect_finish(void * state, void * ioc)
{
}

static inline void trace_vnc_client_disconnect_finish(void * state, void * ioc)
{
    if (true) {
        _nocheck__trace_vnc_client_disconnect_finish(state, ioc);
    }
}

#define TRACE_VNC_CLIENT_IO_WRAP_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_client_io_wrap(void * state, void * ioc, const char * type)
{
}

static inline void trace_vnc_client_io_wrap(void * state, void * ioc, const char * type)
{
    if (true) {
        _nocheck__trace_vnc_client_io_wrap(state, ioc, type);
    }
}

#define TRACE_VNC_CLIENT_THROTTLE_THRESHOLD_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_client_throttle_threshold(void * state, void * ioc, size_t oldoffset, size_t offset, int client_width, int client_height, int bytes_per_pixel, void * audio_cap)
{
}

static inline void trace_vnc_client_throttle_threshold(void * state, void * ioc, size_t oldoffset, size_t offset, int client_width, int client_height, int bytes_per_pixel, void * audio_cap)
{
    if (true) {
        _nocheck__trace_vnc_client_throttle_threshold(state, ioc, oldoffset, offset, client_width, client_height, bytes_per_pixel, audio_cap);
    }
}

#define TRACE_VNC_CLIENT_THROTTLE_INCREMENTAL_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_client_throttle_incremental(void * state, void * ioc, int job_update, size_t offset)
{
}

static inline void trace_vnc_client_throttle_incremental(void * state, void * ioc, int job_update, size_t offset)
{
    if (true) {
        _nocheck__trace_vnc_client_throttle_incremental(state, ioc, job_update, offset);
    }
}

#define TRACE_VNC_CLIENT_THROTTLE_FORCED_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_client_throttle_forced(void * state, void * ioc, int job_update, size_t offset)
{
}

static inline void trace_vnc_client_throttle_forced(void * state, void * ioc, int job_update, size_t offset)
{
    if (true) {
        _nocheck__trace_vnc_client_throttle_forced(state, ioc, job_update, offset);
    }
}

#define TRACE_VNC_CLIENT_THROTTLE_AUDIO_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_client_throttle_audio(void * state, void * ioc, size_t offset)
{
}

static inline void trace_vnc_client_throttle_audio(void * state, void * ioc, size_t offset)
{
    if (true) {
        _nocheck__trace_vnc_client_throttle_audio(state, ioc, offset);
    }
}

#define TRACE_VNC_CLIENT_UNTHROTTLE_FORCED_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_client_unthrottle_forced(void * state, void * ioc)
{
}

static inline void trace_vnc_client_unthrottle_forced(void * state, void * ioc)
{
    if (true) {
        _nocheck__trace_vnc_client_unthrottle_forced(state, ioc);
    }
}

#define TRACE_VNC_CLIENT_UNTHROTTLE_INCREMENTAL_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_client_unthrottle_incremental(void * state, void * ioc, size_t offset)
{
}

static inline void trace_vnc_client_unthrottle_incremental(void * state, void * ioc, size_t offset)
{
    if (true) {
        _nocheck__trace_vnc_client_unthrottle_incremental(state, ioc, offset);
    }
}

#define TRACE_VNC_CLIENT_OUTPUT_LIMIT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_client_output_limit(void * state, void * ioc, size_t offset, size_t threshold)
{
}

static inline void trace_vnc_client_output_limit(void * state, void * ioc, size_t offset, size_t threshold)
{
    if (true) {
        _nocheck__trace_vnc_client_output_limit(state, ioc, offset, threshold);
    }
}

#define TRACE_VNC_AUTH_INIT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_auth_init(void * display, int websock, int auth, int subauth)
{
}

static inline void trace_vnc_auth_init(void * display, int websock, int auth, int subauth)
{
    if (true) {
        _nocheck__trace_vnc_auth_init(display, websock, auth, subauth);
    }
}

#define TRACE_VNC_AUTH_START_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_auth_start(void * state, int method)
{
}

static inline void trace_vnc_auth_start(void * state, int method)
{
    if (true) {
        _nocheck__trace_vnc_auth_start(state, method);
    }
}

#define TRACE_VNC_AUTH_PASS_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_auth_pass(void * state, int method)
{
}

static inline void trace_vnc_auth_pass(void * state, int method)
{
    if (true) {
        _nocheck__trace_vnc_auth_pass(state, method);
    }
}

#define TRACE_VNC_AUTH_FAIL_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_auth_fail(void * state, int method, const char * message, const char * reason)
{
}

static inline void trace_vnc_auth_fail(void * state, int method, const char * message, const char * reason)
{
    if (true) {
        _nocheck__trace_vnc_auth_fail(state, method, message, reason);
    }
}

#define TRACE_VNC_AUTH_REJECT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_auth_reject(void * state, int expect, int got)
{
}

static inline void trace_vnc_auth_reject(void * state, int expect, int got)
{
    if (true) {
        _nocheck__trace_vnc_auth_reject(state, expect, got);
    }
}

#define TRACE_VNC_AUTH_VENCRYPT_VERSION_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_auth_vencrypt_version(void * state, int major, int minor)
{
}

static inline void trace_vnc_auth_vencrypt_version(void * state, int major, int minor)
{
    if (true) {
        _nocheck__trace_vnc_auth_vencrypt_version(state, major, minor);
    }
}

#define TRACE_VNC_AUTH_VENCRYPT_SUBAUTH_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_auth_vencrypt_subauth(void * state, int auth)
{
}

static inline void trace_vnc_auth_vencrypt_subauth(void * state, int auth)
{
    if (true) {
        _nocheck__trace_vnc_auth_vencrypt_subauth(state, auth);
    }
}

#define TRACE_VNC_AUTH_SASL_MECH_LIST_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_auth_sasl_mech_list(void * state, const char * mechs)
{
}

static inline void trace_vnc_auth_sasl_mech_list(void * state, const char * mechs)
{
    if (true) {
        _nocheck__trace_vnc_auth_sasl_mech_list(state, mechs);
    }
}

#define TRACE_VNC_AUTH_SASL_MECH_CHOOSE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_auth_sasl_mech_choose(void * state, const char * mech)
{
}

static inline void trace_vnc_auth_sasl_mech_choose(void * state, const char * mech)
{
    if (true) {
        _nocheck__trace_vnc_auth_sasl_mech_choose(state, mech);
    }
}

#define TRACE_VNC_AUTH_SASL_START_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_auth_sasl_start(void * state, const void * clientdata, size_t clientlen, const void * serverdata, size_t severlen, int ret)
{
}

static inline void trace_vnc_auth_sasl_start(void * state, const void * clientdata, size_t clientlen, const void * serverdata, size_t severlen, int ret)
{
    if (true) {
        _nocheck__trace_vnc_auth_sasl_start(state, clientdata, clientlen, serverdata, severlen, ret);
    }
}

#define TRACE_VNC_AUTH_SASL_STEP_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_auth_sasl_step(void * state, const void * clientdata, size_t clientlen, const void * serverdata, size_t severlen, int ret)
{
}

static inline void trace_vnc_auth_sasl_step(void * state, const void * clientdata, size_t clientlen, const void * serverdata, size_t severlen, int ret)
{
    if (true) {
        _nocheck__trace_vnc_auth_sasl_step(state, clientdata, clientlen, serverdata, severlen, ret);
    }
}

#define TRACE_VNC_AUTH_SASL_SSF_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_auth_sasl_ssf(void * state, int ssf)
{
}

static inline void trace_vnc_auth_sasl_ssf(void * state, int ssf)
{
    if (true) {
        _nocheck__trace_vnc_auth_sasl_ssf(state, ssf);
    }
}

#define TRACE_VNC_AUTH_SASL_USERNAME_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_auth_sasl_username(void * state, const char * name)
{
}

static inline void trace_vnc_auth_sasl_username(void * state, const char * name)
{
    if (true) {
        _nocheck__trace_vnc_auth_sasl_username(state, name);
    }
}

#define TRACE_VNC_AUTH_SASL_ACL_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vnc_auth_sasl_acl(void * state, int allow)
{
}

static inline void trace_vnc_auth_sasl_acl(void * state, int allow)
{
    if (true) {
        _nocheck__trace_vnc_auth_sasl_acl(state, allow);
    }
}

#define TRACE_INPUT_EVENT_KEY_NUMBER_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_input_event_key_number(int conidx, int number, const char * qcode, bool down)
{
}

static inline void trace_input_event_key_number(int conidx, int number, const char * qcode, bool down)
{
    if (true) {
        _nocheck__trace_input_event_key_number(conidx, number, qcode, down);
    }
}

#define TRACE_INPUT_EVENT_KEY_QCODE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_input_event_key_qcode(int conidx, const char * qcode, bool down)
{
}

static inline void trace_input_event_key_qcode(int conidx, const char * qcode, bool down)
{
    if (true) {
        _nocheck__trace_input_event_key_qcode(conidx, qcode, down);
    }
}

#define TRACE_INPUT_EVENT_BTN_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_input_event_btn(int conidx, const char * btn, bool down)
{
}

static inline void trace_input_event_btn(int conidx, const char * btn, bool down)
{
    if (true) {
        _nocheck__trace_input_event_btn(conidx, btn, down);
    }
}

#define TRACE_INPUT_EVENT_REL_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_input_event_rel(int conidx, const char * axis, int value)
{
}

static inline void trace_input_event_rel(int conidx, const char * axis, int value)
{
    if (true) {
        _nocheck__trace_input_event_rel(conidx, axis, value);
    }
}

#define TRACE_INPUT_EVENT_ABS_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_input_event_abs(int conidx, const char * axis, int value)
{
}

static inline void trace_input_event_abs(int conidx, const char * axis, int value)
{
    if (true) {
        _nocheck__trace_input_event_abs(conidx, axis, value);
    }
}

#define TRACE_INPUT_EVENT_SYNC_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_input_event_sync(void)
{
}

static inline void trace_input_event_sync(void)
{
    if (true) {
        _nocheck__trace_input_event_sync();
    }
}

#define TRACE_INPUT_MOUSE_MODE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_input_mouse_mode(int absolute)
{
}

static inline void trace_input_mouse_mode(int absolute)
{
    if (true) {
        _nocheck__trace_input_mouse_mode(absolute);
    }
}

#define TRACE_QEMU_SPICE_ADD_MEMSLOT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_add_memslot(int qid, uint32_t slot_id, unsigned long virt_start, unsigned long virt_end, int async)
{
}

static inline void trace_qemu_spice_add_memslot(int qid, uint32_t slot_id, unsigned long virt_start, unsigned long virt_end, int async)
{
    if (true) {
        _nocheck__trace_qemu_spice_add_memslot(qid, slot_id, virt_start, virt_end, async);
    }
}

#define TRACE_QEMU_SPICE_DEL_MEMSLOT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_del_memslot(int qid, uint32_t gid, uint32_t slot_id)
{
}

static inline void trace_qemu_spice_del_memslot(int qid, uint32_t gid, uint32_t slot_id)
{
    if (true) {
        _nocheck__trace_qemu_spice_del_memslot(qid, gid, slot_id);
    }
}

#define TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_create_primary_surface(int qid, uint32_t sid, void * surface, int async)
{
}

static inline void trace_qemu_spice_create_primary_surface(int qid, uint32_t sid, void * surface, int async)
{
    if (true) {
        _nocheck__trace_qemu_spice_create_primary_surface(qid, sid, surface, async);
    }
}

#define TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_destroy_primary_surface(int qid, uint32_t sid, int async)
{
}

static inline void trace_qemu_spice_destroy_primary_surface(int qid, uint32_t sid, int async)
{
    if (true) {
        _nocheck__trace_qemu_spice_destroy_primary_surface(qid, sid, async);
    }
}

#define TRACE_QEMU_SPICE_WAKEUP_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_wakeup(uint32_t qid)
{
}

static inline void trace_qemu_spice_wakeup(uint32_t qid)
{
    if (true) {
        _nocheck__trace_qemu_spice_wakeup(qid);
    }
}

#define TRACE_QEMU_SPICE_CREATE_UPDATE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_create_update(uint32_t left, uint32_t right, uint32_t top, uint32_t bottom)
{
}

static inline void trace_qemu_spice_create_update(uint32_t left, uint32_t right, uint32_t top, uint32_t bottom)
{
    if (true) {
        _nocheck__trace_qemu_spice_create_update(left, right, top, bottom);
    }
}

#define TRACE_QEMU_SPICE_DISPLAY_UPDATE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_display_update(int qid, uint32_t x, uint32_t y, uint32_t w, uint32_t h)
{
}

static inline void trace_qemu_spice_display_update(int qid, uint32_t x, uint32_t y, uint32_t w, uint32_t h)
{
    if (true) {
        _nocheck__trace_qemu_spice_display_update(qid, x, y, w, h);
    }
}

#define TRACE_QEMU_SPICE_DISPLAY_SURFACE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_display_surface(int qid, uint32_t w, uint32_t h, int fast)
{
}

static inline void trace_qemu_spice_display_surface(int qid, uint32_t w, uint32_t h, int fast)
{
    if (true) {
        _nocheck__trace_qemu_spice_display_surface(qid, w, h, fast);
    }
}

#define TRACE_QEMU_SPICE_DISPLAY_REFRESH_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_display_refresh(int qid, int notify)
{
}

static inline void trace_qemu_spice_display_refresh(int qid, int notify)
{
    if (true) {
        _nocheck__trace_qemu_spice_display_refresh(qid, notify);
    }
}

#define TRACE_QEMU_SPICE_UI_INFO_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_ui_info(int qid, uint32_t width, uint32_t height)
{
}

static inline void trace_qemu_spice_ui_info(int qid, uint32_t width, uint32_t height)
{
    if (true) {
        _nocheck__trace_qemu_spice_ui_info(qid, width, height);
    }
}

#define TRACE_QEMU_SPICE_GL_SURFACE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_gl_surface(int qid, uint32_t w, uint32_t h, uint32_t fourcc)
{
}

static inline void trace_qemu_spice_gl_surface(int qid, uint32_t w, uint32_t h, uint32_t fourcc)
{
    if (true) {
        _nocheck__trace_qemu_spice_gl_surface(qid, w, h, fourcc);
    }
}

#define TRACE_QEMU_SPICE_GL_SCANOUT_DISABLE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_gl_scanout_disable(int qid)
{
}

static inline void trace_qemu_spice_gl_scanout_disable(int qid)
{
    if (true) {
        _nocheck__trace_qemu_spice_gl_scanout_disable(qid);
    }
}

#define TRACE_QEMU_SPICE_GL_SCANOUT_TEXTURE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_gl_scanout_texture(int qid, uint32_t w, uint32_t h, uint32_t fourcc)
{
}

static inline void trace_qemu_spice_gl_scanout_texture(int qid, uint32_t w, uint32_t h, uint32_t fourcc)
{
    if (true) {
        _nocheck__trace_qemu_spice_gl_scanout_texture(qid, w, h, fourcc);
    }
}

#define TRACE_QEMU_SPICE_GL_CURSOR_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_gl_cursor(int qid, bool enabled, bool hotspot)
{
}

static inline void trace_qemu_spice_gl_cursor(int qid, bool enabled, bool hotspot)
{
    if (true) {
        _nocheck__trace_qemu_spice_gl_cursor(qid, enabled, hotspot);
    }
}

#define TRACE_QEMU_SPICE_GL_FORWARD_DMABUF_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_gl_forward_dmabuf(int qid, uint32_t width, uint32_t height)
{
}

static inline void trace_qemu_spice_gl_forward_dmabuf(int qid, uint32_t width, uint32_t height)
{
    if (true) {
        _nocheck__trace_qemu_spice_gl_forward_dmabuf(qid, width, height);
    }
}

#define TRACE_QEMU_SPICE_GL_RENDER_DMABUF_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_gl_render_dmabuf(int qid, uint32_t width, uint32_t height)
{
}

static inline void trace_qemu_spice_gl_render_dmabuf(int qid, uint32_t width, uint32_t height)
{
    if (true) {
        _nocheck__trace_qemu_spice_gl_render_dmabuf(qid, width, height);
    }
}

#define TRACE_QEMU_SPICE_GL_UPDATE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qemu_spice_gl_update(int qid, uint32_t x, uint32_t y, uint32_t w, uint32_t h)
{
}

static inline void trace_qemu_spice_gl_update(int qid, uint32_t x, uint32_t y, uint32_t w, uint32_t h)
{
    if (true) {
        _nocheck__trace_qemu_spice_gl_update(qid, x, y, w, h);
    }
}

#define TRACE_KEYMAP_PARSE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_keymap_parse(const char * file)
{
}

static inline void trace_keymap_parse(const char * file)
{
    if (true) {
        _nocheck__trace_keymap_parse(file);
    }
}

#define TRACE_KEYMAP_ADD_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_keymap_add(int sym, int code, const char * line)
{
}

static inline void trace_keymap_add(int sym, int code, const char * line)
{
    if (true) {
        _nocheck__trace_keymap_add(sym, code, line);
    }
}

#define TRACE_KEYMAP_UNMAPPED_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_keymap_unmapped(int sym)
{
}

static inline void trace_keymap_unmapped(int sym)
{
    if (true) {
        _nocheck__trace_keymap_unmapped(sym);
    }
}

#define TRACE_XKEYMAP_EXTENSION_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_xkeymap_extension(const char * name)
{
}

static inline void trace_xkeymap_extension(const char * name)
{
    if (true) {
        _nocheck__trace_xkeymap_extension(name);
    }
}

#define TRACE_XKEYMAP_VENDOR_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_xkeymap_vendor(const char * name)
{
}

static inline void trace_xkeymap_vendor(const char * name)
{
    if (true) {
        _nocheck__trace_xkeymap_vendor(name);
    }
}

#define TRACE_XKEYMAP_KEYCODES_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_xkeymap_keycodes(const char * name)
{
}

static inline void trace_xkeymap_keycodes(const char * name)
{
    if (true) {
        _nocheck__trace_xkeymap_keycodes(name);
    }
}

#define TRACE_XKEYMAP_KEYMAP_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_xkeymap_keymap(const char * name)
{
}

static inline void trace_xkeymap_keymap(const char * name)
{
    if (true) {
        _nocheck__trace_xkeymap_keymap(name);
    }
}
#endif /* TRACE_UI_GENERATED_TRACERS_H */
