LOCAL_PATH:= $(call my-dir)

# determine the host tag to use
QEMU_HOST_TAG := $(HOST_PREBUILT_TAG)
ifneq ($(USE_MINGW),)
    QEMU_HOST_TAG := windows
endif

# This defines EMULATOR_BUILD_32BITS to indicate that 32-bit binaries
# must be generated by the build system. For now, only for Windows because
# the Win64 do not work yet properly (e.g. can't emulate 32-bit ARM), and
# Linux (because the 32-bit binaries are deprecated, but not obsolete).
EMULATOR_BUILD_32BITS := $(strip $(filter windows linux,$(HOST_OS)))

# This defines EMULATOR_BUILD_64BITS to indicate that 64-bit binaries
# must be generated by the build system. For now, only do it for
# Windows, Linux and Darwin.
EMULATOR_BUILD_64BITS := $(strip $(filter linux darwin windows,$(HOST_OS)))

# EMULATOR_PROGRAM_BITNESS is the bitness of the 'emulator' launcher program.
# It will be 32 if we allow 32-bit binaries to be built, 64 otherwise.
ifneq (,$(EMULATOR_BUILD_32BITS))
    EMULATOR_PROGRAM_BITNESS := 32
else
    EMULATOR_PROGRAM_BITNESS := 64
endif

# A function that includes a file only if 32-bit binaries are necessary,
# or if LOCAL_IGNORE_BITNESS is defined for the current module.
# $1: Build file to include.
include-if-bitness-32 = \
    $(if $(strip $(LOCAL_IGNORE_BITNESS)$(filter true,$(LOCAL_HOST_BUILD))$(EMULATOR_BUILD_32BITS)),\
        $(eval include $1))

# A function that includes a file only of EMULATOR_BUILD_64BITS is not empty.
# or if LOCAL_IGNORE_BITNESS is defined for the current module.
# $1: Build file to include.
include-if-bitness-64 = \
    $(if $(strip $(LOCAL_IGNORE_BITNESS)$(filter true,$(LOCAL_HOST_BUILD))$(EMULATOR_BUILD_64BITS)),\
        $(eval include $1))

# determine the location of platform-specific directories
#
QEMU_CONFIG_DIRS     := \
    $(LOCAL_PATH)/android/config/$(QEMU_HOST_TAG)

QEMU_CONFIG_DIRS := $(LOCAL_PATH)/objs $(QEMU_CONFIG_DIRS)

QEMU_CONFIG_INCLUDES := $(QEMU_CONFIG_DIRS:%=-I%)

MY_CC  := $(HOST_CC)
MY_CXX := $(HOST_CXX)
MY_LD  := $(HOST_LD)
MY_AR  := $(HOST_AR)
MY_WINDRES := $(HOST_WINDRES)

MY_CFLAGS := -g -falign-functions=0
ifeq ($(BUILD_DEBUG_EMULATOR),true)
    MY_CFLAGS += -O0
else
    MY_CFLAGS += -O2
endif

# Generate position-independent binaries. Don't add -fPIC when targetting
# Windows, because newer toolchain complain loudly about it, since all
# Windows code is position-independent.
ifneq (windows,$(HOST_OS))
  MY_CFLAGS += -fPIC
endif

# Ensure that <inttypes.h> always defines all interesting macros.
MY_CFLAGS += -D__STDC_LIMIT_MACROS=1 -D__STDC_FORMAT_MACROS=1

MY_CFLAGS32 :=
MY_CFLAGS64 :=

MY_LDLIBS :=
MY_LDLIBS32 :=
MY_LDLIBS64 :=

MY_LDFLAGS :=
MY_LDFLAGS32 :=
MY_LDFLAGS64 :=

ifeq ($(HOST_OS),freebsd)
  MY_CFLAGS += -I /usr/local/include
endif

ifeq ($(HOST_OS),windows)
  # we need Win32 features that are available since Windows 2000 Professional/Server (NT 5.0)
  MY_CFLAGS += -DWINVER=0x501
  # LARGEADDRESSAWARE gives more address space to 32-bit process
  MY_LDFLAGS32 += -Xlinker --large-address-aware
endif

ifeq ($(HOST_ARCH),ppc)
    MY_CFLAGS += -D__powerpc__
endif

ifeq ($(HOST_OS),darwin)
    MY_CFLAGS += -D_DARWIN_C_SOURCE=1
    # Clang complains about this flag being not useful anymore.
    MY_CFLAGS := $(filter-out -falign-functions=0,$(MY_CFLAGS))
endif

# NOTE: The following definitions are only used by the standalone build.
MY_EXEEXT :=
MY_DLLEXT := .so
ifeq ($(HOST_OS),windows)
  MY_EXEEXT := .exe
  MY_DLLEXT := .dll
endif
ifeq ($(HOST_OS),darwin)
  MY_DLLEXT := .dylib
endif

# Some CFLAGS below use -Wno-missing-field-initializers but this is not
# supported on GCC 3.x which is still present under Cygwin.
# Find out by probing GCC for support of this flag. Note that the test
# itself only works on GCC 4.x anyway.
GCC_W_NO_MISSING_FIELD_INITIALIZERS := -Wno-missing-field-initializers
ifeq ($(HOST_OS),windows)
    ifeq (,$(shell gcc -Q --help=warnings 2>/dev/null | grep missing-field-initializers))
        $(info emulator: Ignoring unsupported GCC flag $(GCC_W_NO_MISSING_FIELD_INITIALIZERS))
        GCC_W_NO_MISSING_FIELD_INITIALIZERS :=
    endif
endif

ifneq ($(HOST_IS_64_BIT),)
  MY_CFLAGS += -m64
  MY_LDFLAGS += -m64
else
  ifneq ($(HOST_ARCH),x86_64)
    MY_CFLAGS += -m32
    MY_LDFLAGS += -m32
  endif
endif

ifneq ($(BUILD_HOST_static),)
  MY_LDLIBS += -static
endif

ifeq ($(HOST_OS),windows)
  # Ensure that printf() et al use GNU printf format specifiers as required
  # by QEMU. This is important when using the newer Mingw64 cross-toolchain.
  # See http://sourceforge.net/apps/trac/mingw-w64/wiki/gnu%20printf
  MY_CFLAGS += -D__USE_MINGW_ANSI_STDIO=1
endif

# Enable warning, except those related to missing field initializers
# (the QEMU coding style loves using these).
#
MY_CFLAGS += -Wall $(GCC_W_NO_MISSING_FIELD_INITIALIZERS)

# When using clang and ccache, disable the spammy warnings about unused
# parameters during compilation, and re-enable colored output.
#
# See http://petereisentraut.blogspot.fr/2011/05/ccache-and-clang.html
ifneq (,$(filter %ccache,$(MY_CC)))
  ifneq (,$(filter LLVM,$(shell $(HOST_CC) -v 2>&1)))
    MY_CFLAGS := -Qunused-arguments -fcolor-diagnostics $(MY_CFLAGS)
  endif
endif

# Needed to build block.c on Linux/x86_64.
MY_CFLAGS += -D_GNU_SOURCE=1

my-host-tool = $(if $(strip $(LOCAL_HOST_BUILD)),$(BUILD_$1),$(MY_$1))

# A useful function that can be used to start the declaration of a host
# module. Avoids repeating the same stuff again and again.
# Usage:
#
#  $(call start-emulator-library, <module-name>)
#
#  ... declarations
#
#  $(call end-emulator-library)
#
start-emulator-library = \
    $(eval include $(CLEAR_VARS)) \
    $(eval LOCAL_NO_DEFAULT_COMPILER_FLAGS := true) \
    $(eval LOCAL_MODULE := $1) \
    $(eval LOCAL_MODULE_CLASS := STATIC_LIBRARIES) \
    $(eval LOCAL_MODULE_BITS := 32) \
    $(eval LOCAL_BUILD_FILE := $(BUILD_HOST_STATIC_LIBRARY))

start-emulator64-library = \
    $(call start-emulator-library, $1) \
    $(eval LOCAL_MODULE_BITS := 64)

# Used with start-emulator-library
end-emulator-library = \
    $(eval $(end-emulator-module-ev)) \

define-emulator-prebuilt-library = \
    $(call start-emulator-library,$1) \
    $(eval LOCAL_BUILD_FILE := $(PREBUILT_STATIC_LIBRARY)) \
    $(eval LOCAL_SRC_FILES := $2) \
    $(eval $(end-emulator-module-ev)) \

define-emulator64-prebuilt-library = \
    $(call start-emulator64-library,$1) \
    $(eval LOCAL_BUILD_FILE := $(PREBUILT_STATIC_LIBRARY)) \
    $(eval LOCAL_SRC_FILES := $2) \
    $(eval $(end-emulator-module-ev)) \

# A variant of start-emulator-library to start the definition of a host
# program instead. Use with end-emulator-program
start-emulator-program = \
    $(call start-emulator-library,$1) \
    $(eval LOCAL_MODULE_CLASS := EXECUTABLES) \
    $(eval LOCAL_BUILD_FILE := $(BUILD_HOST_EXECUTABLE))

start-emulator64-program = \
    $(call start-emulator-program, $1) \
    $(eval LOCAL_MODULE_BITS := 64)

# A varient of end-emulator-library for host programs instead
end-emulator-program = \
    $(eval LOCAL_LDLIBS += $(QEMU_SYSTEM_LDLIBS)) \
    $(eval $(end-emulator-module-ev)) \

define end-emulator-module-ev
LOCAL_CC := $$(call my-host-tool,CC)
LOCAL_CXX := $$(call my-host-tool,CXX)
LOCAL_AR := $$(call my-host-tool,AR)
LOCAL_LD := $$(call my-host-tool,LD)

LOCAL_CFLAGS := \
    $$(call my-host-tool,CFLAGS$$(LOCAL_MODULE_BITS)) \
    $$(call my-host-tool,CFLAGS) \
    $$(LOCAL_CFLAGS)

LOCAL_LDFLAGS := \
    $$(call my-host-tool,LDFLAGS$$(LOCAL_MODULE_BITS)) \
    $$(call my-host-tool,LDFLAGS) \
    $$(LOCAL_LDFLAGS)

LOCAL_LDLIBS := \
    $$(LOCAL_LDLIBS) \
    $$(call my-host-tool,LDLIBS) \
    $$(call my-host-tool,LDLIBS$$(LOCAL_MODULE_BITS))

# Ensure only one of -m32 or -m64 is being used and place it first.
LOCAL_CFLAGS := \
    -m$$(LOCAL_MODULE_BITS) \
    $$(filter-out -m32 -m64, $$(LOCAL_CFLAGS))

LOCAL_LDFLAGS := \
    -m$$(LOCAL_MODULE_BITS) \
    $$(filter-out -m32 -m64, $$(LOCAL_LDFLAGS))

$$(call include-if-bitness-$$(LOCAL_MODULE_BITS), $$(LOCAL_BUILD_FILE))
endef

# The common libraries
#
QEMU_SYSTEM_LDLIBS := -lm
ifeq ($(HOST_OS),windows)
  QEMU_SYSTEM_LDLIBS += -mwindows -mconsole
endif

ifeq ($(HOST_OS),freebsd)
    QEMU_SYSTEM_LDLIBS += -L/usr/local/lib -lpthread -lX11 -lutil
endif

ifeq ($(HOST_OS),linux)
  QEMU_SYSTEM_LDLIBS += -lutil -lrt
endif

ifeq ($(HOST_OS),windows)
  # amd64-mingw32msvc- toolchain still name it ws2_32.  May change it once amd64-mingw32msvc-
  # is stabilized
  QEMU_SYSTEM_LDLIBS += -lwinmm -lws2_32 -liphlpapi
else
  QEMU_SYSTEM_LDLIBS += -lpthread
endif

ifeq ($(HOST_OS),darwin)
  QEMU_SYSTEM_LDLIBS += -Wl,-framework,Cocoa,-framework,QTKit,-framework,CoreVideo,-framework,AVFoundation

  # Required to avoid compilation errors when targetting i386 with newer
  # XCode toolchain.
  MY_LDFLAGS32 += -Wl,-read_only_relocs,suppress

  # SDK 10.6+ doesn't have __dyld_func_lookup anymore. Dynamic library lookup
  # symbols are instead resolved at runtime
  QEMU_SYSTEM_LDLIBS += -undefined dynamic_lookup
endif

# Build libext4_utils and related modules/
include $(LOCAL_PATH)/distrib/zlib-1.2.8/sources.make
include $(LOCAL_PATH)/distrib/libsparse/sources.mk
include $(LOCAL_PATH)/distrib/libselinux/sources.mk
include $(LOCAL_PATH)/distrib/ext4_utils/sources.mk

include $(LOCAL_PATH)/Makefile.common

ifeq ($(HOST_OS),windows)
  # on Windows, link the icon file as well into the executable
  # unfortunately, our build system doesn't help us much, so we need
  # to use some weird pathnames to make this work...

  # Usage: $(eval $(call insert-windows-icon))
  define insert-windows-icon
    LOCAL_PREBUILT_OBJ_FILES += images/emulator_icon$(LOCAL_MODULE_BITS).o
  endef

# This seems to be the only way to add an object file that was not generated from
# a C/C++/Java source file to our build system. and very unfortunately,
# $(TOPDIR)/$(LOCALPATH) will always be prepended to this value, which forces
# us to put the object file in the source directory.
$(LOCAL_PATH)/images/emulator_icon32.o: $(LOCAL_PATH)/images/android_icon.rc
	@echo "Windres (x86): $@"
	$(MY_WINDRES) --target=pe-i386 $< -I $(LOCAL_PATH)/images -o $@

$(LOCAL_PATH)/images/emulator_icon64.o: $(LOCAL_PATH)/images/android_icon.rc
	@echo "Windres (x86_64): $@"
	$(MY_WINDRES) --target=pe-x86-64 $< -I $(LOCAL_PATH)/images -o $@
endif

# We want to build all variants of the emulator binaries. This makes
# it easier to catch target-specific regressions during emulator development.
EMULATOR_TARGET_ARCH := arm
include $(LOCAL_PATH)/Makefile.target

# Note: the same binary handles x86 and x86_64
EMULATOR_TARGET_ARCH := x86
include $(LOCAL_PATH)/Makefile.target
include $(LOCAL_PATH)/Makefile.qemu-launcher

EMULATOR_TARGET_ARCH := x86_64
include $(LOCAL_PATH)/Makefile.qemu-launcher

EMULATOR_TARGET_ARCH := mips
include $(LOCAL_PATH)/Makefile.target

EMULATOR_TARGET_ARCH := mips64
include $(LOCAL_PATH)/Makefile.qemu-launcher

EMULATOR_TARGET_ARCH := arm64
include $(LOCAL_PATH)/Makefile.qemu-launcher

##############################################################################
##############################################################################
###
###  emulator: LAUNCHER FOR TARGET-SPECIFIC EMULATOR
###

# NOTE: Build as 32-bit or 64-bit executable, depending on the value of
#       EMULATOR_PROGRAM_BITNESS.
ifeq (32,$(EMULATOR_PROGRAM_BITNESS))
$(call start-emulator-program, emulator)
else
$(call start-emulator64-program, emulator)
endif
LOCAL_SRC_FILES := \
    android/main-emulator.c \

ifdef EMULATOR_USE_QT
    LOCAL_SRC_FILES += \
        android/qt/qt_path.cpp \
        android/qt/qt_setup.cpp \

    # Needed to compile the call to androidQtSetupEnv() in main-emulator.c
    LOCAL_CFLAGS += -DCONFIG_QT
endif

ifeq (32,$(EMULATOR_PROGRAM_BITNESS))
    LOCAL_STATIC_LIBRARIES := emulator-common
    # Ensure this is always built, even if 32-bit binaries are disabled.
    LOCAL_IGNORE_BITNESS := true
else
    LOCAL_STATIC_LIBRARIES := emulator64-common
endif

LOCAL_LDLIBS += -lstdc++

ifeq ($(HOST_OS),windows)
$(eval $(call insert-windows-icon))
endif

$(call end-emulator-program)

include $(LOCAL_PATH)/Makefile.tests

##############################################################################
##############################################################################
###
###  GPU emulation libraries
###
###  Build directly from sources when using the standalone build.
###
ifeq (,$(strip $(wildcard $(EMULATOR_EMUGL_SOURCES_DIR))))
$(error Cannot find GPU emulation sources directory: $(EMULATOR_EMUGL_SOURCES_DIR))
endif

# TODO(digit): Remove the line below.
BUILD_EMULATOR_OPENGL := true
BUILD_EMULATOR_HOST_OPENGL := true
ifeq (true,$(BUILD_DEBUG_EMULATOR))
EMUGL_BUILD_DEBUG := 1
endif
include $(EMULATOR_EMUGL_SOURCES_DIR)/Android.mk

## VOILA!!
